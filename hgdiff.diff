diff -r da841a06e630 -r 5d849f9519c9 .cproject
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/.cproject	Mon Jan 30 20:09:06 2017 -0800
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.toolchain.gnu.base.802196490">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.toolchain.gnu.base.802196490" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration buildProperties="" id="cdt.managedbuild.toolchain.gnu.base.802196490" name="Default" parent="org.eclipse.cdt.build.core.emptycfg">
+					<folderInfo id="cdt.managedbuild.toolchain.gnu.base.802196490.892696426" name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.base.1548721018" name="Linux GCC" superClass="cdt.managedbuild.toolchain.gnu.base">
+							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="cdt.managedbuild.target.gnu.platform.base.2097890183" name="Debug Platform" osList="linux,hpux,aix,qnx" superClass="cdt.managedbuild.target.gnu.platform.base"/>
+							<builder id="cdt.managedbuild.target.gnu.builder.base.780096079" managedBuildOn="false" name="Gnu Make Builder.Default" superClass="cdt.managedbuild.target.gnu.builder.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1832031744" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.base.1978138478" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.c.compiler.base.1741002866" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.c.linker.base.1461208275" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.base.563591963" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.assembler.base.1606618418" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.base"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="origin.null.2146564565" name="origin"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+</cproject>
diff -r da841a06e630 -r 5d849f9519c9 .project
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/.project	Mon Jan 30 20:09:06 2017 -0800
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>origin</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff -r da841a06e630 -r 5d849f9519c9 DenseMatrixOps.h
--- a/DenseMatrixOps.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/DenseMatrixOps.h	Mon Jan 30 20:09:06 2017 -0800
@@ -452,6 +452,13 @@
 c[3] op a[3]*b[0] + a[8]*b[1] + a[13]*b[2] + a[18]*b[3] + a[23]*b[4]; \
 c[4] op a[4]*b[0] + a[9]*b[1] + a[14]*b[2] + a[19]*b[3] + a[24]*b[4];
 
+#define DENSEMATRIXTRANSTIMESVECTOR6(op, a, b, c) \
+c[0] op a[0]*b[0] + a[6]*b[1] + a[12]*b[2] + a[18]*b[3] + a[24]*b[4] + a[30]*b[5]; \
+c[1] op a[1]*b[0] + a[7]*b[1] + a[13]*b[2] + a[19]*b[3] + a[25]*b[4] + a[31]*b[5]; \
+c[2] op a[2]*b[0] + a[8]*b[1] + a[14]*b[2] + a[20]*b[3] + a[26]*b[4] + a[32]*b[5]; \
+c[3] op a[3]*b[0] + a[9]*b[1] + a[15]*b[2] + a[21]*b[3] + a[27]*b[4] + a[33]*b[5]; \
+c[4] op a[4]*b[0] + a[10]*b[1] + a[16]*b[2] + a[22]*b[3] + a[28]*b[4] + a[34]*b[5]; \
+c[5] op a[5]*b[0] + a[11]*b[1] + a[17]*b[2] + a[23]*b[3] + a[29]*b[4] + a[35]*b[5];
 
 #define DENSEMATRIXTIMESVECTOR6(op, a, b, c) \
 c[0] op a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]+a[4]*b[4]+a[5]*b[5]; \
diff -r da841a06e630 -r 5d849f9519c9 DistBcData.C
--- a/DistBcData.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/DistBcData.C	Mon Jan 30 20:09:06 2017 -0800
@@ -1858,10 +1858,10 @@
       double (*t)[2] = tmp->subData(iSub);
       double (*unode)[dim] = this->Unode.subData(iSub);
       for (int i=0; i<this->Unode.subSize(iSub); ++i) {
-	if (t[i][0] != 0.0) {
-	  double w = 1.0 / t[i][0];
-	  unode[i][5] = w * t[i][1];
-	}
+	    if (t[i][0] != 0.0) {
+	      double w = 1.0 / t[i][0];
+	      unode[i][5] = w * t[i][1];
+	    }
       }
     }
   }
@@ -1898,11 +1898,11 @@
       double (*dt)[2] = dtmp->subData(iSub);
       double (*dunode)[dim] = this->dUnode->subData(iSub);
       for (int i=0; i<this->dUnode->subSize(iSub); ++i) {
-	if (t[i][0] != 0.0) {
-	  double w = 1.0 / t[i][0];
-	  double dw = -1.0 / ( t[i][0] * t[i][0] ) * dt[i][0];
-	  dunode[i][5] = dw * t[i][1] + w * dt[i][1];
-	}
+  	    if (t[i][0] != 0.0) {
+	      double w = 1.0 / t[i][0];
+	      double dw = -1.0 / ( t[i][0] * t[i][0] ) * dt[i][0];
+	      dunode[i][5] = dw * t[i][1] + w * dt[i][1];
+	    }
       }
     }
   }
diff -r da841a06e630 -r 5d849f9519c9 DistGeoState.C
--- a/DistGeoState.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/DistGeoState.C	Mon Jan 30 20:09:06 2017 -0800
@@ -703,7 +703,8 @@
 void DistGeoState::computeDerivatives(RectangularSparseMat<double,3,3> **dEdgeNormdX,
                                       RectangularSparseMat<double,3,3> **dFaceNormdX,
                                       RectangularSparseMat<double,3,1> **dCtrlVoldX,
-                                      DistSVec<double,3> &dX, 
+									  DistSVec<double,3> &X,
+									  DistSVec<double,3> &dX,
                                       DistVec<double> &dCtrlVol,
                                       DistVec<Vec3D>& dEdgeNormal,
                                       DistVec<Vec3D>& dFaceNormal, 
@@ -711,6 +712,10 @@
 {
 
 //Remark: Error mesage for pointers
+  if (Xsa == 0) {
+	fprintf(stderr, "*** Error: Variable Xsa does not exist!\n");
+	exit(1);
+  }
   if (dXsa == 0) {
     fprintf(stderr, "*** Error: Variable dXsa does not exist!\n");
     exit(1);
@@ -734,11 +739,13 @@
 
   data.configSA += 1;
 
+  *Xsa=X;
   *dXsa=dX;
 
   if (data.typeNormals == DGCLData::IMPLICIT_FIRST_ORDER_GCL) {
     domain->computeDerivativeOfNormals(dEdgeNormdX, dFaceNormdX, *dXsa, dEdgeNormal, *dEdgeNormVel, dFaceNormal, dFaceNormalVel);
-//    dEdgeNormal = *dEdgeNorm;   dFaceNormal = *dFaceNorm;   dFaceNormalVel = *dFaceNormVel;
+    *dEdgeNorm = dEdgeNormal;   *dFaceNorm = dFaceNormal;    *dFaceNormVel = dFaceNormalVel;
+    //    dEdgeNormal = *dEdgeNorm;   dFaceNormal = *dFaceNorm;   dFaceNormalVel = *dFaceNormVel;
 /*    
     DistSVec<double,3> dX2(dX);
     DistVec<Vec3D> dEdgeNorm2(*dEdgeNorm), dFaceNorm2(*dFaceNorm);
diff -r da841a06e630 -r 5d849f9519c9 DistGeoState.h
--- a/DistGeoState.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/DistGeoState.h	Mon Jan 30 20:09:06 2017 -0800
@@ -117,7 +117,7 @@
   int getConfigSA() const { return data.configSA; }
   void computeDerivatives(DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &);
   void computeDerivatives(RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,1> **,
-                          DistSVec<double,3> &, DistVec<double> &, DistVec<Vec3D>&, DistVec<Vec3D>&, DistVec<double>&);
+		                  DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &, DistVec<Vec3D>&, DistVec<Vec3D>&, DistVec<double>&);
   void computeTransposeDerivatives(RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,1> **,
                                    DistVec<double>&, DistVec<Vec3D>&, DistVec<Vec3D>&, DistVec<double>&, DistSVec<double,3> &);
   void computeDerivativeOperators(DistSVec<double,3> &, RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,3> **, RectangularSparseMat<double,3,1> **); 
diff -r da841a06e630 -r 5d849f9519c9 DistNodalGrad.C
--- a/DistNodalGrad.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/DistNodalGrad.C	Mon Jan 30 20:09:06 2017 -0800
@@ -685,18 +685,6 @@
     }
     domain->computeDerivativeOfWeightsLeastSquares(dRdXop.dRdX,dRdXop.dRdR, dX, dR2);
    
-
-/*
-    DistSVec<double,3> dX2(dX);    dX2 = 0.0;
-    DistSVec<double,6> dR2(*dR);   dR2 = 0.0;
-    domain->computeDerivativeOfWeightsLeastSquares(dRdXop.dRdX,dRdXop.dRdR, dX, dR2);
-    double aa = dR2*(*dR);
-    domain->computeTransposeDerivativeOfWeightsLeastSquares(dRdXop.dRdX, dRdXop.dRdR, *dR, dX2);
-    double bb = dX2*dX;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0.0) fprintf(stderr, " ... rel. diff = %e\n", diff/abs(aa));
-    else fprintf(stderr, " ... abs. diff = %e\n", diff);
-*/
   }
   else if (typeGradient == SchemeData::GALERKIN || typeGradient == SchemeData::NON_NODAL) {
 //Remark: Error mesage for pointers
@@ -714,6 +702,8 @@
     }
 
 //    domain->computeDerivativeOfWeightsGalerkin(X, dX, *dwii, *dwij, *dwji);
+    fprintf(stderr, "*** Error: DistNodalGrad<dim, Scalar>::computeDerivativeOfWeights is not implemented yet.\n");
+    fprintf(stderr, "           Turn off SparseFlag under SensitivityAnalysis.\n");  exit(-1);
 
   }
 
@@ -750,6 +740,8 @@
     }
 
 //    domain->computeDerivativeOfWeightsGalerkin(X, dX, *dwii, *dwij, *dwji);
+    fprintf(stderr, "*** Error: DistNodalGrad<dim, Scalar>::computeTransposeDerivativeOfWeights is not implemented yet.\n");
+    fprintf(stderr, "           Turn off SparseFlag under SensitivityAnalysis.\n");  exit(-1);
 
   }
 
@@ -779,7 +771,8 @@
       exit(1);
     }
 
-//    domain->computeDerivativeOperatorsOfWeightsGalerkin(X, dX, *dwii, *dwij, *dwji);
+    fprintf(stderr, "*** Error: DistNodalGrad<dim, Scalar>::computeDerivativeOfWeightsOperators is not implemented yet.\n");
+    fprintf(stderr, "           Turn off SparseFlag under SensitivityAnalysis.\n");  exit(-1);
 
   }
 
@@ -813,8 +806,7 @@
 template<int dim, class Scalar>
 template<class Scalar2>
 void DistNodalGrad<dim, Scalar>::computeDerivative(int configSA, DistSVec<double,3> &X, DistSVec<double,3> &dX,
-				 DistVec<double> &ctrlVol, DistVec<double>
-				 &dCtrlVol, DistSVec<Scalar2,dim> &V, DistSVec<Scalar2,dim> &dV)
+		DistVec<double> &ctrlVol, DistVec<double> &dCtrlVol, DistSVec<Scalar2,dim> &V, DistSVec<Scalar2,dim> &dV)
 {
 
 //Remark: Error mesage for pointers
@@ -853,33 +845,16 @@
                                                    DistSVec<double,dim>& dddy_r, DistSVec<double,dim>& dddz_r)
 {
 
-    computeDerivativeOfWeights(*dRdXop, dX, dR_r);
+  computeDerivativeOfWeights(*dRdXop, dX, dR_r);
+
+  *dR = dR_r;
 
   if (typeGradient == SchemeData::LEAST_SQUARES) {
     domain->computeDerivativeOfGradientsLeastSquares(*dRdXop, dX, dR_r, dV_r, dddx_r, dddy_r, dddz_r);
-    Communicator* com = domain->getCommunicator();
-/************************    
-    DistSVec<double,dim> dddx2(dddx_r), dddy2(dddy_r), dddz2(dddz_r), dV2(dV_r);
-    DistSVec<double,3> dX2(dX);
-    DistSVec<double,6> dR2(dR_r);
-
-    dX2 = 0.0;
-    dR2 = 0.0;
-    dV2 = 0.0;
-    dddx2 = 0.0;
-    dddy2 = 0.0;
-    dddz2 = 0.0;
-
-    domain->computeDerivativeOfGradientsLeastSquares(*dRdXop, dX, dR_r, dV_r, dddx2, dddy2, dddz2);
-    double aa = (dddx_r)*dddx2 + (dddy_r)*dddy2 + (dddz_r)*dddz2;
-    domain->computeTransposeDerivativeOfGradientsLeastSquares(*dRdXop, dddx_r, dddy_r, dddz_r, dX2, dR2, dV2);
-    double bb = dX2*(dX)+dR2*(dR_r)+dV2*(dV_r);
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0.0) com->fprintf(stderr, " ... domain->computeTransposeDerivativeOfGradientsLeastSquares ... rel. diff = %e\n", diff/abs(aa));
-    else com->fprintf(stderr, " ... domain->computeTransposeDerivativeOfGradientsLeastSquares ... abs. diff = %e\n", diff);
-*/
+    *dddx = dddx_r;    *dddy = dddy_r;    *dddz = dddz_r;
   } else if (typeGradient == SchemeData::GALERKIN || typeGradient == SchemeData::NON_NODAL) {
-//    domain->computeDerivativeOfGradientsGalerkin(ctrlVol, dCtrlVol, *wii, *wij, *wji, *dwii, *dwij, *dwji, V, dV, dddx_r, dddy_r, dddz_r);
+	fprintf(stderr, " *** ERROR : DistNodalGrad<dim, Scalar>::computeDerivative is not implemented\n");
+	exit(-1);
   }
 }
 
@@ -901,7 +876,8 @@
     Communicator* com = domain->getCommunicator();
     domain->computeTransposeDerivativeOfGradientsLeastSquares(*dRdXop, dddx2, dddy2, dddz2, dX2, dR2, dV2);
   } else if (typeGradient == SchemeData::GALERKIN || typeGradient == SchemeData::NON_NODAL) {
-//    domain->computeDerivativeOfGradientsGalerkin(ctrlVol, dCtrlVol2, *wii, *wij, *wji, *dwii, *dwij, *dwji, V, dV2, dddx2, dddy2, dddz2);
+    fprintf(stderr, " *** ERROR : DistNodalGrad<dim, Scalar>::computeTransposeDerivative is not implemented\n");
+    exit(-1);
   }
 
   computeTransposeDerivativeOfWeights(*dRdXop, dR2, dX2);
@@ -934,9 +910,10 @@
 
   if (typeGradient == SchemeData::LEAST_SQUARES)
     domain->computeDerivativeOperatorsOfGradientsLeastSquares(X, *R, V, dRdXop);
-//  else if (typeGradient == SchemeData::GALERKIN || typeGradient == SchemeData::NON_NODAL)
-//    domain->computeDerivativeOfGradientsGalerkin(ctrlVol, *wii, *wij, *wji, *dwii, *dwij, *dwji, V, dV, *dddx, *dddy, *dddz);
-
+  else if (typeGradient == SchemeData::GALERKIN || typeGradient == SchemeData::NON_NODAL) {
+    fprintf(stderr, "*** ERROR: DistNodalGrad<dim, Scalar>::computeDerivativeOperators is not implemented yet\n");
+    exit(-1);
+  }
 }
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 DistVector.h
--- a/DistVector.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/DistVector.h	Mon Jan 30 20:09:06 2017 -0800
@@ -380,7 +380,7 @@
 
   int iSub;
 
-  Scalar res = 0;
+  Scalar res = 0.0;
 
 #ifndef MPI_OMP_REDUCTION
   Scalar *allres = reinterpret_cast<Scalar *>(alloca(sizeof(Scalar) * distInfo.numGlobSub));
@@ -400,7 +400,7 @@
       int locOffset = distInfo.subOffset[iSub];
       int locLen = distInfo.subLen[iSub];
 
-      Scalar locres = 0;
+      Scalar locres = 0.0;
 
       for (int i = 0; i < locLen; ++i)
         if (distInfo.masterFlag[locOffset+i])
@@ -427,7 +427,7 @@
       int locOffset = distInfo.subOffset[iSub];
       int locLen = distInfo.subLen[iSub];
 
-      Scalar locres = 0;
+      Scalar locres = 0.0;
 
       for (int i = 0; i < locLen; ++i)
         locres += this->v[locOffset+i] * x.v[locOffset+i];
diff -r da841a06e630 -r 5d849f9519c9 Domain.C
--- a/Domain.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/Domain.C	Mon Jan 30 20:09:06 2017 -0800
@@ -307,10 +307,6 @@
                                                                        dddx(iSub), dddy(iSub), dddz(iSub), dX2(iSub), dR2(iSub), dV2(iSub));
   }
 
-//  assemble(vec3DPat, dX2);
-//  CommPattern<Scalar> *vPat = getCommPat(dddx);
-//  assemble(vPat, dV2);  
-
   timer->addNodalGradTime(t0);
 
 }
@@ -1097,45 +1093,6 @@
                                                          bcData(iSub), geoState(iSub),
 		                                                     dX(iSub), ngrad(iSub), legrad, 
                                                          dddx(iSub), dddy(iSub), dddz(iSub), dEdgeNormal(iSub), dFaceNormal(iSub), dFaceNormalVel(iSub), dF(iSub));
-/*
-    SVec<double,3> dX2(dX(iSub));  
-    SVec<double,dim> dF2(dF(iSub)), dddx2(dddx(iSub)), dddy2(dddy(iSub)), dddz2(dddz(iSub));
-    Vec<double> dFaceNormalVel2(dFaceNormalVel(iSub));
-    Vec<Vec3D> dEdgeNormal2(dEdgeNormal(iSub)), dFaceNormal2(dFaceNormal(iSub));
-    dX2 = 0.0;    dF2 = 0.0; 
-    subDomain[iSub]->computeDerivativeOfFiniteVolumeTerm(dRdXop.dFluxdddx[iSub], dRdXop.dFluxdddy[iSub], dRdXop.dFluxdddz[iSub],
-                                                         dRdXop.dFluxdEdgeNorm[iSub], dRdXop.dFluxdX[iSub],
-                                                         dRdXop.dFluxdFaceNormal[iSub], dRdXop.dFluxdFaceNormalVel[iSub], dRdXop.dFluxdUb[iSub],
-                                                         bcData(iSub), geoState(iSub),
-		                                                     dX(iSub), ngrad(iSub), legrad, 
-                                                         dddx(iSub), dddy(iSub), dddz(iSub), dEdgeNormal(iSub), dFaceNormal(iSub), dFaceNormalVel(iSub), dF2);
-    double aa = dF2*dF(iSub);
-    dddx2 = 0.0;   dddy2 = 0.0;   dddz2 = 0.0;   dEdgeNormal2 = 0.0;   dFaceNormal2 = 0.0;   dFaceNormalVel2 = 0.0;
-
-    subDomain[iSub]->computeTransposeDerivativeOfFiniteVolumeTerm(dRdXop.dFluxdddx[iSub], dRdXop.dFluxdddy[iSub], dRdXop.dFluxdddz[iSub],
-                                                         dRdXop.dFluxdEdgeNorm[iSub], dRdXop.dFluxdX[iSub],
-                                                         dRdXop.dFluxdFaceNormal[iSub], dRdXop.dFluxdFaceNormalVel[iSub], dRdXop.dFluxdUb[iSub],
-                                                         bcData(iSub), geoState(iSub), dF(iSub), ngrad(iSub), legrad, dX2, 
-                                                         dddx2, dddy2, dddz2, dEdgeNormal2, dFaceNormal2, dFaceNormalVel2);
-
-    SVec<double,3> dEdgeNormalSVec(dEdgeNormal(iSub).size()), dEdgeNormal2SVec(dEdgeNormal2.size());
-    SVec<double,3> dFaceNormalSVec(dFaceNormal.size()), dFaceNormal2SVec(dFaceNormal.size());
-    for(int i=0; i<dEdgeNormal2.size(); ++i)
-      for(int j=0; j<3; ++j) { 
-        dEdgeNormalSVec[i][j] = dEdgeNormal(iSub)[i][j];
-        dEdgeNormal2SVec[i][j] = dEdgeNormal2[i][j];
-      }
-    for(int i=0; i<dFaceNormal2.size(); ++i)
-      for(int j=0; j<3; ++j) { 
-        dFaceNormalSVec[i][j] = dFaceNormal(iSub)[i][j];
-        dFaceNormal2SVec[i][j] = dFaceNormal2[i][j];
-      }
-
-    double bb = dX2*dX(iSub) + dddx2*dddx(iSub) + dddy2*dddy(iSub) + dddz2*dddz(iSub) + dEdgeNormal2SVec*dEdgeNormalSVec + dFaceNormal2SVec*dFaceNormalSVec + dFaceNormalVel2*dFaceNormalVel(iSub);
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) fprintf(stderr, " ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else fprintf(stderr, " ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
   }
   assemble(vecPat, dF);
 
@@ -2400,6 +2357,62 @@
 
 //------------------------------------------------------------------------------
 
+template<int dim>
+void Domain::computeDerivativeOfGalerkinTerm(dRdXoperators<dim> &dRdXop, FemEquationTerm *fet, DistBcData<dim> &bcData,
+				 DistGeoState &geoState, DistSVec<double,3> &X, DistSVec<double,3> &dX,
+				 DistSVec<double,dim> &V, DistSVec<double,dim> &dV, double dMach, DistSVec<double,dim> &dR)
+{ // YC
+
+  double t0 = timer->getTime();
+
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub)
+    subDomain[iSub]->computeDerivativeOfGalerkinTerm(dRdXop.dViscousFluxdX[iSub], fet, bcData(iSub), geoState(iSub),
+					 X(iSub), dX(iSub), V(iSub), dV(iSub), dMach, dR(iSub));
+
+  timer->addFiniteElementTermTime(t0);
+
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void Domain::computeTransposeDerivativeOfGalerkinTerm(dRdXoperators<dim> &dRdXop, DistSVec<double,dim> &dR, DistSVec<double,3> &dX)
+{ // YC
+
+  double t0 = timer->getTime();
+
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub)
+    subDomain[iSub]->computeTransposeDerivativeOfGalerkinTerm(dRdXop.dViscousFluxdX[iSub], dR(iSub), dX(iSub));
+
+  timer->addFiniteElementTermTime(t0);
+
+}
+
+//------------------------------------------------------------------------------
+
+// Included (YC)
+template<int dim>
+void Domain::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,
+				 DistGeoState &geoState, DistSVec<double,3> &X,
+				 DistSVec<double,dim> &V, RectangularSparseMat<double,3,dim> **dViscousFluxdX)
+{
+
+  double t0 = timer->getTime();
+
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub)
+    subDomain[iSub]->computeDerivativeOperatorsOfGalerkinTerm(fet, bcData(iSub), geoState(iSub),
+					 X(iSub), V(iSub), *dViscousFluxdX[iSub]);
+
+  timer->addFiniteElementTermTime(t0);
+
+}
+
+//------------------------------------------------------------------------------
+
+
 // Included (MB)
 template<int dim>
 void Domain::computeOnlyGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,
@@ -4983,9 +4996,6 @@
   for (int iSub=0; iSub<numLocSub; iSub++)
     subDomain[iSub]->getDerivativeOfGradP(*dGradPdddx[iSub], *dGradPdddy[iSub], *dGradPdddz[iSub], dddx(iSub), dddy(iSub), dddz(iSub), dGradP(iSub));
 
-// dGradP is not assembled originally
-//  assemble(vec3DPat, dGradP);
-
 }
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 Domain.h
--- a/Domain.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/Domain.h	Mon Jan 30 20:09:06 2017 -0800
@@ -1188,6 +1188,19 @@
 			   DistSVec<double,dim> &, DistSVec<double,dim> &, double, DistSVec<double,dim> &);
 
   template<int dim>
+  void computeDerivativeOfGalerkinTerm(dRdXoperators<dim> &, FemEquationTerm *, DistBcData<dim> &,
+			   DistGeoState &, DistSVec<double,3> &, DistSVec<double,3> &,
+			   DistSVec<double,dim> &, DistSVec<double,dim> &, double, DistSVec<double,dim> &);
+
+  template<int dim>
+  void computeTransposeDerivativeOfGalerkinTerm(dRdXoperators<dim> &, DistSVec<double,dim> &, DistSVec<double,3> &);
+
+  template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, DistBcData<dim> &,
+			   DistGeoState &, DistSVec<double,3> &,
+			   DistSVec<double,dim> &, RectangularSparseMat<double,3,dim> **);
+
+  template<int dim>
   void applyBCsToDerivativeOfResidual(BcFcn *, DistBcData<dim> &,
 			  DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
 
diff -r da841a06e630 -r 5d849f9519c9 DomainCore.C
--- a/DomainCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/DomainCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -1207,36 +1207,6 @@
 #pragma omp parallel for
   for (iSub=0; iSub<numLocSub; ++iSub) {
     subDomain[iSub]->computeDerivativeOfNormals(*dEdgeNormdX[iSub], *dFaceNormdX[iSub], dX(iSub), dEdgeNorm(iSub), dFaceNorm(iSub));
-/*
-    SVec<double,3> dX2(dX);
-    Vec<Vec3D> dEdgeNorm2(dEdgeNorm(iSub)), dFaceNorm2(dFaceNorm(iSub));
-    dX2 = 0.0;
-    dEdgeNorm2 = 0.0;     dFaceNorm2 = 0.0;
-
-    subDomain[iSub]->computeDerivativeOfNormals(*dEdgeNormdX[iSub], *dFaceNormdX[iSub], dX(iSub), dEdgeNorm2, dFaceNorm2);
-    SVec<double,3> dEdgeNorm3(dEdgeNorm2.size()), dFaceNorm3(dFaceNorm2.size());
-    SVec<double,3> dEdgeNorm4(dEdgeNorm2.size()), dFaceNorm4(dFaceNorm2.size());
-    for(int i=0; i<dEdgeNorm2.size(); ++i)
-      for(int j=0; j<3; ++j) {
-        dEdgeNorm3[i][j] = dEdgeNorm2[i][j];
-        dEdgeNorm4[i][j] = dEdgeNorm(iSub)[i][j];
-      }
-    for(int i=0; i<dFaceNorm2.size(); ++i)
-      for(int j=0; j<3; ++j) {
-        dFaceNorm3[i][j] = dFaceNorm2[i][j];
-        dFaceNorm4[i][j] = dFaceNorm(iSub)[i][j];
-      }
-    fprintf(stderr, " norm of dEdgeNorm3 = %e, norm of dEdgeNorm2 = %e\n", dEdgeNorm3.norm(), dEdgeNorm2.norm());
-
-    double aa = dEdgeNorm3*dEdgeNorm4 + dFaceNorm3*dFaceNorm4;
-
-
-    subDomain[iSub]->computeTransposeDerivativeOfNormals(*dEdgeNormdX[iSub], *dFaceNormdX[iSub], dEdgeNorm(iSub), dFaceNorm(iSub), dX2);
-    double bb = dX2*dX;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0.0) fprintf(stderr, " ... rel. diff = %e\n", diff/abs(aa));
-    else fprintf(stderr, " ... abs. diff = %e\n", diff);
-*/
 
 // TODO: part below was uncommented.
     subDomain[iSub]->sndNormals(*edgePat, dEdgeNorm.subData(iSub), dEdgeNormVel.subData(iSub));
@@ -1645,7 +1615,7 @@
 //------------------------------------------------------------------------------
 
 // Included (MB)
-// YC: if you modify this member function, you also must modify Domain::computeDerivativeTransposeOfWeightsLeastSquares accordingly
+// YC: if you modify this member function, you must modify Domain::computeDerivativeTransposeOfWeightsLeastSquares accordingly
 void Domain::computeDerivativeOfWeightsLeastSquares(DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,6> &dR)
 {
 
@@ -1655,30 +1625,10 @@
 
   double t0 = timer->getTime();
 
-//  dR = 0.0;
-//  DistSVec<double,3> x(this->getNodeDistInfo()), q(this->getNodeDistInfo());
-//  x = dX;
-//  q = 0.0;
-//  DistSVec<double,6> y(this->getNodeDistInfo());
-//  y = 2.0;
-
 #pragma omp parallel for
   for (iSub=0; iSub<numLocSub; ++iSub) {
-//    if(isSparse) {
-//      subDomain[iSub]->computeWeightsLeastSquaresEdgePart(X(iSub), R(iSub));
-//      subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(*dRdX[iSub], dX(iSub), dR(iSub));
-//    } else 
-      subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(X(iSub), dX(iSub), R(iSub), dR(iSub));
+    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(X(iSub), dX(iSub), R(iSub), dR(iSub));
     subDomain[iSub]->sndData(*weightPat, R.subData(iSub));
-
-//    YC: verification of transpose implementation for debug 
-
-//    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(X(iSub), x(iSub), R(iSub), dR(iSub));
-//    subDomain[iSub]->computeDerivativeTransposeOfWeightsLeastSquaresEdgePart(X(iSub), y(iSub), R(iSub), q(iSub));
-//    double z = dR(iSub)*y(iSub);
-//    double p = q(iSub)*x(iSub);
-//    com->fprintf(stderr,"z = %e, w = %e, rel. diff. = %e\n", z, p, (z-p)/z); 
-
   }
 
   weightPat->exchange();
@@ -1691,30 +1641,10 @@
 
   weightDerivativePat->exchange();
 
-/*
-  DistSVec<double,6> x(this->getNodeDistInfo()), q(this->getNodeDistInfo());
-  q = 0.0;
-  DistSVec<double,6> y(this->getNodeDistInfo()), s(this->getNodeDistInfo());
-  x = 3425.235;
-  s = dR;
-*/
-
 #pragma omp parallel for
   for (iSub = 0; iSub < numLocSub; ++iSub) {
     subDomain[iSub]->addRcvData(*weightDerivativePat, dR.subData(iSub));
-//    if(isSparse) subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(*dRdR[iSub], dR(iSub));
-//    else 
-      subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(R(iSub), dR(iSub));
-//   YC: verification of transpose implementation for dubug
-/*
-    y = s;
-    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(R(iSub), y(iSub));
-    q = x;
-    subDomain[iSub]->computeDerivativeTransposeOfWeightsLeastSquaresNodePart(R(iSub), q(iSub));
-    double z = x(iSub)*y(iSub);
-    double p = s(iSub)*q(iSub);
-    com->fprintf(stderr,"z = %e, p = %e, rel. diff. = %e\n", z, p, (z-p)/z); 
-*/
+    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(R(iSub), dR(iSub));
   }
 
   timer->addNodalWeightsTime(t0);
@@ -1736,17 +1666,6 @@
 #pragma omp parallel for
   for (iSub=0; iSub<numLocSub; ++iSub) {
     subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(*dRdX[iSub], dX(iSub), dR(iSub));
-/*
-    SVec<double,3> dX2(dX(iSub));    dX2 = 0.0;
-    SVec<double,6> dR2(dR(iSub));    dR2 = 0.0;
-    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresEdgePart(*dRdX[iSub], dX(iSub), dR2);
-    double aa = dR2*dR(iSub);
-    subDomain[iSub]->computeTransposeDerivativeOfWeightsLeastSquaresEdgePart(*dRdX[iSub], dR(iSub), dX2);
-    double bb = dX2*dX(iSub);
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0.0) fprintf(stderr, " ... rel. diff = %e\n", diff/abs(aa));
-    else fprintf(stderr, " ... abs. diff = %e\n", diff);
-*/  
   }
 
 #pragma omp parallel for
@@ -1759,18 +1678,7 @@
 #pragma omp parallel for
   for (iSub = 0; iSub < numLocSub; ++iSub) {
     subDomain[iSub]->addRcvData(*weightDerivativePat, dR.subData(iSub));
-//    SVec<double,6> dR2b(dR(iSub)), dR2(dR(iSub));
     subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(*dRdR[iSub], dR(iSub));
-/*
-    SVec<double,6> dR3b(dR(iSub)), dR3(dR(iSub));
-    subDomain[iSub]->computeDerivativeOfWeightsLeastSquaresNodePart(*dRdR[iSub], dR2);
-    double aa = dR3b*dR2;
-    subDomain[iSub]->computeTransposeDerivativeOfWeightsLeastSquaresNodePart(*dRdR[iSub], dR3);
-    double bb = dR3*dR2b;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0.0) fprintf(stderr, " ... rel. diff = %e\n", diff/abs(aa));
-    else fprintf(stderr, " ... abs. diff = %e\n", diff);
-*/
   }
 
   timer->addNodalWeightsTime(t0);
@@ -1804,7 +1712,7 @@
     subDomain[iSub]->computeTransposeDerivativeOfWeightsLeastSquaresEdgePart(*dRdX[iSub], dR(iSub), dX2(iSub));
   }
 
-//  assemble(vec3DPat, dX2);
+//  assemble(vec3DPat, dX2); // Must be removed. Verification Purpose
   timer->addNodalWeightsTime(t0);
 
 }
@@ -1815,8 +1723,6 @@
 // YC: if you modify this member function, you also must modify Domain::computeDerivativeTransposeOfWeightsLeastSquares accordingly
 void Domain::computeDerivativeOperatorsOfWeightsLeastSquares(DistSVec<double,3> &X, RectangularSparseMat<double,3,6> **dRdX, RectangularSparseMat<double,6,6> **dRdR)
 {
-
-//  com->printf(4," ... in Domain::computeDerivativeOperatorsOfWeightsLeastSquares 01 \n");
   int iSub;
 
   DistSVec<double,6> R(getNodeDistInfo());
@@ -1919,28 +1825,10 @@
 {
 
   double t0 = timer->getTime();
-/*
-  DistSVec<double,3> x(this->getNodeDistInfo()), y(this->getEdgeDistInfo()), zzz(this->getEdgeDistInfo());
-  DistSVec<double,3> xx(this->getNodeDistInfo()), yy(this->getEdgeDistInfo()), zz(this->getEdgeDistInfo());
-  DistSVec<double,3> dxx(this->getNodeDistInfo());
-  x = 1.0;   y = 2.0;  zzz = 3.0;  dxx = 0.0; 
-  xx = 0.0;  yy= 0.0;  zz = 0.0; 
-*/
 
 #pragma omp parallel for
   for (int iSub=0; iSub<numLocSub; ++iSub) {
     subDomain[iSub]->computeDerivativeOfWeightsGalerkin(X(iSub), dX(iSub), dwii(iSub), dwij(iSub), dwji(iSub));
-/*    com->fprintf(stderr,"xx = %e, yy = %e, zz = %e\n", xx(iSub).norm(), yy(iSub).norm(), zz(iSub).norm());
-    com->fprintf(stderr,"x = %e, y = %e, zzz = %e\n", x(iSub).norm(), y(iSub).norm(), zzz(iSub).norm());
-    com->fprintf(stderr,"dX = %e\n", dX(iSub).norm());
-    subDomain[iSub]->computeDerivativeOfWeightsGalerkin(X(iSub), dX(iSub), xx(iSub), yy(iSub), zz(iSub));
-    com->fprintf(stderr,"xx = %e, yy = %e, zz = %e\n", xx(iSub).norm(), yy(iSub).norm(), zz(iSub).norm());
-    com->fprintf(stderr,"x = %e, y = %e, zzz = %e\n", x(iSub).norm(), y(iSub).norm(), zzz(iSub).norm());
-    com->fprintf(stderr,"dX = %e\n", dX(iSub).norm());
-    double z = xx(iSub)*x(iSub) + yy(iSub)*y(iSub) + zz(iSub)*zzz(iSub);
-    subDomain[iSub]->computeDerivativeTransposeOfWeightsGalerkin(X(iSub), x(iSub), y(iSub), zzz(iSub), dxx(iSub));
-    double p = dX(iSub)*dxx(iSub);
-    com->fprintf(stderr,"z = %e, w = %e, rel. diff. = %e\n", z, p, (z-p)/z); */
   }
 
   timer->addNodalWeightsTime(t0);
@@ -1955,29 +1843,10 @@
 {
 
   double t0 = timer->getTime();
-/*
-  DistSVec<double,3> x(this->getNodeDistInfo()), y(this->getEdgeDistInfo()), zzz(this->getEdgeDistInfo());
-  DistSVec<double,3> xx(this->getNodeDistInfo()), yy(this->getEdgeDistInfo()), zz(this->getEdgeDistInfo());
-  DistSVec<double,3> dxx(this->getNodeDistInfo());
-  x = 1.0;   y = 2.0;  zzz = 3.0;  dxx = 0.0; 
-  xx = 0.0;  yy= 0.0;  zz = 0.0; 
-*/
 
 #pragma omp parallel for
   for (int iSub=0; iSub<numLocSub; ++iSub) {
     subDomain[iSub]->computeDerivativeOfWeightsGalerkin(X(iSub), dX(iSub), dwii(iSub), dwij(iSub), dwji(iSub));
-/*    com->fprintf(stderr,"xx = %e, yy = %e, zz = %e\n", xx(iSub).norm(), yy(iSub).norm(), zz(iSub).norm());
-    com->fprintf(stderr,"x = %e, y = %e, zzz = %e\n", x(iSub).norm(), y(iSub).norm(), zzz(iSub).norm());
-    com->fprintf(stderr,"dX = %e\n", dX(iSub).norm());
-    subDomain[iSub]->computeDerivativeOfWeightsGalerkin(X(iSub), dX(iSub), xx(iSub), yy(iSub), zz(iSub));
-    com->fprintf(stderr,"xx = %e, yy = %e, zz = %e\n", xx(iSub).norm(), yy(iSub).norm(), zz(iSub).norm());
-    com->fprintf(stderr,"x = %e, y = %e, zzz = %e\n", x(iSub).norm(), y(iSub).norm(), zzz(iSub).norm());
-    com->fprintf(stderr,"dX = %e\n", dX(iSub).norm());
-    double z = xx(iSub)*x(iSub) + yy(iSub)*y(iSub) + zz(iSub)*zzz(iSub);
-    subDomain[iSub]->computeDerivativeTransposeOfWeightsGalerkin(X(iSub), x(iSub), y(iSub), zzz(iSub), dxx(iSub));
-    double p = dX(iSub)*dxx(iSub);
-    com->fprintf(stderr,"z = %e, w = %e, rel. diff. = %e\n", z, p, (z-p)/z); 
-*/
   }
 
   timer->addNodalWeightsTime(t0);
diff -r da841a06e630 -r 5d849f9519c9 Edge.C
--- a/Edge.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/Edge.C	Mon Jan 30 20:09:06 2017 -0800
@@ -3368,6 +3368,31 @@
         } else {
 
 	  //*************************************
+
+//TODO CONFLICT ORIGINAL
+//      if (masterFlag[l]) {
+//
+//      	    V6NodeData (*v6data)[2] = higherOrderFSI->getV6Data();
+//                  if (v6data == NULL) {
+//                    for (int k=0; k<dim; k++) {
+//                      Wstar[k] = V[i][k]+(0.5/max(1.0-resij.alpha,alpha))*(Wstar[k]-V[i][k]);
+//                    }
+//                  } else {
+//                    higherOrderFSI->extrapolateV6(l, 0, i, V, Vi, Wstar, X, resij.alpha, length, fluidId, betai);
+//                    memcpy(Wstar, Vi, sizeof(double)*dim);
+//                  }
+//                  varFcn->getVarFcnBase(fluidId[i])->verification(0,Udummy,Wstar);
+//                  fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Wstar, Wstar, fluxi, fluidId[i], false);
+//
+//                  if (iPorous) {
+//                    fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Vi, Vj, flux, fluidId[i]);
+//                    for (int k=0; k<dim; k++) fluxi[k] = (1.0 - resij.porosity)*fluxi[k] + resij.porosity*flux[k];
+//                  }
+//
+//      	    for (int k=0; k<dim; k++) fluxes[i][k] += fluxi[k];
+//
+//      }
+      //TODO CONFLICT MERGE
 	  if (masterFlag[l]) {
 
 	    V6NodeData (*v6data)[2] = higherOrderFSI->getV6Data();
@@ -3375,11 +3400,13 @@
               for (int k=0; k<dim; k++) {
                 Wstar[k] = V[i][k]+(0.5/max(1.0-resij.alpha,alpha))*(Wstar[k]-V[i][k]);
               }
+              varFcn->getVarFcnBase(fluidId[i])->verification(0,Udummy,Wstar);
             } else {
               higherOrderFSI->extrapolateV6(l, 0, i, V, Vi, Wstar, X, resij.alpha, length, fluidId, betai);
               memcpy(Wstar, Vi, sizeof(double)*dim);
+              varFcn->getVarFcnBase(fluidId[i])->verification(0,Udummy,Wstar);
             }
-            varFcn->getVarFcnBase(fluidId[i])->verification(0,Udummy,Wstar);
+
             fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Wstar, Wstar, fluxi, fluidId[i], false);
 
             if (iPorous) {
@@ -3472,19 +3499,46 @@
 
         } else {
 
-	  //*************************************	   
+	  //*************************************
+//      //TODO CONFLICT ORIGINAL
+//      if (masterFlag[l]) {
+//
+//      	    V6NodeData (*v6data)[2] = higherOrderFSI->getV6Data();
+//                  if (v6data==NULL) {
+//                    for (int k=0; k<dim; k++) {
+//                      Wstar[k] = V[j][k]+(0.5/max(1.0-resji.alpha,alpha))*(Wstar[k]-V[j][k]);
+//                    }
+//                  } else {
+//                    higherOrderFSI->extrapolateV6(l, 1, j, V, Vj, Wstar, X, 1.0-resji.alpha, length, fluidId,betaj);
+//                    memcpy(Wstar, Vj, sizeof(double)*dim);
+//                  }
+//                  varFcn->getVarFcnBase(fluidId[j])->verification(0,Udummy,Wstar);
+//                  fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Wstar, Wstar, fluxj, fluidId[j], false);
+//
+//                  if (jPorous) {
+//                    fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Vi, Vj, flux, fluidId[j]);
+//                    for (int k=0; k<dim; k++) {
+//      		fluxj[k] = (1.0 - resji.porosity)*fluxj[k] + resji.porosity*flux[k];
+//      	      }
+//                  }
+//
+//      	    for (int k=0; k<dim; k++) fluxes[j][k] -= fluxj[k];
+//      }
+      //TODO CONFLICT MERGE
 	  if (masterFlag[l]) {
 
 	    V6NodeData (*v6data)[2] = higherOrderFSI->getV6Data();      
             if (v6data==NULL) {
               for (int k=0; k<dim; k++) {
                 Wstar[k] = V[j][k]+(0.5/max(1.0-resji.alpha,alpha))*(Wstar[k]-V[j][k]);
+                varFcn->getVarFcnBase(fluidId[j])->verification(0,Udummy,Wstar);
               }
             } else {
               higherOrderFSI->extrapolateV6(l, 1, j, V, Vj, Wstar, X, 1.0-resji.alpha, length, fluidId,betaj);
-              memcpy(Wstar, Vj, sizeof(double)*dim);
+              memcpy(Wstar, Vj, sizeof(double)*dim);//TODO chekc if this should be removed
+              varFcn->getVarFcnBase(fluidId[j])->verification(0,Udummy,Wstar);
             }
-            varFcn->getVarFcnBase(fluidId[j])->verification(0,Udummy,Wstar);
+
             fluxFcn[BC_INTERNAL]->compute(length, 0.0, normal[l], normalVel[l], Wstar, Wstar, fluxj, fluidId[j], false);
 
             if (jPorous) {
diff -r da841a06e630 -r 5d849f9519c9 Elem.C
--- a/Elem.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/Elem.C	Mon Jan 30 20:09:06 2017 -0800
@@ -163,6 +163,18 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
+void ElemSet::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, GeoState &geoState,
+				 SVec<double,3> &X, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX)
+{
+
+  Vec<double> &d2wall = geoState.getDistanceToWall();
+
+  for (int i=0; i<numElems; ++i)
+    elems[i]->computeDerivativeOperatorsOfGalerkinTerm(fet, X, d2wall, V, dViscousFluxdX);
+}
+
+//------------------------------------------------------------------------------
+template<int dim>
 void ElemSet::computeMBarAndM(DynamicVMSTerm *dvmst,
 			      SVec<double,dim> **VBar,
 			      SVec<double,1> **volRatio,
diff -r da841a06e630 -r 5d849f9519c9 Elem.h
--- a/Elem.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/Elem.h	Mon Jan 30 20:09:06 2017 -0800
@@ -195,6 +195,10 @@
 			   SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &) = 0;
 
   virtual
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, SVec<double,3> &, Vec<double> &,
+			   SVec<double,dim> &, RectangularSparseMat<double,3,dim> &) = 0; // YC
+
+  virtual
   void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *, int [3], int, Vec3D &, Vec3D &,
 			       SVec<double,3> &, SVec<double,3> &, Vec<double> &, double *, double *,
 			       SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &) = 0;
@@ -373,6 +377,12 @@
     t->computeDerivativeOfGalerkinTerm(fet, X, dX, d2wall, V, dV, dMach, dR);
   }
 
+  //YC
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,
+             Vec<double> &d2wall, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX) {
+     t->computeDerivativeOperatorsOfGalerkinTerm(fet, X, d2wall, V, dViscousFluxdX);
+  }
+
   void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,
 				  SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &d2wall, double *Vwall, double *dVwall,
 				  SVec<double,dim> &V, SVec<double,dim> &dV, double dMach, SVec<double,dim> &dR) {
@@ -620,6 +630,8 @@
   virtual void computeDerivativeTransposeOfWeightsGalerkin(SVec<double,3> &, SVec<double,3> &, SVec<double,3> &, SVec<double,3> &, SVec<double,3> &) = 0;
 
   virtual double computeDerivativeOfGradientP1Function(SVec<double,3> &, SVec<double,3> &, double [4][3]) = 0;
+  virtual double computeDerivativeOfGradientP1Function2(SVec<double,3> &, SVec<double,3> &, double [4][3], double dX[4][3]) = 0;
+  virtual void  computeDerivativeOperatorOfGradientP1Function(SVec<double,3> &, double [4][3], double[4][3][4][3], int [4]) = 0;
   virtual void computeDerivativeTransposeOfGradientP1Function(SVec<double,3> &, double, double [4][3], double [4][3], SVec<double,3> &) = 0;
 
   virtual void computeBarycentricCoordinates(SVec<double,3>&, const Vec3D& , double [3]) = 0;
@@ -844,6 +856,16 @@
   }
 
   template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,
+			      Vec<double> &d2wall, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX) {  //YC
+    ElemHelper_dim<dim> h;
+    char xx[64];
+    GenElemWrapper_dim<dim> *wrapper=
+      (GenElemWrapper_dim<dim> *)getWrapper_dim(&h, 64, xx);
+    wrapper->computeDerivativeOperatorsOfGalerkinTerm(fet, X, d2wall, V, dViscousFluxdX);
+  }
+
+  template<int dim>
   void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,
 				  SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &d2wall, double *Vwall, double *dVwall,
 				  SVec<double,dim> &V, SVec<double,dim> &dV, double dMach, SVec<double,dim> &dR) {
@@ -1074,6 +1096,13 @@
   }
 
   template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,
+			      Vec<double> &d2wall, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX) { //YC
+    fprintf(stderr, "Error: undefined function (computeDerivativeOperatorsOfGalerkinTerm) for this elem type\n"); exit(1);
+  }
+
+
+  template<int dim>
   void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,
 				  SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &d2wall, double *Vwall, double *dVwall,
 				  SVec<double,dim> &V, SVec<double,dim> &dV, double dMach, SVec<double,dim> &dR) {
@@ -1089,6 +1118,12 @@
     return -1;
   }
 
+
+//  // Included (YC)
+//    template<int dim>
+//    void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, GeoState &, SVec<double,3> &,
+//  			   SVec<double,dim> &, RectangularSparseMat<double,3,dim> &);
+
 // Level Set Reinitialization
 
   template<int dimLS>
@@ -1163,6 +1198,11 @@
   template<int dim>
 	  void computeTimeStep(FemEquationTerm *,SVec<double,3> &,SVec<double,dim> &,Vec<double> &, LevelSetStructure *LSS = 0);
 
+  // Included (YC) //TODO UNSURE
+  template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, GeoState &, SVec<double,3> &,
+                                      		   SVec<double,dim> &, RectangularSparseMat<double,3,dim> &);
+
   template<int dim>
   void computeGalerkinTerm(FemEquationTerm *, GeoState &, SVec<double,3> &, 
 			   SVec<double,dim> &, SVec<double,dim> &,
diff -r da841a06e630 -r 5d849f9519c9 ElemTet.C
--- a/ElemTet.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/ElemTet.C	Mon Jan 30 20:09:06 2017 -0800
@@ -126,8 +126,30 @@
   double vol = computeGradientP1Function(X, dp1dxj);
 
   double ddp1dxj[4][3];
+  double ddp1dxj2[4][3];
+  double diff[4][3];
   double dvol = computeDerivativeOfGradientP1Function(X, dX, ddp1dxj);
 
+  double dvol2dNodes[4][3] = {0}, ddp1dxj2dNodes[4][3][4][3] = {0};
+  computeDerivativeOperatorOfGradientP1Function(X, dvol2dNodes, ddp1dxj2dNodes);
+  double dvol3(0), ddp1dxj3[4][3] = {0};
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j) {
+      dvol3 += dvol2dNodes[i][j]*dX[ nodeNum(i) ][j];
+      for(int k=0; k<4; ++k)
+        for(int l=0; l<3; ++l) {
+          ddp1dxj3[i][j] += ddp1dxj2dNodes[i][j][k][l]*dX[ nodeNum(k) ][l];
+        }
+    }
+
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j) {
+      diff[i][j] = ddp1dxj[i][j] - ddp1dxj3[i][j];
+      if(diff[i][j] > 1e-12) {
+        fprintf(stderr, "diff for ddp1dxj in ElemTet::computeDerivativeOfGalerkinTerm is %e\n",diff[i][j]); exit(-1);
+      }
+    }
+
   double d2w[4] = {d2wall[nodeNum(0)], d2wall[nodeNum(1)],
 		   d2wall[nodeNum(2)], d2wall[nodeNum(3)]};
   double *v[4] = {V[nodeNum(0)], V[nodeNum(1)], V[nodeNum(2)], V[nodeNum(3)]};
@@ -290,6 +312,118 @@
 
 //------------------------------------------------------------------------------
 
+// Included (YC)
+template<int dim>
+void ElemTet::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, //SVec<double,3> &dX,
+			      Vec<double> &d2wall, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX)
+            //SVec<double,dim> &dV, double dMach,
+			      //SVec<double,dim> &dR)
+{
+
+  double dp1dxj[4][3];
+  double vol = computeGradientP1Function(X, dp1dxj);
+
+  double ddp1dxj[4][3];
+  double diff[4][3];
+  double dvoldNodes[4][3] = {0}, ddp1dxjdNodes[4][3][4][3] = {0};
+  computeDerivativeOperatorOfGradientP1Function(X, dvoldNodes, ddp1dxjdNodes);
+/*  double dvol3(0), ddp1dxj3[4][3] = {0};
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j) {
+      dvol3 += dvoldNodes[i][j]*dX[ nodeNum(i) ][j];
+      for(int k=0; k<4; ++k)
+        for(int l=0; l<3; ++l) {
+          ddp1dxj3[i][j] += ddp1dxjdNodes[i][j][k][l]*dX[ nodeNum(k) ][l];
+        }
+    }*/
+//  fprintf(stderr, "dvol-dvol3 = %e\n", dvol-dvol3);
+/*
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j) {
+      diff[i][j] = ddp1dxj[i][j] - ddp1dxj3[i][j];
+      if(diff[i][j] > 1e-15)
+        fprintf(stderr, "diff is %e\n",diff[i][j]);
+    }
+*/
+  double d2w[4] = {d2wall[nodeNum(0)], d2wall[nodeNum(1)],
+		   d2wall[nodeNum(2)], d2wall[nodeNum(3)]};
+  double *v[4] = {V[nodeNum(0)], V[nodeNum(1)], V[nodeNum(2)], V[nodeNum(3)]};
+//  double *dv[4] = {dV[nodeNum(0)], dV[nodeNum(1)], dV[nodeNum(2)], dV[nodeNum(3)]};
+
+  double r[3][dim], s[dim], pr[12];
+  bool porousTermExists =  fet->computeVolumeTerm(dp1dxj, d2w, v, reinterpret_cast<double *>(r),
+                                                  s, pr, vol, X, nodeNum(), volume_id);
+
+//  double dr[3][dim], ds[dim], dpr[12];
+//  fet->computeDerivativeOfVolumeTerm(dp1dxj, ddp1dxj, d2w, v, dv, dMach, reinterpret_cast<double *>(dr), ds, dpr, dvol, X, nodeNum(), volume_id);
+  double drddp1dxj[3][5][4][3] ={0}, drdV[3][5][4][5] = {0}, drdMach[3][5] ={0};
+  fet->computeDerivativeOperatorsOfVolumeTerm(dp1dxj, v, drddp1dxj, drdV, drdMach);
+/*  double dr2[3][dim] = {0};
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<5; ++j) {
+      dr2[i][j] += drdMach[i][j]*dMach;
+      for(int k=0; k<4; ++k) {
+        for(int l=0; l<3; ++l)
+          dr2[i][j] += drddp1dxj[i][j][k][l]*ddp1dxj[k][l];
+        for(int l=0; l<5; ++l)
+          dr2[i][j] += drdV[i][j][k][l]*dV[k][l];
+      }
+    } */
+/*
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<dim; ++j) {
+      double diff = abs(dr2[i][j] - dr[i][j]);
+      if(diff > 1.0e-15) fprintf(stderr, "diff is %e and dr2[i][j] is %e and dr[i][j] = %e\n",diff, dr2[i][j], dr[i][j]);
+    }
+*/
+  double dRdX[4][4][dim][3] = {0};
+  for (int j=0; j<4; ++j) {
+    int idx = nodeNum(j);
+    for (int k=0; k<dim; ++k) {
+      for(int i=0; i<4; ++i)
+        for(int l=0; l<3; ++l) {
+//          dR[idx][k] += dvoldNodes[i][l]*dX[ nodeNum(i) ][l] * ( (r[0][k] * dp1dxj[j][0] + r[1][k] * dp1dxj[j][1] + r[2][k] * dp1dxj[j][2]) - fourth * s[k] );
+          dRdX[j][i][k][l] += dvoldNodes[i][l]*( (r[0][k] * dp1dxj[j][0] + r[1][k] * dp1dxj[j][1] + r[2][k] * dp1dxj[j][2]) - fourth * s[k] );
+        }
+      for(int i=0; i<3; ++i) {
+        for(int m=0; m<4; ++m)
+          for(int l=0; l<3; ++l)
+            for(int p=0; p<4; ++p)
+              for(int q=0; q<3; ++q) {
+//                dR[idx][k] += vol*dp1dxj[j][i]*drddp1dxj[i][k][m][l]*ddp1dxjdNodes[m][l][p][q]*dX[ nodeNum(p) ][q];
+                dRdX[j][p][k][q] += vol*dp1dxj[j][i]*drddp1dxj[i][k][m][l]*ddp1dxjdNodes[m][l][p][q];
+              }
+        for(int m=0; m<4; ++m)
+          for(int l=0; l<3; ++l) {
+//            dR[idx][k] += vol*r[i][k]*(ddp1dxjdNodes[j][i][m][l]*dX[ nodeNum(m) ][l]);
+            dRdX[j][m][k][l] += vol*r[i][k]*ddp1dxjdNodes[j][i][m][l];
+          }
+      }
+//      dR[idx][k] -= vol*fourth*ds[k];
+
+    }
+  }
+
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<4; ++j)
+      dViscousFluxdX.addContrib(nodeNum(j),nodeNum(i), dRdX[j][i][0]);
+
+/*
+  if (porousTermExists) {
+    for (int j=0; j<4; ++j) {
+      int idx = nodeNum(j);
+      for (int k=1; k<4; ++k) {
+        dRdpr[idx][k] += 1.0;
+        dR[idx][k] += dpr[3*j+k-1];
+      }
+    }
+  }
+*/
+}
+
+//------------------------------------------------------------------------------
+
+
 template<int dim>
 void ElemTet::computeP1Avg(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, 
                            Vec<double> &modS_Test, SVec<double,8> &Eng_Test, SVec<double,3> &X, 
diff -r da841a06e630 -r 5d849f9519c9 ElemTet.h
--- a/ElemTet.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/ElemTet.h	Mon Jan 30 20:09:06 2017 -0800
@@ -201,6 +201,8 @@
 			      SVec<double,3> &, SVec<double,3> &);
 
   double computeDerivativeOfGradientP1Function(SVec<double,3> &, SVec<double,3> &, double [4][3]);
+  double computeDerivativeOfGradientP1Function2(SVec<double,3> &, SVec<double,3> &, double [4][3], double [4][3]);
+  void computeDerivativeOperatorOfGradientP1Function(SVec<double,3> &, double [4][3], double [4][3][4][3], int [4] = NULL);
   void computeDerivativeTransposeOfGradientP1Function(SVec<double,3> &, double, double [4][3], double [4][3], SVec<double,3> &);
 
   template<int dim>
@@ -208,6 +210,9 @@
 			   SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &);
 
   template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, SVec<double,3> &, Vec<double> &,
+                                                SVec<double,dim> &, RectangularSparseMat<double,3,dim> &);
+  template<int dim>
   void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *, int [3], int, Vec3D &, Vec3D &,
 			       SVec<double,3> &, SVec<double,3> &, Vec<double> &, double *, double *,
 			       SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &);
diff -r da841a06e630 -r 5d849f9519c9 ElemTetCore.C
--- a/ElemTetCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/ElemTetCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -76,40 +76,12 @@
 {
 
   Vec3D x[4] = { X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)], X[nodeNum(3)] };
-//  Vec3D dx[4] = { dX[nodeNum(0)], dX[nodeNum(1)], dX[nodeNum(2)], dX[nodeNum(3)] };
 
   Vec3D v1 = x[1] - x[0];
   Vec3D v2 = x[2] - x[0];
   Vec3D v3 = x[3] - x[0];
   Vec3D v12 = v1 ^ v2;
-/*
-  double dVolume = sixth * [ v12[0]*dx[3][0] - v12[0]*dx[0][0] + v12[1]*dx[3][1] - v12[1]*dx[0][1] + v12[2]*dx[3][2] - v12[2]*dx[0][2] ]
-                 + sixth * v3 * ( ((dx[1] - dx[0]) ^ v2) + (v1 ^ (dx[2] - dx[0])) );
-
-  (dx[1] - dx[0]) ^ v2 = [ v2[2]*dx[1][1] - v2[2]*dx[0][1] - v2[1]*dx[1][2] + v2[1]*dx[0][2] ]
-                         [ v2[0]*dx[1][2] - v2[0]*dx[0][2] - v2[2]*dx[1][0] + v2[2]*dx[0][0] ]
-                         [ v2[1]*dx[1][0] - v2[1]*dx[0][0] - v2[0]*dx[1][1] + v2[0]*dx[0][1] ]
-  v1 ^ (dx[2] - dx[0]) = [ v1[1]*dx[2][2] - v1[1]*dx[0][2] - v1[2]*dx[2][1] + v1[2]*dx[0][1] ]
-                         [ v1[2]*dx[2][0] - v1[2]*dx[0][0] - v1[0]*dx[2][2] + v1[0]*dx[0][2] ]
-                         [ v1[0]*dx[2][1] - v1[0]*dx[0][1] - v1[1]*dx[2][0] + v1[1]*dx[0][0] ]
-
-  sum = [ (v1[2]-v2[2])*dx[0][1] + (v2[1]-v1[1])*dx[0][2] + v2[2]*dx[1][1] - v2[1]*dx[1][2] - v1[2]*dx[2][1] + v1[1]*dx[2][2] ] 
-        [ (v2[2]-v1[2])*dx[0][0] + (v1[0]-v2[0])*dx[0][2] - v2[2]*dx[1][0] + v2[0]*dx[1][2] + v1[2]*dx[2][0] - v1[0]*dx[2][2] ]
-        [ (v1[1]-v2[1])*dx[0][0] + (v2[0]-v1[0])*dx[0][1] + v2[1]*dx[1][0] - v2[0]*dx[1][1] - v1[1]*dx[2][0] + v1[0]*dx[2][1] ]
-
-  dVolume = sixth*[ v3[1]*(v2[2]-v1[2]) + v3[2]*(v1[1]-v2[1]) - v12[0] ]T[ dx[0][0] ]
-                  [ v3[2]*(v2[0]-v1[0]) + v3[0]*(v1[2]-v2[2]) - v12[1] ] [ dx[0][1] ]
-                  [ v3[0]*(v2[1]-v1[1]) + v3[1]*(v1[0]-v2[0]) - v12[2] ] [ dx[0][2] ]
-                  [ v3[2]*v2[1] - v3[1]*v2[2]                          ] [ dx[1][0] ]
-                  [ v3[0]*v2[2] - v3[2]*v2[0]                          ] [ dx[1][1] ]
-                  [ v3[1]*v2[0] - v3[0]*v2[1]                          ] [ dx[1][2] ] 
-                  [ v3[1]*v1[2] - v3[2]*v1[1]                          ] [ dx[2][0] ]
-                  [ v3[2]*v1[0] - v3[0]*v1[2]                          ] [ dx[2][1] ]
-                  [ v3[0]*v1[1] - v3[1]*v1[0]                          ] [ dx[2][2] ]
-                  [ v12[0]                                             ] [ dx[3][0] ]
-                  [ v12[1]                                             ] [ dx[3][1] ]
-                  [ v12[2]                                             ] [ dx[3][2] ]
-*/
+
   dVolumedX0[0][0] = 0.25 * sixth * ( v3[1]*(v2[2]-v1[2]) + v3[2]*(v1[1]-v2[1]) - v12[0] );
   dVolumedX0[0][1] = 0.25 * sixth * ( v3[2]*(v2[0]-v1[0]) + v3[0]*(v1[2]-v2[2]) - v12[1] ); 
   dVolumedX0[0][2] = 0.25 * sixth * ( v3[0]*(v2[1]-v1[1]) + v3[1]*(v1[0]-v2[0]) - v12[2] );
@@ -557,11 +529,6 @@
     Vec3D xg0_np1 = f_np1[ edgeFace(l,0) ] - g_np1;
     Vec3D xg1_np1 = f_np1[ edgeFace(l,1) ] - g_np1;
 
-//    Vec3D dxg0_n = df_n[ edgeFace(l,0) ] - dg_n;
-//    Vec3D dxg1_n = df_n[ edgeFace(l,1) ] - dg_n;
-//    Vec3D dxg0_np1 = df_np1[ edgeFace(l,0) ] - dg_np1;
-//    Vec3D dxg1_np1 = df_np1[ edgeFace(l,1) ] - dg_np1;
-
     double dxg0_ndf_n[3][12] = {0}, dxg1_ndf_n[3][12] = {0}, dxg0_np1df_np1[3][12] = {0}, dxg1_np1df_np1[3][12] = {0};
     double dxg0_ndg_n[3][3] = {0}, dxg1_ndg_n[3][3] = {0}, dxg0_np1dg_np1[3][3] = {0}, dxg1_np1dg_np1[3][3] = {0};
     for(int k=0; k<3; ++k) {
@@ -602,10 +569,6 @@
     dndxg0_n[1][2] = -0.5*xg1_n[0] - 0.25*xg1_np1[0];
     dndxg0_n[2][0] = -0.5*xg1_n[1] - 0.25*xg1_np1[1];
     dndxg0_n[2][1] =  0.5*xg1_n[0] + 0.25*xg1_np1[0];
-    
-
-//    Vec3D dn = 0.5 * ((dxg1_np1 ^ xg0_np1) + (xg1_np1 ^ dxg0_np1) + (dxg1_n ^ xg0_n) + (xg1_n ^ dxg0_n)) +
-//      0.25 * ((dxg1_np1 ^ xg0_n) + (xg1_np1 ^ dxg0_n) + (dxg1_n ^ xg0_np1) + (xg1_n ^ dxg0_np1));
 
     double dndX0[3][3] = {0}, dndX1[3][3] = {0}, dndX2[3][3] = {0}, dndX3[3][3] = {0};
     if (nodeNum( edgeEnd(l,0) ) < nodeNum( edgeEnd(l,1) )) {
@@ -637,10 +600,6 @@
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(1),dndX1[0]);
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(2),dndX2[0]);
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(3),dndX3[0]);
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(0) = %d\n", l, l, edgeNum(l), nodeNum(0));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(1) = %d\n", l, l, edgeNum(l), nodeNum(1));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(2) = %d\n", l, l, edgeNum(l), nodeNum(2));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(3) = %d\n", l, l, edgeNum(l), nodeNum(3));
     }
     else {
       for(int k=0; k<3; ++k) 
@@ -671,10 +630,6 @@
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(1),dndX1[0]);
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(2),dndX2[0]);
       dEdgeNormdX.addContrib(edgeNum(l),nodeNum(3),dndX3[0]);
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(0) = %d\n", l, l, edgeNum(l), nodeNum(0));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(1) = %d\n", l, l, edgeNum(l), nodeNum(1));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(2) = %d\n", l, l, edgeNum(l), nodeNum(2));
-//      fprintf(stderr," ... in diEdgeNormdX, l = %d, edgeNum(%d) = %d, nodeNum(3) = %d\n", l, l, edgeNum(l), nodeNum(3));
     }
   }
 }
@@ -2332,6 +2287,353 @@
 
 }
 
+
+// YC: If you modify ElemTet::computeDerivativeOfGradientP1Function, you must modify ElemTet::computeDerivativeTransposeOfGradientP1Function accordingly
+inline
+double ElemTet::computeDerivativeOfGradientP1Function2(SVec<double,3> &nodes, SVec<double,3> &dNodes, double dNGrad[4][3], double dX[4][3])
+{
+
+  double jac[3][3], dJac[3][3];
+/*  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j)
+      dJac[i][j] = 0.0;
+*/
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j)
+      dX[i][j] = dNodes[nodeNum(i)][j];
+
+  //Jacobian
+  // J_ij = dx_i/dxi_j
+  jac[0][0] = nodes[ nodeNum(1) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][1] = nodes[ nodeNum(2) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][2] = nodes[ nodeNum(3) ][0] - nodes[ nodeNum(0) ][0];
+  jac[1][0] = nodes[ nodeNum(1) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][1] = nodes[ nodeNum(2) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][2] = nodes[ nodeNum(3) ][1] - nodes[ nodeNum(0) ][1];
+  jac[2][0] = nodes[ nodeNum(1) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][1] = nodes[ nodeNum(2) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][2] = nodes[ nodeNum(3) ][2] - nodes[ nodeNum(0) ][2];
+/*
+  double dJacdNodes[3][3][4][3] = {0};
+  dJacdNodes[0][2][3][0] = dJacdNodes[0][1][2][0] = dJacdNodes[0][0][1][0] = 1.0;
+  dJacdNodes[1][2][3][1] = dJacdNodes[1][1][2][1] = dJacdNodes[1][0][1][1] = 1.0;
+  dJacdNodes[2][2][3][2] = dJacdNodes[2][1][2][2] = dJacdNodes[2][0][1][2] = 1.0;
+  dJacdNodes[0][2][0][0] = dJacdNodes[0][1][0][0] = dJacdNodes[0][0][0][0] = -1.0;
+  dJacdNodes[1][2][0][1] = dJacdNodes[1][1][0][1] = dJacdNodes[1][0][0][1] = -1.0;
+  dJacdNodes[2][2][0][2] = dJacdNodes[2][1][0][2] = dJacdNodes[2][0][0][2] = -1.0;
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j)
+      for(int k=0; k<4; ++k)
+        for(int l=0; l<3; ++l)
+          if(dJacdNodes[i][j][k][l] != 0.0) dJac[i][j] += dJacdNodes[i][j][k][l]*dNodes[nodeNum(k)][l];
+*/
+
+  dJac[0][0] = dNodes[ nodeNum(1) ][0] - dNodes[ nodeNum(0) ][0];
+  dJac[0][1] = dNodes[ nodeNum(2) ][0] - dNodes[ nodeNum(0) ][0];
+  dJac[0][2] = dNodes[ nodeNum(3) ][0] - dNodes[ nodeNum(0) ][0];
+  dJac[1][0] = dNodes[ nodeNum(1) ][1] - dNodes[ nodeNum(0) ][1];
+  dJac[1][1] = dNodes[ nodeNum(2) ][1] - dNodes[ nodeNum(0) ][1];
+  dJac[1][2] = dNodes[ nodeNum(3) ][1] - dNodes[ nodeNum(0) ][1];
+  dJac[2][0] = dNodes[ nodeNum(1) ][2] - dNodes[ nodeNum(0) ][2];
+  dJac[2][1] = dNodes[ nodeNum(2) ][2] - dNodes[ nodeNum(0) ][2];
+  dJac[2][2] = dNodes[ nodeNum(3) ][2] - dNodes[ nodeNum(0) ][2];
+
+  // compute determinant of jac and derivative of the jac
+  double dOmega = jac[0][0] * (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]) +
+                                 jac[1][0] * (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]) +
+                                 jac[2][0] * (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]);
+
+  double ddOmega = dJac[0][0] * (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]) +
+                                      jac[0][0] * (dJac[1][1] * jac[2][2] + jac[1][1] * dJac[2][2] - dJac[1][2] * jac[2][1] - jac[1][2] * dJac[2][1]) +
+                                   dJac[1][0] * (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]) +
+                                      jac[1][0] * (dJac[0][2] * jac[2][1] + jac[0][2] * dJac[2][1] - dJac[0][1] * jac[2][2] - jac[0][1] * dJac[2][2]) +
+                                   dJac[2][0] * (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]) +
+                                      jac[2][0] * (dJac[0][1] * jac[1][2] + jac[0][1] * dJac[1][2] - dJac[0][2] * jac[1][1] - jac[0][2] * dJac[1][1]);
+
+  // compute inverse matrix of jac and derivative of the jac
+  // Maple code used
+  double t17 = -1.0/dOmega;
+  double dT17 = 1.0/(dOmega*dOmega)*ddOmega;
+
+  //compute shape function derivative of the gradients
+//  nGrad[1][0] =  (-jac[1][1] * jac[2][2] + jac[1][2] * jac[2][1] ) * t17;
+//  nGrad[1][1] =  ( jac[0][1] * jac[2][2] - jac[0][2] * jac[2][1] ) * t17;
+//  nGrad[1][2] = -( jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1] ) * t17;
+
+//  nGrad[2][0] = -(-jac[1][0] * jac[2][2] + jac[1][2] * jac[2][0] ) * t17;
+//  nGrad[2][1] = -( jac[0][0] * jac[2][2] - jac[0][2] * jac[2][0] ) * t17;
+//  nGrad[2][2] =  ( jac[0][0] * jac[1][2] - jac[0][2] * jac[1][0] ) * t17;
+
+//  nGrad[3][0] = -( jac[1][0] * jac[2][1] - jac[1][1] * jac[2][0] ) * t17;
+//  nGrad[3][1] =  ( jac[0][0] * jac[2][1] - jac[0][1] * jac[2][0] ) * t17;
+//  nGrad[3][2] = -( jac[0][0] * jac[1][1] - jac[0][1] * jac[1][0] ) * t17;
+
+  dNGrad[1][0] =  (-jac[1][1] * jac[2][2] + jac[1][2] * jac[2][1] ) * dT17 +
+                                (-dJac[1][1] * jac[2][2] - jac[1][1] * dJac[2][2] + dJac[1][2] * jac[2][1] + jac[1][2] * dJac[2][1] ) * t17;
+  dNGrad[1][1] =  ( jac[0][1] * jac[2][2] - jac[0][2] * jac[2][1] ) * dT17 +
+                                ( dJac[0][1] * jac[2][2] + jac[0][1] * dJac[2][2] - dJac[0][2] * jac[2][1] - jac[0][2] * dJac[2][1] ) * t17;
+  dNGrad[1][2] = -( jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1] ) * dT17 -
+                                ( dJac[0][1] * jac[1][2] + jac[0][1] * dJac[1][2] - dJac[0][2] * jac[1][1] - jac[0][2] * dJac[1][1] ) * t17;
+
+  dNGrad[2][0] = -(-jac[1][0] * jac[2][2] + jac[1][2] * jac[2][0] ) * dT17 -
+                                (-dJac[1][0] * jac[2][2] - jac[1][0] * dJac[2][2] + dJac[1][2] * jac[2][0] + jac[1][2] * dJac[2][0] ) * t17;
+  dNGrad[2][1] = -( jac[0][0] * jac[2][2] - jac[0][2] * jac[2][0] ) * dT17 -
+                                ( dJac[0][0] * jac[2][2] + jac[0][0] * dJac[2][2] - dJac[0][2] * jac[2][0] - jac[0][2] * dJac[2][0] ) * t17;
+  dNGrad[2][2] =  ( jac[0][0] * jac[1][2] - jac[0][2] * jac[1][0] ) * dT17 +
+                                ( dJac[0][0] * jac[1][2] + jac[0][0] * dJac[1][2] - dJac[0][2] * jac[1][0] - jac[0][2] * dJac[1][0] ) * t17;
+
+  dNGrad[3][0] = -( jac[1][0] * jac[2][1] - jac[1][1] * jac[2][0] ) * dT17 -
+                                ( dJac[1][0] * jac[2][1] + jac[1][0] * dJac[2][1] - dJac[1][1] * jac[2][0] - jac[1][1] * dJac[2][0] ) * t17;
+  dNGrad[3][1] =  ( jac[0][0] * jac[2][1] - jac[0][1] * jac[2][0] ) * dT17 +
+                                ( dJac[0][0] * jac[2][1] + jac[0][0] * dJac[2][1] - dJac[0][1] * jac[2][0] - jac[0][1] * dJac[2][0] ) * t17;
+  dNGrad[3][2] = -( jac[0][0] * jac[1][1] - jac[0][1] * jac[1][0] ) * dT17 -
+                                ( dJac[0][0] * jac[1][1] + jac[0][0] * dJac[1][1] - dJac[0][1] * jac[1][0] - jac[0][1] * dJac[1][0] ) * t17;
+
+  // Shape function gradients dN_i/dx_i = dN/dxi * transpose(jInv)
+  // Note: 1st index = shape function #
+  // 2nd index = direction (0=x, 1=y, 2=z)
+
+//  nGrad[0][0] = -( nGrad[1][0] + nGrad[2][0] + nGrad[3][0] );
+//  nGrad[0][1] = -( nGrad[1][1] + nGrad[2][1] + nGrad[3][1] );
+//  nGrad[0][2] = -( nGrad[1][2] + nGrad[2][2] + nGrad[3][2] );
+
+  dNGrad[0][0] = -( dNGrad[1][0] + dNGrad[2][0] + dNGrad[3][0] );
+  dNGrad[0][1] = -( dNGrad[1][1] + dNGrad[2][1] + dNGrad[3][1] );
+  dNGrad[0][2] = -( dNGrad[1][2] + dNGrad[2][2] + dNGrad[3][2] );
+
+  return sixth * ddOmega;
+
+}
+
+//------------------------------------------------------------------------------
+/*
+inline
+double ElemTet::computeDerivativeOfGradientP1Function2(SVec<double,3> &nodes, SVec<double,3> &dNodes, double dNGrad[4][3], double dX[4][3])
+{
+
+  double jac[3][3], dJac[3][3] = {0};
+
+  //Jacobian
+  // J_ij = dx_i/dxi_j
+  jac[0][0] = nodes[ nodeNum(1) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][1] = nodes[ nodeNum(2) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][2] = nodes[ nodeNum(3) ][0] - nodes[ nodeNum(0) ][0];
+  jac[1][0] = nodes[ nodeNum(1) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][1] = nodes[ nodeNum(2) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][2] = nodes[ nodeNum(3) ][1] - nodes[ nodeNum(0) ][1];
+  jac[2][0] = nodes[ nodeNum(1) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][1] = nodes[ nodeNum(2) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][2] = nodes[ nodeNum(3) ][2] - nodes[ nodeNum(0) ][2];
+
+  double dJacdNodes[3][3][4][3] = {0};
+  dJacdNodes[0][2][3][0] = dJacdNodes[0][1][2][0] = dJacdNodes[0][0][1][0] = 1.0;
+  dJacdNodes[1][2][3][1] = dJacdNodes[1][1][2][1] = dJacdNodes[1][0][1][1] = 1.0;
+  dJacdNodes[2][2][3][2] = dJacdNodes[2][1][2][2] = dJacdNodes[2][0][1][2] = 1.0;
+  dJacdNodes[0][2][0][0] = dJacdNodes[0][1][0][0] = dJacdNodes[0][0][0][0] = -1.0;
+  dJacdNodes[1][2][0][1] = dJacdNodes[1][1][0][1] = dJacdNodes[1][0][0][1] = -1.0;
+  dJacdNodes[2][2][0][2] = dJacdNodes[2][1][0][2] = dJacdNodes[2][0][0][2] = -1.0;
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j)
+      for(int k=0; k<4; ++k)
+        for(int l=0; l<3; ++l)
+          dJac[i][j] += dJacdNodes[i][j][k][l]*dNodes[nodeNum(k)][l];
+
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j)
+      dX[i][j] = dNodes[nodeNum(i)][j];
+
+  // compute determinant of jac and derivative of the jac
+  double dOmega = jac[0][0] * (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]) +
+                                 jac[1][0] * (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]) +
+                                 jac[2][0] * (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]);
+  double ddOmega = 0;
+  double ddOmegadJac[3][3] = {0};
+  ddOmegadJac[0][0] += (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]);
+  ddOmegadJac[1][0] += (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]);
+  ddOmegadJac[2][0] += (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]);
+  ddOmegadJac[1][1] +=  jac[0][0] * jac[2][2];
+  ddOmegadJac[2][2] +=  jac[0][0] * jac[1][1];
+  ddOmegadJac[1][2] += -jac[0][0] * jac[2][1];
+  ddOmegadJac[2][1] += -jac[0][0] * jac[1][2];
+  ddOmegadJac[0][2] +=  jac[1][0] * jac[2][1];
+  ddOmegadJac[2][1] +=  jac[1][0] * jac[0][2];
+  ddOmegadJac[0][1] += -jac[1][0] * jac[2][2];
+  ddOmegadJac[2][2] += -jac[1][0] * jac[0][1];
+  ddOmegadJac[0][1] +=  jac[2][0] * jac[1][2];
+  ddOmegadJac[1][2] +=  jac[2][0] * jac[0][1];
+  ddOmegadJac[0][2] += -jac[2][0] * jac[1][1];
+  ddOmegadJac[1][1] += -jac[2][0] * jac[0][2];
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j)
+      ddOmega += ddOmegadJac[i][j]*dJac[i][j];
+
+  // compute inverse matrix of jac and derivative of the jac
+  // Maple code used
+  double t17 = -1.0/dOmega;
+  double dT17ddOmega = 1.0/(dOmega*dOmega);
+  double dT17 = dT17ddOmega*ddOmega;
+
+  //compute shape function derivative of the gradients
+  double dNGraddJac[4][3][3][3] = {0}, dNGraddT17[4][3] = {0};
+  dNGraddT17[1][0] += (-jac[1][1] * jac[2][2] + jac[1][2] * jac[2][1] );
+  dNGraddT17[1][1] += ( jac[0][1] * jac[2][2] - jac[0][2] * jac[2][1] );
+  dNGraddT17[1][2] += -( jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1] );
+  dNGraddT17[2][0] += -(-jac[1][0] * jac[2][2] + jac[1][2] * jac[2][0] );
+  dNGraddT17[2][1] += -( jac[0][0] * jac[2][2] - jac[0][2] * jac[2][0] );
+  dNGraddT17[2][2] += ( jac[0][0] * jac[1][2] - jac[0][2] * jac[1][0] );
+  dNGraddT17[3][0] += -( jac[1][0] * jac[2][1] - jac[1][1] * jac[2][0] );
+  dNGraddT17[3][1] += ( jac[0][0] * jac[2][1] - jac[0][1] * jac[2][0] );
+  dNGraddT17[3][2] += -( jac[0][0] * jac[1][1] - jac[0][1] * jac[1][0] );
+  dNGraddT17[0][0] = -(dNGraddT17[1][0] + dNGraddT17[2][0] + dNGraddT17[3][0]);
+  dNGraddT17[0][1] = -(dNGraddT17[1][1] + dNGraddT17[2][1] + dNGraddT17[3][1]);
+  dNGraddT17[0][2] = -(dNGraddT17[1][2] + dNGraddT17[2][2] + dNGraddT17[3][2]);
+
+
+  dNGraddJac[1][0][1][1] += -jac[2][2]*t17;  dNGraddJac[1][0][2][2] += -jac[1][1]*t17;  dNGraddJac[1][0][1][2] +=  jac[2][1]*t17;  dNGraddJac[1][0][2][1] +=  jac[1][2]*t17;
+  dNGraddJac[1][1][0][1] +=  jac[2][2]*t17;  dNGraddJac[1][1][2][2] +=  jac[0][1]*t17;  dNGraddJac[1][1][0][2] += -jac[2][1]*t17;  dNGraddJac[1][1][2][1] += -jac[0][2]*t17;
+  dNGraddJac[1][2][0][1] += -jac[1][2]*t17;  dNGraddJac[1][2][1][2] += -jac[0][1]*t17;  dNGraddJac[1][2][0][2] +=  jac[1][1]*t17;  dNGraddJac[1][2][1][1] +=  jac[0][2]*t17;
+  dNGraddJac[2][0][1][0] +=  jac[2][2]*t17;  dNGraddJac[2][0][2][2] +=  jac[1][0]*t17;  dNGraddJac[2][0][1][2] += -jac[2][0]*t17;  dNGraddJac[2][0][2][0] += -jac[1][2]*t17;
+  dNGraddJac[2][1][0][0] += -jac[2][2]*t17;  dNGraddJac[2][1][2][2] += -jac[0][0]*t17;  dNGraddJac[2][1][0][2] +=  jac[2][0]*t17;  dNGraddJac[2][1][2][0] +=  jac[0][2]*t17;
+  dNGraddJac[2][2][0][0] +=  jac[1][2]*t17;  dNGraddJac[2][2][1][2] +=  jac[0][0]*t17;  dNGraddJac[2][2][0][2] += -jac[1][0]*t17;  dNGraddJac[2][2][1][0] += -jac[0][2]*t17;
+  dNGraddJac[3][0][1][0] += -jac[2][1]*t17;  dNGraddJac[3][0][2][1] += -jac[1][0]*t17;  dNGraddJac[3][0][1][1] +=  jac[2][0]*t17;  dNGraddJac[3][0][2][0] +=  jac[1][1]*t17;
+  dNGraddJac[3][1][0][0] +=  jac[2][1]*t17;  dNGraddJac[3][1][2][1] +=  jac[0][0]*t17;  dNGraddJac[3][1][0][1] += -jac[2][0]*t17;  dNGraddJac[3][1][2][0] += -jac[0][1]*t17;
+  dNGraddJac[3][2][0][0] += -jac[1][1]*t17;  dNGraddJac[3][2][1][1] += -jac[0][0]*t17;  dNGraddJac[3][2][0][1] +=  jac[1][0]*t17;  dNGraddJac[3][2][1][0] +=  jac[0][1]*t17;
+
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j) {
+      dNGraddJac[0][0][i][j] += -( dNGraddJac[1][0][i][j] + dNGraddJac[2][0][i][j] + dNGraddJac[3][0][i][j] );
+      dNGraddJac[0][1][i][j] += -( dNGraddJac[1][1][i][j] + dNGraddJac[2][1][i][j] + dNGraddJac[3][1][i][j] );
+      dNGraddJac[0][2][i][j] += -( dNGraddJac[1][2][i][j] + dNGraddJac[2][2][i][j] + dNGraddJac[3][2][i][j] );
+    }
+
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j)
+      for(int k=0; k<3; ++k)
+        for(int l=0; l<3; ++l)
+          for(int m=0; m<4; ++m)
+            for(int n=0; n<3; ++n)
+              dNGrad[i][j] += (dNGraddJac[i][j][k][l] + dNGraddT17[i][j]*dT17ddOmega*ddOmegadJac[k][l])*dJacdNodes[k][l][m][n]*dNodes[nodeNum(m)][n];
+
+
+  return sixth * ddOmega;
+
+}
+*/
+//------------------------------------------------------------------------------
+
+inline
+void ElemTet::computeDerivativeOperatorOfGradientP1Function(SVec<double,3> &nodes, double ddOmegadNodes[4][3], double dNGraddNodes[4][3][4][3], int nodeNumTet[4])
+{ //YC
+
+  double jac[3][3], dJac[3][3] = {0};
+  if(nodeNumTet) for(int i=0; i<4; ++i) nodeNumTet[i] = nodeNum(i);
+
+  //Jacobian
+  // J_ij = dx_i/dxi_j
+  jac[0][0] = nodes[ nodeNum(1) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][1] = nodes[ nodeNum(2) ][0] - nodes[ nodeNum(0) ][0];
+  jac[0][2] = nodes[ nodeNum(3) ][0] - nodes[ nodeNum(0) ][0];
+  jac[1][0] = nodes[ nodeNum(1) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][1] = nodes[ nodeNum(2) ][1] - nodes[ nodeNum(0) ][1];
+  jac[1][2] = nodes[ nodeNum(3) ][1] - nodes[ nodeNum(0) ][1];
+  jac[2][0] = nodes[ nodeNum(1) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][1] = nodes[ nodeNum(2) ][2] - nodes[ nodeNum(0) ][2];
+  jac[2][2] = nodes[ nodeNum(3) ][2] - nodes[ nodeNum(0) ][2];
+
+  double dJacdNodes[3][3][4][3] = {0};
+  dJacdNodes[0][2][3][0] = dJacdNodes[0][1][2][0] = dJacdNodes[0][0][1][0] = 1.0;
+  dJacdNodes[1][2][3][1] = dJacdNodes[1][1][2][1] = dJacdNodes[1][0][1][1] = 1.0;
+  dJacdNodes[2][2][3][2] = dJacdNodes[2][1][2][2] = dJacdNodes[2][0][1][2] = 1.0;
+  dJacdNodes[0][2][0][0] = dJacdNodes[0][1][0][0] = dJacdNodes[0][0][0][0] = -1.0;
+  dJacdNodes[1][2][0][1] = dJacdNodes[1][1][0][1] = dJacdNodes[1][0][0][1] = -1.0;
+  dJacdNodes[2][2][0][2] = dJacdNodes[2][1][0][2] = dJacdNodes[2][0][0][2] = -1.0;
+
+  // compute determinant of jac and derivative of the jac
+  double dOmega = jac[0][0] * (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]) +
+                                 jac[1][0] * (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]) +
+                                 jac[2][0] * (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]);
+  double ddOmega = 0;
+  double ddOmegadJac[3][3] = {0};
+  ddOmegadJac[0][0] += (jac[1][1] * jac[2][2] - jac[1][2] * jac[2][1]);
+  ddOmegadJac[1][0] += (jac[0][2] * jac[2][1] - jac[0][1] * jac[2][2]);
+  ddOmegadJac[2][0] += (jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1]);
+  ddOmegadJac[1][1] +=  jac[0][0] * jac[2][2];
+  ddOmegadJac[2][2] +=  jac[0][0] * jac[1][1];
+  ddOmegadJac[1][2] += -jac[0][0] * jac[2][1];
+  ddOmegadJac[2][1] += -jac[0][0] * jac[1][2];
+  ddOmegadJac[0][2] +=  jac[1][0] * jac[2][1];
+  ddOmegadJac[2][1] +=  jac[1][0] * jac[0][2];
+  ddOmegadJac[0][1] += -jac[1][0] * jac[2][2];
+  ddOmegadJac[2][2] += -jac[1][0] * jac[0][1];
+  ddOmegadJac[0][1] +=  jac[2][0] * jac[1][2];
+  ddOmegadJac[1][2] +=  jac[2][0] * jac[0][1];
+  ddOmegadJac[0][2] += -jac[2][0] * jac[1][1];
+  ddOmegadJac[1][1] += -jac[2][0] * jac[0][2];
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j)
+      ddOmega += ddOmegadJac[i][j]*dJac[i][j];
+
+  // compute inverse matrix of jac and derivative of the jac
+  // Maple code used
+  double t17 = -1.0/dOmega;
+  double dT17ddOmega = 1.0/(dOmega*dOmega);
+  double dT17 = dT17ddOmega*ddOmega;
+
+  //compute shape function derivative of the gradients
+  double dNGraddJac[4][3][3][3] = {0}, dNGraddT17[4][3] = {0};
+  dNGraddT17[1][0] += (-jac[1][1] * jac[2][2] + jac[1][2] * jac[2][1] );
+  dNGraddT17[1][1] += ( jac[0][1] * jac[2][2] - jac[0][2] * jac[2][1] );
+  dNGraddT17[1][2] += -( jac[0][1] * jac[1][2] - jac[0][2] * jac[1][1] );
+  dNGraddT17[2][0] += -(-jac[1][0] * jac[2][2] + jac[1][2] * jac[2][0] );
+  dNGraddT17[2][1] += -( jac[0][0] * jac[2][2] - jac[0][2] * jac[2][0] );
+  dNGraddT17[2][2] += ( jac[0][0] * jac[1][2] - jac[0][2] * jac[1][0] );
+  dNGraddT17[3][0] += -( jac[1][0] * jac[2][1] - jac[1][1] * jac[2][0] );
+  dNGraddT17[3][1] += ( jac[0][0] * jac[2][1] - jac[0][1] * jac[2][0] );
+  dNGraddT17[3][2] += -( jac[0][0] * jac[1][1] - jac[0][1] * jac[1][0] );
+  dNGraddT17[0][0] = -(dNGraddT17[1][0] + dNGraddT17[2][0] + dNGraddT17[3][0]);
+  dNGraddT17[0][1] = -(dNGraddT17[1][1] + dNGraddT17[2][1] + dNGraddT17[3][1]);
+  dNGraddT17[0][2] = -(dNGraddT17[1][2] + dNGraddT17[2][2] + dNGraddT17[3][2]);
+
+
+  dNGraddJac[1][0][1][1] += -jac[2][2]*t17;  dNGraddJac[1][0][2][2] += -jac[1][1]*t17;  dNGraddJac[1][0][1][2] +=  jac[2][1]*t17;  dNGraddJac[1][0][2][1] +=  jac[1][2]*t17;
+  dNGraddJac[1][1][0][1] +=  jac[2][2]*t17;  dNGraddJac[1][1][2][2] +=  jac[0][1]*t17;  dNGraddJac[1][1][0][2] += -jac[2][1]*t17;  dNGraddJac[1][1][2][1] += -jac[0][2]*t17;
+  dNGraddJac[1][2][0][1] += -jac[1][2]*t17;  dNGraddJac[1][2][1][2] += -jac[0][1]*t17;  dNGraddJac[1][2][0][2] +=  jac[1][1]*t17;  dNGraddJac[1][2][1][1] +=  jac[0][2]*t17;
+  dNGraddJac[2][0][1][0] +=  jac[2][2]*t17;  dNGraddJac[2][0][2][2] +=  jac[1][0]*t17;  dNGraddJac[2][0][1][2] += -jac[2][0]*t17;  dNGraddJac[2][0][2][0] += -jac[1][2]*t17;
+  dNGraddJac[2][1][0][0] += -jac[2][2]*t17;  dNGraddJac[2][1][2][2] += -jac[0][0]*t17;  dNGraddJac[2][1][0][2] +=  jac[2][0]*t17;  dNGraddJac[2][1][2][0] +=  jac[0][2]*t17;
+  dNGraddJac[2][2][0][0] +=  jac[1][2]*t17;  dNGraddJac[2][2][1][2] +=  jac[0][0]*t17;  dNGraddJac[2][2][0][2] += -jac[1][0]*t17;  dNGraddJac[2][2][1][0] += -jac[0][2]*t17;
+  dNGraddJac[3][0][1][0] += -jac[2][1]*t17;  dNGraddJac[3][0][2][1] += -jac[1][0]*t17;  dNGraddJac[3][0][1][1] +=  jac[2][0]*t17;  dNGraddJac[3][0][2][0] +=  jac[1][1]*t17;
+  dNGraddJac[3][1][0][0] +=  jac[2][1]*t17;  dNGraddJac[3][1][2][1] +=  jac[0][0]*t17;  dNGraddJac[3][1][0][1] += -jac[2][0]*t17;  dNGraddJac[3][1][2][0] += -jac[0][1]*t17;
+  dNGraddJac[3][2][0][0] += -jac[1][1]*t17;  dNGraddJac[3][2][1][1] += -jac[0][0]*t17;  dNGraddJac[3][2][0][1] +=  jac[1][0]*t17;  dNGraddJac[3][2][1][0] +=  jac[0][1]*t17;
+
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j) {
+      dNGraddJac[0][0][i][j] += -( dNGraddJac[1][0][i][j] + dNGraddJac[2][0][i][j] + dNGraddJac[3][0][i][j] );
+      dNGraddJac[0][1][i][j] += -( dNGraddJac[1][1][i][j] + dNGraddJac[2][1][i][j] + dNGraddJac[3][1][i][j] );
+      dNGraddJac[0][2][i][j] += -( dNGraddJac[1][2][i][j] + dNGraddJac[2][2][i][j] + dNGraddJac[3][2][i][j] );
+    }
+
+  for(int i=0; i<4; ++i)
+    for(int j=0; j<3; ++j)
+      for(int k=0; k<3; ++k)
+        for(int l=0; l<3; ++l)
+          for(int m=0; m<4; ++m)
+            for(int n=0; n<3; ++n)
+              dNGraddNodes[i][j][m][n] += (dNGraddJac[i][j][k][l] + dNGraddT17[i][j]*dT17ddOmega*ddOmegadJac[k][l])*dJacdNodes[k][l][m][n];
+
+  if(ddOmegadNodes) {
+    for(int i=0; i<3; ++i)
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<4; ++k)
+          for(int l=0; l<3; ++l)
+            ddOmegadNodes[k][l] += sixth*ddOmegadJac[i][j]*dJacdNodes[i][j][k][l];
+  }
+
+}
+
+
+
+
+
 //------------------------------------------------------------------------------
 /*
 
diff -r da841a06e630 -r 5d849f9519c9 Face.h
--- a/Face.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/Face.h	Mon Jan 30 20:09:06 2017 -0800
@@ -148,7 +148,7 @@
                                              double, double [3], SVec<double,3> &, 
                                              double* gradP[3], double* dGradP[3]) = 0;
 
-  virtual void computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double* gradP[3],
+  virtual void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double* gradP[3],
                                                       RectangularSparseMat<double,3,3> &dForcedX,
                                                       RectangularSparseMat<double,3,3> &dForcedGradP,
                                                       RectangularSparseMat<double,dim,3> &dForcedV,
@@ -164,6 +164,28 @@
                                                  SVec<double,dim> &, SVec<double,dim> &, double [3], 
                                                  Vec3D &, Vec3D &, Vec3D &, Vec3D &, Vec3D &, 
                                                  double* gradP[3], double* dGradP[3], int = 0) = 0;
+  /*
+    virtual void computeDerivativeOfForceAndMoment2(ElemSet &, PostFcn *, SVec<double,3> &, SVec<double,3> &,
+                                                    Vec<double> &, double *, double *,
+                                                    SVec<double,dim> &, SVec<double,dim> &, double [3],
+                                                    Vec3D &, Vec3D &, Vec3D &, Vec3D &, Vec3D &,
+                                                    double* gradP[3], double* dGradP[3], int = 0) = 0;
+  */
+  virtual void computeDerivativeOperatorsOfForceAndMoment(ElemSet &, PostFcn *, SVec<double,3> &,
+                                                          Vec<double> &, double *, SVec<double,dim> &, Vec3D &,
+                                                          double* gradP[3], int ,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,dim,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,dim,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,dim,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,3,3> &,
+                                                          RectangularSparseMat<double,dim,3> &) = 0;
 
   virtual void computeDerivativeOfGalerkinTerm(ElemSet &, FemEquationTerm *, SVec<double,3> &, SVec<double,3> &,
                                                Vec<double> &, double *, double *, SVec<double,dim> &, 
@@ -289,12 +311,12 @@
     t->computeDerivativeOfNodalForce(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, pin, dS, dF, gradP, dGradP);
   }
 
-  void computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double* gradP[3],
+  void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double* gradP[3],
                                               RectangularSparseMat<double,3,3> &dForcedX,
                                               RectangularSparseMat<double,3,3> &dForcedGradP,
                                               RectangularSparseMat<double,dim,3> &dForcedV,
                                               RectangularSparseMat<double,3,3> &dForcedS) {
-    t->computeDerivativeOperatorsOfNodalForce(postFcn, X, V, Pin, gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
+	t->computeDerivativeOperatorsOfNodalForce(elems, postFcn, X, V, Pin, gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
   }
 
   void computeDerivativeOfNodalHeatPower(ElemSet& elems, PostFcn* postFcn, SVec<double,3>& X, 
@@ -312,6 +334,35 @@
                                          double* gradP[3], double* dGradP[3], int hydro) {
     t->computeDerivativeOfForceAndMoment(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, x0, dFi, dMi, dFv, dMv, gradP, dGradP, hydro);
   }
+  /*
+    void computeDerivativeOfForceAndMoment2(ElemSet &elems, PostFcn *postFcn,
+                                           SVec<double,3> &X, SVec<double,3> &dX,
+                                           Vec<double> &d2wall, double *Vwall, double *dVwall,
+                                           SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
+                                           Vec3D &x0, Vec3D &dFi, Vec3D &dMi, Vec3D &dFv, Vec3D &dMv,
+                                           double* gradP[3], double* dGradP[3], int hydro) {
+      t->computeDerivativeOfForceAndMoment2(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, x0, dFi, dMi, dFv, dMv, gradP, dGradP, hydro);
+    }
+  */
+  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
+                                                  Vec<double> &d2wall, double *Vwall, SVec<double,dim> &V, Vec3D &x0,
+                                                  double* gradP[3], int hydro,
+                                                  RectangularSparseMat<double,3,3> &dFidGradP,
+                                                  RectangularSparseMat<double,3,3> &dFidX,
+                                                  RectangularSparseMat<double,dim,3> &dFidV,
+                                                  RectangularSparseMat<double,3,3> &dFvdX,
+                                                  RectangularSparseMat<double,dim,3> &dFvdV,
+                                                  RectangularSparseMat<double,3,3> &dFidS,
+                                                  RectangularSparseMat<double,3,3> &dMidGradP,
+                                                  RectangularSparseMat<double,3,3> &dMidX,
+                                                  RectangularSparseMat<double,dim,3> &dMidV,
+                                                  RectangularSparseMat<double,3,3> &dMidS,
+                                                  RectangularSparseMat<double,3,3> &dMvdX,
+                                                  RectangularSparseMat<double,dim,3> &dMvdV) {
+    t->computeDerivativeOperatorsOfForceAndMoment(elems, postFcn, X, d2wall, Vwall, V, x0, gradP, hydro,
+                                                  dFidGradP, dFidX, dFidV, dFvdX, dFvdV, dFidS,
+                                                  dMidGradP, dMidX, dMidV, dMidS, dMvdX, dMvdV);
+  }
 
   void computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,
                                        Vec<double> &d2wall, double *Vwall, double *dVwall, SVec<double,dim> &V, 
@@ -796,7 +847,7 @@
   }
 
   template<int dim>
-  void computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double *gradP[3],
+  void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double *gradP[3],
                                               RectangularSparseMat<double,3,3> &dForcedX,
                                               RectangularSparseMat<double,3,3> &dForcedGradP,
                                               RectangularSparseMat<double,dim,3> &dForcedV,
@@ -805,7 +856,7 @@
     char xx[64];
     GenFaceWrapper_dim<dim> *wrapper=
       (GenFaceWrapper_dim<dim> *)getWrapper_dim(&h, 64, xx);
-    wrapper->computeDerivativeOperatorsOfNodalForce(postFcn, X, V, Pin, gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
+    wrapper->computeDerivativeOperatorsOfNodalForce(elems, postFcn, X, V, Pin, gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
   }
 
   template<int dim>
@@ -821,6 +872,21 @@
 
   template<int dim>
   void computeDerivativeOfForceAndMoment(ElemSet &elems, PostFcn *postFcn,
+                                         SVec<double,3> &X, SVec<double,3> &dX,
+                                         Vec<double> &d2wall, double *Vwall, double *dVwall,
+                                         SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
+                                         Vec3D &x0, Vec3D &dFi, Vec3D &dMi, Vec3D &dFv, Vec3D &dMv,
+                                         double* gradP[3], double* dGradP[3], int hydro) {
+
+    FaceHelper_dim<dim> h;
+    char xx[64];
+    GenFaceWrapper_dim<dim> *wrapper=
+      (GenFaceWrapper_dim<dim> *)getWrapper_dim(&h, 64, xx);
+    wrapper->computeDerivativeOfForceAndMoment(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, x0, dFi, dMi, dFv, dMv, gradP, dGradP, hydro);
+  }
+/*
+  template<int dim>
+  void computeDerivativeOfForceAndMoment2(ElemSet &elems, PostFcn *postFcn,
                                              SVec<double,3> &X, SVec<double,3> &dX,
                                              Vec<double> &d2wall, double *Vwall, double *dVwall,
                                              SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
@@ -831,7 +897,32 @@
     char xx[64];
     GenFaceWrapper_dim<dim> *wrapper=
       (GenFaceWrapper_dim<dim> *)getWrapper_dim(&h, 64, xx);
-    wrapper->computeDerivativeOfForceAndMoment(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, x0, dFi, dMi, dFv, dMv, gradP, dGradP, hydro);
+    wrapper->computeDerivativeOfForceAndMoment2(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, x0, dFi, dMi, dFv, dMv, gradP, dGradP, hydro);
+  }
+*/
+  template<int dim>
+  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
+                                                  Vec<double> &d2wall, double *Vwall, SVec<double,dim> &V, Vec3D &x0,
+                                                  double* gradP[3], int hydro,
+                                                  RectangularSparseMat<double,3,3> &dFidGradP,
+                                                  RectangularSparseMat<double,3,3> &dFidX,
+                                                  RectangularSparseMat<double,dim,3> &dFidV,
+                                                  RectangularSparseMat<double,3,3> &dFvdX,
+                                                  RectangularSparseMat<double,dim,3> &dFvdV,
+                                                  RectangularSparseMat<double,3,3> &dFidS,
+                                                  RectangularSparseMat<double,3,3> &dMidGradP,
+                                                  RectangularSparseMat<double,3,3> &dMidX,
+                                                  RectangularSparseMat<double,dim,3> &dMidV,
+                                                  RectangularSparseMat<double,3,3> &dMidS,
+                                                  RectangularSparseMat<double,3,3> &dMvdX,
+                                                  RectangularSparseMat<double,dim,3> &dMvdV) {
+    FaceHelper_dim<dim> h;
+    char xx[64];
+    GenFaceWrapper_dim<dim> *wrapper=
+      (GenFaceWrapper_dim<dim> *)getWrapper_dim(&h, 64, xx);
+    wrapper->computeDerivativeOperatorsOfForceAndMoment(elems, postFcn, X, d2wall, Vwall, V, x0, gradP, hydro,
+                                                        dFidGradP, dFidX, dFidV, dFvdX, dFvdV, dFidS,
+                                                        dMidGradP, dMidX, dMidV, dMidS, dMvdX, dMvdV);
   }
 
   template<int dim>
@@ -993,7 +1084,7 @@
   }
 
   template<int dim>
-  void computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X,
+  void computeDerivativeOperatorsOfNodalForce(ElemSet *elems, PostFcn *postFcn, SVec<double,3> &X,
                           SVec<double,dim> &V, double pin, double* gradP[3],
                           RectangularSparseMat<double,3,3> &dForcedX,
                           RectangularSparseMat<double,3,3> &dForcedGradP,
@@ -1020,6 +1111,37 @@
 
     fprintf(stderr, "Error: undefined function (computeDerivativeOfForceAndMoment) for this face type\n"); exit(1);
   }
+  /*
+    template<int dim>
+    void computeDerivativeOfForceAndMoment2(ElemSet &elems, PostFcn *postFcn,
+                                               SVec<double,3> &X, SVec<double,3> &dX,
+                                               Vec<double> &d2wall, double *Vwall, double *dVwall,
+                                               SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
+                                               Vec3D &x0, Vec3D &dFi, Vec3D &dMi, Vec3D &dFv, Vec3D &dMv,
+  				             double* gradP[3], double* dGradP[3], int hydro) {
+
+      fprintf(stderr, "Error: undefined function (computeDerivativeOfForceAndMoment2) for this face type\n"); exit(1);
+    }
+  */
+  template<int dim>
+  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
+                                                  Vec<double> &d2wall, double *Vwall, SVec<double,dim> &V, Vec3D &x0,
+                                                  double* gradP[3], int hydro,
+                                                  RectangularSparseMat<double,3,3> &dFidGradP,
+                                                  RectangularSparseMat<double,3,3> &dFidX,
+                                                  RectangularSparseMat<double,dim,3> &dFidV,
+                                                  RectangularSparseMat<double,3,3> &dFvdX,
+                                                  RectangularSparseMat<double,dim,3> &dFvdV,
+                                                  RectangularSparseMat<double,3,3> &dFidS,
+                                                  RectangularSparseMat<double,3,3> &dMidGradP,
+                                                  RectangularSparseMat<double,3,3> &dMidX,
+                                                  RectangularSparseMat<double,dim,3> &dMidV,
+                                                  RectangularSparseMat<double,3,3> &dMidS,
+                                                  RectangularSparseMat<double,3,3> &dMvdX,
+                                                  RectangularSparseMat<double,dim,3> &dMvdV) {
+    fprintf(stderr, "Error: undefined function (computeDerivativeOperatorsOfForceAndMoment) for this face type\n"); exit(1);
+  }
+
 
   template<int dim>
   void computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,
diff -r da841a06e630 -r 5d849f9519c9 FaceTria.C
--- a/FaceTria.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/FaceTria.C	Mon Jan 30 20:09:06 2017 -0800
@@ -149,12 +149,10 @@
 
   double d2w[3] = {d2wall[nodeNum(0)], d2wall[nodeNum(1)], d2wall[nodeNum(2)]};
   double *Vface[3] = {V[nodeNum(0)], V[nodeNum(1)], V[nodeNum(2)]};
-  double *Vtet[4] = {V[elem[0]], V[elem[1]],
-		     V[elem[2]], V[elem[3]]};
+  double *Vtet[4] = {V[elem[0]], V[elem[1]], V[elem[2]], V[elem[3]]};
   double *Xface[3] = {X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)]};
   double *dVface[3] = {dV[nodeNum(0)], dV[nodeNum(1)], dV[nodeNum(2)]};
-  double *dVtet[4] = {dV[elem[0]], dV[elem[1]],
-		     dV[elem[2]], dV[elem[3]]};
+  double *dVtet[4] = {dV[elem[0]], dV[elem[1]], dV[elem[2]], dV[elem[3]]};
   double *dXface[3] = {dX[nodeNum(0)], dX[nodeNum(1)], dX[nodeNum(2)]};
 
   double dPdx[3][3], ddPdx[3][3];
@@ -167,8 +165,176 @@
     ddPdx[i][1] = dGradP[1][nodeNum(i)];
     ddPdx[i][2] = dGradP[2][nodeNum(i)];
   }
+  //  Vec3D dFi00(dFi0), dFi11(dFi1), dFi22(dFi2), dFvv(dFv);
+  postFcn->computeDerivativeOfForce(dp1dxj, ddp1dxj, Xface, dXface, n, dn, d2w, Vwall, dVwall, Vface, dVface, Vtet, dVtet, dS, pin, dFi0, dFi1, dFi2, dFv, dPdx, ddPdx, hydro);
+  //  postFcn->computeDerivativeOfForce2(dp1dxj, ddp1dxj, Xface, dXface, n, dn, d2w, Vwall, dVwall, Vface, dVface, Vtet, dVtet, dS, pin, dFi00, dFi11, dFi22, dFvv, dPdx, ddPdx, hydro);
+  /*
+    double dFi0dn[3] ={0};          double dFi1dn[3] = {0};         double dFi2dn[3] ={0};
+    double dFi0dGradP[3][3] = {0};   double dFi1dGradP[3][3] ={0};    double dFi2dGradP[3][3] ={0};
+    double dFi0dX0[3][3] = {0}; double dFi0dX1[3][3] = {0}; double dFi0dX2[3][3] = {0};
+    double dFi1dX0[3][3] = {0}; double dFi1dX1[3][3] = {0}; double dFi1dX2[3][3] = {0};
+    double dFi2dX0[3][3] = {0}; double dFi2dX1[3][3] = {0}; double dFi2dX2[3][3] = {0};
+    double dFidS[3][3] = {0};
+    double dFi0dV[3][5] = {0};  double dFi1dV[3][5] = {0};  double dFi2dV[3][5] = {0};
+    double dFvdX[3][3][3] = {0}, dFvdXtet[3][4][3] = {0}, dFvdV[3][4][dim] = {0};
+  //  postFcn->computeDerivativeOperatorsOfForce(Xface, n, Vface, pin, dPdx, hydro,
+  //                                     dFi0dn, dFi1dn, dFi2dn, dFi0dGradP, dFi1dGradP, dFi2dGradP,
+  //                                     dFi0dX0, dFi0dX1, dFi0dX2,
+  //                                     dFi1dX0, dFi1dX1, dFi1dX2,
+  //                                     dFi2dX0, dFi2dX1, dFi2dX2,
+  //                                     dFi0dS, dFi1dS, dFi2dS, dFi0dV, dFi1dV, dFi2dV);
 
-  postFcn->computeDerivativeOfForce(dp1dxj, ddp1dxj, Xface, dXface, n, dn, d2w, Vwall, dVwall, Vface, dVface, Vtet, dVtet, dS, pin, dFi0, dFi1, dFi2, dFv, dPdx, ddPdx, hydro);
+    computeDerivativeOperatorsOfForce(elems, postFcn, X, V, pin, gradP, hydro,
+                                      dFi0dGradP, dFi1dGradP, dFi2dGradP,
+                                      dFi0dX0, dFi0dX1, dFi0dX2,
+                                      dFi1dX0, dFi1dX1, dFi1dX2,
+                                      dFi2dX0, dFi2dX1, dFi2dX2,
+                                      dFidS,
+                                      dFi0dV, dFi1dV, dFi2dV, dFvdX, dFvdXtet, dFvdV);
+
+    double dndX[3][3][3] = {0};
+    compute_dndX(X, dndX);
+
+    for(int i=0; i<3; ++i) {
+
+      for(int l=0; l<5; ++l) {
+        dFi00[i] += dFi0dV[i][l]*dV[nodeNum(0)][l];
+        dFi11[i] += dFi1dV[i][l]*dV[nodeNum(1)][l];
+        dFi22[i] += dFi2dV[i][l]*dV[nodeNum(2)][l];
+      }
+      for(int j=0; j<3; ++j) {
+  //      dFi0dX0[i][j] += dFi0dn[i]*dndX[0][i][j];      dFi0dX1[i][j] += dFi0dn[i]*dndX[1][i][j];      dFi0dX2[i][j] += dFi0dn[i]*dndX[2][i][j];
+  //      dFi1dX0[i][j] += dFi1dn[i]*dndX[0][i][j];      dFi1dX1[i][j] += dFi1dn[i]*dndX[1][i][j];      dFi1dX2[i][j] += dFi1dn[i]*dndX[2][i][j];
+  //      dFi2dX0[i][j] += dFi2dn[i]*dndX[0][i][j];      dFi2dX1[i][j] += dFi2dn[i]*dndX[1][i][j];      dFi2dX2[i][j] += dFi2dn[i]*dndX[2][i][j];
+        dFi00[i] += dFi0dGradP[i][j]*dGradP[j][nodeNum(0)]
+                 + dFi0dX0[i][j]*dX[nodeNum(0)][j] + dFi0dX1[i][j]*dX[nodeNum(1)][j] + dFi0dX2[i][j]*dX[nodeNum(2)][j]
+                 + dFidS[i][j];
+        dFi11[i] += dFi1dGradP[i][j]*dGradP[j][nodeNum(1)]
+                 + dFi1dX0[i][j]*dX[nodeNum(0)][j] + dFi1dX1[i][j]*dX[nodeNum(1)][j] + dFi1dX2[i][j]*dX[nodeNum(2)][j];
+        dFi22[i] += dFi2dGradP[i][j]*dGradP[j][nodeNum(2)]
+                 + dFi2dX0[i][j]*dX[nodeNum(0)][j] + dFi2dX1[i][j]*dX[nodeNum(1)][j] + dFi2dX2[i][j]*dX[nodeNum(2)][j];
+      }
+    }
+
+  //  Vec3D diffdFi0 = dFi00 - dFi0;
+  //  Vec3D diffdFi1 = dFi11 - dFi1;
+  //  Vec3D diffdFi2 = dFi22 - dFi2;
+
+  //  double diffdFi0norm = diffdFi0.norm();
+  //  double diffdFi1norm = diffdFi1.norm();
+  //  double diffdFi2norm = diffdFi2.norm();
+  //  double dFi0norm = dFi0.norm();
+  //  double dFi1norm = dFi1.norm();
+  //  double dFi2norm = dFi2.norm();
+
+  //  if(dFi0norm != 0) if(diffdFi0norm/dFi0norm > 1.0e-10) fprintf(stderr, " ... rel. diff = %e\n", diffdFi0norm/dFi0norm);
+  //  else if(diffdFi0norm > 1.0e-10) fprintf(stderr, " ... abs. diff = %e\n", diffdFi0norm);
+  //  if(dFi1norm != 0) if(diffdFi1norm/dFi1norm > 1.0e-10) fprintf(stderr, " ... rel. diff = %e\n", diffdFi1norm/dFi1norm);
+  //  else if(diffdFi1norm > 1.0e-10) fprintf(stderr, " ... abs. diff = %e\n", diffdFi1norm);
+  //  if(dFi2norm != 0) if(diffdFi2norm/dFi2norm > 1.0e-10) fprintf(stderr, " ... rel. diff = %e\n", diffdFi2norm/dFi2norm);
+  //  else if(diffdFi2norm > 1.0e-10) fprintf(stderr, " ... abs. diff = %e\n", diffdFi2norm);
+
+    dFvv = 0.0;
+    for(int l=0; l<3; ++l) {
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<3; ++k)
+          dFvv[l] += dFvdX[l][j][k]*dX[nodeNum(j)][k];
+      for(int j=0; j<4; ++j) {
+        for(int k=0; k<3; ++k)
+          dFvv[l] += dFvdXtet[l][j][k]*dX[nodeNumTet[j]][k];
+        for(int k=0; k<5; ++k)
+          dFvv[l] += dFvdV[l][j][k]*dV[elem[j]][k];
+      }
+    }
+
+    Vec3D diffv = dFv - dFvv;
+    double diffvnorm = diffv.norm();
+    double dFvnorm = dFv.norm();
+
+    if(dFvnorm != 0) {
+      double reldiff = diffvnorm/dFvnorm;
+      if(reldiff > 1.0e-10) { fprintf(stderr, " ... 3. rel. diff for dFv is %e\n", diffvnorm/dFvnorm); exit(-1); }
+    } else {
+      if(diffvnorm > 1.0e-10) { fprintf(stderr, " ... 3. abs. diff for dFv is %e\n", diffvnorm); exit(-1); }
+    }
+  */
+  }
+
+  //------------------------------------------------------------------------------
+
+  template<int dim>
+  inline
+  void FaceTria::computeDerivativeOperatorsOfForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double *pin, double* gradP[3], int hydro,
+                                                   double dFi0dGradP[3][3], double dFi1dGradP[3][3], double dFi2dGradP[3][3],
+                                                   double dFi0dX0[3][3], double dFi0dX1[3][3], double dFi0dX2[3][3],
+                                                   double dFi1dX0[3][3], double dFi1dX1[3][3], double dFi1dX2[3][3],
+                                                   double dFi2dX0[3][3], double dFi2dX1[3][3], double dFi2dX2[3][3],
+                                                   double dFidS[3][3],
+                                                   double dFi0dV[3][5], double dFi1dV[3][5], double dFi2dV[3][5],
+                                                   double dFvdX[3][3][3], double dFvdXtet[3][4][3], double dFvdV[3][4][dim])
+  {
+
+    Elem& elem = elems[elemNum];
+
+    Vec3D n, dn;
+    computeNormal(X, n);
+    double dndX[3][3][3] = {0};
+    compute_dndX(X, dndX);
+
+    nodeNumTet[0] = -1;
+    double dp1dxj[4][3], ddp1dxjdX[4][3][4][3] = {0};
+    if (postFcn->doesFaceNeedGradientP1Function()) {
+      elem.computeGradientP1Function(X, dp1dxj);
+      elem.computeDerivativeOperatorOfGradientP1Function(X, NULL, ddp1dxjdX, nodeNumTet);
+      elem.computeDerivativeOperatorOfGradientP1Function(X, NULL, ddp1dxjdX, nodeNumTet);
+    }
+    double *Vface[3] = {V[nodeNum(0)], V[nodeNum(1)], V[nodeNum(2)]};
+    double *Xface[3] = {X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)]};
+    double *Vtet[4] = {V[elem[0]], V[elem[1]], V[elem[2]], V[elem[3]]};
+
+    double dPdx[3][3];
+    for(int i=0; i<3; i++) // i represents node
+    {
+      dPdx[i][0] = gradP[0][nodeNum(i)];
+      dPdx[i][1] = gradP[1][nodeNum(i)];
+      dPdx[i][2] = gradP[2][nodeNum(i)];
+    }
+
+    double dFi0dn[3] ={0};          double dFi1dn[3] = {0};         double dFi2dn[3] = {0};
+    double dFi0dS[3][3] = {0};      double dFi1dS[3][3] = {0};      double dFi2dS[3][3] = {0};
+    double dFvddp1dxj[3][4][3] = {0};  double dFvdn[3][3] = {0};    double dFvdVp[3][4][5] = {0};
+
+    postFcn->computeDerivativeOperatorsOfForce(dp1dxj, Xface, n, Vface, Vtet, pin, dPdx, hydro,
+                                       dFi0dn, dFi1dn, dFi2dn,
+                                       dFi0dGradP, dFi1dGradP, dFi2dGradP,
+                                       dFi0dX0, dFi0dX1, dFi0dX2,
+                                       dFi1dX0, dFi1dX1, dFi1dX2,
+                                       dFi2dX0, dFi2dX1, dFi2dX2,
+                                       dFi0dS, dFi1dS, dFi2dS, dFi0dV, dFi1dV, dFi2dV,
+                                       dFvddp1dxj, dFvdn, dFvdVp);
+
+    for(int i=0; i<3; ++i) {
+      for(int j=0; j<3; ++j) {
+        dFi0dX0[i][j] += dFi0dn[i]*dndX[0][i][j];      dFi0dX1[i][j] += dFi0dn[i]*dndX[1][i][j];      dFi0dX2[i][j] += dFi0dn[i]*dndX[2][i][j];
+        dFi1dX0[i][j] += dFi1dn[i]*dndX[0][i][j];      dFi1dX1[i][j] += dFi1dn[i]*dndX[1][i][j];      dFi1dX2[i][j] += dFi1dn[i]*dndX[2][i][j];
+        dFi2dX0[i][j] += dFi2dn[i]*dndX[0][i][j];      dFi2dX1[i][j] += dFi2dn[i]*dndX[1][i][j];      dFi2dX2[i][j] += dFi2dn[i]*dndX[2][i][j];
+        dFidS[i][j] += dFi0dS[i][j] + dFi1dS[i][j] + dFi2dS[i][j];
+      }
+    }
+    for(int i=0; i<3; ++i) {
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<3; ++k)
+          for(int l=0; l<3; ++l)
+            dFvdX[i][k][l] += dFvdn[i][j]*dndX[k][j][l];
+      for(int j=0; j<4; ++j) {
+        for(int k=0; k<3; ++k)
+          for(int l=0; l<4; ++l)
+            for(int m=0; m<3; ++m)
+              dFvdXtet[i][l][m] += dFvddp1dxj[i][j][k]*ddp1dxjdX[j][k][l][m];
+        for(int k=0; k<5; ++k)
+          dFvdV[i][j][k] = dFvdVp[i][j][k];
+      }
+    }
 
 }
 
@@ -258,125 +424,81 @@
       ddPdxdGradP[i][j] = 1.0;
   }
 
-//  Vec3D dFi00(dFi0), dFi11(dFi1), dFi22(dFi2), dFvv(dFv), diff0, diff1, diff2, diffv;
+//  Vec3D dFvv(dFv);
   postFcn->computeDerivativeOfForceTransmitted(dp1dxj, ddp1dxj, Xface, dXface, n, dn, d2w, Vwall, dVwall, Vface, dVface, Vtet, dVtet, dS, pin, dFi0, dFi1, dFi2, dFv, dPdx, ddPdx, hydro);
+  /* Verification
+    double dFi0dn[3] = {0}, dFi0dS[3][3] = {0}, dFi0dVface[3][3][5] = {0}, dFi0ddPdx[3][3][3] = {0}, dFi0dXface[3][3][3] = {0};
+    double dFi1dn[3] = {0}, dFi1dS[3][3] = {0}, dFi1dVface[3][3][5] = {0}, dFi1ddPdx[3][3][3] = {0}, dFi1dXface[3][3][3] = {0};
+    double dFi2dn[3] = {0}, dFi2dS[3][3] = {0}, dFi2dVface[3][3][5] = {0}, dFi2ddPdx[3][3][3] = {0}, dFi2dXface[3][3][3] = {0};
+    double dFvddp1dxj[3][4][3] = {0}, dFvdn[3][3] = {0}, dFvdV[3][4][5] = {0};
 
-  double dFi0dn[3] = {0}, dFi0dS[3][3] = {0}, dFi0dVface[3][3][5] = {0}, dFi0ddPdx[3][3][3] = {0}, dFi0dXface[3][3][3] = {0};
-  double dFi1dn[3] = {0}, dFi1dS[3][3] = {0}, dFi1dVface[3][3][5] = {0}, dFi1ddPdx[3][3][3] = {0}, dFi1dXface[3][3][3] = {0};
-  double dFi2dn[3] = {0}, dFi2dS[3][3] = {0}, dFi2dVface[3][3][5] = {0}, dFi2ddPdx[3][3][3] = {0}, dFi2dXface[3][3][3] = {0};
+    postFcn->computeDerivativeOperatorsOfForceTransmitted(dp1dxj, Xface, n, Vface, Vtet, pin, dPdx, hydro,
+                                                          dFi0dn, dFi0dS, dFi0dVface, dFi0ddPdx, dFi0dXface,
+                                                          dFi1dn, dFi1dS, dFi1dVface, dFi1ddPdx, dFi1dXface,
+                                                          dFi2dn, dFi2dS, dFi2dVface, dFi2ddPdx, dFi2dXface,
+                                                          dFvddp1dxj, dFvdn, dFvdV);
 
-  postFcn->computeDerivativeOperatorsOfForceTransmitted(Xface, n, Vface, pin, dPdx, hydro, 
-                                                        dFi0dn, dFi0dS, dFi0dVface, dFi0ddPdx, dFi0dXface,
-                                                        dFi1dn, dFi1dS, dFi1dVface, dFi1ddPdx, dFi1dXface,
-                                                        dFi2dn, dFi2dS, dFi2dVface, dFi2ddPdx, dFi2dXface);
-/*
- dFi00 = 0.0;
- for(int l=0; l<3; ++l) {
-//   dFi00[l] += dFi0dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi00[l] += dFi0dS[l][j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi00[l] += dFi0dVface[l][j][k]*dVfacedV[j][k]*dV[nodeNum(j)][k];
-     for(int k=0; k<3; ++k) {
-       dFi00[l] += dFi0ddPdx[l][j][k]*ddPdxdGradP[j][k]*dGradP[k][nodeNum(j)] + dFi0dXface[l][j][k]*dXfacedX[j][k]*dX[nodeNum(j)][k];
-       dFi00[l] += dFi0dn[l]*dndX[j][l][k]*dX[nodeNum(j)][k];
-     }
-   }
- }
+    for(int i=0; i<3; ++i) {
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<3; ++k)
+          for(int l=0; l<3; ++l)
+          dFvv[i] += dFvdn[i][j]*dndX[k][j][l]*dX[nodeNum(k)][l];
+      for(int j=0; j<4; ++j) {
+        for(int k=0; k<3; ++k)
+          for(int l=0; l<4; ++l)
+            for(int m=0; m<3; ++m)
+              dFvv[i] += dFvddp1dxj[i][j][k]*ddp1dxjdX[j][k][l][m]*dX[nodeNumTet[l]][m];
+        for(int k=0; k<5; ++k)
+          dFvv[i] += dFvdV[i][j][k]*dV[elem[j]][k];
+      }
+    }
 
- dFi11 = 0.0;
- for(int l=0; l<3; ++l) {
-//   dFi11[l] += dFi1dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi11[l] += dFi1dS[l][j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi11[l] += dFi1dVface[l][j][k]*dVfacedV[j][k]*dV[nodeNum(j)][k];
-     for(int k=0; k<3; ++k) {
-       dFi11[l] += dFi1ddPdx[l][j][k]*ddPdxdGradP[j][k]*dGradP[k][nodeNum(j)] + dFi1dXface[l][j][k]*dXfacedX[j][k]*dX[nodeNum(j)][k];
-       dFi11[l] += dFi1dn[l]*dndX[j][l][k]*dX[nodeNum(j)][k];
-     }
-   }
- }
+    Vec3D diffv = dFv - dFvv;
+    double diffvnorm = diffv.norm();
+    double dFvnorm = dFv.norm();
 
- dFi22 = 0.0;
- for(int l=0; l<3; ++l) {
-//   dFi22[l] += dFi2dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi22[l] += dFi2dS[l][j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi22[l] += dFi2dVface[l][j][k]*dVfacedV[j][k]*dV[nodeNum(j)][k];
-     for(int k=0; k<3; ++k) {
-       dFi22[l] += dFi2ddPdx[l][j][k]*ddPdxdGradP[j][k]*dGradP[k][nodeNum(j)] + dFi2dXface[l][j][k]*dXfacedX[j][k]*dX[nodeNum(j)][k];
-       dFi22[l] += dFi2dn[l]*dndX[j][l][k]*dX[nodeNum(j)][k];
-     }
-   }
- }
+    if(dFvnorm != 0) {
+      double reldiff = diffvnorm/dFvnorm;
+      if(reldiff > 1.0e-10) fprintf(stderr, " ... 0. rel. diff for dFv is %e\n", diffvnorm/dFvnorm);
+    } else {
+      if(diffvnorm > 1.0e-10) fprintf(stderr, " ... 0. abs. diff for dFv is %e\n", diffvnorm);
+    }
 
-  dFvv = 0.0;
-  diff0 = dFi0 - dFi00;
-  diff1 = dFi1 - dFi11;  
-  diff2 = dFi2 - dFi22;
-  diffv = dFv - dFvv;
-  double diff0norm = diff0.norm();
-  double diff1norm = diff1.norm();
-  double diff2norm = diff2.norm();
-  double diffvnorm = diffv.norm();
-  double dFi0norm = dFi0.norm();
-  double dFi1norm = dFi1.norm();
-  double dFi2norm = dFi2.norm();
-  double dFvnorm = dFv.norm();
-  
-  if(dFi0norm != 0) {
-    double reldiff = diff0norm/dFi0norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi0 is %e\n", diff0norm/dFi0norm);
-  } else {
-    if(diff0norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi0 is %e\n", diff0norm);
-  }
-
-  if(dFi1norm != 0) {
-    double reldiff = diff1norm/dFi1norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi1 is %e\n", diff1norm/dFi1norm);
-  } else {
-    if(diff1norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi1 is %e\n", diff1norm);
-  }
-
-  if(dFi2norm != 0) {
-    double reldiff = diff2norm/dFi2norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi2 is %e\n", diff2norm/dFi2norm);
-  } else {
-    if(diff2norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi2 is %e\n", diff2norm);
-  }
-
-  if(dFvnorm != 0) {
-    double reldiff = diffvnorm/dFvnorm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFv is %e\n", diffvnorm/dFvnorm);
-  } else {
-    if(diffvnorm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFv is %e\n", diffvnorm);
-  }
-*/
+  // Verification ends
+  */
 }
 
 //------------------------------------------------------------------------------
 
 template<int dim>
 inline
-void FaceTria::computeDerivativeOperatorsOfForceTransmitted(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, 
+void FaceTria::computeDerivativeOperatorsOfForceTransmitted(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V,
                                                             double *pin, double* gradP[3], int hydro,
                                                             double dFi0dV[3][3][dim], double dFi0dGradP[3][3][3], double dFi0dX[3][3][3],
                                                             double dFi0dn[3], double dFi0dS[3][3],
                                                             double dFi1dV[3][3][dim], double dFi1dGradP[3][3][3], double dFi1dX[3][3][3],
                                                             double dFi1dn[3], double dFi1dS[3][3],
                                                             double dFi2dV[3][3][dim], double dFi2dGradP[3][3][3], double dFi2dX[3][3][3],
-                                                            double dFi2dn[3], double dFi2dS[3][3])
+															double dFi2dn[3], double dFi2dS[3][3],
+															double dFvdX[3][3][3], double dFvdXtet[3][4][3], double dFvdV[3][4][dim])
 {
 
   Vec3D n;
   double dndX[3][3][3] = {0};
+  Elem& elem = elems[elemNum];
   computeNormal(X, n);
   compute_dndX(X, dndX);
 
+  nodeNumTet[0] = -1;
+  double dp1dxj[4][3], ddp1dxjdX[4][3][4][3] = {0};
+  if (postFcn->doesFaceNeedGradientP1Function()) {
+    elem.computeGradientP1Function(X, dp1dxj);
+    elem.computeDerivativeOperatorOfGradientP1Function(X, NULL, ddp1dxjdX, nodeNumTet);
+  }
+
   double *Vface[3] = {V[nodeNum(0)], V[nodeNum(1)], V[nodeNum(2)]};
   double *Xface[3] = {X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)]};
+  double *Vtet[4] = {V[elem[0]], V[elem[1]], V[elem[2]], V[elem[3]]};
   double dVfacedV[3][dim] = {0}, dXfacedX[3][3] = {0};
   for(int i=0; i<3; ++i) for(int j=0; j<dim; ++j) dVfacedV[i][j] = 1.0;
   for(int i=0; i<3; i++) for(int j=0; j<3; ++j) dXfacedX[i][j] = 1.0;
@@ -395,11 +517,47 @@
   double dFi0dVface[3][3][5] = {0}, dFi0ddPdx[3][3][3] = {0}, dFi0dXface[3][3][3] = {0};
   double dFi1dVface[3][3][5] = {0}, dFi1ddPdx[3][3][3] = {0}, dFi1dXface[3][3][3] = {0};
   double dFi2dVface[3][3][5] = {0}, dFi2ddPdx[3][3][3] = {0}, dFi2dXface[3][3][3] = {0};
+  double dFvddp1dxj[3][4][3] = {0}, dFvdn[3][3] = {0}, dFvdVp[3][4][5] = {0};
 
-  postFcn->computeDerivativeOperatorsOfForceTransmitted(Xface, n, Vface, pin, dPdx, hydro, 
+  postFcn->computeDerivativeOperatorsOfForceTransmitted(dp1dxj, Xface, n, Vface, Vtet, pin, dPdx, hydro,
                                                         dFi0dn, dFi0dS, dFi0dVface, dFi0ddPdx, dFi0dXface,
                                                         dFi1dn, dFi1dS, dFi1dVface, dFi1ddPdx, dFi1dXface,
-                                                        dFi2dn, dFi2dS, dFi2dVface, dFi2ddPdx, dFi2dXface);
+														dFi2dn, dFi2dS, dFi2dVface, dFi2ddPdx, dFi2dXface,
+														dFvddp1dxj, dFvdn, dFvdVp);
+ /*
+   for(int i=0; i<3; ++i)
+     for(int j=0; j<3; ++j)
+       for(int k=0; k<3; ++k)
+         for(int l=0; l<3; ++l)
+           dFvdX[i][k][l] += dFvdn[i][j]*dndX[k][j][l];
+
+   for(int i=0; i<3; ++i)
+     for(int j=0; j<4; ++j)
+       for(int k=0; k<3; ++k)
+         for(int l=0; l<4; ++l)
+           for(int m=0; m<3; ++m)
+             dFvdXtet[i][l][m] += dFvddp1dxj[i][j][k]*ddp1dxjdX[j][k][l][m];
+
+   for(int i=0; i<3; ++i)
+     for(int j=0; j<4; ++j)
+       for(int k=0; k<5; ++k)
+         dFvdV[i][j][k] = dFvdVp[i][j][k];
+ */
+ for(int i=0; i<3; ++i) {
+   for(int j=0; j<3; ++j)
+     for(int k=0; k<3; ++k)
+       for(int l=0; l<3; ++l)
+         dFvdX[i][k][l] += dFvdn[i][j]*dndX[k][j][l];
+   for(int j=0; j<4; ++j) {
+     for(int k=0; k<3; ++k)
+       for(int l=0; l<4; ++l)
+         for(int m=0; m<3; ++m)
+           dFvdXtet[i][l][m] += dFvddp1dxj[i][j][k]*ddp1dxjdX[j][k][l][m];
+     for(int k=0; k<5; ++k)
+       dFvdV[i][j][k] = dFvdVp[i][j][k];
+   }
+ }
+
  for(int l=0; l<3; ++l) {
    for(int j=0; j<3; ++j) {
      for(int k=0; k<dim; ++k) {
@@ -472,15 +630,47 @@
 // Included (MB)
 template<int dim>
 void FaceTria::computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,
+           Vec<double> &d2wall, double *Vwall, double *dVwall, SVec<double,dim> &V, SVec<double,dim> &dV,
+           double pin, double dS[3], SVec<double,3> &dF, double* gradP[3], double* dGradP[3])
+{
+
+  if (code == BC_ISOTHERMAL_WALL_MOVING || code == BC_ADIABATIC_WALL_MOVING
+    || code == BC_SLIP_WALL_MOVING || code == BC_POROUS_WALL_MOVING) {
+
+    Vec3D dFi0, dFi1, dFi2, dFv;
+    computeDerivativeOfForceTransmitted(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, 0, dFi0, dFi1, dFi2, dFv, gradP, dGradP);
+
+    Vec3D dFtot[3];
+    dFtot[0] = dFi0 + third*dFv;
+    dFtot[1] = dFi1 + third*dFv;
+    dFtot[2] = dFi2 + third*dFv;
+
+    for (int j=0; j<3; ++j) {
+      dF[ nodeNum(j) ][0] += dFtot[j][0];
+      dF[ nodeNum(j) ][1] += dFtot[j][1];
+      dF[ nodeNum(j) ][2] += dFtot[j][2];
+    }
+
+  }
+
+}
+
+//------------------------------------------------------------------------------
+/*
+// Included (MB)
+template<int dim>
+void FaceTria::computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,
 			     Vec<double> &d2wall, double *Vwall, double *dVwall, SVec<double,dim> &V, SVec<double,dim> &dV,
 			     double pin, double dS[3], SVec<double,3> &dF, double* gradP[3], double* dGradP[3])
 {
 
   SVec<double,3> dF2(dF), diff2(dF);
+  Elem& elem = elems[elemNum];
 
   if (code == BC_ISOTHERMAL_WALL_MOVING || code == BC_ADIABATIC_WALL_MOVING
     || code == BC_SLIP_WALL_MOVING || code == BC_POROUS_WALL_MOVING) {
 
+    double *dVtet[4] = {dV[elem[0]], dV[elem[1]], dV[elem[2]], dV[elem[3]]};
     Vec3D dFi0, dFi1, dFi2, dFv;
     Vec3D dFi00(dFi0), dFi11(dFi1), dFi22(dFi2), dFvv(dFv), diff0, diff1, diff2, diffv;
     computeDerivativeOfForceTransmitted(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, 0, dFi0, dFi1, dFi2, dFv, gradP, dGradP);
@@ -489,10 +679,21 @@
     double dFi1dn[3] = {0}, dFi1dS[3][3] = {0}, dFi1dV[3][3][dim] = {0}, dFi1dGradP[3][3][3] = {0}, dFi1dX[3][3][3] = {0};
     double dFi2dn[3] = {0}, dFi2dS[3][3] = {0}, dFi2dV[3][3][dim] = {0}, dFi2dGradP[3][3][3] = {0}, dFi2dX[3][3][3] = {0};
 
-    computeDerivativeOperatorsOfForceTransmitted(postFcn, X, V, 0, gradP, 0,
+    computeDerivativeOperatorsOfForceTransmitted(elems, postFcn, X, V, 0, gradP, 0,
                                                  dFi0dV, dFi0dGradP, dFi0dX, dFi0dn, dFi0dS,
                                                  dFi1dV, dFi1dGradP, dFi1dX, dFi1dn, dFi1dS,
-                                                 dFi2dV, dFi2dGradP, dFi2dX, dFi2dn, dFi2dS);
+                                                 dFi2dV, dFi2dGradP, dFi2dX, dFi2dn, dFi2dS,
+                                                 dFvdX, dFvdXtet, dFvdV);
+Vec3D dFtot[3];
+dFtot[0] = dFi0 + third*dFv;
+dFtot[1] = dFi1 + third*dFv;
+dFtot[2] = dFi2 + third*dFv;
+
+for (int j=0; j<3; ++j) {
+  dF[ nodeNum(j) ][0] += dFtot[j][0];
+  dF[ nodeNum(j) ][1] += dFtot[j][1];
+  dF[ nodeNum(j) ][2] += dFtot[j][2];
+}
 
  dFi00 = 0.0;
  for(int l=0; l<3; ++l) {
@@ -534,6 +735,18 @@
  }
 
   dFvv = 0.0;
+ for(int l=0; l<3; ++l) {
+   for(int j=0; j<3; ++j)
+     for(int k=0; k<3; ++k)
+       dFvv[l] += dFvdX[l][j][k]*dX[nodeNum(j)][k];
+   for(int j=0; j<4; ++j) {
+     for(int k=0; k<3; ++k)
+       dFvv[l] += dFvdXtet[l][j][k]*dX[nodeNumTet[j]][k];
+     for(int k=0; k<5; ++k)
+       dFvv[l] += dFvdV[l][j][k]*dV[elem[j]][k];
+   }
+ }
+
   diff0 = dFi0 - dFi00;
   diff1 = dFi1 - dFi11;  
   diff2 = dFi2 - dFi22;
@@ -546,73 +759,66 @@
   double dFi1norm = dFi1.norm();
   double dFi2norm = dFi2.norm();
   double dFvnorm = dFv.norm();
-/*  
+
   if(dFi0norm != 0) {
     double reldiff = diff0norm/dFi0norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi0 is %e\n", diff0norm/dFi0norm);
+    if(reldiff > 1.0e-12) { fprintf(stderr, " ... rel. diff for dFi0 is %e\n", diff0norm/dFi0norm); exit(-1); }
   } else {
-    if(diff0norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi0 is %e\n", diff0norm);
+    if(diff0norm > 1.0e-12) { fprintf(stderr, " ... abs. diff for dFi0 is %e\n", diff0norm); exit(-1); }
   }
 
   if(dFi1norm != 0) {
     double reldiff = diff1norm/dFi1norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi1 is %e\n", diff1norm/dFi1norm);
+    if(reldiff > 1.0e-12) { fprintf(stderr, " ... rel. diff for dFi1 is %e\n", diff1norm/dFi1norm); exit(-1); }
   } else {
-    if(diff1norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi1 is %e\n", diff1norm);
+    if(diff1norm > 1.0e-12) { fprintf(stderr, " ... abs. diff for dFi1 is %e\n", diff1norm); exit(-1); }
   }
 
   if(dFi2norm != 0) {
     double reldiff = diff2norm/dFi2norm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFi2 is %e\n", diff2norm/dFi2norm);
+    if(reldiff > 1.0e-12) { fprintf(stderr, " ... rel. diff for dFi2 is %e\n", diff2norm/dFi2norm); exit(-1); }
   } else {
-    if(diff2norm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFi2 is %e\n", diff2norm);
+    if(diff2norm > 1.0e-12) { fprintf(stderr, " ... abs. diff for dFi2 is %e\n", diff2norm); exit(-1); }
   }
 
   if(dFvnorm != 0) {
     double reldiff = diffvnorm/dFvnorm;
-    if(reldiff > 1.0e-12) fprintf(stderr, " ... rel. diff for dFv is %e\n", diffvnorm/dFvnorm);
+    if(reldiff > 1.0e-10) { fprintf(stderr, " ... rel. diff for dFv is %e\n", diffvnorm/dFvnorm); exit(-1); }
   } else {
-    if(diffvnorm > 1.0e-12) fprintf(stderr, " ... abs. diff for dFv is %e\n", diffvnorm);
+    if(diffvnorm > 1.0e-10) { fprintf(stderr, " ... abs. diff for dFv is %e\n", diffvnorm); exit(-1); }
   }
-*/
 
-   Vec3D dFtot[3];
-   dFtot[0] = dFi0 + third*dFv; 
-   dFtot[1] = dFi1 + third*dFv;
-   dFtot[2] = dFi2 + third*dFv;
-/*
-   for (int j=0; j<3; ++j) {
-     dF[ nodeNum(j) ][0] += dFtot[j][0];
-     dF[ nodeNum(j) ][1] += dFtot[j][1];
-     dF[ nodeNum(j) ][2] += dFtot[j][2];
-   }
-*/
-   dF[ nodeNum(0) ][0] += dFi00[0] + third*dFvv[0];
-   dF[ nodeNum(0) ][1] += dFi00[1] + third*dFvv[1]; 
-   dF[ nodeNum(0) ][2] += dFi00[2] + third*dFvv[2];
-   dF[ nodeNum(1) ][0] += dFi11[0] + third*dFvv[0];
-   dF[ nodeNum(1) ][1] += dFi11[1] + third*dFvv[1];
-   dF[ nodeNum(1) ][2] += dFi11[2] + third*dFvv[2];
-   dF[ nodeNum(2) ][0] += dFi22[0] + third*dFvv[0]; 
-   dF[ nodeNum(2) ][1] += dFi22[1] + third*dFvv[1];
-   dF[ nodeNum(2) ][2] += dFi22[2] + third*dFvv[2];
+   dF2[ nodeNum(0) ][0] += dFi00[0] + third*dFvv[0];
+   dF2[ nodeNum(0) ][1] += dFi00[1] + third*dFvv[1];
+   dF2[ nodeNum(0) ][2] += dFi00[2] + third*dFvv[2];
+   dF2[ nodeNum(1) ][0] += dFi11[0] + third*dFvv[0];
+   dF2[ nodeNum(1) ][1] += dFi11[1] + third*dFvv[1];
+   dF2[ nodeNum(1) ][2] += dFi11[2] + third*dFvv[2];
+   dF2[ nodeNum(2) ][0] += dFi22[0] + third*dFvv[0];
+   dF2[ nodeNum(2) ][1] += dFi22[1] + third*dFvv[1];
+   dF2[ nodeNum(2) ][2] += dFi22[2] + third*dFvv[2];
 
   }
-/*
+
   diff2 = dF2 - dF;
   double diff2norm = diff2.norm();
   double dF2norm = dF2.norm();
   double dFnorm = dF.norm();
-  if(dFnorm != 0) fprintf(stderr, " ... rel. diff = %e\n", diff2norm/dFnorm);
-  else fprintf(stderr, " ... abs. diff = %e\n", diff2norm);
-*/
+  if(dFnorm != 0) {
+    double reldiff = diff2norm/dFnorm;
+    if(reldiff >1e-12) { fprintf(stderr, " ... rel. diff = %e\n", reldiff); exit(-1); }
+  } else {
+    if(diff2norm >1e-12) { fprintf(stderr, " ... abs. diff = %e\n", diff2norm); exit(-1); }
+  }
+
 
 }
+*/
 
 //------------------------------------------------------------------------------
 // Included (YC)
 template<int dim>
-void FaceTria::computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, 
+void FaceTria::computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
                           SVec<double,dim> &V, double pin, double* gradP[3], 
                           RectangularSparseMat<double,3,3> &dForcedX,
                           RectangularSparseMat<double,3,3> &dForcedGradP,
@@ -624,15 +830,63 @@
   if (code == BC_ISOTHERMAL_WALL_MOVING || code == BC_ADIABATIC_WALL_MOVING
     || code == BC_SLIP_WALL_MOVING || code == BC_POROUS_WALL_MOVING) {
 
+	Elem& elem = elems[elemNum];
     double dFi0dn[3] = {0}, dFi0dS[3][3] = {0}, dFi0dV[3][3][dim] = {0}, dFi0dGradP[3][3][3] = {0}, dFi0dX[3][3][3] = {0};
     double dFi1dn[3] = {0}, dFi1dS[3][3] = {0}, dFi1dV[3][3][dim] = {0}, dFi1dGradP[3][3][3] = {0}, dFi1dX[3][3][3] = {0};
     double dFi2dn[3] = {0}, dFi2dS[3][3] = {0}, dFi2dV[3][3][dim] = {0}, dFi2dGradP[3][3][3] = {0}, dFi2dX[3][3][3] = {0};
+    double dFvdX[3][3][3] = {0}, dFvdXtet[3][4][3] = {0}, dFvdV[3][4][dim] = {0};
 
-    computeDerivativeOperatorsOfForceTransmitted(postFcn, X, V, 0, gradP, 0,
+    computeDerivativeOperatorsOfForceTransmitted(elems, postFcn, X, V, 0, gradP, 0,
                                                  dFi0dV, dFi0dGradP, dFi0dX, dFi0dn, dFi0dS,
                                                  dFi1dV, dFi1dGradP, dFi1dX, dFi1dn, dFi1dS,
-                                                 dFi2dV, dFi2dGradP, dFi2dX, dFi2dn, dFi2dS);
-/*
+												 dFi2dV, dFi2dGradP, dFi2dX, dFi2dn, dFi2dS,
+												 dFvdX, dFvdXtet, dFvdV);
+
+     for(int i=0; i<3; ++i)
+       for(int j=0; j<3; ++j)
+         for(int k=0; k<3; ++k) {
+           dFi0dX[i][j][k] += third*dFvdX[j][i][k];
+           dFi1dX[i][j][k] += third*dFvdX[j][i][k];
+           dFi2dX[i][j][k] += third*dFvdX[j][i][k];
+         }
+
+     double dFvdXtet2[4][3][3] = {0}, dFvdV2[4][3][dim] = {0};
+     for(int i=0; i<3; ++i)
+       for(int j=0; j<4; ++j) {
+         for(int k=0; k<3; ++k)
+           dFvdXtet2[j][i][k] = third*dFvdXtet[i][j][k];
+         for(int k=0; k<5; ++k)
+           dFvdV2[j][i][k] = third*dFvdV[i][j][k];
+       }
+
+      if(nodeNumTet[0] >= 0) {
+        dForcedX.addContrib(nodeNum(0), nodeNumTet[0], dFvdXtet2[0][0]);
+        dForcedX.addContrib(nodeNum(0), nodeNumTet[1], dFvdXtet2[1][0]);
+        dForcedX.addContrib(nodeNum(0), nodeNumTet[2], dFvdXtet2[2][0]);
+        dForcedX.addContrib(nodeNum(0), nodeNumTet[3], dFvdXtet2[3][0]);
+        dForcedX.addContrib(nodeNum(1), nodeNumTet[0], dFvdXtet2[0][0]);
+        dForcedX.addContrib(nodeNum(1), nodeNumTet[1], dFvdXtet2[1][0]);
+        dForcedX.addContrib(nodeNum(1), nodeNumTet[2], dFvdXtet2[2][0]);
+        dForcedX.addContrib(nodeNum(1), nodeNumTet[3], dFvdXtet2[3][0]);
+        dForcedX.addContrib(nodeNum(2), nodeNumTet[0], dFvdXtet2[0][0]);
+        dForcedX.addContrib(nodeNum(2), nodeNumTet[1], dFvdXtet2[1][0]);
+        dForcedX.addContrib(nodeNum(2), nodeNumTet[2], dFvdXtet2[2][0]);
+        dForcedX.addContrib(nodeNum(2), nodeNumTet[3], dFvdXtet2[3][0]);
+      }
+
+      dForcedV.addContrib(nodeNum(0), elem[0], dFvdV2[0][0]);
+      dForcedV.addContrib(nodeNum(0), elem[1], dFvdV2[1][0]);
+      dForcedV.addContrib(nodeNum(0), elem[2], dFvdV2[2][0]);
+      dForcedV.addContrib(nodeNum(0), elem[3], dFvdV2[3][0]);
+      dForcedV.addContrib(nodeNum(1), elem[0], dFvdV2[0][0]);
+      dForcedV.addContrib(nodeNum(1), elem[1], dFvdV2[1][0]);
+      dForcedV.addContrib(nodeNum(1), elem[2], dFvdV2[2][0]);
+      dForcedV.addContrib(nodeNum(1), elem[3], dFvdV2[3][0]);
+      dForcedV.addContrib(nodeNum(2), elem[0], dFvdV2[0][0]);
+      dForcedV.addContrib(nodeNum(2), elem[1], dFvdV2[1][0]);
+      dForcedV.addContrib(nodeNum(2), elem[2], dFvdV2[2][0]);
+      dForcedV.addContrib(nodeNum(2), elem[3], dFvdV2[3][0]);
+   /*
    dF[ nodeNum(0) ][0] += dFi0[0] + third*dFv[0];
    dF[ nodeNum(0) ][1] += dFi0[1] + third*dFv[1]; 
    dF[ nodeNum(0) ][2] += dFi0[2] + third*dFv[2];
@@ -896,6 +1150,7 @@
                                              Vec3D &x0, Vec3D &dFi, Vec3D &dMi, Vec3D &dFv, Vec3D &dMv, 
 				             double* gradP[3], double* dGradP[3], int hydro)
 {
+	Elem& elem = elems[elemNum];
 
     Vec3D x[3] = {X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)]};
     Vec3D dxds[3] = {dX[nodeNum(0)], dX[nodeNum(1)], dX[nodeNum(2)]};
@@ -904,16 +1159,437 @@
     Vec3D dxm = third*(x[0]+x[1]+x[2]) - x0;
     Vec3D ddxm = third*(dxds[0]+dxds[1]+dxds[2]);
 
+    //    Vec3D dFi2(dFi);  // Verification
     Vec3D dfi0, dfi1, dfi2, dfv;
     computeDerivativeOfForce(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, 0, dfi0, dfi1, dfi2, dfv, gradP, dGradP, hydro);
     dFi += dfi0 + dfi1 + dfi2;
     dFv += dfv;
 
+    /*
+    // Verification
+        double dFi0dGradP[3][3] = {0}, dFi1dGradP[3][3] = {0}, dFi2dGradP[3][3] = {0};
+        double dFi0dX0[3][3] = {0},    dFi0dX1[3][3] = {0},    dFi0dX2[3][3] = {0};
+        double dFi1dX0[3][3] = {0},    dFi1dX1[3][3] = {0},    dFi1dX2[3][3] = {0};
+        double dFi2dX0[3][3] = {0},    dFi2dX1[3][3] = {0},    dFi2dX2[3][3] = {0};
+        double dFidS[3][3];
+        double dFi0dV[3][5] = {0},   dFi1dV[3][5] = {0},   dFi2dV[3][5] = {0};
+        double dFvdX[3][3][3] = {0}, dFvdXtet[3][4][3] = {0}, dFvdV[3][4][dim] = {0};
+        computeDerivativeOperatorsOfForce(elems, postFcn, X, V, 0, gradP, hydro,
+                                          dFi0dGradP, dFi1dGradP, dFi2dGradP,
+                                          dFi0dX0, dFi0dX1, dFi0dX2,
+                                          dFi1dX0, dFi1dX1, dFi1dX2,
+                                          dFi2dX0, dFi2dX1, dFi2dX2,
+                                          dFidS,
+                                          dFi0dV, dFi1dV, dFi2dV,
+                                          dFvdX, dFvdXtet, dFvdV);
+        for(int i=0; i<3; ++i) {
+          for(int j=0; j<3; ++j) {
+            dFi2[i] += dFidS[i][j]*dS[j];
+            dFi2[i] += dFi0dGradP[i][j]*dGradP[j][nodeNum(0)]
+                     + dFi0dX0[i][j]*dX[nodeNum(0)][j] + dFi0dX1[i][j]*dX[nodeNum(1)][j] + dFi0dX2[i][j]*dX[nodeNum(2)][j];
+            dFi2[i] += dFi1dGradP[i][j]*dGradP[j][nodeNum(1)]
+                     + dFi1dX0[i][j]*dX[nodeNum(0)][j] + dFi1dX1[i][j]*dX[nodeNum(1)][j] + dFi1dX2[i][j]*dX[nodeNum(2)][j];
+            dFi2[i] += dFi2dGradP[i][j]*dGradP[j][nodeNum(2)]
+                     + dFi2dX0[i][j]*dX[nodeNum(0)][j] + dFi2dX1[i][j]*dX[nodeNum(1)][j] + dFi2dX2[i][j]*dX[nodeNum(2)][j];
+
+          }
+          for(int j=0; j<dim; ++j) {
+            dFi2[i] += dFi0dV[i][j]*dV[nodeNum(0)][j];
+            dFi2[i] += dFi1dV[i][j]*dV[nodeNum(1)][j];
+            dFi2[i] += dFi2dV[i][j]*dV[nodeNum(2)][j];
+          }
+        }
+        Vec3D dFvv = 0.0;
+        for(int l=0; l<3; ++l) {
+          for(int j=0; j<3; ++j)
+            for(int k=0; k<3; ++k)
+              dFvv[l] += dFvdX[l][j][k]*dX[nodeNum(j)][k];
+          for(int j=0; j<4; ++j) {
+            if(nodeNumTet[0] >= 0) {
+              for(int k=0; k<3; ++k)
+                dFvv[l] += dFvdXtet[l][j][k]*dX[nodeNumTet[j]][k];
+            }
+            for(int k=0; k<5; ++k)
+              dFvv[l] += dFvdV[l][j][k]*dV[elem[j]][k];
+          }
+        }
+        Vec3D diffi = dFi - dFi2;
+        Vec3D diffv = dfv - dFvv;
+        double diffinorm = diffi.norm();
+        double diffvnorm = diffv.norm();
+        double dFinorm = dFi.norm();
+        double dFvnorm = dfv.norm();
+
+        if(dFinorm != 0) {
+          double reldiff = diffinorm/dFinorm;
+          if(reldiff > 1.0e-10) { fprintf(stderr, " ... 4. rel. diff for dFi is %e\n", diffinorm/dFinorm); exit(-1); }
+        } else {
+          if(diffinorm > 1.0e-10) { fprintf(stderr, " ... 4. abs. diff for dFi is %e\n", diffinorm); exit(-1); }
+        }
+        if(dFvnorm != 0) {
+          double reldiff = diffvnorm/dFvnorm;
+          if(reldiff > 1.0e-10) { fprintf(stderr, " ... 4. rel. diff for dFv is %e\n", diffvnorm/dFvnorm); exit(-1); }
+        } else {
+          if(diffvnorm > 1.0e-10) { fprintf(stderr, " ... 4. abs. diff for dFv is %e\n", diffvnorm); exit(-1); }
+        }
+       Vec3D dMi00(dMi), dMv00(dMv);
+    // Verification ends
+    */
+
     Vec3D fi0,fi1,fi2,fv;
     computeForceTransmitted(elems, postFcn, X, d2wall, Vwall, V, 0, fi0,fi1,fi2, fv, gradP, hydro);
     computeDerivativeOfForceTransmitted(elems, postFcn, X, dX, d2wall, Vwall, dVwall, V, dV, dS, 0, dfi0, dfi1, dfi2, dfv, gradP, dGradP, hydro);
     dMi += (ddx[0] ^ fi0) + (dx[0] ^ dfi0) + (ddx[1] ^ fi1) + (dx[1] ^ dfi1) + (ddx[2] ^ fi2) + (dx[2] ^ dfi2);
     dMv += (ddxm ^ fv) + (dxm ^ dfv);
+    /*
+    // Verification
+    double dMiddx0[3][3] = {0}, dMiddx1[3][3] = {0}, dMiddx2[3][3] = {0}, dMidfi0[3][3] = {0}, dMidfi1[3][3] = {0}, dMidfi2[3][3] = {0};
+    double dMvddxm[3][3] = {0}, dMvdfv[3][3] = {0};
+    dx[0].crossProductSensitivityOperator(dMidfi0);
+    dx[1].crossProductSensitivityOperator(dMidfi1);
+    dx[2].crossProductSensitivityOperator(dMidfi2);
+    dxm.crossProductSensitivityOperator(dMvdfv);
+    ddx[0].crossProductSensitivityOperator(fi0,dMiddx0);
+    ddx[1].crossProductSensitivityOperator(fi1,dMiddx1);
+    ddx[2].crossProductSensitivityOperator(fi2,dMiddx2);
+    ddxm.crossProductSensitivityOperator(fv,dMvddxm);
+
+    double dFi0dn[3] = {0}, dFi0dS2[3][3] = {0}, dFi0dV2[3][3][dim] = {0}, dFi0dGradP2[3][3][3] = {0}, dFi0dX[3][3][3] = {0};
+    double dFi1dn[3] = {0}, dFi1dS2[3][3] = {0}, dFi1dV2[3][3][dim] = {0}, dFi1dGradP2[3][3][3] = {0}, dFi1dX[3][3][3] = {0};
+    double dFi2dn[3] = {0}, dFi2dS2[3][3] = {0}, dFi2dV2[3][3][dim] = {0}, dFi2dGradP2[3][3][3] = {0}, dFi2dX[3][3][3] = {0};
+    double dFvdXp[3][3][3] = {0}, dFvdXtetp[3][4][3] = {0}, dFvdVp[3][4][dim] = {0};
+    computeDerivativeOperatorsOfForceTransmitted(elems, postFcn, X, V, 0, gradP, 0,
+                                                 dFi0dV2, dFi0dGradP2, dFi0dX, dFi0dn, dFi0dS2,
+                                                 dFi1dV2, dFi1dGradP2, dFi1dX, dFi1dn, dFi1dS2,
+                                                 dFi2dV2, dFi2dGradP2, dFi2dX, dFi2dn, dFi2dS2,
+                                                 dFvdXp, dFvdXtetp, dFvdVp);
+
+
+    Vec3D dFi00 = 0.0;
+    for(int l=0; l<3; ++l) {
+      for(int j=0; j<3; ++j) {
+        dFi00[l] += dFi0dS2[l][j]*dS[j];
+        for(int k=0; k<dim; ++k)
+          dFi00[l] += dFi0dV2[j][l][k]*dV[nodeNum(j)][k];
+        for(int k=0; k<3; ++k) {
+          dFi00[l] += dFi0dGradP2[j][l][k]*dGradP[k][nodeNum(j)] + dFi0dX[j][l][k]*dX[nodeNum(j)][k];
+        }
+      }
+    }
+
+    Vec3D dFi11 = 0.0;
+    for(int l=0; l<3; ++l) {
+      for(int j=0; j<3; ++j) {
+        dFi11[l] += dFi1dS2[l][j]*dS[j];
+        for(int k=0; k<dim; ++k)
+          dFi11[l] += dFi1dV2[j][l][k]*dV[nodeNum(j)][k];
+        for(int k=0; k<3; ++k) {
+          dFi11[l] += dFi1dGradP2[j][l][k]*dGradP[k][nodeNum(j)] + dFi1dX[j][l][k]*dX[nodeNum(j)][k];
+        }
+      }
+    }
+
+    Vec3D dFi22 = 0.0;
+    for(int l=0; l<3; ++l) {
+      for(int j=0; j<3; ++j) {
+        dFi22[l] += dFi2dS2[l][j]*dS[j];
+        for(int k=0; k<dim; ++k)
+          dFi22[l] += dFi2dV2[j][l][k]*dV[nodeNum(j)][k];
+        for(int k=0; k<3; ++k) {
+          dFi22[l] += dFi2dGradP2[j][l][k]*dGradP[k][nodeNum(j)] + dFi2dX[j][l][k]*dX[nodeNum(j)][k];
+        }
+      }
+    }
+
+    dFvv = 0.0;
+    for(int l=0; l<3; ++l) {
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<3; ++k)
+          dFvv[l] += dFvdXp[l][j][k]*dX[nodeNum(j)][k];
+      for(int j=0; j<4; ++j) {
+        if(nodeNumTet[0] >= 0) {
+          for(int k=0; k<3; ++k)
+            dFvv[l] += dFvdXtetp[l][j][k]*dX[nodeNumTet[j]][k];
+        }
+        for(int k=0; k<5; ++k)
+          dFvv[l] += dFvdVp[l][j][k]*dV[elem[j]][k];
+      }
+    }
+
+    for(int i=0; i<3; ++i)
+      for(int j=0; j<3; ++j) {
+        for(int k=0; k<3; ++k) {
+          dMi00[i] += dMidfi0[i][j]*dFi0dS2[j][k]*dS[k] + dMidfi1[i][j]*dFi1dS2[j][k]*dS[k] + dMidfi2[i][j]*dFi2dS2[j][k]*dS[k];
+          for(int l=0; l<dim; ++l) {
+            dMi00[i] += (dMidfi0[i][j]*dFi0dV2[k][j][l] + dMidfi1[i][j]*dFi1dV2[k][j][l] + dMidfi2[i][j]*dFi2dV2[k][j][l])*dV[nodeNum(k)][l];
+          }
+          for(int l=0; l<3; ++l) {
+            dMi00[i] += (dMidfi0[i][j]*dFi0dGradP2[k][j][l] + dMidfi1[i][j]*dFi1dGradP2[k][j][l] + dMidfi2[i][j]*dFi2dGradP2[k][j][l])*dGradP[l][nodeNum(k)]
+                      + (dMidfi0[i][j]*dFi0dX[k][j][l] + dMidfi1[i][j]*dFi1dX[k][j][l] + dMidfi2[i][j]*dFi2dX[k][j][l])*dX[nodeNum(k)][l];
+            dMv00[i] += dMvdfv[i][j]*dFvdXp[j][k][l]*dX[nodeNum(k)][l];
+          }
+        }
+        for(int k=0; k<4; ++k) {
+          if(nodeNumTet[0] >= 0) {
+            for(int l=0; l<3; ++l)
+              dMv00[i] += dMvdfv[i][j]*dFvdXtetp[j][k][l]*dX[nodeNumTet[k]][l];
+          }
+          for(int l=0; l<5; ++l)
+            dMv00[i] += dMvdfv[i][j]*dFvdVp[j][k][l]*dV[elem[k]][l];
+        }
+        dMi00[i] += dMiddx0[i][j]*dX[nodeNum(0)][j] + dMiddx1[i][j]*dX[nodeNum(1)][j] + dMiddx2[i][j]*dX[nodeNum(2)][j];
+
+        dMv00[i] += third*dMvddxm[i][j]*(dX[nodeNum(0)][j] + dX[nodeNum(1)][j] + dX[nodeNum(2)][j]);
+      }
+
+
+    Vec3D diff0 = dfi0 - dFi00;
+    Vec3D diff1 = dfi1 - dFi11;
+    Vec3D diff2 = dfi2 - dFi22;
+    diffv = dfv - dFvv;
+    double diff0norm = diff0.norm();
+    double diff1norm = diff1.norm();
+    double diff2norm = diff2.norm();
+    diffvnorm = diffv.norm();
+    double dFi0norm = dfi0.norm();
+    double dFi1norm = dfi1.norm();
+    double dFi2norm = dfi2.norm();
+    dFvnorm = dfv.norm();
+
+    if(dFi0norm != 0) {
+      double reldiff = diff0norm/dFi0norm;
+      if(reldiff > 1.0e-12) { fprintf(stderr, " ... 7. rel. diff for dFi0 is %e\n", diff0norm/dFi0norm); exit(-1); }
+    } else {
+      if(diff0norm > 1.0e-12) { fprintf(stderr, " ... 7. abs. diff for dFi0 is %e\n", diff0norm); exit(-1); }
+    }
+
+    if(dFi1norm != 0) {
+      double reldiff = diff1norm/dFi1norm;
+      if(reldiff > 1.0e-12) { fprintf(stderr, " ... 7. rel. diff for dFi1 is %e\n", diff1norm/dFi1norm); exit(-1); }
+    } else {
+      if(diff1norm > 1.0e-12) { fprintf(stderr, " ... 7. abs. diff for dFi1 is %e\n", diff1norm); exit(-1); }
+    }
+
+    if(dFi2norm != 0) {
+      double reldiff = diff2norm/dFi2norm;
+      if(reldiff > 1.0e-12) { fprintf(stderr, " ... 7. rel. diff for dFi2 is %e\n", diff2norm/dFi2norm); exit(-1); }
+    } else {
+      if(diff2norm > 1.0e-12) { fprintf(stderr, " ... 7. abs. diff for dFi2 is %e\n", diff2norm); exit(-1); }
+    }
+
+    if(dFvnorm != 0) {
+      double reldiff = diffvnorm/dFvnorm;
+      if(reldiff > 1.0e-10) { fprintf(stderr, " ... 7. rel. diff for dFv is %e\n", diffvnorm/dFvnorm); exit(-1); }
+    } else {
+      if(diffvnorm > 1.0e-10) { fprintf(stderr, " ... 7. abs. diff for dFv is %e\n", diffvnorm); exit(-1); }
+    }
+
+
+    double diffminorm = (dMi00 - dMi).norm();
+    double dMinorm = dMi.norm();
+    double diffmvnorm = (dMv00 - dMv).norm();
+    double dMvnorm = dMv.norm();
+    if(dMinorm != 0) {
+      double reldiff = diffminorm/dMinorm;
+      if(reldiff > 1.0e-10) { fprintf(stderr, " ... 7. rel. diff for dMi is %e\n", diffminorm/dMinorm); exit(-1); }
+    } else {
+      if(diffminorm > 1.0e-10) { fprintf(stderr, " ... 7. abs. diff for dMi is %e\n", diffminorm); exit(-1); }
+    }
+    if(dMvnorm != 0) {
+      double reldiff = diffmvnorm/dMvnorm;
+      if(reldiff > 1.0e-10) { fprintf(stderr, " ... 7. rel. diff for dMv is %e\n", diffmvnorm/dMvnorm); exit(-1); }
+    } else {
+      if(diffmvnorm > 1.0e-10) { fprintf(stderr, " ... 7. abs. diff for dMv is %e\n", diffmvnorm); exit(-1); }
+    }
+    // Verification ends
+    */
+}
+
+    //------------------------------------------------------------------------------
+
+    // Included (YC)
+    template<int dim>
+    void FaceTria::computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
+                                                              Vec<double> &d2wall, double *Vwall, SVec<double,dim> &V, Vec3D &x0,
+                                                              double* gradP[3], int hydro,
+                                                              RectangularSparseMat<double,3,3> &dFidGradP,
+                                                              RectangularSparseMat<double,3,3> &dFidX,
+                                                              RectangularSparseMat<double,dim,3> &dFidV,
+                                                              RectangularSparseMat<double,3,3> &dFvdX,
+                                                              RectangularSparseMat<double,dim,3> &dFvdV,
+                                                              RectangularSparseMat<double,3,3> &dFidS,
+                                                              RectangularSparseMat<double,3,3> &dMidGradP,
+                                                              RectangularSparseMat<double,3,3> &dMidX,
+                                                              RectangularSparseMat<double,dim,3> &dMidV,
+                                                              RectangularSparseMat<double,3,3> &dMidS,
+                                                              RectangularSparseMat<double,3,3> &dMvdX,
+                                                              RectangularSparseMat<double,dim,3> &dMvdV)
+    {
+
+        Elem& elem = elems[elemNum];
+        Vec3D x[3] = {X[nodeNum(0)], X[nodeNum(1)], X[nodeNum(2)]};
+        Vec3D dx[3] = {x[0]-x0 , x[1]-x0 , x[2]-x0};
+        Vec3D dxm = third*(x[0]+x[1]+x[2]) - x0;
+
+        Vec3D dfi0, dfi1, dfi2, dfv;
+        dfi0 = 0.0;  dfi1 = 0.0;  dfi2 = 0.0;  dfv = 0.0;
+        double dFi0dGradP[3][3] = {0}, dFi1dGradP[3][3] = {0}, dFi2dGradP[3][3] = {0};
+        double dFi0dX0[3][3] = {0},    dFi0dX1[3][3] = {0},    dFi0dX2[3][3] = {0};
+        double dFi1dX0[3][3] = {0},    dFi1dX1[3][3] = {0},    dFi1dX2[3][3] = {0};
+        double dFi2dX0[3][3] = {0},    dFi2dX1[3][3] = {0},    dFi2dX2[3][3] = {0};
+        double dFidX0[3][3] = {0},     dFidX1[3][3] = {0},     dFidX2[3][3] = {0};
+        double dFi0dV[3][5] = {0},   dFi1dV[3][5] = {0},   dFi2dV[3][5] = {0};
+        double dFidSarray[3][3] = {0};
+        double dFvdXp[3][3][3] = {0}, dFvdXtetp[3][4][3] = {0}, dFvdVp[3][4][dim] = {0};
+        computeDerivativeOperatorsOfForce(elems, postFcn, X, V, 0, gradP, hydro,
+                                          dFi0dGradP, dFi1dGradP, dFi2dGradP,
+                                          dFi0dX0, dFi0dX1, dFi0dX2,
+                                          dFi1dX0, dFi1dX1, dFi1dX2,
+                                          dFi2dX0, dFi2dX1, dFi2dX2,
+                                          dFidSarray,
+                                          dFi0dV, dFi1dV, dFi2dV,
+                                          dFvdXp, dFvdXtetp, dFvdVp);
+        for(int i=0; i<3; ++i)
+          for(int j=0; j<3; ++j) {
+            dFidX0[i][j] += dFi0dX0[i][j] + dFi1dX0[i][j] + dFi2dX0[i][j];
+            dFidX1[i][j] += dFi0dX1[i][j] + dFi1dX1[i][j] + dFi2dX1[i][j];
+            dFidX2[i][j] += dFi0dX2[i][j] + dFi1dX2[i][j] + dFi2dX2[i][j];
+          }
+
+        double dFvdXpp[3][3][3]={0}, dFvdXtetpp[4][3][3]={0}, dFvdVpp[4][3][dim]={0};
+        for(int i=0; i<3; ++i) {
+          for(int j=0; j<3; ++j)
+            for(int k=0; k<3; ++k)
+              dFvdXpp[j][i][k] = dFvdXp[i][j][k];
+          for(int j=0; j<4; ++j) {
+            for(int k=0; k<3; ++k)
+              dFvdXtetpp[j][i][k] = dFvdXtetp[i][j][k];
+            for(int k=0; k<dim; ++k)
+              dFvdVpp[j][i][k] = dFvdVp[i][j][k];
+          }
+        }
+
+        for(int i=0; i<3; ++i)
+          dFvdX.addContrib(0, nodeNum(i), dFvdXpp[i][0]);
+
+        if(nodeNumTet[0] >= 0)
+          for(int i=0; i<4; ++i)
+            dFvdX.addContrib(0, nodeNumTet[i], dFvdXtetpp[i][0]);
+
+        for(int i=0; i<4; ++i)
+          dFvdV.addContrib(0, elem[i], dFvdVpp[i][0]);
+
+        dFidGradP.addContrib(0, nodeNum(0), dFi0dGradP[0]);
+        dFidGradP.addContrib(0, nodeNum(1), dFi1dGradP[0]);
+        dFidGradP.addContrib(0, nodeNum(2), dFi2dGradP[0]);
+
+        dFidX.addContrib(0, nodeNum(0), dFidX0[0]);
+        dFidX.addContrib(0, nodeNum(1), dFidX1[0]);
+        dFidX.addContrib(0, nodeNum(2), dFidX2[0]);
+
+        dFidS.addContrib(0, 0, dFidSarray[0]);
+
+        dFidV.addContrib(0, nodeNum(0), dFi0dV[0]);
+        dFidV.addContrib(0, nodeNum(1), dFi1dV[0]);
+        dFidV.addContrib(0, nodeNum(2), dFi2dV[0]);
+
+
+
+        Vec3D fi0,fi1,fi2,fv;
+        computeForceTransmitted(elems, postFcn, X, d2wall, Vwall, V, 0, fi0,fi1,fi2, fv, gradP, hydro);
+
+        double dFi0dn[3] = {0}, dFi0dS2[3][3] = {0}, dFi0dV2[3][3][dim] = {0}, dFi0dGradP2[3][3][3] = {0}, dFi0dX[3][3][3] = {0};
+        double dFi1dn[3] = {0}, dFi1dS2[3][3] = {0}, dFi1dV2[3][3][dim] = {0}, dFi1dGradP2[3][3][3] = {0}, dFi1dX[3][3][3] = {0};
+        double dFi2dn[3] = {0}, dFi2dS2[3][3] = {0}, dFi2dV2[3][3][dim] = {0}, dFi2dGradP2[3][3][3] = {0}, dFi2dX[3][3][3] = {0};
+        double dFvdXp2[3][3][3] = {0}, dFvdXtetp2[3][4][3] = {0}, dFvdVp2[3][4][dim] = {0};
+
+        computeDerivativeOperatorsOfForceTransmitted(elems, postFcn, X, V, 0, gradP, 0,
+                                                     dFi0dV2, dFi0dGradP2, dFi0dX, dFi0dn, dFi0dS2,
+                                                     dFi1dV2, dFi1dGradP2, dFi1dX, dFi1dn, dFi1dS2,
+                                                     dFi2dV2, dFi2dGradP2, dFi2dX, dFi2dn, dFi2dS2,
+                                                     dFvdXp2, dFvdXtetp2, dFvdVp2);
+
+
+        double dMidX0[3][3], dMidX1[3][3], dMidX2[3][3], dMidfi0[3][3], dMidfi1[3][3], dMidfi2[3][3];
+        dx[0].crossProductSensitivityOperator(fi0, dMidX0);
+        dx[1].crossProductSensitivityOperator(fi1, dMidX1);
+        dx[2].crossProductSensitivityOperator(fi2, dMidX2);
+        dx[0].crossProductSensitivityOperator(dMidfi0);
+        dx[1].crossProductSensitivityOperator(dMidfi1);
+        dx[2].crossProductSensitivityOperator(dMidfi2);
+
+        double dMvdXarray[3][3], dMvdfv[3][3];
+        dxm.crossProductSensitivityOperator(fv, dMvdXarray);
+        dxm.crossProductSensitivityOperator(dMvdfv);
+        double dMidSarray[3][3] = {0};
+        double dMidGradP0[3][3] = {0}, dMidGradP1[3][3] = {0}, dMidGradP2[3][3] = {0};
+        double dMidV0[3][5] = {0}, dMidV1[3][5] = {0}, dMidV2[3][5] = {0};
+
+        for(int i=0; i<3; ++i)
+          for(int j=0; j<3; ++j) {
+            dMvdXarray[i][j] *= third;
+            for(int k=0; k<3; ++k)
+              dMidSarray[i][k] += dMidfi0[i][j]*dFi0dS2[j][k] + dMidfi1[i][j]*dFi1dS2[j][k] + dMidfi2[i][j]*dFi2dS2[j][k];
+            for(int l=0; l<dim; ++l) {
+                dMidV0[i][l] += dMidfi0[i][j]*dFi0dV2[0][j][l] + dMidfi1[i][j]*dFi1dV2[0][j][l] + dMidfi2[i][j]*dFi2dV2[0][j][l];
+                dMidV1[i][l] += dMidfi0[i][j]*dFi0dV2[1][j][l] + dMidfi1[i][j]*dFi1dV2[1][j][l] + dMidfi2[i][j]*dFi2dV2[1][j][l];
+                dMidV2[i][l] += dMidfi0[i][j]*dFi0dV2[2][j][l] + dMidfi1[i][j]*dFi1dV2[2][j][l] + dMidfi2[i][j]*dFi2dV2[2][j][l];
+            }
+            for(int l=0; l<3; ++l) {
+                dMidGradP0[i][l] += dMidfi0[i][j]*dFi0dGradP2[0][j][l] + dMidfi1[i][j]*dFi1dGradP2[0][j][l] + dMidfi2[i][j]*dFi2dGradP2[0][j][l];
+                dMidGradP1[i][l] += dMidfi0[i][j]*dFi0dGradP2[1][j][l] + dMidfi1[i][j]*dFi1dGradP2[1][j][l] + dMidfi2[i][j]*dFi2dGradP2[1][j][l];
+                dMidGradP2[i][l] += dMidfi0[i][j]*dFi0dGradP2[2][j][l] + dMidfi1[i][j]*dFi1dGradP2[2][j][l] + dMidfi2[i][j]*dFi2dGradP2[2][j][l];
+                dMidX0[i][l] += dMidfi0[i][j]*dFi0dX[0][j][l] + dMidfi1[i][j]*dFi1dX[0][j][l] + dMidfi2[i][j]*dFi2dX[0][j][l];
+                dMidX1[i][l] += dMidfi0[i][j]*dFi0dX[1][j][l] + dMidfi1[i][j]*dFi1dX[1][j][l] + dMidfi2[i][j]*dFi2dX[1][j][l];
+                dMidX2[i][l] += dMidfi0[i][j]*dFi0dX[2][j][l] + dMidfi1[i][j]*dFi1dX[2][j][l] + dMidfi2[i][j]*dFi2dX[2][j][l];
+
+            }
+          }
+
+        double dMvdXp[3][3][3] = {0}, dMvdXtet[4][3][3] = {0}, dMvdVp[4][3][dim] = {0};
+        for(int i=0; i<3; ++i)
+          for(int j=0; j<3; ++j) {
+            for(int k=0; k<3; ++k) {
+              for(int l=0; l<3; ++l) {
+                dMvdXp[k][i][l] += dMvdfv[i][j]*dFvdXp2[j][k][l];
+              }
+            }
+            for(int k=0; k<4; ++k) {
+              for(int l=0; l<3; ++l)
+                dMvdXtet[k][i][l] += dMvdfv[i][j]*dFvdXtetp2[j][k][l];
+              for(int l=0; l<5; ++l)
+                dMvdVp[k][i][l] += dMvdfv[i][j]*dFvdVp2[j][k][l];
+            }
+          }
+
+
+
+        dMidS.addContrib(0, 0, dMidSarray[0]);
+
+        dMidX.addContrib(0, nodeNum(0), dMidX0[0]);
+        dMidX.addContrib(0, nodeNum(1), dMidX1[0]);
+        dMidX.addContrib(0, nodeNum(2), dMidX2[0]);
+
+        dMidV.addContrib(0, nodeNum(0), dMidV0[0]);
+        dMidV.addContrib(0, nodeNum(1), dMidV1[0]);
+        dMidV.addContrib(0, nodeNum(2), dMidV2[0]);
+
+        dMidGradP.addContrib(0, nodeNum(0), dMidGradP0[0]);
+        dMidGradP.addContrib(0, nodeNum(1), dMidGradP1[0]);
+        dMidGradP.addContrib(0, nodeNum(2), dMidGradP2[0]);
+
+        for(int i=0; i<3; ++i) {
+          dMvdX.addContrib(0, nodeNum(i), dMvdXarray[0]);
+          dMvdX.addContrib(0, nodeNum(i), dMvdXp[i][0]);
+        }
+
+        if(nodeNumTet[0] >= 0)
+          for(int i=0; i<4; ++i)
+            dMvdX.addContrib(0, nodeNumTet[i], dMvdXtet[i][0]);
+
+        for(int i=0; i<4; ++i) {
+          dMvdV.addContrib(0, elem[i], dMvdVp[i][0]);
+        }
 
 }
 
diff -r da841a06e630 -r 5d849f9519c9 FaceTria.h
--- a/FaceTria.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/FaceTria.h	Mon Jan 30 20:09:06 2017 -0800
@@ -14,6 +14,7 @@
 
   int nodeNumT[3];
   int edgeNumT[3];
+  int nodeNumTet[4];
 
   // This is for triangles only (6 Vec3D's = 3 positions at t_n and t_n+1... 
   // make general function (also need to modify function calls)
@@ -163,6 +164,17 @@
                                 Vec<double> &, double *, double *, SVec<double,dim> &,
                                 SVec<double,dim> &, double [3], double *, Vec3D &, Vec3D &, 
                                 Vec3D &, Vec3D &, double * gradP[3], double* dGradP[3], int = 0);
+
+  template<int dim>
+  void computeDerivativeOperatorsOfForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double *pin, double* gradP[3], int hydro,
+                                         double dFi0dGradP[3][3], double dFi1dGradP[3][3], double dFi2dGradP[3][3],
+                                         double dFi0dX0[3][3], double dFi0dX1[3][3], double dFi0dX2[3][3],
+                                         double dFi1dX0[3][3], double dFi1dX1[3][3], double dFi1dX2[3][3],
+                                         double dFi2dX0[3][3], double dFi2dX1[3][3], double dFi2dX2[3][3],
+                                         double dFidS[3][3],
+                                         double dFi0dV[3][5], double dFi1dV[3][5], double dFi2dV[3][5],
+                                         double dFvdX[3][3][3], double dFvdXtet[3][4][3], double dFvdV[3][4][dim]);
+
   template<int dim>
   void computeDerivativeOfForceTransmitted(ElemSet &, PostFcn *, SVec<double,3> &, SVec<double,3> &,
                                            Vec<double> &, double *, double *, SVec<double,dim> &,
@@ -170,14 +182,15 @@
                                            Vec3D &, Vec3D &, double* gradP[3], double* dGradP[3], int = 0);
 
   template<int dim>
-  void computeDerivativeOperatorsOfForceTransmitted(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V,
+  void computeDerivativeOperatorsOfForceTransmitted(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V,
                                                     double *pin, double* gradP[3], int hydro,
                                                     double dFi0dV[3][3][dim], double dFi0dGradP[3][3][3], double dFi0dX[3][3][3],
                                                     double dFi0dn[3], double dFi0dS[3][3],
                                                     double dFi1dV[3][3][dim], double dFi1dGradP[3][3][3], double dFi1dX[3][3][3],
                                                     double dFi1dn[3], double dFi1dS[3][3],
                                                     double dFi2dV[3][3][dim], double dFi2dGradP[3][3][3], double dFi2dX[3][3][3],
-                                                    double dFi2dn[3], double dFi2dS[3][3]);
+													double dFi2dn[3], double dFi2dS[3][3],
+													double dFvdX[3][3][3], double dFvdXtet[3][4][3], double dFvdV[3][4][dim]);
 
   template<int dim>
   void computeDerivativeOfNodalForce(ElemSet &, PostFcn *, SVec<double,3> &, SVec<double,3> &,
@@ -187,7 +200,7 @@
                                      double * gradP[3], double* dGradP[3]);
 
   template<int dim>
-  void computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, 
+  void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,
                           SVec<double,dim> &V, double pin, double* gradP[3], 
                           RectangularSparseMat<double,3,3> &dForcedX,
                           RectangularSparseMat<double,3,3> &dForcedGradP,
@@ -204,6 +217,31 @@
                                          SVec<double,dim> &, SVec<double,dim> &, double [3],
                                          Vec3D &, Vec3D &, Vec3D &, Vec3D &, Vec3D &, 
                                          double * gradP[3], double* dGradP[3], int = 0);
+
+  //  template<int dim>
+  //  void computeDerivativeOfForceAndMoment2(ElemSet &, PostFcn *, SVec<double,3> &, SVec<double,3> &,
+  //                                          Vec<double> &, double *, double *,
+  //                                          SVec<double,dim> &, SVec<double,dim> &, double [3],
+  //                                          Vec3D &, Vec3D &, Vec3D &, Vec3D &, Vec3D &,
+  //                                          double * gradP[3], double* dGradP[3], int = 0);
+
+  template<int dim>
+  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &, PostFcn *, SVec<double,3> &,
+                                                  Vec<double> &, double *, SVec<double,dim> &,
+                                                  Vec3D &, double * gradP[3], int,
+                                                  RectangularSparseMat<double,3,3> &dFidGradP,
+                                                  RectangularSparseMat<double,3,3> &dFidX,
+                                                  RectangularSparseMat<double,dim,3> &dFidV,
+                                                  RectangularSparseMat<double,3,3> &dFvdX,
+                                                  RectangularSparseMat<double,dim,3> &dFvdV,
+                                                  RectangularSparseMat<double,3,3> &dFidS,
+                                                  RectangularSparseMat<double,3,3> &dMidGradP,
+                                                  RectangularSparseMat<double,3,3> &dMidX,
+                                                  RectangularSparseMat<double,dim,3> &dMidV,
+                                                  RectangularSparseMat<double,3,3> &dMidS,
+                                                  RectangularSparseMat<double,3,3> &dMvdX,
+                                                  RectangularSparseMat<double,dim,3> &dMvdV);
+
   template<int dim>
   void computeDerivativeOfGalerkinTerm(ElemSet &, FemEquationTerm *, SVec<double,3> &, SVec<double,3> &,
                                        Vec<double> &, double *, double *, SVec<double,dim> &, 
diff -r da841a06e630 -r 5d849f9519c9 FemEquationTerm.h
--- a/FemEquationTerm.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/FemEquationTerm.h	Mon Jan 30 20:09:06 2017 -0800
@@ -88,6 +88,8 @@
 // Included (MB)
   virtual bool computeDerivativeOfVolumeTerm(double dp1dxj[4][3], double ddp1dxj[4][3], double d2w[4], double *v[4],
 				 double *dv[4], double dMach, double *dr, double *ds, double *dpr, double dtetvol, SVec<double,3> &x, int nodenum[4], int volid) = 0;
+  virtual void computeDerivativeOperatorsOfVolumeTerm(double dp1dxj[4][3], double *v[4],
+  			 double (*drddp1dxj)[5][4][3], double (*drdV)[5][4][5], double (*drdMach)[5]) = 0;
   virtual void computeDerivativeOfSurfaceTerm(int c, Vec3D &n, Vec3D &dn, double d2w[3],
 				  double *vw, double *dvw, double *v[3], double *dv[3], double dMach, double *dr) = 0;
   virtual void computeDerivativeOfSurfaceTerm(double dp1dxj[4][3], double ddp1dxj[4][3], int c, Vec3D &n, Vec3D &dn, double d2w[4],
diff -r da841a06e630 -r 5d849f9519c9 FemEquationTermDesc.C
--- a/FemEquationTermDesc.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/FemEquationTermDesc.C	Mon Jan 30 20:09:06 2017 -0800
@@ -225,6 +225,94 @@
 
 }
 
+
+// Included (YC)
+void FemEquationTermNS::computeDerivativeOperatorsOfVolumeTerm(double dp1dxj[4][3], double *V[4],
+            double (*drddp1dxj)[5][4][3], double (*drdV)[5][4][5], double (*drdMach)[5])
+{
+  double u[4][3], ucg[3];
+  computeVelocity(V, u, ucg);
+
+  double dudV[4][3][4][4] = {0}, ducgdV[3][4][4] = {0};
+  computeDerivativeOperatorsOfVelocity(dudV, ducgdV);
+
+  double T[4], Tcg;
+  computeTemperature(V, T, Tcg);
+
+  double dTdV[4][5] = {0}, dTcgdV[4] = {0};
+  computeDerivativeOperatorsOfTemperature(V, dTdV, dTcgdV);
+
+  double dudxj[3][3];
+  computeVelocityGradient(dp1dxj, u, dudxj);
+
+  double ddudxj[3][3] = {0};
+  double ddudxjddp1dxj[3][3][4][3] = {0}, ddudxjdu[3][3][4][3] = {0};
+  computeDerivativeOperatorsOfVelocityGradient(dp1dxj, u, ddudxjddp1dxj, ddudxjdu);
+
+  double dTdxj[3];
+  computeTemperatureGradient(dp1dxj, T, dTdxj);
+
+  double ddTdxjddp1dxj[3][4][3] = {0}, ddTdxjdT[3][4] = {0};
+  computeDerivativeOperatorsOfTemperatureGradient(dp1dxj, T, ddTdxjddp1dxj, ddTdxjdT);
+
+  double coef = -1.0 / ( reynolds_muNS * reynolds_muNS ) * dRe_mudMachNS;
+  double mu, lambda, kappa;
+  computeTransportCoefficients(Tcg, mu, lambda, kappa);
+
+  double dmudTcg(0), dmudMach(0);
+  viscoFcn->compute_muDerivativeOperators(Tcg, dmudTcg, dmudMach);
+  double dlambdadmu(0), dlambdadMach(0);
+  viscoFcn->compute_lambdaDerivativeOperators(dlambdadmu, dlambdadMach);
+  double dkappadTcg(0), dkappadMach(0);
+  thermalCondFcn->computeDerivativeOperators(Tcg, dkappadTcg, dkappadMach);
+
+  mu     *= ooreynolds_mu;
+  lambda *= ooreynolds_mu;
+  kappa  *= ooreynolds_mu;
+  double drdmu[3][5] = {0}, drdlambda[3][5] = {0}, drdkappa[3][5] = {0}, drdu[3][5][3] = {0}, drddudxj[3][5][3][3] = {0}, drddTdxj[3][5][3] = {0};
+  computeDerivativeOperatorsOfVolumeTermNS(mu, lambda, kappa, ucg, dudxj, dTdxj,
+                                           drdmu, drdlambda, drdkappa, drdu, drddudxj, drddTdxj);
+  for(int i=0; i<3; ++i) {
+    for(int j=0; j<5; ++j) {
+      drdMach[i][j] += (drdkappa[i][j]*(coef*kappa+ooreynolds_mu*dkappadMach) + drdmu[i][j]*(coef*mu+ooreynolds_mu*dmudMach) + drdlambda[i][j]*(coef*lambda+ooreynolds_mu*dlambdadMach+ooreynolds_mu*dlambdadmu*ooreynolds_mu*dmudMach+ooreynolds_mu*dlambdadmu*mu*coef));
+      for(int k=0; k<4; ++k) {
+        for(int l=0; l<5; ++l) {
+          drdV[i][j][k][l] += (drdmu[i][j]*ooreynolds_mu*dmudTcg + drdkappa[i][j]*ooreynolds_mu*dkappadTcg + drdlambda[i][j]*ooreynolds_mu*dlambdadmu*ooreynolds_mu*dmudTcg)*dTcgdV[k];
+        }
+      }
+      for(int k=0; k<3; ++k) {
+        for(int l=0; l<4; ++l) {
+          for(int m=0; m<5; ++m) {
+            drdV[i][j][l][m] += drddTdxj[i][j][k]*ddTdxjdT[k][l]*dTdV[l][m];//added
+          }
+          for(int w=0; w<3; ++w) {
+            drddp1dxj[i][j][l][w] += drddTdxj[i][j][k]*ddTdxjddp1dxj[k][l][w];
+          }
+        }
+        for(int l=0; l<4; ++l) {
+          for(int m=0; m<4; ++m) {
+            drdV[i][j][l][m] += drdu[i][j][k]*ducgdV[k][l][m];
+          }
+        }
+        for(int l=0; l<3; ++l) {
+          for(int m=0; m<4; ++m) {
+            for(int n=0; n<3; ++n) {
+              drddp1dxj[i][j][m][n] += drddudxj[i][j][k][l]*ddudxjddp1dxj[k][l][m][n];
+              for(int o=0; o<4; ++o) {
+                for(int p=0; p<4; ++p) {
+                  drdV[i][j][o][p] += drddudxj[i][j][k][l]*ddudxjdu[k][l][m][n]*dudV[m][n][o][p];
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+
+
 //------------------------------------------------------------------------------
 
 // This function was modified to account for the derivative of the mu with respect to the conservative variables
diff -r da841a06e630 -r 5d849f9519c9 FemEquationTermDesc.h
--- a/FemEquationTermDesc.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/FemEquationTermDesc.h	Mon Jan 30 20:09:06 2017 -0800
@@ -46,6 +46,10 @@
   void computeJacobianSurfaceTerm(int, Vec3D &, double [3], double *, double *[3], double *);
   void computeSurfaceTerm(double [4][3], int, Vec3D &, double [4], 
                           double *, double *[4], double *);
+
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]);
+
   void computeJacobianSurfaceTerm(double [4][3], int, Vec3D &, double [4], 
                                   double *, double *[4], double *);
   
@@ -138,6 +142,12 @@
   
   bool computeJacobianVolumeTerm(double [4][3], double [4], double *[4], double *, double *, double *, double,
                                  SVec<double,3> &, int [4], int);
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (
+    double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermSA::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
   void computeSurfaceTerm(int, Vec3D &, double [3], 
                           double *, double *[3], double *);
   void computeJacobianSurfaceTerm(int, Vec3D &, double [3], double *, double *[3], double *);
@@ -250,6 +260,12 @@
    double, double *, double *, double *, double, SVec<double,3> &, int [4], int
    );
   
+   void computeDerivativeOperatorsOfVolumeTerm // YC
+   (double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+     fprintf(stderr, "*** Error: FemEquationTermDES::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+     exit(-1);
+   }
+
   
   /// UH (08/10) The following function results in exit (Not Implemented).
   void computeDerivativeOfSurfaceTerm
@@ -370,6 +386,11 @@
     exit(1);
   }
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermSAmean::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
   
   void computeDerivativeOfSurfaceTerm
   (
@@ -494,6 +515,14 @@
     exit(1);
   }
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (
+   double [4][3], double *[4],
+   double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermDESmean::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+   exit(-1);
+  }
+
   
   void computeDerivativeOfSurfaceTerm
   (
@@ -619,6 +648,13 @@
     exit(1);
   }
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (
+    double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermSAturb::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
+
   void computeDerivativeOfSurfaceTerm
   (
    int c, Vec3D &n, Vec3D &dn, double d2w[3],
@@ -744,7 +780,13 @@
     fprintf(stderr, "*** Error: FemEquationTermDESturb::computeDerivativeOfVolumeTerm should not be called\n");
     exit(1);
   }
-  
+
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (
+   double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+   fprintf(stderr, "*** Error: FemEquationTermDESturb::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+   exit(-1);
+  }
   
   void computeDerivativeOfSurfaceTerm
   (
@@ -859,6 +901,13 @@
    double, double *, double *, double *, double, SVec<double,3> &, int [4], int
    );
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC WTF is this code style?
+  (
+   double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermKE::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
+
   
   void computeDerivativeOfSurfaceTerm
   (
@@ -975,6 +1024,13 @@
     exit(1);
   }
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+   (
+    double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermKEmean::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
+
   void computeDerivativeOfSurfaceTerm
   (
    int c, Vec3D &n, Vec3D &dn, double d2w[3],
@@ -1098,6 +1154,13 @@
     exit(1);
   }
   
+  void computeDerivativeOperatorsOfVolumeTerm // YC
+  (
+   double [4][3], double *[4], double (*)[5][4][3], double (*)[5][4][5], double (*)[5]) {
+    fprintf(stderr, "*** Error: FemEquationTermKEturb::computeDerivativeOperatorsOfVolumeTerm is not implemented yet\n");
+    exit(-1);
+  }
+
   
   void computeDerivativeOfSurfaceTerm
   (
diff -r da841a06e630 -r 5d849f9519c9 FluidShapeOptimizationHandler.C
--- a/FluidShapeOptimizationHandler.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/FluidShapeOptimizationHandler.C	Mon Jan 30 20:09:06 2017 -0800
@@ -35,6 +35,11 @@
 dFdS(dom->getNodeDistInfo()),
 dFdSref(dom->getNodeDistInfo()),
 dUdS(dom->getNodeDistInfo()),
+dfaU(dom->getNodeDistInfo()),
+dfaX(dom->getNodeDistInfo()),
+lambdaU(dom->getNodeDistInfo()),
+lambdaSDisp(dom->getNodeDistInfo()),
+lambdaX(dom->getNodeDistInfo()),
 p(dom->getNodeDistInfo()),
 dPdS(dom->getNodeDistInfo()),
 Flux(dom->getNodeDistInfo()),
@@ -154,6 +159,8 @@
   dFdS=0.0;
   dFdSref=0.0;
   dUdS=0.0;
+  dfaU=0.0;
+  dfaX=0.0;
   p=0.0;
   dPdS=0.0;
   dddx=0.0;
@@ -220,12 +227,6 @@
 
   ioData.bc.inlet.beta = teta;
   ioData.bc.outlet.beta = teta;
-
-//  this->com->fprintf(stderr, "\n\n FluidSensitivityAnalysis values: \n\n");
-//  this->com->fprintf(stderr, "\n\n Inlet Alpha = %20.17e \n\n",ioData.bc.inlet.alpha);
-//  this->com->fprintf(stderr, "\n\n Inlet Beta = %20.17e \n\n",ioData.bc.inlet.beta);
-//  this->com->fprintf(stderr, "\n\n Outlet Alpha = %20.17e \n\n",ioData.bc.outlet.alpha);
-//  this->com->fprintf(stderr, "\n\n Outlet Beta = %20.17e \n\n",ioData.bc.outlet.beta);
       
   if (ioData.problem.mode == ProblemData::NON_DIMENSIONAL) 
   {
@@ -334,8 +335,8 @@
       (1.0 + ioData.eqs.viscosityModel.sutherlandReferenceTemperature/ioData.ref.temperature);
     ioData.ref.reynolds_mu = velocity * ioData.ref.length * ioData.ref.density / viscosity;
 
-    if (ioData.eqs.type == EquationsData::NAVIER_STOKES)
-      this->com->fprintf(stderr, "\n\n Reynolds = %e \n\n",ioData.ref.reynolds_mu);
+//    if (ioData.eqs.type == EquationsData::NAVIER_STOKES)
+//      this->com->fprintf(stderr, "\n\n Reynolds = %e \n\n",ioData.ref.reynolds_mu);
 
     double dvelocitydMach = sqrt(gamma * ioData.ref.pressure / ioData.ref.density);
     ioData.ref.dRe_mudMach = dvelocitydMach * ioData.ref.length * ioData.ref.density / viscosity;
@@ -583,6 +584,11 @@
   Vec3D *Fvm = new Vec3D[nSurfs];
   Vec3D *Mvm = new Vec3D[nSurfs];
 
+  Vec3D *dFi2 = new Vec3D[nSurfs];
+  Vec3D *dMi2 = new Vec3D[nSurfs];
+  Vec3D *dFv2 = new Vec3D[nSurfs];
+  Vec3D *dMv2 = new Vec3D[nSurfs];
+
   x0[0] = ioData.output.transient.x0;
   x0[1] = ioData.output.transient.y0;
   x0[2] = ioData.output.transient.z0;
@@ -763,9 +769,34 @@
   M = Mi[0] + Mv[0];
 
   dRdXoperators<dim> *dRdXop = dRdX->getdRdXop(); 
-  this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx, dddy, dddz, dR, dGradP);
-
-  this->postOp->computeDerivativeOfForceAndMoment(x0, X, dX, U, dU, DFSPAR, dFi, dMi, dFv, dMv);
+//  this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx, dddy, dddz, dR, dGradP);
+//  this->postOp->computeDerivativeOfForceAndMoment(x0, X, dX, U, dU, DFSPAR, dFi, dMi, dFv, dMv);
+
+
+  if(isSparse) this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx, dddy, dddz, dR, dGradP);
+  else this->spaceOp->computeDerivativeOfGradP(X, dX, *this->A, dAdS, U, dU);
+
+  if(isSparse) {
+    this->postOp->computeDerivativeOfForceAndMoment(dRdXop, dX, dU, DFSPAR, dGradP, dFi, dMi, dFv, dMv);
+/* Verificaiton
+    this->postOp->computeDerivativeOfForceAndMoment(x0, X, dX, U, dU, DFSPAR, dFi2, dMi2, dFv2, dMv2);
+    for(int i=0; i<3; ++i) {
+      double diff = abs(dFi2[0][i] - dFi[0][i]);
+      if(dFi2[0][i] != 0) this->com->fprintf(stderr, "diff for dFi is %e\n", diff/abs(dFi2[0][i]));
+      else this->com->fprintf(stderr, "diff for dFi is %e\n", diff);
+      diff = abs(dMi2[0][i] - dMi[0][i]);
+      if(dMi2[0][i] != 0) this->com->fprintf(stderr, "diff for dMi is %e\n", diff/abs(dMi2[0][i]));
+      else this->com->fprintf(stderr, "diff for dMi is %e\n", diff);
+      diff = abs(dFv2[0][i] - dFv[0][i]);
+      if(dFv2[0][i] != 0) this->com->fprintf(stderr, "diff for dFv is %e\n", diff/abs(dFv2[0][i]));
+      else this->com->fprintf(stderr, "diff for dFv is %e\n", diff);
+      diff = abs(dMv2[0][i] - dMv[0][i]);
+      if(dMv2[0][i] != 0) this->com->fprintf(stderr, "diff for dMv is %e\n", diff/abs(dMv2[0][i]));
+      else this->com->fprintf(stderr, "diff for dMv is %e\n", diff);
+    }
+*/
+  } else this->postOp->computeDerivativeOfForceAndMoment(x0, X, dX, U, dU, DFSPAR, dFi, dMi, dFv, dMv);
+
 
   dF = 0.0;
   dM = 0.0;
@@ -816,6 +847,96 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
+void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(IoData &ioData,
+                                                                                                    Vec3D &dForces,
+                                                                                                    Vec3D &dMoments,
+                                                                                                    Vec3D &dL,
+                                                                                                    DistSVec<double,3> &X,
+                                                                                                    DistSVec<double,dim> &U,
+                                                                                                    DistSVec<double,3> &dQdX,
+                                                                                                    DistSVec<double,dim> &dQdU)
+{
+
+// Q is a quantity of your interest.
+// If you want Q to be first component of lift, that is L[0],
+// then set dL = [1 0 0]
+// If you want Q to be second component of forces,
+// then set dForces = [0 1 0]
+
+  int nSurfs = this->postOp->getNumSurf();
+  if(nSurfs != 1) { this->com->fprintf(stderr, " *** Error : Sparse format supports only nSurfs = 1\n");  exit(-1); }
+
+  Vec3D x0, F, dF, M, dM;
+  Vec3D *Fi = new Vec3D[nSurfs];
+  Vec3D *Mi = new Vec3D[nSurfs];
+  Vec3D *Fv = new Vec3D[nSurfs];
+  Vec3D *Mv = new Vec3D[nSurfs];
+
+  x0[0] = ioData.output.transient.x0;
+  x0[1] = ioData.output.transient.y0;
+  x0[2] = ioData.output.transient.z0;
+
+  this->spaceOp->computeGradP(X, *this->A, U);
+  this->postOp->computeForceAndMoment(x0, X, U, 0, Fi, Mi, Fv, Mv);
+
+  F = 0.0;
+  M = 0.0;
+  F = Fi[0] + Fv[0];
+  M = Mi[0] + Mv[0];
+
+  double sin_a = sin(ioData.bc.inlet.alpha);
+  double cos_a = cos(ioData.bc.inlet.alpha);
+  double sin_b = sin(ioData.bc.inlet.beta);
+  double cos_b = cos(ioData.bc.inlet.beta);
+
+  SVec<double,3> dFiSVec(1), dMiSVec(1), dFvSVec(1), dMvSVec(1), dSSVec(1);
+  dddx = 0.0;  dddy = 0.0;  dddz = 0.0;  dR = 0.0;  dAdS = 0.0;
+  // transpose computation.
+  dQdX = 0.0;  dGradP = 0.0;  dQdU = 0.0;
+  dF = 0.0;  dSSVec = 0.0;  dM = 0.0;
+
+  double dLdF[3][3] = {0}, dLdS[3][3] = {0};
+  dLdF[0][0] = cos_a*cos_b;  dLdF[0][1] = cos_a*sin_b;  dLdF[0][2] = sin_a;
+  dLdF[1][0] = -sin_b;       dLdF[1][1] = cos_b;
+  dLdF[2][0] = -sin_a*cos_b; dLdF[2][1] =-sin_a*sin_b;  dLdF[2][2] = cos_a;
+
+  dLdS[0][1] = (F[2]*cos_a - F[0]*sin_a*cos_b - F[1]*sin_a*sin_b);
+  dLdS[0][2] = (F[0]*cos_a*sin_b + F[1]*cos_a*cos_b);
+  dLdS[1][2] = -(F[0]*cos_b + F[1]*sin_b);
+  dLdS[2][1] = -(F[0]*cos_a*cos_b + F[1]*cos_a*sin_b + F[2]*sin_a);
+  dLdS[2][2] = (F[0]*sin_a*sin_b - F[1]*sin_a*cos_b);
+
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<3; ++j) {
+      dF[i] += dLdF[j][i]*dL[j];
+      dSSVec[0][i] += dLdS[j][i]*dL[j];
+    }
+
+
+  dF += dForces;
+  dM += dMoments;
+  if(this->refVal->mode == RefVal::NON_DIMENSIONAL) {
+    dF *= 2.0 * this->refVal->length*this->refVal->length / surface;
+    dM *= 2.0 * this->refVal->length*this->refVal->length*this->refVal->length / (surface * length);
+  }
+  else {
+    dF *= this->refVal->force;
+    dM *= this->refVal->energy;
+  }
+
+  dFiSVec[0][0] = dF[0];    dFiSVec[0][1] = dF[1];   dFiSVec[0][2] = dF[2];
+  dFvSVec[0][0] = dF[0];    dFvSVec[0][1] = dF[1];   dFvSVec[0][2] = dF[2];
+  dMiSVec[0][0] = dM[0];    dMiSVec[0][1] = dM[1];   dMiSVec[0][2] = dM[2];
+  dMvSVec[0][0] = dM[0];    dMvSVec[0][1] = dM[1];   dMvSVec[0][2] = dM[2];
+  dRdXoperators<dim> *dRdXop = dRdX->getdRdXop();
+  this->postOp->computeTransposeDerivativeOfForceAndMoment(dRdXop, dFiSVec, dMiSVec, dFvSVec, dMvSVec, dQdX, dQdU, dSSVec, dGradP);
+  this->spaceOp->computeTransposeDerivativeOfGradP(dRdXop, dGradP, dddx, dddy, dddz, dR, dAdS, dQdX, dQdU);
+
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
 void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,
                                                             DistSVec<double,dim> &U, DistSVec<double,dim> &dU, DistSVec<double,3> &load, DistSVec<double,3> &dLoad)
 {
@@ -878,7 +999,6 @@
   dLoad=0.0;
 
   this->spaceOp->computeGradP(X, A, U);
-
   this->postOp->computeNodalForce(X, U, Pin, load);
 
   xmachc=xmach;
@@ -973,113 +1093,28 @@
 
   load=0.0;
   dLoad=0.0;
-//  DistSVec<double,3> dLoad2(dLoad), diff(dLoad);
+
   this->spaceOp->computeGradP(X, *this->A, U);
   this->postOp->computeNodalForce(X, U, Pin, load);
 
   dRdXoperators<dim> *dRdXop = dRdX->getdRdXop(); 
-  if(isSparse) 
+  if(isSparse) {
     this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx, dddy, dddz, dR, dGradP);
-  else this->spaceOp->computeDerivativeOfGradP(X, dX, *this->A, dAdS, U, dU);
-/*/////////////// checking spaceOp->computeDerivativeOfGradP & spaceOp->computeTransposeDerivativeOfGradP
- //
- //
-  DistSVec<double,3> dGradP2(dGradP), dX2(dX);
-  DistSVec<double,dim> dddx2(dddx), dddy2(dddy), dddz2(dddz), dU2(dU);
-  DistSVec<double,6> dR2(dR);
-  DistVec<double> dAdS2(dAdS);
-  dGradP2 = 0;  dX2 = 0;  dddx2 = 0;  dddy2 = 0;  dddz2 = 0;  dU2 = 0;  dR2 = 0;  dAdS2 = 0;
-  this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx2, dddy2, dddz2, dR2, dGradP2); 
-  double aa = dGradP2*dGradP; // + dR2*dR;
-
-  dddx2 = 0;  dddy2 = 0;   dddz2 = 0;
-  this->spaceOp->computeTransposeDerivativeOfGradP(dRdXop, dGradP, dddx2, dddy2, dddz2, dR, dAdS2, dX2, dU2);
-  double bb = dAdS2*dAdS + dX2*dX + dU2*dU; 
-
-  double diffnorm = sqrt((aa-bb)*(aa-bb));
-  if(aa != 0) this->com->fprintf(stderr, " ... rel. diff is %e\n", diffnorm/std::abs(aa));
-  else this->com->fprintf(stderr, " ... abs. diff is %e\n", diffnorm);
-*/
+  } else this->spaceOp->computeDerivativeOfGradP(X, dX, *this->A, dAdS, U, dU);
 
   //TODO: must treat dS2 better in case that dS is not zero.
   double dS2[3] = {0}; 
 
-  if(isSparse) this->postOp->computeDerivativeOfNodalForce(dRdXop->dForcedX, dRdXop->dForcedGradP, dRdXop->dForcedV, dRdXop->dForcedS,
-                                                           dRdXop->dVdU, dX, dGradP, dU, DFSPAR, dLoad); 
+  if(isSparse) {
+//    DistSVec<double,3> dLoad2(dLoad), diff(dLoad);
+    this->postOp->computeDerivativeOfNodalForce(dRdXop->dForcedX, dRdXop->dForcedGradP, dRdXop->dForcedV, dRdXop->dForcedS,
+                                                dRdXop->dVdU, dX, dGradP, dU, DFSPAR, dLoad);
+//    this->postOp->computeDerivativeOfNodalForce(X, dX, U, dU, Pin, DFSPAR, dLoad2);
+//    diff = dLoad2 - dLoad;
+//    this->com->fprintf(stderr, " difference between dLoad and dLoad2 is %e and dLoad = %e, dLoad2 = %e\n", diff.norm()/dLoad.norm(), dLoad.norm(), dLoad2.norm());
+  }
   else this->postOp->computeDerivativeOfNodalForce(X, dX, U, dU, Pin, DFSPAR, dLoad);
 
-/* ////////////////// checking computeDerivativeOfNodalForce && computeTransposeDerivativeOfNodalForce
- //
- //
-  DistSVec<double,dim> dU2(dU);
-  DistSVec<double,3> dGradP2(dGradP), dX2(dX), dLoad2(dLoad);
-  DistVec<double> dAdS2(dAdS);
-  dGradP2 = 0.0;  dX2 = 0.0;  dU2 = 0.0;  dAdS2 = 0.0;  dLoad2 = 0.0;
- 
-  this->postOp->computeDerivativeOfNodalForce(dRdXop->dForcedX, dRdXop->dForcedGradP, dRdXop->dForcedV, dRdXop->dForcedS,
-                                              dRdXop->dVdU, dX, dGradP, dU, DFSPAR, dLoad2);
-  double aa = dLoad2*dLoad; 
-
-  this->postOp->computeTransposeDerivativeOfNodalForce(dRdXop->dForcedX,
-                                                       dRdXop->dForcedGradP,
-                                                       dRdXop->dForcedV,
-                                                       dRdXop->dForcedS,
-                                                       dRdXop->dVdU,
-                                                       dLoad, dX2, dGradP2, 
-                                                       dU2, dS2);
-  
-  double bb = dU2*dU + dX2*dX + dAdS2*dAdS + dGradP2*dGradP;
-  double diffnorm = sqrt((aa-bb)*(aa-bb));
-  if( aa != 0.0 ) this->com->fprintf(stderr, " ... final rel. diff = %e\n", diffnorm/sqrt(aa*aa));
-  else this->com->fprintf(stderr, " ... final abs. diff = %e\n", diffnorm);
-
-  this->com->fprintf(stderr, " ... dS2[0] = %e, dS2[1] = %e, dS2[2] = %e\n", dS2[0], dS2[1], dS2[2]);
-*/
-
-
-
-/* //////////////////// checking spaceOp->computeDerivativeOfGradP & spaceOp->computeTransposeDerivativeOfGradP
- ////////////////////// checking computeDerivativeOfNodalForce && computeTransposeDerivativeOfNodalForce 
- //
- //
-  DistSVec<double,dim> dU2(dU);
-  DistSVec<double,3> dGradP2(dGradP), dX2(dX), dLoad2(dLoad);
-  DistVec<double> dAdS2(dAdS);
- 
-  dGradP2 = 0.0;  dLoad2 = 0.0;  dddx = 0.0; dddy = 0.0;  dddz = 0.0;  dR = 0.0;
-  this->spaceOp->computeDerivativeOfGradP(dRdXop, dX, dAdS, dU, dddx, dddy, dddz, dR, dGradP2);
-  this->postOp->computeDerivativeOfNodalForce(dRdXop->dForcedX, dRdXop->dForcedGradP, dRdXop->dForcedV, dRdXop->dForcedS,
-                                              dRdXop->dVdU, dX, dGradP2, dU, DFSPAR, dLoad2);
-  double aa = dLoad2*dLoad; 
-
-  dddx = 0.0; dddy = 0.0;  dddz = 0.0;  dR = 0.0;   dGradP2 = 0.0;    dU2 = 0.0;   dX2 = 0.0;   dAdS2 = 0.0; 
-  this->postOp->computeTransposeDerivativeOfNodalForce(dRdXop->dForcedX,
-                                                       dRdXop->dForcedGradP,
-                                                       dRdXop->dForcedV,
-                                                       dRdXop->dForcedS,
-                                                       dRdXop->dVdU,
-                                                       dLoad, dX2, dGradP2, 
-                                                       dU2, dS2);
-  
-  this->spaceOp->computeTransposeDerivativeOfGradP(dRdXop, dGradP2, dddx, dddy, dddz, dR, dAdS2, dX2, dU2); 
-  double bb = dU2*dU + dX2*dX + dAdS2*dAdS;
-  double diffnorm = sqrt((aa-bb)*(aa-bb));
-  if( aa != 0.0 ) this->com->fprintf(stderr, " ... final rel. diff = %e\n", diffnorm/sqrt(aa*aa));
-  else this->com->fprintf(stderr, " ... final abs. diff = %e\n", diffnorm);
-
-  this->com->fprintf(stderr, " ... dS2[0] = %e, dS2[1] = %e, dS2[2] = %e\n", dS2[0], dS2[1], dS2[2]);
-*/
-
-
-/*
-  diff = dLoad2 - dLoad;
-  double diffnorm = diff.norm();
-  double dLoadnorm = dLoad.norm();
-  double dLoad2norm = dLoad2.norm();
-  if(dLoadnorm != 0) this->com->fprintf(stderr, " ... rel. diff is %e, dLoadnorm = %e, dLoad2norm = %e\n", diffnorm/dLoadnorm, dLoadnorm, dLoad2norm);
-  else this->com->fprintf(stderr, " ... abs. diff is %e\n", diffnorm);
-*/
-
   if (this->refVal->mode == RefVal::NON_DIMENSIONAL) {
     dLoad *= 2.0 * this->refVal->length*this->refVal->length / surface;
   }
@@ -1102,19 +1137,16 @@
   double dVelocity= sqrt(gamma * ioData.ref.pressure / ioData.ref.density)*DFSPAR[0];
   double dForce=2.0*ioData.ref.density*ioData.ref.length*ioData.ref.length*velocity*dVelocity;
 
-  dX = 0.0;
-  dU = 0.0;
 
   dRdXoperators<dim> *dRdXop = dRdX->getdRdXop(); 
 
   //TODO: must treat DFSPAR2 better in case that it is not zero.
   double DFSPAR2[3] = {0}; 
 
-  DistSVec<double,dim> dU2(dU);
-  DistSVec<double,3> dGradP2(dGradP), dX2(dX), dLoad2(dLoad);
+  DistSVec<double,3> dGradP2(dGradP);
   DistVec<double> dAdS2(dAdS);
 
-  dddx = 0.0; dddy = 0.0;  dddz = 0.0;  dR = 0.0;   dGradP = 0.0;    dAdS2 = 0.0; 
+  dddx = 0.0; dddy = 0.0;  dddz = 0.0;  dR = 0.0;   dGradP2 = 0.0;    dU = 0.0;   dX = 0.0;   dAdS2 = 0.0;
   this->postOp->computeTransposeDerivativeOfNodalForce(dRdXop->dForcedX,
                                                        dRdXop->dForcedGradP,
                                                        dRdXop->dForcedV,
@@ -1123,7 +1155,9 @@
                                                        dLoad, dX, dGradP2, 
                                                        dU, DFSPAR2);
   
-  this->spaceOp->computeTransposeDerivativeOfGradP(dRdXop, dGradP2, dddx, dddy, dddz, dR, dAdS2, dX, dU); 
+  this->spaceOp->computeTransposeDerivativeOfGradP(dRdXop, dGradP2, dddx, dddy, dddz, dR, dAdS2, dX, dU, false);
+  dEdgeNorm = 0;  dFaceNorm = 0;  dFaceNormVel = 0;
+  this->geoState->computeTransposeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dAdS2, dEdgeNorm, dFaceNorm, dFaceNormVel, dX);
 
   if (this->refVal->mode == RefVal::NON_DIMENSIONAL) {
     dX *= 2.0 * this->refVal->length*this->refVal->length / surface;
@@ -1292,14 +1326,13 @@
 
 template<int dim>
 void FluidShapeOptimizationHandler<dim>::fsoAnalytical
-(bool isSparse, IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U, DistSVec<double,dim> &dFdS)
+(bool isSparse, IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dXdS, DistVec<double> &A, DistSVec<double,dim> &U, DistSVec<double,dim> &dFdS)
 {
  
   //
   // Computing the normal, derivative of the normal and of the control volume
   //
 
-
   DistSVec<double,dim> dddx2(dddx), dddy2(dddy), dddz2(dddz);
   DistSVec<double,6> dR2(dR);
   DistVec<double> dFaceNormVel(domain->getFaceNormDistInfo());
@@ -1307,128 +1340,27 @@
 
 
   dRdXoperators<dim> *dRdXop = dRdX->getdRdXop();
-  if(isSparse)
-    this->geoState->computeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dXdS, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel); 
-  else
+  if(isSparse) {
+    this->geoState->computeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, X, dXdS, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel);
+  } else
     this->geoState->computeDerivatives(X, dXdS, this->bcData->getVelocityVector(), this->bcData->getDerivativeOfVelocityVector(), dAdS); 
- 
 
   //
   // Computing the derivatives of the boundary fluxes
   //
-// TODO:: uncomment this!
   this->bcData->initializeSA(ioData, X, dXdS, DFSPAR[0], DFSPAR[1], DFSPAR[2]);
 
   //
   // Computing the partial derivative of the flux with respect to the variables
   //
-
-  if(isSparse) this->spaceOp->computeDerivativeOfResidual(dRdXop, dXdS, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel, dFdS, dR, dddx, dddy, dddz);
-  else this->spaceOp->computeDerivativeOfResidual(X, dXdS, A, dAdS, U, DFSPAR[0], Flux, dFdS, this->timeState);
-
-
-/*  checking   BOTH   geoState->computeDerivatives   &&   spaceOp->computeDerivativeOfResidual
-//
-    DistSVec<double,3> dXdS2(dXdS);  
-    DistSVec<double,dim> dFdS2(dFdS);
-    DistVec<double> dFaceNormVel2(dFaceNormVel), dAdS2(dAdS);
-    DistVec<Vec3D> dEdgeNorm2(dEdgeNorm), dFaceNorm2(dFaceNorm);
-
-    dFdS2 = 0.0;   dR2 = 0.0;   dddx2 = 0.0;  dddy2 = 0.0;   dddz2 = 0.0;  dAdS2 = 0.0;    dEdgeNorm2 = 0.0;   dFaceNorm2 = 0.0;   dFaceNormVel2 = 0.0;
-    this->geoState->computeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dXdS, dAdS2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2); 
-    this->spaceOp->computeDerivativeOfResidual(dRdXop, dXdS, dAdS2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2, dFdS2, dR2, dddx2, dddy2, dddz2);
-    double aa = dFdS2*dFdS; 
-
-    dXdS2 = 0.0;   dR2 = 0.0;   dddx2 = 0.0;  dddy2 = 0.0;   dddz2 = 0.0;  dAdS2 = 0.0;    dEdgeNorm2 = 0.0;   dFaceNorm2 = 0.0;   dFaceNormVel2 = 0.0;
-    this->spaceOp->computeTransposeDerivativeOfResidual(dRdXop, dFdS, dAdS2, dXdS2, dddx2, dddy2, dddz2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2, dR2);
-    this->geoState->computeTransposeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dAdS2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2, dXdS2); 
-
-    double bb = dXdS2*dXdS; 
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) this->com->fprintf(stderr, " ... dFlux/dX relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else this->com->fprintf(stderr, " ... dFlux/dX absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-
-/*  checking   spaceOp->computeDerivativeOfResidual
-    DistSVec<double,3> dXdS2(dXdS);  
-    DistSVec<double,dim> dFdS2(dFdS);
-    DistVec<double> dFaceNormVel2(dFaceNormVel), dAdS2(dAdS);
-    DistVec<Vec3D> dEdgeNorm2(dEdgeNorm), dFaceNorm2(dFaceNorm);
-
-    dFdS2 = 0.0;   dR2 = 0.0;   dddx2 = 0.0;  dddy2 = 0.0;   dddz2 = 0.0;  
-    this->spaceOp->computeDerivativeOfResidual(dRdXop, dXdS, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel, dFdS2, dR2, dddx2, dddy2, dddz2);
-    double aa = dFdS2*dFdS; 
-
-    dXdS2 = 0.0;   dR2 = 0.0;   dddx2 = 0.0;  dddy2 = 0.0;   dddz2 = 0.0;  dAdS2 = 0.0;    dEdgeNorm2 = 0.0;   dFaceNorm2 = 0.0;   dFaceNormVel2 = 0.0;
-    this->spaceOp->computeTransposeDerivativeOfResidual(dRdXop, dFdS, dAdS2, dXdS2, dddx2, dddy2, dddz2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2, dR2);
-
-
-    DistSVec<double,3> dEdgeNormSVec(dEdgeNorm.info()), dEdgeNorm2SVec(dEdgeNorm2.info());
-    DistSVec<double,3> dFaceNormSVec(dFaceNorm.info()), dFaceNorm2SVec(dFaceNorm2.info());
-    for(int iSub=0; iSub< dEdgeNorm.info().numLocThreads; iSub++)
-      for(int i=0; i<dEdgeNorm[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dEdgeNormSVec(iSub)[i][j] = dEdgeNorm(iSub)[i][j];
-          dEdgeNorm2SVec(iSub)[i][j] = dEdgeNorm2(iSub)[i][j];
-        }
-    for(int iSub=0; iSub< dFaceNorm.info().numLocThreads; iSub++)
-      for(int i=0; i<dFaceNorm[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dFaceNormSVec(iSub)[i][j] = dFaceNorm(iSub)[i][j];
-          dFaceNorm2SVec(iSub)[i][j] = dFaceNorm2(iSub)[i][j];
-        }
-
-    double bb = dXdS2*dXdS + dAdS2*dAdS + dEdgeNormSVec*dEdgeNorm2SVec + dFaceNormSVec*dFaceNorm2SVec + dFaceNormVel2*dFaceNormVel; 
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) this->com->fprintf(stderr, " ... computeTransposeDerivativeOfResidual ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else this->com->fprintf(stderr, " ... computeTransposeDerivativeOfResidual ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-
-/*  checking   geoState->computeDerivatives  
-    DistSVec<double,3> dXdS2(dXdS);  
-    DistSVec<double,dim> dFdS2(dFdS);
-    DistVec<double> dFaceNormVel2(dFaceNormVel), dAdS2(dAdS);
-    DistVec<Vec3D> dEdgeNorm2(dEdgeNorm), dFaceNorm2(dFaceNorm);
-
-    dAdS2 = 0.0;    dEdgeNorm2 = 0.0;   dFaceNorm2 = 0.0;   dFaceNormVel2 = 0.0;
-    this->geoState->computeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dXdS, dAdS2, dEdgeNorm2, dFaceNorm2, dFaceNormVel2); 
-    DistSVec<double,3> dEdgeNormSVec(dEdgeNorm.info()), dEdgeNorm2SVec(dEdgeNorm2.info());
-    DistSVec<double,3> dFaceNormSVec(dFaceNorm.info()), dFaceNorm2SVec(dFaceNorm2.info());
-    for(int iSub=0; iSub< dEdgeNorm.info().numLocThreads; iSub++)
-      for(int i=0; i<dEdgeNorm[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dEdgeNormSVec(iSub)[i][j] = dEdgeNorm(iSub)[i][j];
-          dEdgeNorm2SVec(iSub)[i][j] = dEdgeNorm2(iSub)[i][j];
-        }
-    for(int iSub=0; iSub< dFaceNorm.info().numLocThreads; iSub++)
-      for(int i=0; i<dFaceNorm[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dFaceNormSVec(iSub)[i][j] = dFaceNorm(iSub)[i][j];
-          dFaceNorm2SVec(iSub)[i][j] = dFaceNorm2(iSub)[i][j];
-        }
-    double aa = dAdS2*dAdS + dEdgeNorm2SVec*dEdgeNormSVec + dFaceNorm2SVec*dFaceNormSVec + dFaceNormVel2*dFaceNormVel; 
-
-    dXdS2 = 0.0;
-    this->geoState->computeTransposeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel, dXdS2); 
-    double bb = dXdS2*dXdS; 
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) this->com->fprintf(stderr, " ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else this->com->fprintf(stderr, " ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-
-
-/*
-  DistSVec<double,dim> dFdS2(dFdS), diff(dFdS);
-  this->spaceOp->computeDerivativeOfResidual(X, dXdS, A, dAdS, U, DFSPAR[0], Flux, dFdS2, this->timeState, false, dRdXop);
-
-  diff = dFdS-dFdS2;
-  double dFdSnorm(0), dFdS2norm(0), diffnorm(0);
-  dFdSnorm = dFdS.norm();
-  dFdS2norm = dFdS2.norm();
-  diffnorm = diff.norm();
-  if(dFdSnorm != 0) this->com->fprintf(stderr, "... rel. error = %e\n", diffnorm/dFdSnorm);
-  else this->com->fprintf(stderr, "... abs. error = %e\n", diffnorm);
-*/
+  if(isSparse) {
+  //      DistSVec<double,dim> dFdS2(dFdS), diff(dFdS);
+  //      this->spaceOp->computeDerivativeOfResidual(X, dXdS, A, dAdS, U, DFSPAR[0], Flux, dFdS2, this->timeState);
+        this->spaceOp->computeDerivativeOfResidual(dRdXop, X, dXdS, A, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel, Flux, dFdS, dR, dddx, dddy, dddz, U, DFSPAR[0], this->timeState);
+  //      diff = dFdS2 - dFdS;
+  //      this->com->fprintf(stderr, " diff between sparse_dFdS and sparse_dFdS is %e, dFdS is %e, nonsparse_dFdS2 is %e\n", diff.norm()/dFdS.norm(), dFdS.norm(), dFdS2.norm());
+  } else
+       this->spaceOp->computeDerivativeOfResidual(X, dXdS, A, dAdS, U, DFSPAR[0], Flux, dFdS, this->timeState);
 
   this->spaceOp->applyBCsToDerivativeOfResidual(U, dFdS);
   if(DFSPAR[1] || DFSPAR[2]) dFdS *= 0.0174532925;  // convert radian to degree
@@ -1437,28 +1369,19 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
-void FluidShapeOptimizationHandler<dim>::fsoAnalyticalTranspose
-(DistSVec<double,dim> &dFdS, DistSVec<double,3> &dXdS)
+void FluidShapeOptimizationHandler<dim>::fsoApply_dFdXtranspose
+(DistVec<double> &A, DistSVec<double,dim> &lambdaU, DistSVec<double,3> &rhs)
 {
 
-  dEdgeNorm = 0.0;  dFaceNorm = 0.0;  dddx = 0.0;  dddy = 0.0;  dddz = 0.0;  dFaceNormVel = 0.0;  dR = 0.0;
+  DistVec<double> dAdS2(dAdS);
+  DistSVec<double,dim> lambdaU1(lambdaU);
+
+  dEdgeNorm = 0.0;  dFaceNorm = 0.0;  dddx = 0.0;  dddy = 0.0;  dddz = 0.0;  dFaceNormVel = 0.0;  dR = 0.0;   rhs = 0.0;  dAdS2 = 0.0;  dFaceNormVel = 0.0;
   dRdXoperators<dim> *dRdXop = dRdX->getdRdXop();
-  this->spaceOp->computeTransposeDerivativeOfResidual(dRdXop, dFdS, dAdS, dXdS, dddx, dddy, dddz, dEdgeNorm, dFaceNorm, dFaceNormVel, dR);
-
-  //
-  // Computing the derivatives of the boundary fluxes
-  //
-// TODO:: uncomment this!
-//  this->bcData->initializeSA(ioData, X, dXdS, DFSPAR[0], DFSPAR[1], DFSPAR[2]);
-
-  //
-  // Computing the partial derivative of the flux with respect to the variables
-  //
-
-  this->geoState->computeTransposeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dAdS, dEdgeNorm, dFaceNorm, dFaceNormVel, dXdS); 
-
-//  this->spaceOp->applyBCsToDerivativeOfResidual(U, dFdS);
-//  if(DFSPAR[1] || DFSPAR[2]) dFdS *= 0.0174532925;  // convert radian to degree
+
+  this->spaceOp->computeTransposeDerivativeOfResidual(dRdXop, Flux, lambdaU1, A, dAdS2, rhs, dddx, dddy, dddz, dEdgeNorm, dFaceNorm, dFaceNormVel, dR);
+  this->geoState->computeTransposeDerivatives(dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX, dAdS2, dEdgeNorm, dFaceNorm, dFaceNormVel, rhs);
+
 }
 
 //------------------------------------------------------------------------------
@@ -1527,6 +1450,56 @@
 
 //------------------------------------------------------------------------------
 
+template<int dim>
+void FluidShapeOptimizationHandler<dim>::fsoSetUpAdjointLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A,
+                                                                     DistSVec<double,dim> &U, DistSVec<double,dim> &dFdS)
+{
+
+// Preparing the linear solver
+
+  fsoRestartBcFluxs(ioData);
+
+  this->geoState->reset(X);
+
+  this->geoState->compute(this->timeState->getData(), this->bcData->getVelocityVector(), X, A);
+
+  this->bcData->update(X);
+
+  this->spaceOp->computeResidual(X, A, U, FluxFD, this->timeState);
+
+  if (ioData.sa.homotopy == SensitivityAnalysis::ON_HOMOTOPY)
+    this->timeState->add_dAW_dt(1, *this->geoState, A, U, FluxFD);
+
+  this->spaceOp->applyBCsToResidual(U, FluxFD);
+
+  mvp->evaluate(0, X, A, U, FluxFD);
+
+  DistMat<PrecScalar,dim> *_pc = dynamic_cast<DistMat<PrecScalar,dim> *>(pc);
+
+  if (_pc) {
+
+    MatVecProdFD<dim,dim> *mvpfd = dynamic_cast<MatVecProdFD<dim,dim> *>(mvp);
+    MatVecProdH2<dim,MatScalar,dim> *mvph2 = dynamic_cast<MatVecProdH2<dim,MatScalar,dim> *>(mvp);
+
+    if (mvpfd || mvph2)
+    {
+      this->spaceOp->computeJacobian(X, A, U, *_pc, this->timeState);
+      if (ioData.sa.homotopy == SensitivityAnalysis::ON_HOMOTOPY)
+        this->timeState->addToJacobian(A, *_pc, U);
+      this->spaceOp->applyBCsToJacobian(U, *_pc);
+    }
+
+  } // END if (_pc)
+
+  pc->setup();
+  pc->setupTR();
+
+  // Computing flux for compatibility correction of the derivative of the flux
+  this->spaceOp->computeResidual(X, A, U, Flux, this->timeState, false);
+
+}
+
+//------------------------------------------------------------------------------
 
 template<int dim>
 void FluidShapeOptimizationHandler<dim>::fsoLinearSolver
@@ -1562,6 +1535,41 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
+void FluidShapeOptimizationHandler<dim>::fsoAdjointLinearSolver
+(
+  IoData &ioData,
+  DistSVec<double,dim> &dQdU, DistSVec<double,dim> &lambdaU,
+  bool isFSI
+)
+{
+
+  DistSVec<double,dim> rhs(dQdU);
+  if(isFSI) {
+    dfaX = 0;  dfaU = 0;
+    fsoGetTransposeDerivativeOfLoadAnalytical(ioData, lambdaSDisp, dfaX, dfaU);
+    rhs += dfaU;
+  }
+
+  if(!isFSI) ksp->setup(0, 1, rhs);
+
+  int numberIteration;
+  bool istop = false;
+  int iter = 0;
+
+  while ((istop == false) && (iter < 100))
+  {
+    numberIteration = ksp->solveT(rhs, lambdaU);
+    if ((!ioData.sa.excsol) || (numberIteration < ioData.sa.ksp.maxIts))
+      istop = true;
+    iter += 1;
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+template<int dim>
 void FluidShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)
 {
    this->com->fprintf(stderr, Text);
@@ -1580,7 +1588,6 @@
   for (int iSub = 0; iSub < numLocSub; ++iSub)
     for (int j=0; j<V(iSub).size(); ++j)
         fprintf(outFile," %20.17e \n",V(iSub)[j]);
-//        fprintf(outFile," %9.6e \n",V(iSub)[j]);
 
 
 fclose(outFile);
@@ -1600,7 +1607,6 @@
     for (int j=0; j<V(iSub).size(); ++j) {
       for (int k=0; k<3; ++k)
         fprintf(outFile," %20.17e ",V(iSub)[j][k]);
-//        fprintf(outFile," %9.6e ",V(iSub)[j][k]);
       fprintf(outFile,"\n");
 
     }
@@ -1625,7 +1631,6 @@
     for (int j=0; j<V(iSub).size(); ++j) {
       for (int k=0; k<dim; ++k)
         fprintf(outFile," %20.17e ",V(iSub)[j][k]);
-//        fprintf(outFile," %9.6e ",V(iSub)[j][k]);
       fprintf(outFile,"\n");
     }
 
@@ -1685,23 +1690,39 @@
   this->computeTimeStep(1, &dtLeft, U);
   this->computeMeshMetrics();
   this->updateStateVectors(U);
-  bool isSparse = false;
-
-  fsoSetUpLinearSolver(ioData, *this->X, *this->A, U, dFdS);
-
-  if (ioData.sa.sensMesh == SensitivityAnalysis::ON_SENSITIVITYMESH) fso_on_sensitivityMesh(isSparse, ioData, U);
-  if (ioData.sa.sensMach == SensitivityAnalysis::ON_SENSITIVITYMACH) fso_on_sensitivityMach(isSparse, ioData, U);
-  if (ioData.sa.sensAlpha == SensitivityAnalysis::ON_SENSITIVITYALPHA) fso_on_sensitivityAlpha(isSparse, ioData, U); 
-  if (ioData.sa.sensBeta == SensitivityAnalysis::ON_SENSITIVITYBETA) fso_on_sensitivityBeta(isSparse, ioData, U); 
+
+
+  bool isSparse = bool(ioData.sa.sparseFlag);
+  if(ioData.sa.method == SensitivityAnalysis::ADJOINT) isSparse = true;
+
+  if(isSparse) {
+
+    Vec3D x0;
+    x0[0] = ioData.output.transient.x0;
+    x0[1] = ioData.output.transient.y0;
+    x0[2] = ioData.output.transient.z0;
+
+    dRdX->constructOperators(x0, *this->X, *this->A, U, DFSPAR[0], Flux, Pin, this->timeState, this->postOp);
+  }
+
+  if (ioData.sa.method == SensitivityAnalysis::DIRECT) {
+    fsoSetUpLinearSolver(ioData, *this->X, *this->A, U, dFdS);
+    if (ioData.sa.sensMesh == SensitivityAnalysis::ON_SENSITIVITYMESH) fso_on_sensitivityMesh(isSparse, ioData, U);
+    if (ioData.sa.sensMach == SensitivityAnalysis::ON_SENSITIVITYMACH) fso_on_sensitivityMach(isSparse, ioData, U);
+    if (ioData.sa.sensAlpha == SensitivityAnalysis::ON_SENSITIVITYALPHA) fso_on_sensitivityAlpha(isSparse, ioData, U);
+    if (ioData.sa.sensBeta == SensitivityAnalysis::ON_SENSITIVITYBETA) fso_on_sensitivityBeta(isSparse, ioData, U);
+  } else if(ioData.sa.method == SensitivityAnalysis::ADJOINT) {
+    fsoSetUpAdjointLinearSolver(ioData, *this->X, *this->A, U, dFdS);
+    if (ioData.sa.sensMesh == SensitivityAnalysis::ON_SENSITIVITYMESH) fso_on_AdjointSensitivityMesh(ioData, U);
+  }
+
+
 
   bool lastIt = true;
-//  this->outputToDisk(ioData, &lastIt, 0, 0, 0, 0, dtLeft, U); 
-//  this->outputPositionVectorToDisk(U);
 
   this->output->closeAsciiFiles();
   
 
-//  this->com->barrier();
   MyLocalTimer += this->timer->getTime();
   if (this->com->cpuNum() == 0)
   {
@@ -1761,36 +1782,121 @@
 
   // Start basic timer
   double MyLocalTimer = -this->timer->getTime();
- 
-  bool isSparse = false;
+
+  bool isSparse = bool(ioData.sa.sparseFlag);
+  if(ioData.sa.method == SensitivityAnalysis::ADJOINT) isSparse = true;
   double dtLeft = 0.0;
   this->computeTimeStep(1, &dtLeft, U);
   this->computeMeshMetrics();
   this->updateStateVectors(U);
 
-  fsoSetUpLinearSolver(ioData, *this->X, *this->A, U, dFdS);
-  int totalNumParamTypes; 
-  this->getNumParam(totalNumParamTypes,actvar,steadyTol);
-  if(ioData.sa.sensMach == SensitivityAnalysis::ON_SENSITIVITYMACH) {  totalNumParamTypes++; }
-  if(ioData.sa.sensAlpha == SensitivityAnalysis::ON_SENSITIVITYALPHA) { totalNumParamTypes++; }
-  if(ioData.sa.sensBeta == SensitivityAnalysis::ON_SENSITIVITYBETA) { totalNumParamTypes++; }
-
-  if(isSparse)  dRdX->constructOperators(*this->X, *this->A, U, DFSPAR[0], Flux, Pin, this->timeState, this->postOp);
-
-  for(int iparam=0; iparam<totalNumParamTypes; ++iparam) {
-    int numParam;
-    this->getNumParam(numParam,actvar,steadyTol);
-    setDFSPAR(ioData);
-    for(int i=0; i<numParam; ++i) fso_on_aeroelasticSensitivityFSI(isSparse, ioData, U);
+
+  if(ioData.sa.method == SensitivityAnalysis::DIRECT) {
+    fsoSetUpLinearSolver(ioData, *this->X, *this->A, U, dFdS);
+    int totalNumParamTypes;
+    this->getNumParam(totalNumParamTypes,actvar,steadyTol);
+    if(ioData.sa.sensMach == SensitivityAnalysis::ON_SENSITIVITYMACH) {  totalNumParamTypes++; }
+    if(ioData.sa.sensAlpha == SensitivityAnalysis::ON_SENSITIVITYALPHA) { totalNumParamTypes++; }
+    if(ioData.sa.sensBeta == SensitivityAnalysis::ON_SENSITIVITYBETA) { totalNumParamTypes++; }
+
+    if(isSparse) {
+
+      Vec3D x0;
+      x0[0] = ioData.output.transient.x0;
+      x0[1] = ioData.output.transient.y0;
+      x0[2] = ioData.output.transient.z0;
+
+      dRdX->constructOperators(x0, *this->X, *this->A, U, DFSPAR[0], Flux, Pin, this->timeState, this->postOp);
+    }
+
+    for(int iparam=0; iparam<totalNumParamTypes; ++iparam) {
+      int numParam;
+      this->getNumParam(numParam,actvar,steadyTol);
+      setDFSPAR(ioData);
+      for(int i=0; i<numParam; ++i) fso_on_aeroelasticSensitivityFSI(isSparse, ioData, U);
+    }
+    bool lastIt = true;
+
+    this->output->closeAsciiFiles();
+
+  } else if(ioData.sa.method == SensitivityAnalysis::ADJOINT) {
+    fsoSetUpAdjointLinearSolver(ioData, *this->X, *this->A, U, dFdS);
+    int totalNumStructureQuantities(0), totalNumFluidQuantities(0);
+    this->getNumParam(totalNumStructureQuantities,actvar,steadyTol);
+    if(ioData.output.transient.dLiftx[0] != 0) { totalNumFluidQuantities++; }
+    if(ioData.output.transient.dLifty[0] != 0) { totalNumFluidQuantities++; }
+    if(ioData.output.transient.dLiftz[0] != 0) { totalNumFluidQuantities++; }
+    this->sendNumParam(totalNumFluidQuantities);
+    this->com->fprintf(stderr, " ... In fluid, totalNumStructureQuantities = %d, totalNumFluidQuantities = %d\n",
+                                totalNumStructureQuantities, totalNumFluidQuantities);
+    if(isSparse) {
+
+      Vec3D x0;
+      x0[0] = ioData.output.transient.x0;
+      x0[1] = ioData.output.transient.y0;
+      x0[2] = ioData.output.transient.z0;
+
+      dRdX->constructOperators(x0, *this->X, *this->A, U, DFSPAR[0], Flux, Pin, this->timeState, this->postOp);
+    }
+
+    // structure sensitivity quantities (e.g., aggregated von Mises stress, tip displacement of structure, etc) are computed first
+    for(int iquan=0; iquan<totalNumStructureQuantities; ++iquan) {
+      int numQuans;
+      this->getNumParam(numQuans,actvar,steadyTol);  // numQuans is number of quantities related to a sensitivity quantity type
+                                                     // actvar = 1: shape variable
+                                                     // actvar = 2: Mach number variable
+                                                     // actvar = 3: angle of attack variable
+                                                     // actvar = 4: yaw angle variable
+                                                     // actvar = 5: FSI variable such as structure thickness
+                                                     // actvar = 6: aggregated von Mises stress quantity
+                                                     // actvar = 7: von Mises stress quantity
+                                                     // actvar = 8: structure displacement quantity
+                                                     // actvar = 9: liftx quantity
+                                                     // actvar = 10: lifty quantity
+                                                     // actvar = 11: liftz quantity
+      this->com->fprintf(stderr, " ... In fluid, numQuans = %d, actvar = %d, steadyTol = %e\n", numQuans, actvar, steadyTol);
+      for(int i=0; i<numQuans; ++i) fso_on_aeroelasticAdjointSensitivityFSI(ioData, U);
+    }
+    int numStructParamTypes(0);
+    this->getNumParam(numStructParamTypes, actvar, steadyTol);
+    this->com->fprintf(stderr, " ... numStructParamTypes = %d\n", numStructParamTypes);
+    if(ioData.output.transient.dLiftx[0] != 0) {
+      this->com->fprintf(stderr, "x-direction lift sensitivity will be computed\n"); actvar = 9;
+      fso_on_aeroelasticAdjointSensitivityFSI(ioData, U);
+      for(int iStParam=0; iStParam<numStructParamTypes; ++iStParam) {
+        double dlift(0);
+        this->getRelResidual(dlift);
+        this->output->writeDerivativeOfLiftxToDisk(dlift);
+      }
+    }
+    if(ioData.output.transient.dLifty[0] != 0) {
+      this->com->fprintf(stderr, "y-direction lift sensitivity will be computed\n"); actvar = 10;
+      fso_on_aeroelasticAdjointSensitivityFSI(ioData, U);
+      for(int iStParam=0; iStParam<numStructParamTypes; ++iStParam) {
+        double dlift(0);
+        this->getRelResidual(dlift);
+        this->output->writeDerivativeOfLiftyToDisk(dlift);
+      }
+    }
+    if(ioData.output.transient.dLiftz[0] != 0) {
+      this->com->fprintf(stderr, "z-direction lift sensitivity will be computed\n"); actvar = 11;
+      fso_on_aeroelasticAdjointSensitivityFSI(ioData, U);
+      for(int iStParam=0; iStParam<numStructParamTypes; ++iStParam) {
+        double dlift(0);
+        this->getRelResidual(dlift);
+        this->output->writeDerivativeOfLiftzToDisk(dlift);
+      }
+    }
+
+
+
+    bool lastIt = true;
+
+    this->output->closeAsciiFiles();
+
   }
-  bool lastIt = true;
-//  this->outputToDisk(ioData, &lastIt, 0, 0, 0, 0, dtLeft, U); 
-//  this->outputPositionVectorToDisk(U);
-
-  this->output->closeAsciiFiles();
   
 
-//  this->com->barrier();
   MyLocalTimer += this->timer->getTime();
   if (this->com->cpuNum() == 0)
   {
@@ -1903,7 +2009,6 @@
       } else ksp->setEps(steadyTol);
       // Reading derivative of the overall deformation
       this->receiveBoundaryPositionSensitivityVector(dXdSb); // [F] receive boundary displacement sensitivity from structure ...
-//      this->com->fprintf(stderr, "norm of dXdSb is %e\n",dXdSb.norm());
 
       // Checking if dXdSb has entries different from zero at the interior of the mesh
       this->postOp->checkVec(dXdSb);
@@ -1921,7 +2026,6 @@
 
       // Check that the mesh perturbation is propagated
       if (dXdS.norm() == 0.0) this->com->fprintf(stderr, "\n !!! WARNING !!! No Mesh Sensitivity Perturbation !!!\n\n");
-//      else this->com->fprintf(stderr, "\n norm of dXdS is %e\n", dXdS.norm());
 
       fsoComputeDerivativesOfFluxAndSolution(ioData, *this->X, *this->A, U, true, isSparse);
   
@@ -1940,7 +2044,67 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
-void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityMesh(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)
+void FluidShapeOptimizationHandler<dim>::fso_on_aeroelasticAdjointSensitivityFSI(IoData &ioData, DistSVec<double,dim> &U)
+{
+
+  double tag = 0.0;
+  bool lastIt = false;
+  int iter = 0;
+  dXdS = 0.0;
+  dAdS = 0.0;
+  lambdaSDisp = 0.0;
+  DistSVec<double,3> dQdX(*this->X);
+  DistSVec<double,dim> dQdU(U);
+  Vec3D dForces(0.0), dMoments(0.0), dL(0.0);
+  double relres, relres_p(1.0), relres_pp(1.0);
+
+  while (!lastIt) {
+
+    this->cmdCom(&lastIt);
+    if(lastIt) { dXdSb = 0.0; break; }
+    this->com->fprintf(stderr, "fso_aeroelatic_adjoint_sensitivity Iteration\t");
+    this->getRelResidual(relres);
+    if(ioData.sa.adaptiveEpsFSI && relres < relres_p && relres < relres_pp && relres < 1.0) {
+      ksp->setEps(relres);
+      relres_pp = relres_p;
+      relres_p = relres;
+    } else ksp->setEps(steadyTol);
+    // Reading derivative of the overall deformation
+    this->receiveBoundaryPositionSensitivityVector(lambdaSDisp, true); // [F] receive dual variable for structure displacement TODO: need to specify second argument (true)
+
+    // Checking if dXdSb has entries different from zero at the interior of the mesh
+    this->postOp->checkVec(lambdaSDisp);
+
+    if (lambdaSDisp.norm() == 0.0)
+    {
+      this->com->fprintf(stderr, "\n *** WARNING *** zero structure displacement dual variable \n\n");
+      if(!ioData.sa.fsiFlag) exit(1);
+    }
+    if(actvar < 9) { dQdX = 0; dQdU =0; }
+    else if(actvar == 9) { // Liftx
+      dL = 0;  dForces = 0;  dMoments = 0;  dL[0] = 1;  dQdX = 0;  dQdU = 0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+    } else if(actvar == 10) { // Lifty
+      dL = 0;  dForces = 0;  dMoments = 0;  dL[1] = 1;  dQdX = 0;  dQdU = 0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+    } else if(actvar == 11) { // Liftz
+      dL = 0;  dForces = 0;  dMoments = 0;  dL[2] = 1;  dQdX = 0;  dQdU = 0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+    }
+    fsoComputeAdjoint(ioData, *this->A, dQdX, dQdU, true);
+    this->sendForceSensitivity(&lambdaX, false);
+
+    lambdaSDisp = 0;
+
+    iter++;
+  }
+  step++;
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void FluidShapeOptimizationHandler<dim>::fso_on_AdjointSensitivityMesh(IoData &ioData, DistSVec<double,dim> &U)
 {
 
     double tag = 0.0;
@@ -1954,37 +2118,105 @@
     DFSPAR[2] = 0.0;
     actvar = 1;
 
+    int numShapeVars = 100; // maximum shape vairbales is set 100.
+    DistSVec<double,3> **dDdS = new DistSVec<double,3>*[numShapeVars];
+    while(true) {
+      this->com->fprintf(stderr, "\n ***** Surface derivatives of shape variable %d are read\n", step);
+      // Reading derivative of the overall deformation
+      bool readOK = domain->readVectorFromFile(this->input->shapederivatives, step, &tag, dXdSb);
+      if(!readOK) break;
+
+      // Checking if dXdSb has entries different from zero at the interior of the mesh
+      this->postOp->checkVec(dXdSb);
+
+      if (dXdSb.norm() == 0.0) {
+        this->com->fprintf(stderr, "\n *** WARNING *** No Mesh Perturbation \n\n");
+        if(!ioData.sa.fsiFlag) exit(1);
+      }
+      dDdS[step] = new DistSVec<double,3>(dXdSb);
+      dXdSb = 0.0;
+
+      step = step + 1;
+    }
+    if(step < numShapeVars) numShapeVars = step;
+
+    Vec3D dForces(0.0), dMoments(0.0), dL(0.0);
+    DistSVec<double,3> dQdX(*this->X);
+    DistSVec<double,dim> dQdU(U);
+    if(ioData.output.transient.dLiftx[0] != 0) {
+      dQdX = 0;  dQdU = 0;  dL = 0;  dMoments = 0;  dForces = 0;  dL[0] = 1.0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+      fsoComputeAdjoint(ioData, *this->A, dQdX, dQdU, false);
+      for(step = 0; step<numShapeVars; ++step) {
+        double dlift = -1.0*(*dDdS[step]*lambdaX);
+        this->output->writeDerivativeOfLiftxToDisk(dlift);
+      }
+    }
+    if(ioData.output.transient.dLifty[0] != 0) {
+      dQdX = 0;  dQdU = 0;  dL = 0;  dMoments = 0;  dForces = 0;  dL[1] = 1.0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+      fsoComputeAdjoint(ioData, *this->A, dQdX, dQdU, false);
+      for(step = 0; step<numShapeVars; ++step) {
+        double dlift = -1.0*(*dDdS[step]*lambdaX);
+        this->output->writeDerivativeOfLiftyToDisk(dlift);
+      }
+    }
+    if(ioData.output.transient.dLiftz[0] != 0) {
+      dQdX = 0;  dQdU = 0;  dL = 0;  dMoments = 0;  dForces = 0;  dL[2] = 1.0;
+      fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(ioData, dForces, dMoments, dL, *this->X, U, dQdX, dQdU);
+      fsoComputeAdjoint(ioData, *this->A, dQdX, dQdU, false);
+      for(step = 0; step<numShapeVars; ++step) {
+        double dlift = -1.0*(*dDdS[step]*lambdaX);
+        this->output->writeDerivativeOfLiftzToDisk(dlift);
+      }
+    }
+
+    fsoPrintTextOnScreen("\n ***** Derivatives of mesh position were computed! \n");
+
+}
+
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityMesh(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)
+{
+
+    double tag = 0.0;
+
+    step = 0;
+    dXdS = 0.0;
+    dXdSb = 0.0;
+    dAdS = 0.0;
+    DFSPAR[0] = 0.0;
+    DFSPAR[1] = 0.0;
+    DFSPAR[2] = 0.0;
+    actvar = 1;
+
     while (true) {
 
-      if ( ioData.input.shapederivativesType == InputData::WALL) {
-        // Reading derivative of the overall deformation
-        bool readOK = domain->readVectorFromFile(this->input->shapederivatives, step, &tag, dXdSb); 
-        if(!readOK) break;
-
-        // Checking if dXdSb has entries different from zero at the interior of the mesh
-        this->postOp->checkVec(dXdSb);
+      // Reading derivative of the overall deformation
+      bool readOK = domain->readVectorFromFile(this->input->shapederivatives, step, &tag, dXdSb);
+      if(!readOK) break;
+
+      // Checking if dXdSb has entries different from zero at the interior of the mesh
+      this->postOp->checkVec(dXdSb);
 
       if (dXdSb.norm() == 0.0) {
-          this->com->fprintf(stderr, "\n *** WARNING *** No Mesh Perturbation \n\n");
-          if(!ioData.sa.fsiFlag) exit(1);
-        }
-
-
-        // Updating the mesh
-        dXdS = *this->X;
-        mms->solve(dXdSb, dXdS);
-        dXdS -= *this->X;
-      } else if ( ioData.input.shapederivativesType == InputData::VOLUME) {
-        // Reading derivative of the overall deformation
-        bool readOK = domain->readVectorFromFile(this->input->shapederivatives, step, &tag, dXdS); 
-        if(!readOK) break;
+        this->com->fprintf(stderr, "\n *** WARNING *** No Mesh Perturbation \n\n");
+        if(!ioData.sa.fsiFlag) exit(1);
       }
 
+      this->com->fprintf(stderr, "\n ***** Shape variable %d\n", step);
+
+      // Updating the mesh
+      dXdS = *this->X;
+      mms->solve(dXdSb, dXdS);
+      dXdS -= *this->X;
+
       // Check that the mesh perturbation is propagated
       if (dXdS.norm() == 0.0) this->com->fprintf(stderr, "\n !!! WARNING !!! No Mesh Sensitivity Perturbation !!!\n\n");
 
-      this->com->fprintf(stderr, "\n ***** Shape variable %d\n", step);
-
       fsoComputeDerivativesOfFluxAndSolution(ioData, *this->X, *this->A, U, false, isSparse);
       fsoComputeSensitivities(isSparse, ioData, "Derivatives with respect to the mesh position:", ioData.sa.sensoutput, *this->X, U);
 
@@ -1996,6 +2228,7 @@
 
 }
 
+
 //------------------------------------------------------------------------------
 
 template<int dim>
@@ -2006,19 +2239,17 @@
 
   // Derivative of the Flux, either analytical or semi-analytical
   if ( ioData.sa.scFlag == SensitivityAnalysis::ANALYTICAL ) {
-    fsoAnalytical(isSparse, ioData, X, A, U, dFdS);
-/*    dFdSref = 0.0;
-    fsoSemiAnalytical(ioData, X, A, U, dFdSref);
-    DistSVec<double,dim> difference(domain->getNodeDistInfo()); 
-    difference = dFdS - dFdSref;
-    this->com->fprintf(stderr, "!!! dFdS and dFdSref do not match. The relative difference norm is %e\n", difference.norm()/dFdS.norm());
-    this->com->fprintf(stderr, "!!! dFdSref norm is %e\n", dFdSref.norm());  */
+	DistSVec<double,dim> dFdS2(dFdS), diff(dFdS);
+	fsoAnalytical(isSparse, ioData, X, dXdS, A, U, dFdS);
+	fsoSemiAnalytical(ioData, X, A, U, dFdS2);
+	diff = dFdS2 - dFdS;
+	this->com->fprintf(stderr, "diff bw/ dFdS and dFdS2 is %e, dFdS = %e, dFdS2 = %e\n", diff.norm()/dFdS.norm(), dFdS.norm(), dFdS2.norm());
   } else {
     fsoSemiAnalytical(ioData, X, A, U, dFdS);
   }
 
   // Computing the derivative of the fluid variables 
-  // with respect to the fsoimization variables
+  // with respect to the optimization variables
   fsoLinearSolver(ioData, dFdS, dUdS,isFSI);
 
 }
@@ -2026,23 +2257,51 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
+void FluidShapeOptimizationHandler<dim>::fsoComputeAdjoint(IoData &ioData, DistVec<double> &A, DistSVec<double,3> &dQdX, DistSVec<double,dim> &dQdU, bool isFSI)
+{
+
+//  lambdaU = 0.0;
+  lambdaX = 0.0;
+  DistSVec<double,3> rhs(dXdS);
+  rhs = 0.0;
+
+  // Derivative of the Flux, either analytical or semi-analytical
+  if ( ioData.sa.scFlag != SensitivityAnalysis::ANALYTICAL ) {
+    this->com->fprintf(stderr, " --- WARNING : only analytical adjoint sensitivities are available\n");
+  }
+
+  fsoAdjointLinearSolver(ioData, dQdU, lambdaU, isFSI);
+  fsoApply_dFdXtranspose(A, lambdaU, rhs);
+  rhs -= dQdX;
+  if(isFSI) rhs -= dfaX;
+
+  mms->setAdjointFlagOn();
+  // solve for lambdaX
+  lambdaX = *this->X;
+  mms->solveAdjoint(rhs, lambdaX);
+  lambdaX -= *this->X;
+
+  mms->applyProjectorTranspose(lambdaX);
+
+}
+
+//------------------------------------------------------------------------------
+
+
+template<int dim>
 void FluidShapeOptimizationHandler<dim>::fsoComputeAndSendForceSensitivities(bool isSparse, IoData &ioData, const char *fileName, 
                                                                              DistSVec<double,3> &X, DistSVec<double,dim> &U)
 {
 
-//  if ( ioData.sa.sensFSI == SensitivityAnalysis::ON_SENSITIVITYFSI ) {
     if (ioData.sa.scFlag == SensitivityAnalysis::FINITEDIFFERENCE ) { 
       fsoGetDerivativeOfLoadFiniteDifference(ioData, X, dXdS, *this->A, U, dUdS, *load, *dLoad);
     } else {
+//      DistSVec<double,3> dLoad2(*dLoad), diff(*dLoad);
       fsoGetDerivativeOfLoadAnalytical(isSparse, ioData, X, dXdS, U, dUdS, *load, *dLoad);
-/*      *dLoadref = 0.0;
-      fsoGetDerivativeOfLoadFiniteDifference(ioData, X, dXdS, *this->A, U, dUdS, *load, *dLoadref);
-      DistSVec<double,3> difference(domain->getNodeDistInfo());
-      difference = *dLoad - *dLoadref;
-      this->com->fprintf(stderr, "!!! dLoad and dLoadref do not match. The relative difference norm is %e\n", difference.norm()/dLoad->norm());
-      this->com->fprintf(stderr, "!!! dLoadref norm is %e\n", dLoadref->norm()); */
+//      fsoGetDerivativeOfLoadFiniteDifference(ioData, X, dXdS, *this->A, U, dUdS, *load, dLoad2);
+//      diff = *dLoad - dLoad2;
+//      this->com->fprintf(stderr, "diff is %e, andLoad = %e, fdLoad = %e\n", diff.norm()/dLoad->norm(), dLoad->norm(), dLoad2.norm());
     }
-//  }
 
   this->sendForceSensitivity(dLoad); 
 
@@ -2061,12 +2320,29 @@
   fsoGetEfforts(ioData, X, U, F, M, L);
 
 // Computing derivative of the efforts
-  Vec3D dFds, dMds, dLds;
+  Vec3D dFds, dMds, dLdS;
 
   if ( ioData.sa.scFlag == SensitivityAnalysis::FINITEDIFFERENCE )
     fsoGetDerivativeOfEffortsFiniteDifference(ioData, X, dXdS, *this->A, U, dUdS, dFds, dMds);
-  else
-    fsoGetDerivativeOfEffortsAnalytical(isSparse, ioData, X, dXdS, U, dUdS, dFds, dMds, dLds);
+  else {
+    fsoGetDerivativeOfEffortsAnalytical(isSparse, ioData, X, dXdS, U, dUdS, dFds, dMds, dLdS);
+    /*
+    // Verification
+    Vec3D dFds2, dMds2;
+    fsoGetDerivativeOfEffortsFiniteDifference(ioData, X, dXdS, *this->A, U, dUdS, dFds2, dMds2);
+    Vec3D diffF = dFds2 - dFds;
+    Vec3D diffM = dMds2 - dMds;
+    double diffFnorm = diffF.norm();
+    double diffMnorm = diffM.norm();
+    double dFdSnorm = dFds.norm();
+    double dMdSnorm = dMds.norm();
+    if(dFdSnorm != 0) this->com->fprintf(stderr, "diff for dForcedS is %e\n", diffFnorm/dFdSnorm);
+    else this->com->fprintf(stderr, "diff for dForcedS is %e\n", diffFnorm);
+    if(dMdSnorm != 0) this->com->fprintf(stderr, "diff for dMomentdS is %e\n", diffMnorm/dMdSnorm);
+    else this->com->fprintf(stderr, "diff for dMomentdS is %e\n", diffMnorm);
+    // Verification ends
+    */
+  }
 
   if ((!ioData.sa.angleRad) && (DFSPAR[1] || DFSPAR[2])) {
     dFds *= acos(-1.0) / 180.0;
@@ -2120,7 +2396,7 @@
   //
   //this->output->writeDerivativeOfFluxNormToDisk(step, actvar, normF2, dnormF2);
   this->output->writeDerivativeOfForcesToDisk(step, actvar, F, dFds, M, dMds, sboom, dSboom);
-  this->output->writeDerivativeOfLiftDragToDisk(step, actvar, L, dLds); 
+  this->output->writeDerivativeOfLiftDragToDisk(step, actvar, L, dLdS);
  
   //
   // This function is writing to the disk quantities of interest in binary files.
diff -r da841a06e630 -r 5d849f9519c9 FluidShapeOptimizationHandler.h
--- a/FluidShapeOptimizationHandler.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/FluidShapeOptimizationHandler.h	Mon Jan 30 20:09:06 2017 -0800
@@ -66,6 +66,8 @@
   DistSVec<double,3> dPdS;
   DistSVec<double,3> dXdS;
   DistSVec<double,3> dXdSb;
+  DistSVec<double,3> lambdaSDisp;
+  DistSVec<double,3> dfaX;
   DistSVec<double,3> dXb;
   DistSVec<double,3> Xc;
   DistSVec<double,3> *Xp;
@@ -86,11 +88,14 @@
   DistSVec<double,dim> *Up;
   DistSVec<double,dim> *Um;
   DistSVec<double,dim> dUdS;
+  DistSVec<double,dim> lambdaU;
+  DistSVec<double,dim> dfaU;
   DistSVec<double,dim> Uc;
 
   DistSVec<double,3> Xplus;
   DistSVec<double,3> Xminus;
   DistSVec<double,3> dX;
+  DistSVec<double,3> lambdaX;
 
   DistSVec<double,dim> dddx;  // nodal gradients or adjoint vectors
   DistSVec<double,dim> dddy;
@@ -143,6 +148,15 @@
 
   void fsoGetDerivativeOfEffortsAnalytical(bool, IoData &, DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,dim> &, DistSVec<double,dim> &, Vec3D &, Vec3D &, Vec3D &);
 
+  void fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(IoData &,
+		  Vec3D &,
+		  Vec3D &,
+		  Vec3D &,
+		  DistSVec<double,3> &,
+		  DistSVec<double,dim> &,
+		  DistSVec<double,3> &,
+		  DistSVec<double,dim> &);
+
   /// \note This function is implemented but never called.
   void fsoGetDerivativeOfLoadFiniteDifference(IoData &, DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,3> &, DistSVec<double,3> &);
 
@@ -150,22 +164,32 @@
   void fsoGetDerivativeOfLoadAnalytical(bool, IoData &, DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,3> &, DistSVec<double,3> &);
   void fsoGetTransposeDerivativeOfLoadAnalytical(IoData &, DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,dim> &);
   void fsoSemiAnalytical(IoData &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
-  void fsoAnalytical(bool, IoData &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
-  void fsoAnalyticalTranspose(DistSVec<double,dim> &, DistSVec<double,3> &);
+  void fsoAnalytical(bool, IoData &, DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
+  void fsoApply_dFdXtranspose(DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,3> &);
   void fsoSetUpLinearSolver(IoData &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
+  void fsoSetUpAdjointLinearSolver(IoData &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
   void fsoLinearSolver(IoData &, DistSVec<double,dim> &, DistSVec<double,dim> &, bool=false);
+  void fsoAdjointLinearSolver(IoData &, DistSVec<double,dim> &, DistSVec<double,dim> &, bool=false);
   int fsoHandler(IoData &, DistSVec<double,dim> &);
   int fsoAeroelasticHandler(IoData &, DistSVec<double,dim> &);
   void fsoComputeDerivativesOfFluxAndSolution(IoData &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, bool=false, bool=false);
   void fsoComputeSensitivities(bool, IoData &, const char *, const char *, DistSVec<double,3> &, DistSVec<double,dim> &);
+  void fsoComputeAdjoint(IoData &, DistVec<double> &, DistSVec<double,3> &, DistSVec<double,dim> &, bool);
   void fsoComputeAndSendForceSensitivities(bool, IoData &, const char *, DistSVec<double,3> &, DistSVec<double,dim> &);
   void fsoInitialize(IoData &ioData, DistSVec<double,dim> &U);
   void fso_on_aeroelasticSensitivityFSI(bool, IoData &ioData, DistSVec<double,dim> &U);
+  void fso_on_aeroelasticAdjointSensitivityFSI(IoData &ioData, DistSVec<double,dim> &U);
   void fso_on_sensitivityMesh(bool, IoData &ioData, DistSVec<double,dim> &U);
   void fso_on_sensitivityMach(bool, IoData &ioData, DistSVec<double,dim> &U);
   void fso_on_sensitivityAlpha(bool, IoData &ioData, DistSVec<double,dim> &U);
   void fso_on_sensitivityBeta(bool, IoData &ioData, DistSVec<double,dim> &U);
 
+  void fso_on_AdjointSensitivityMesh(IoData &ioData, DistSVec<double,dim> &U);
+//  void fso_on_AdjointSensitivityMach(IoData &ioData, DistSVec<double,dim> &U);
+//  void fso_on_AdjointSensitivityAlpha(IoData &ioData, DistSVec<double,dim> &U);
+//  void fso_on_AdjointSensitivityBeta(IoData &ioData, DistSVec<double,dim> &U);
+
+
 };
 
 
diff -r da841a06e630 -r 5d849f9519c9 FluxFcnDescSG.C
--- a/FluxFcnDescSG.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/FluxFcnDescSG.C	Mon Jan 30 20:09:06 2017 -0800
@@ -1038,6 +1038,19 @@
 
 //------------------------------------------------------------------------------
 
+// Included (YC)
+inline
+void FluxFcnSGInflowEuler3D::computeDerivativeOperators
+(
+  double *normal, double normalVel, double *V, double *Ub,
+  double dFluxdNormal[7][3], double dFluxdNormalVel[7][1], double dFluxdUb[7][7]
+)
+{
+  F77NAME(computedboundfluxoperator)(0, vf->getGamma(), normal, normalVel, V, Ub, dFluxdNormal, dFluxdNormalVel, dFluxdUb);
+}
+
+//------------------------------------------------------------------------------
+
 void FluxFcnSGOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel,
                                     double *V, double *Ub, double *flux, bool useLimiter)
 {
diff -r da841a06e630 -r 5d849f9519c9 FluxFcnDescSG.h
--- a/FluxFcnDescSG.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/FluxFcnDescSG.h	Mon Jan 30 20:09:06 2017 -0800
@@ -385,6 +385,12 @@
     double *v, double *ub, double *dub, double *f, double *df
   );
 
+  virtual void computeDerivativeOperators
+  (
+    double*, double, double*, double*,
+    double [7][3], double[7][1], double [7][7]
+  );
+
 };
 
 //------------------------------------------------------------------------------
@@ -420,6 +426,16 @@
     double *v, double *ub, double *dub, double *f, double *df
   );
 
+  virtual void computeDerivativeOperators
+  (
+    double*, double, double*, double*,
+    double [7][3], double[7][1], double [7][7]
+  )
+  {
+    std::cout << "\n !!! FluxFcnSGInternalInflowEuler3D::computeDerivative (14 arg.) is not implemented !!!\n\n";
+    exit(1);
+  }
+
 };
 
 //------------------------------------------------------------------------------
@@ -455,6 +471,16 @@
     double *v, double *ub, double *dub, double *f, double *df
   );
 
+  virtual void computeDerivativeOperators
+  (
+    double*, double, double*, double*,
+    double [7][3], double[7][1], double [7][7]
+  )
+  {
+    std::cout << "\n !!! FluxFcnSGDirectStateInflowEuler3D::computeDerivative (14 arg.) is not implemented !!!\n\n";
+    exit(1);
+  }
+
 };
 
 //------------------------------------------------------------------------------
@@ -490,6 +516,16 @@
     double *v, double *ub, double *dub, double *f, double *df
   );
 
+  virtual void computeDerivativeOperators
+  (
+    double*, double, double*, double*,
+    double [7][3], double[7][1], double [7][7]
+  )
+  {
+    std::cout << "\n !!! FluxFcnSGMassFlowInflowEuler3D::computeDerivative (14 arg.) is not implemented !!!\n\n";
+    exit(1);
+  }
+
 };
 
 //------------------------------------------------------------------------------
@@ -565,6 +601,16 @@
     double *v, double *ub, double *dub, double *f, double *df
   );
 
+  virtual void computeDerivativeOperators
+  (
+    double*, double, double*, double*,
+    double [7][3], double[7][1], double [7][7]
+  )
+  {
+    std::cout << "\n !!! FluxFcnSGInternalOutflowEuler3D::computeDerivative (14 arg.) is not implemented !!!\n\n";
+    exit(1);
+  }
+
 };
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 ImplicitCoupledTsDesc.C
--- a/ImplicitCoupledTsDesc.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/ImplicitCoupledTsDesc.C	Mon Jan 30 20:09:06 2017 -0800
@@ -225,12 +225,12 @@
 
   double t0 = this->timer->getTime();
 
-////////////////////////////////////////
+//*****************    Verification of Adjointness of Jacobian dF/dW     ******************************
 /*
   DistSVec<double,dim> w(this->domain->getNodeDistInfo()),p(this->domain->getNodeDistInfo()),q(this->domain->getNodeDistInfo()),z(this->domain->getNodeDistInfo());
   DistSVec<double,dim> one(this->domain->getNodeDistInfo());
   DistSVec<double,dim> bp(this->domain->getNodeDistInfo());
-  one = 1.0;
+  one = b;
   bp = b;
 
   double direcTime(0), adjoinTime(0);
diff -r da841a06e630 -r 5d849f9519c9 IoData.h
--- a/IoData.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/IoData.h	Mon Jan 30 20:09:06 2017 -0800
@@ -303,6 +303,9 @@
   const char *dDisplacement;
   const char *dForces;
   const char *dLiftDrag;
+  const char *dLiftx;
+  const char *dLifty;
+  const char *dLiftz;
 
   const char *tempnormalderivative;
   const char *surfaceheatflux;
@@ -1815,6 +1818,9 @@
   enum SensitivityMach {OFF_SENSITIVITYMACH = 0, ON_SENSITIVITYMACH = 1} sensMach;
   enum SensitivityAOA {OFF_SENSITIVITYALPHA = 0, ON_SENSITIVITYALPHA = 1} sensAlpha;
   enum SensitivityYAW {OFF_SENSITIVITYBETA = 0, ON_SENSITIVITYBETA = 1} sensBeta;
+  enum SensitivityLiftx {OFF_SENSITIVITYLIFTX = 0, ON_SENSITIVITYLIFTX = 1} sensLiftx;
+  enum SensitivityLifty {OFF_SENSITIVITYLIFTY = 0, ON_SENSITIVITYLIFTY = 1} sensLifty;
+  enum SensitivityLiftz {OFF_SENSITIVITYLIFTZ = 0, ON_SENSITIVITYLIFTZ = 1} sensLiftz;
 
   // This flag repeats the linear solves until the number of iterations
   // is smaller than the maximum allowed.
@@ -1837,8 +1843,8 @@
   bool apressFlag;
   bool fsiFlag;
 
-  int si;
-  int sf;
+  int sparseFlag;
+  int numShapeVariables;
   int avgsIt;
 
   double eps;
diff -r da841a06e630 -r 5d849f9519c9 IoDataCore.C
--- a/IoDataCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/IoDataCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -448,6 +448,9 @@
   dDisplacement = "";
   dForces = "";
   dLiftDrag = "";
+  dLiftx = "";
+  dLifty = "";
+  dLiftz = "";
   dEddyvis = "";
 
   tempnormalderivative = "";
@@ -474,7 +477,7 @@
 {
 
 // Modified (MB)
-  ClassAssigner *ca = new ClassAssigner(name, 86, father); 
+  ClassAssigner *ca = new ClassAssigner(name, 102, father);
 
   new ClassStr<TransientData>(ca, "Prefix", this, &TransientData::prefix);
 
@@ -582,7 +585,6 @@
   new ClassStr<TransientData>(ca, "VelocitySensitivity", this, &TransientData::dVelocityVector);
   new ClassStr<TransientData>(ca, "DisplacementSensitivity", this, &TransientData::dDisplacement);
   new ClassStr<TransientData>(ca, "ForceSensitivity", this, &TransientData::dForces);
-  new ClassStr<TransientData>(ca, "LiftandDragSensitivity", this, &TransientData::dLiftDrag); //YC
 
   new ClassStr<TransientData>(ca, "TemperatureNormalDerivative", this, &TransientData::tempnormalderivative);
   new ClassStr<TransientData>(ca, "HeatFluxPerUnitSurface", this, &TransientData::surfaceheatflux); 
@@ -593,6 +595,11 @@
 
   new ClassStr<TransientData>(ca, "MultiSolutionFluxNorm", this, &TransientData::multiSolnFluxNorm);
 
+  // Included (YC)
+  new ClassStr<TransientData>(ca, "LiftandDragSensitivity", this, &TransientData::dLiftDrag);
+  new ClassStr<TransientData>(ca, "LiftxSensitivity", this, &TransientData::dLiftx);
+  new ClassStr<TransientData>(ca, "LiftySensitivity", this, &TransientData::dLifty);
+  new ClassStr<TransientData>(ca, "LiftzSensitivity", this, &TransientData::dLiftz);
   //do defaults
 
 }
@@ -3231,10 +3238,10 @@
   sensMach = OFF_SENSITIVITYMACH;
   sensAlpha = OFF_SENSITIVITYALPHA;
   sensBeta = OFF_SENSITIVITYBETA;
-  si = 0;
-  sf = -1;
+  numShapeVariables = 0;
   fsiFlag = false;
   adaptiveEpsFSI = OFF_ADAPTIVEEPSFSI;
+  sparseFlag = false;
 
   // For debugging purposes
   excsol = OFF_EXACTSOLUTION;
@@ -3257,8 +3264,9 @@
 void SensitivityAnalysis::setup(const char *name, ClassAssigner *father)
 {
 
-  ClassAssigner *ca = new ClassAssigner(name, 22, father);
+  ClassAssigner *ca = new ClassAssigner(name, 24, father);
   new ClassToken<SensitivityAnalysis>(ca, "Method", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::method), 2, "Direct", 0, "Adjoint", 1);
+  new ClassToken<SensitivityAnalysis>(ca, "SparseApproach", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::sparseFlag), 2, "Off", 0, "On", 1);
   new ClassToken<SensitivityAnalysis>(ca, "MatrixVectorProduct", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::mvp), 4, "FiniteDifference", 0, "Approximate", 1, "Exact", 2, "ApproximateFiniteDifference", 3);
   new ClassToken<SensitivityAnalysis>(ca, "LeastSquaresSolver", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::lsSolver), 2, "QR", 0, "NormalEquations", 1);
   new ClassToken<SensitivityAnalysis>(ca, "SensitivityComputation", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::scFlag), 3, "Analytical", 0, "SemiAnalytical", 1, "FiniteDifference", 2);
@@ -3269,8 +3277,7 @@
   new ClassToken<SensitivityAnalysis>(ca, "SensitivityAlpha", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::sensAlpha), 2, "Off", 0, "On", 1);
   new ClassToken<SensitivityAnalysis>(ca, "SensitivityBeta", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::sensBeta), 2, "Off", 0, "On", 1);
   new ClassToken<SensitivityAnalysis>(ca, "AdaptiveEpsFSI", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::adaptiveEpsFSI), 2, "Off", 0, "On", 1);
-  new ClassInt<SensitivityAnalysis>(ca, "ShapeVariableInitial", this, &SensitivityAnalysis::si);
-  new ClassInt<SensitivityAnalysis>(ca, "ShapeVariableFinal", this, &SensitivityAnalysis::sf);
+  new ClassInt<SensitivityAnalysis>(ca, "NumShapeVariables", this, &SensitivityAnalysis::numShapeVariables);
 
 // For debugging purposes
   new ClassToken<SensitivityAnalysis>(ca, "ExactSolution", this, reinterpret_cast<int SensitivityAnalysis::*>(&SensitivityAnalysis::excsol), 2, "Off", 0, "On", 1);
diff -r da841a06e630 -r 5d849f9519c9 KspPrec.C
--- a/KspPrec.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/KspPrec.C	Mon Jan 30 20:09:06 2017 -0800
@@ -314,6 +314,44 @@
 //------------------------------------------------------------------------------
 
 template<class Scalar, int dim, class Scalar2>
+void IluPrec<Scalar,dim, Scalar2>::applyTranspose(DistSVec<Scalar2,dim> &y, DistSVec<Scalar2,dim> &x)
+{
+
+  int iSub;
+
+  DistSVec<Scalar2, dim> tmp(y);
+
+  // switched RAS to ASH
+
+  if (type == PcData::ASH) tmp.restrict();
+  if (type == PcData::AAS) tmp.average();
+//  if (type == PcData::RAS) tmp.restrict();
+
+#pragma omp parallel for
+  for (iSub = 0; iSub < this->numLocSub; ++iSub)
+    A[iSub]->lusolTR(tmp(iSub), x(iSub));
+
+  // switched ASH to RAS
+  if (type == PcData::RAS) x.restrict();
+  if (type == PcData::AAS) x.average();
+//  if (type == PcData::ASH) x.restrict();
+
+  CommPattern<Scalar2> *vPat = this->getCommPat(x);
+#pragma omp parallel for
+  for (iSub = 0; iSub < this->numLocSub; ++iSub)
+    this->subDomain[iSub]->sndData(*vPat, x.subData(iSub));
+  vPat->exchange();
+
+#pragma omp parallel for
+  for (iSub = 0; iSub < this->numLocSub; ++iSub)
+    this->subDomain[iSub]->addRcvData(*vPat, x.subData(iSub));
+
+}
+
+//------------------------------------------------------------------------------
+
+
+template<class Scalar, int dim, class Scalar2>
 template<class MatScal>
 void IluPrec<Scalar,dim, Scalar2>::getData(DistMat<MatScal,dim> &B)
 {
diff -r da841a06e630 -r 5d849f9519c9 KspPrec.h
--- a/KspPrec.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/KspPrec.h	Mon Jan 30 20:09:06 2017 -0800
@@ -26,12 +26,15 @@
   virtual void exportMemory(MemoryPool *mp) {}
 
   virtual void setup() = 0;
-  void setupTR() { std::cout << "setupTR not implemented for this Preconditioner" << endl; }
+  virtual void setupTR() { std::cout << "setupTR not implemented for this Preconditioner" << endl; }
 
   // all KspPrec derived class must have the following functions
   virtual void apply(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default apply function in KspPrec" << endl; }
   virtual void apply(DistVec<Scalar2> &, DistVec<Scalar2> &)  { std::cout << "  ERROR: Using default apply function in KspPrec" << endl; }
   virtual void applyT(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default applyT function in KspPrec" << endl; }
+  virtual void applyT(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { std::cout<< " ERROR: Using default applyT function in KspPrec" << endl; }
+  virtual void applyTranspose(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default applyTranspose function in KspPrec" << endl; }
+  virtual void applyTranspose(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { std::cout<< " ERROR: Using default applyTranspose function in KspPrec" << endl; }
 
   void apply(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { 
     apply(x.real(), Px.real());
@@ -57,6 +60,7 @@
 
   void apply(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix); 
   void applyT(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix) { Ix = x; }
+  void applyTranspose(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix) { Ix = x; }
 
 };
 
@@ -124,6 +128,7 @@
 
   void apply(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &);
   void applyT(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &);
+  void applyTranspose(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &);
 
   template<class MatScal>
   void getData(DistMat<MatScal,dim> &);
diff -r da841a06e630 -r 5d849f9519c9 KspSolver.h
--- a/KspSolver.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/KspSolver.h	Mon Jan 30 20:09:06 2017 -0800
@@ -40,6 +40,7 @@
 
 public:
   int maxits;
+  int typePrec;
 
   KspSolver() {}
   KspSolver(KspData &, MatVecProdOp *, PrecOp *, IoOp *);
@@ -52,12 +53,14 @@
   void disableOutput() { output = NULL; } 
 
   virtual int solve(VecType &, VecType &) = 0;
+  virtual int solveT(VecType &, VecType &) = 0;
   virtual int solveLS(VecType &, VecType &) { return 0; };
 
   void printParam() { ioOp->fprintf(stderr, " solver params: %d maxits, %e eps\n", maxits, eps);  }
 
   void setKspBinaryOutput(KspBinaryOutput<VecType>*);
   KspBinaryOutput<VecType> *kspBinaryOutput;
+  void setTypePrec(int tp) { typePrec = tp; }
 
 };
 
@@ -76,6 +79,7 @@
 
   int solve(VecType &, VecType &);
   int solveLS(VecType &, VecType &);
+  int solveT(VecType &, VecType &) { return 0; }
 
 };
 
@@ -93,7 +97,10 @@
   ~CgSolver() {}
 
   int solve(VecType &, VecType &);
+  //int solveLS(VecType &, VecType &);
   int solveLS(VecType &, VecType &);
+  int solveT(VecType &, VecType &) { return 0;}
+  int solveMRhs(VecType &, VecType &);
 
 };
 
@@ -161,6 +168,7 @@
   ~GcrSolver() {}
                       
   int solve(VecType &, VecType &);
+  int solveT(VecType &, VecType &) { return 0; }
   int solveMRhs(VecType &, VecType &);
                                                         
 };
diff -r da841a06e630 -r 5d849f9519c9 MatVecProd.C
--- a/MatVecProd.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/MatVecProd.C	Mon Jan 30 20:09:06 2017 -0800
@@ -1928,12 +1928,12 @@
 
   if (R)
   {
-    std::cout << "\n !!! R is being added !!\n";
+//    std::cout << "\n !!! R is being added !!\n";
     *vProd = (Scalar2) 0;
-    R->apply(p, *vProd);
+    R->applyTranspose(p, *vProd);
     prod += *vProd;
   }
-  else if (RFD)
+  else if (RFD) //TODO: YC: have not checked this works
   {
     *vProd = (Scalar2) 0;
     RFD->applyViscous(p, *vProd);
@@ -2774,6 +2774,7 @@
 ) :
   MatVecProd<dim,neq>(),
   timeState(ts),
+  iod(&ioData),
   spaceOp(0),
   fluxFcn(0),
   X(0),
@@ -2807,6 +2808,18 @@
     dRdXop->dFluxdFaceNormalVel[iSub] = subDomain[iSub]->template create_NodeToFaceBaseddRdXoperators<1,dim>();
     dRdXop->dFluxdUb[iSub] = subDomain[iSub]->template create_NodeToFaceBaseddRdXoperators<dim,dim>();
     dRdXop->dFaceNormdX[iSub] = subDomain[iSub]->template create_FaceBaseddRdXoperators<3,3>();
+    dRdXop->dFidGradP[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dFidX[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dFvdX[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dFidV[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<dim,3>();
+    dRdXop->dFvdV[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<dim,3>();
+    dRdXop->dFidS[iSub] = subDomain[iSub]->template create_ConstantToConstantBaseddRdXoperators<3,3>();
+    dRdXop->dMidGradP[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dMidX[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dMvdX[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<3,3>();
+    dRdXop->dMvdV[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<dim,3>();
+    dRdXop->dMidV[iSub] = subDomain[iSub]->template create_ConstantToNodeBaseddRdXoperators<dim,3>();
+    dRdXop->dMidS[iSub] = subDomain[iSub]->template create_ConstantToConstantBaseddRdXoperators<3,3>();
     dRdXop->dCtrlVoldX[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,1>();
     dRdXop->dRdX[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,6>();
     dRdXop->dRdR[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<6,6>();
@@ -2823,15 +2836,27 @@
     dRdXop->dFluxdddy[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,dim>();
     dRdXop->dFluxdddz[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,dim>();
     dRdXop->dFluxdX[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,dim>();
+    dRdXop->dViscousFluxdX[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,dim>();
     dRdXop->dGradPdddx[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,3>();
     dRdXop->dGradPdddy[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,3>();
     dRdXop->dGradPdddz[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,3>();
     dRdXop->dForcedGradP[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,3>();
     dRdXop->dForcedX[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<3,3>();
     dRdXop->dForcedV[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,3>();
-    dRdXop->dForcedS[iSub] = subDomain[iSub]->template create_ConstantBaseddRdXoperators<3,3>();
     dRdXop->dVdU[iSub] = subDomain[iSub]->template create_NodeBaseddRdXoperators<dim,dim>();
-    dRdXop->dVdPstiff[iSub] = subDomain[iSub]->template create_ConstantBaseddRdXoperators<1,dim>();
+    dRdXop->dVdPstiff[iSub] = subDomain[iSub]->template create_NodeToConstantBaseddRdXoperators<1,dim>();
+    size += double(dRdXop->dMidGradP[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dMidX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dMvdX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dMvdV[iSub]->numNonZeroBlocks()*dim*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dMidV[iSub]->numNonZeroBlocks()*dim*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dMidS[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFidGradP[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFidX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFvdX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFidV[iSub]->numNonZeroBlocks()*dim*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFvdV[iSub]->numNonZeroBlocks()*dim*3*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dFidS[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dCtrlVoldX[iSub]->numNonZeroBlocks()*3*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dEdgeNormdX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dFaceNormdX[iSub]->numNonZeroBlocks()*3*3*sizeof(double)) / (1024.*1024.);
@@ -2853,6 +2878,7 @@
     size += double(dRdXop->dFluxdddy[iSub]->numNonZeroBlocks()*dim*dim*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dFluxdddz[iSub]->numNonZeroBlocks()*dim*dim*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dFluxdX[iSub]->numNonZeroBlocks()*3*dim*sizeof(double)) / (1024.*1024.);
+    size += double(dRdXop->dViscousFluxdX[iSub]->numNonZeroBlocks()*3*dim*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dGradPdddx[iSub]->numNonZeroBlocks()*3*dim*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dGradPdddy[iSub]->numNonZeroBlocks()*3*dim*sizeof(double)) / (1024.*1024.);
     size += double(dRdXop->dGradPdddz[iSub]->numNonZeroBlocks()*3*dim*sizeof(double)) / (1024.*1024.);
@@ -2919,6 +2945,18 @@
 
 #pragma omp parallel for
   for (int iSub = 0; iSub < numLocSub; ++iSub) {
+	*dRdXop->dMidX[iSub] = x;
+	*dRdXop->dMvdX[iSub] = x;
+	*dRdXop->dMvdV[iSub] = x;
+	*dRdXop->dMidV[iSub] = x;
+	*dRdXop->dMidS[iSub] = x;
+	*dRdXop->dMidGradP[iSub] = x;
+	*dRdXop->dFidX[iSub] = x;
+	*dRdXop->dFvdX[iSub] = x;
+	*dRdXop->dFidV[iSub] = x;
+	*dRdXop->dFvdV[iSub] = x;
+	*dRdXop->dFidS[iSub] = x;
+	*dRdXop->dFidGradP[iSub] = x;
     *dRdXop->dCtrlVoldX[iSub] = x;
     *dRdXop->dEdgeNormdX[iSub] = x;
     *dRdXop->dFaceNormdX[iSub] = x;
@@ -2937,6 +2975,7 @@
     *dRdXop->dFluxdddy[iSub] = x;
     *dRdXop->dFluxdddz[iSub] = x;
     *dRdXop->dFluxdX[iSub] = x;
+    *dRdXop->dViscousFluxdX[iSub] = x;
     *dRdXop->dGradPdddx[iSub] = x;
     *dRdXop->dGradPdddy[iSub] = x;
     *dRdXop->dGradPdddz[iSub] = x;
@@ -2956,7 +2995,8 @@
 
 //------------------------------------------------------------------------------
 template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::constructOperators(DistSVec<double,3> &X, 
+void MatVecProd_dRdX<dim,Scalar,neq>::constructOperators(Vec3D &x0,
+                                                         DistSVec<double,3> &X,
                                                          DistVec<double> &ctrlVol,
                                                          DistSVec<double,dim> &U,
                                                          double dMach,
@@ -2965,489 +3005,8 @@
                                                          DistTimeState<dim> *timeState,
                                                          PostOperator<dim> *postOp)
 {
-  com->printf(5," ... in MatVecProd_dRdX<dim,Scalar,neq>::constructOperators\n");
+  com->printf(5," ... in MatVecProd_dRdX<dim,Scalar,neq>::constructOperators, norm of X is %e\n", X.norm());
   initializeOperators(0.0);
-  spaceOp->computeDerivativeOperators(X, ctrlVol, U, dMach, R, Pin, timeState, postOp, dRdXop); 
+  spaceOp->computeDerivativeOperators(x0, X, ctrlVol, U, dMach, R, Pin, timeState, postOp, dRdXop);
 }
 
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evaluate(int it, DistSVec<double,3> &x, DistVec<double> &cv, 
-					DistSVec<double,dim> &q, DistSVec<double,dim> &f)
-{
-/*
-// Included (MB)
-  evaluateInviscid(it, x, cv, q, f);
-  evaluateViscous( it, x, cv, q, f);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-// Included (MB)
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evaluateInviscid(int it, DistSVec<double,3> &x, DistVec<double> &cv, 
-					DistSVec<double,dim> &q, DistSVec<double,dim> &f)
-{
-/*
-  X = &x;
-  ctrlVol = &cv;
-  Q = &q;
-
-  if (!this->isFSI){
-    spaceOp->computeH2(*X, *ctrlVol, *Q, *this, aij, aji, bij, bji);
-  }else{
-    spaceOp->computeH2(*X, *ctrlVol, *Q, this->fsi.LSS, *(this->fsi.fluidId), 
-		       this->fsi.riemann, this->fsi.Nriemann,
-		       this->fsi.ghostPoints, *this, aij, aji, bij, bji, betaij, betaji);
-  }
-
-  if (timeState)
-    timeState->addToH2(*ctrlVol, *Q, *this);
-
-  spaceOp->applyBCsToH2Jacobian(*Q, *this);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-// Included (MB)
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evaluateViscous(int it, DistSVec<double,3> &x, DistVec<double> &cv, 
-					DistSVec<double,dim> &q, DistSVec<double,dim> &f)
-{
-/*
-  // compute viscous flux jacobian
-  if (R)  {
-    R->evaluateViscous(it, *X, *ctrlVol);
-    spaceOp->applyBCsToJacobian(*Q, *R);
-  }
-
-  if (RFD) {
-    F = &f;
-    RFD->evaluateViscous(it, *X, *ctrlVol, *Q, *F);
-  }
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evaluate(int it, DistSVec<double,3> &x, 
-                               DistVec<double> &cv, DistSVec<double,dim> &q, 
-                               DistSVec<double,dim> &F, Scalar shift)
-{
-/*
-  X = &x;
-  ctrlVol = &cv;
-  Q = &q;
-
-  spaceOp->computeH2(*X, *ctrlVol, *Q, *this, aij, aji, bij, bji);
-
-  if (timeState) {
-     switch (it)  {
-       //case for the construction of the POD
-       case 0:
-         timeState->addToH2(*ctrlVol, *Q, *this, shift, 1.0);
-         break;   
-       case 1:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(2.0), 1.0);
-         break;
-       case 2:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(2.0), -1.0);
-         break;
-       case 3:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(3.0), 2.0);
-         break;
-       case 4:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(4.0), -2.0);
-         break;
-       case 5:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(2.0), -2.0);
-         break;
-       case 6:
-         timeState->addToH2(*ctrlVol, *Q, *this, (Scalar(4.0)*shift+Scalar(2.0))/(shift*(shift+Scalar(1.0))), 2.0);
-         break;
-       case 7:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(8.0/3.0), 2.0);
-         break;
-       case 8:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(16.0/3.0), 2.0);
-         break;
-       case 9:
-         timeState->addToH2(*ctrlVol, *Q, *this, Scalar(10.0/3.0), 2.0);
-         break;
-
-    }
-  }
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evaluate2(int it, DistSVec<double,3> &x, DistVec<double> &cv, 
-                                         DistSVec<double,dim> &q, DistSVec<double,dim> &F)
-{
-/*
-  X = &x;
-  ctrlVol = &cv;
-  Q = &q;
-
-  spaceOp->computeH2(*X, *ctrlVol, *Q, *this, aij, aji, bij, bji);
-
-  if (timeState) {
-    timeState->addToH2Minus(*ctrlVol, *Q, *this);
-  }
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::evalH(int it, DistSVec<double,3> &x,
-                               DistVec<double> &cv, DistSVec<double,dim> &q)  
-{
-/*
-  X = &x;
-  ctrlVol = &cv;
-  Q = &q;
-
-  spaceOp->computeH2(*X, *ctrlVol, *Q, *this, aij, aji, bij, bji);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::apply(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)
-{
-/*
-  Multiplier<dim,neq,Scalar,double> Operator;
-  Operator.Apply(spaceOp, *X, *ctrlVol, *Q, *this, aij, aji, bij, bji, p, prod,
-                 R, RFD, vProd);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::apply(DistEmbeddedVec<double,dim> &p, DistEmbeddedVec<double,dim> &prod)
-{
-/*
-  //std::cout << "$$$$$ IN MatVecProc EMB H2 applyXXXX \n";
-
-  spaceOp->applyH2(*X, *ctrlVol, *Q, 
-		   this->fsi.LSS, *(this->fsi.fluidId), 
-		   this->fsi.linRecAtInterface, this->fsi.viscSecOrder,
-		   this->fsi.riemann, this->fsi.Nriemann,
-		   this->fsi.ghostPoints, 
-		   *this, aij, aji, bij, bji, betaij, betaji,
-		   p.real(), prod.real());
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-template<int dd, int nn, class Scalar1, class Scalar2>
-void MatVecProd_dRdX<dim,Scalar,neq>::Multiplier<dd,nn,Scalar1,Scalar2>::Apply
-(
-  SpaceOperator<dd> *spaceOp
-  , DistSVec<double,3> &X
-  , DistVec<double> &ctrlVol
-  , DistSVec<double,dd> &U
-  , DistMat<Scalar1,dd> &H2
-  , DistSVec<double,dd> &aij, DistSVec<double,dd> &aji
-  , DistSVec<double,dd> &bij, DistSVec<double,dd> &bji
-  , DistSVec<Scalar2,nn> &p, DistSVec<Scalar2,nn> &prod
-  , MatVecProdH1<dd, Scalar1, nn> *R
-  , MatVecProdFD<dd, nn> *RFD
-  , DistSVec<Scalar2, nn> *vProd
-)
-{
-/*
-  if (nn > dd)
-  {
-    std::cout << "\n !!! Apply Not Implemented for dd = " << dd;
-    std::cout << " nn = " << nn << std::endl;
-    exit(-1);
-  }
-
-  DistSVec<Scalar2,dd> pExt(p.info());
-  pExt = (Scalar2) 0;
-
-  int numLocSub = p.numLocSub();
-#pragma omp parallel for
-  for (int iSub = 0; iSub < numLocSub; ++iSub)
-  {
-    Scalar2 (*locp)[nn] = p.subData(iSub);
-    Scalar2 (*locExt)[dd] = pExt.subData(iSub);
-    for (int i = 0; i < p.subSize(iSub); ++i)
-    {
-      for (int jj = 0; jj < nn; ++jj)
-        locExt[i][jj] = locp[i][jj];
-    }
-  } // for (int iSub = 0; iSub < numLocSub; ++iSub)
-
-  spaceOp->applyH2(X, ctrlVol, U, H2, aij, aji, bij, bji, pExt, pExt);
-
-#pragma omp parallel for
-  for (int iSub = 0; iSub < numLocSub; ++iSub)
-  {
-    Scalar2 (*locp)[nn] = prod.subData(iSub);
-    Scalar2 (*locExt)[dd] = pExt.subData(iSub);
-    for (int i = 0; i < p.subSize(iSub); ++i)
-    {
-      for (int jj = 0; jj < nn; ++jj)
-        locp[i][jj] = locExt[i][jj];
-    }
-  } // for (int iSub = 0; iSub < numLocSub; ++iSub)
-
-  if (R)
-  {
-    *vProd = (Scalar2) 0;
-    R->apply(p, *vProd);
-    prod += *vProd;
-  }
-  else if (RFD)
-  {
-    *vProd = (Scalar2) 0;
-    RFD->applyViscous(p, *vProd);
-    prod += *vProd;
-  }
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-template<int dd, class Scalar1, class Scalar2>
-void MatVecProd_dRdX<dim,Scalar,neq>::Multiplier<dd,dd,Scalar1,Scalar2>::Apply
-(
-  SpaceOperator<dd> *spaceOp
-  , DistSVec<double,3> &X
-  , DistVec<double> &ctrlVol
-  , DistSVec<double,dd> &U
-  , DistMat<Scalar1,dd> &H2
-  , DistSVec<double,dd> &aij, DistSVec<double,dd> &aji
-  , DistSVec<double,dd> &bij, DistSVec<double,dd> &bji
-  , DistSVec<Scalar2,dd> &p, DistSVec<Scalar2,dd> &prod
-  , MatVecProdH1<dd, Scalar1, dd> *R
-  , MatVecProdFD<dd, dd> *RFD
-  , DistSVec<Scalar2, dd> *vProd
-)
-{
-/*
-  spaceOp->applyH2(X, ctrlVol, U, H2, aij, aji, bij, bji, p, prod);
-  
-
-  if (R)
-  {
-    *vProd = (Scalar2) 0;
-    R->apply(p, *vProd);
-    prod += *vProd;
-  }
-  else if (RFD)
-  {
-    *vProd = (Scalar2) 0;
-    RFD->applyViscous(p, *vProd);
-    prod += *vProd;
-  }
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::apply(DistSVec<bcomp,neq> &p,
-                DistSVec<bcomp,neq> &prod)
-{
-/*
-  //std::cout << "$$$$$ IN MatVecProc H2 C applyapply\n";
-
-  Multiplier<dim,neq,Scalar,bcomp> Operator;
-  Operator.Apply(spaceOp, *X, *ctrlVol, *Q, *this, aij, aji, bij, bji, p, prod,
-                 0, 0, 0);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::applyT(DistSVec<double,neq> &p,
-        DistSVec<double,neq> &prod)
-{
-/*
-  Multiplier<dim,neq,Scalar,double> Operator;
-  Operator.ApplyT(spaceOp, *X, *ctrlVol, *Q, *this, aij, aji, bij, bji, p, prod);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::applyT(DistSVec<bcomp,neq> &p,
-        DistSVec<bcomp,neq> &prod)
-{
-/*
-  Multiplier<dim,neq,Scalar,bcomp> Operator;
-  Operator.ApplyT(spaceOp, *X, *ctrlVol, *Q, *this, aij, aji, bij, bji, p, prod);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-template<int dd, int nn, class Scalar1, class Scalar2>
-void MatVecProd_dRdX<dim,Scalar,neq>::Multiplier<dd,nn,Scalar1,Scalar2>::ApplyT
-(
-  SpaceOperator<dd> *spaceOp
-  , DistSVec<double,3> &X
-  , DistVec<double> &ctrlVol
-  , DistSVec<double,dd> &U
-  , DistMat<Scalar1,dd> &H2
-  , DistSVec<double,dd> &aij, DistSVec<double,dd> &aji
-  , DistSVec<double,dd> &bij, DistSVec<double,dd> &bji
-  , DistSVec<Scalar2,nn> &p, DistSVec<Scalar2,nn> &prod
-)
-{
-/*
-  std::cout << "\n !!! ApplyT Not Implemented !!\n";
-  exit(-1);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-template<int dim, class Scalar, int neq>
-template<int dd, class Scalar1, class Scalar2>
-void MatVecProd_dRdX<dim,Scalar,neq>::Multiplier<dd,dd,Scalar1,Scalar2>::ApplyT
-(
-  SpaceOperator<dd> *spaceOp
-  , DistSVec<double,3> &X
-  , DistVec<double> &ctrlVol
-  , DistSVec<double,dd> &U
-  , DistMat<Scalar1,dd> &H2
-  , DistSVec<double,dd> &aij, DistSVec<double,dd> &aji
-  , DistSVec<double,dd> &bij, DistSVec<double,dd> &bji
-  , DistSVec<Scalar2,dd> &p, DistSVec<Scalar2,dd> &prod
-)
-{
-/*
-  spaceOp->applyH2T(X, ctrlVol, U, H2, aij, aji, bij, bji, p, prod);
-*/
-}
-
-//------------------------------------------------------------------------------
-
-// Included (MB)
-template<int dim, class Scalar, int neq>
-void MatVecProd_dRdX<dim,Scalar,neq>::rstSpaceOp
-(
-  IoData & ioData, VarFcn *varFcn, SpaceOperator<dim> *spo, 
-  bool typeAlloc, SpaceOperator<dim> *spofd
-)
-{
-/*
-  if (dim != neq)
-  {
-    // UH (09/10) This function is only called from the sensitivity module.
-    // The sensitivity module assumes a strong turbulence model coupling
-    // (i.e. dim == neq).
-    this->com->fprintf(stderr, "\n *** MatVecProd_dRdX<dim,Scalar,neq>::rstSpaceOp");
-    this->com->fprintf(stderr, " is not verified for weakly coupled systems.\n\n");
-    exit(1);
-  }
-
-  // UH (09/10) -> Check for memory leak
-  // No FluxFcn pointer is deleted.
-
-  fluxFcn = new FluxFcn*[BC_MAX_CODE - BC_MIN_CODE + 1]; 
-  fluxFcn -= BC_MIN_CODE;
-  if(BC_MAX_CODE-BC_MIN_CODE+1 < 22)
-    fprintf(stderr,"Be prepared to see a segmentation fault shortly...\n");
-
-  fluxFcn[BC_SYMMETRY] = new FluxFcn(0,BC_SYMMETRY,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_MASSFLOW_OUTLET_MOVING] = new FluxFcn(0,BC_MASSFLOW_OUTLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_MASSFLOW_OUTLET_FIXED] = new FluxFcn(0,BC_MASSFLOW_OUTLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_MASSFLOW_INLET_MOVING] = new FluxFcn(0,BC_MASSFLOW_INLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_MASSFLOW_INLET_FIXED] = new FluxFcn(0,BC_MASSFLOW_INLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_DIRECTSTATE_OUTLET_MOVING] = new FluxFcn(0,BC_DIRECTSTATE_OUTLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_DIRECTSTATE_OUTLET_FIXED] = new FluxFcn(0,BC_DIRECTSTATE_OUTLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_DIRECTSTATE_INLET_MOVING] = new FluxFcn(0,BC_DIRECTSTATE_INLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_DIRECTSTATE_INLET_FIXED] = new FluxFcn(0,BC_DIRECTSTATE_INLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_OUTLET_MOVING] = new FluxFcn(0,BC_OUTLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_OUTLET_FIXED] = new FluxFcn(0,BC_OUTLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_INLET_MOVING] = new FluxFcn(0,BC_INLET_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_INLET_FIXED] = new FluxFcn(0,BC_INLET_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_POROUS_WALL_MOVING] = new FluxFcn(0,BC_POROUS_WALL_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_POROUS_WALL_FIXED] = new FluxFcn(0,BC_POROUS_WALL_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_ADIABATIC_WALL_MOVING] = new FluxFcn(0,BC_ADIABATIC_WALL_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_ADIABATIC_WALL_FIXED] = new FluxFcn(0,BC_ADIABATIC_WALL_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_SLIP_WALL_MOVING] = new FluxFcn(0,BC_SLIP_WALL_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_SLIP_WALL_FIXED] = new FluxFcn(0,BC_SLIP_WALL_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_ISOTHERMAL_WALL_MOVING] = new FluxFcn(0,BC_ISOTHERMAL_WALL_MOVING,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_ISOTHERMAL_WALL_FIXED] = new FluxFcn(0,BC_ISOTHERMAL_WALL_FIXED,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-  fluxFcn[BC_INTERNAL] = new FluxFcn(0,BC_INTERNAL,ioData,varFcn,FluxFcnBase::PRIMITIVE);
-
-  spaceOp->setFluxFcn(fluxFcn);
-*/
-}
-
-
-/*
-template<int dim, class Scalar, int neq>
-MatVecProdRomH1<dim,Scalar,neq>::MatVecProdRomH1(DistTimeState<dim> *ts, SpaceOperator<dim> *spo,
-                                                 Domain *domain, IoData &ioData,
-                                                 VecSet<DistSVec<Scalar, dim> > &_Phi) :
-MatVecProdH1<dim, Scalar, neq>(ts, spo, domain, ioData),
-Phi(_Phi)
-{
-  this->reducedDimension = this->Phi.numVectors();
-}
-
-
-template<int dim, class Scalar, int neq>
-MatVecProdRomH1<dim,Scalar,neq>::~MatVecProdRomH1()
-{
-  // todo: remove Phi
-}
-
-/*
- * let A be the matrix mvpOp represent,
- * then Phi^T A Phi x = b.
- * warning: unoptimized code.
- *
-template<int dim, class Scalar, int neq>
-void MatVecProdRomH1<dim,Scalar,neq>::apply(Vec<double> &x, Vec<double> &b){
-  // step 0: skipped. check x.len == this->reducedDimension
-  //todo: not sure about this declaration
-  VecSet<DistSVec<Scalar, dim> > result(this->reducedDimension, this->domain->getNodeDistInfo());
-  // step 1: compute A * Phi = result
-  for(int i = 0; i < this->reducedDimension; i++){
-    DistEmbeddedVec<Scalar, dim> embedded_x(this->domain->getNodeDistInfo());
-    DistEmbeddedVec<Scalar, dim> embedded_b(this->domain->getNodeDistInfo());
-    embedded_b = 0.0;
-    embedded_x = 0.0;
-    embedded_x.real() = reducedBasis[i];
-
-    // result from apply on distEmbeddedSVec type
-    this->apply(embedded_x, embedded_b);
-    DistSVec<Scalar, dim> result(this->domain->getNodeDistInfo());
-    result[i] = embedded_b.real();
-  }
-  // step 2: compute result * x = res
-  DistSVec<Scalar, dim> res(this->domain->getNodeDistInfo());
-  res = 0.0;
-  for(int i = 0; i < this->reducedDimension; i++){
-    res += result[i] * x[i];
-  }
-  // step 3: compute Phi^T * res = b
-  b = 0.0;
-  for(int i = 0; i < this->reducedDimension; i++){
-    b[i] = Phi[i] * res;
-  }
-}
-*/
\ No newline at end of file
diff -r da841a06e630 -r 5d849f9519c9 MatVecProd.h
--- a/MatVecProd.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/MatVecProd.h	Mon Jan 30 20:09:06 2017 -0800
@@ -15,6 +15,7 @@
 class FluxFcn;
 class DistGeoState;
 class MemoryPool;
+//struct Vec3D;
 
 template<int dimLS> class LevelSet;
 template<int dim> class RecFcnConstant;
@@ -40,7 +41,7 @@
   MatVecProd() : isFSI(false) {}
   virtual ~MatVecProd() {}
 
-  virtual void constructOperators(DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
+  virtual void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
                                   double, DistSVec<double,dim> &, DistVec<double> &, DistTimeState<dim> *, PostOperator<dim> *) = 0;
   virtual dRdXoperators<dim> *getdRdXop() = 0;
   virtual void exportMemory(MemoryPool *mp) {}
@@ -64,6 +65,8 @@
   virtual void applyT(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &) = 0;
 
   virtual void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &) = 0;
+  virtual void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }
+  virtual void applyTranspose(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &) { }
 
   virtual void evaluateRestrict(int, DistSVec<double,3> &, DistVec<double> &,
                 DistSVec<double,dim> &, DistSVec<double,dim> &, RestrictionMapping<dim> &,
@@ -201,7 +204,7 @@
 
   void attachHH(DistEmbeddedVec<double,dim>& v);
 
-  void constructOperators(DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
+  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
                           double, DistSVec<double,dim> &, DistVec<double> &, DistTimeState<dim> *, PostOperator<dim> *) {}
   dRdXoperators<dim> *getdRdXop() { return 0;}
   void evaluate(int, DistSVec<double,3> &, DistVec<double> &, 
@@ -225,6 +228,7 @@
 
   void apply(DistSVec<double,neq> &, DistSVec<double,neq> &);
   void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &) {}
+  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }
   void applyWeighted(DistSVec<double,neq> &, DistSVec<double,neq> &, VarFcn *);
   void applyRestrict(DistSVec<double,neq> &, DistSVec<double,neq> &, RestrictionMapping<neq> &,
                 TsDesc<dim>* probDesc=NULL,
@@ -295,7 +299,7 @@
 
   DistMat<Scalar,neq> &operator= (const Scalar);
 
-  void constructOperators(DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
+  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
                           double, DistSVec<double,dim> &, DistVec<double> &, DistTimeState<dim> *, PostOperator<dim> *) {}
 
   dRdXoperators<dim> *getdRdXop() { return 0; }
@@ -316,6 +320,7 @@
 
   void apply(DistSVec<double,neq> &, DistSVec<double,neq> &);
   void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &);
+  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }
   void apply(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &)  {
     std::cout << "... ERROR: ::apply function not implemented for class MatVecProdH1 with complex arguments" << endl; }
 
@@ -497,7 +502,7 @@
 
   GenMat<Scalar,dim> &operator() (int i) { return *A[i]; }
 
-  void constructOperators(DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
+  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,
                           double, DistSVec<double,dim> &, DistVec<double> &, DistTimeState<dim> *, PostOperator<dim> *) {}
   dRdXoperators<dim> *getdRdXop() { return 0; }
 /*
@@ -549,6 +554,7 @@
   void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &);
   void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y);
   void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &);
+  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }
 
 // Included (MB)
   void evaluateInviscid(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
@@ -596,6 +602,8 @@
   virtual void applyT(DistSVec<bcomp,dim> &x, DistSVec<bcomp,dim> &y) = 0;
   virtual void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &) = 0;
   
+  virtual void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }
+
   virtual void evaluateHH(DistVec<double> &hhterm,
 			  DistVec<double> &bcVal ) { }
 
@@ -671,6 +679,7 @@
   void applyT(DistSVec<double,dim> &, DistSVec<double,dim> &) {}
   void applyT(DistSVec<bcomp,dim> &x, DistSVec<bcomp,dim> &y) {}
   void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &) {}
+  void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }
   
   void evaluateHH(DistVec<double> &hhterm,
 		  DistVec<double> &bcVal );
@@ -714,6 +723,7 @@
   void applyT(DistSVec<double,dim> &, DistSVec<double,dim> &) {}
   void applyT(DistSVec<bcomp,dim> &x, DistSVec<bcomp,dim> &y) {}
   void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &) {}
+  void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }
 };
 
 //----------------------------------------------------------------------------//
@@ -762,6 +772,7 @@
   void applyT(DistSVec<double,dimLS> &, DistSVec<double,dimLS> &) {}
   void applyT(DistSVec<bcomp,dimLS> &x, DistSVec<bcomp,dimLS> &y) {}
   void applyTranspose(DistSVec<double,dimLS> &, DistSVec<double,dimLS> &) {}
+  void applyTranspose(DistEmbeddedVec<double,dimLS> &, DistEmbeddedVec<double,dimLS> &) { }
 
 };
                                                                                                                       
@@ -771,6 +782,18 @@
 struct dRdXoperators
 {
   int numLocSub;
+  RectangularSparseMat<double,3,3> **dMidGradP;
+  RectangularSparseMat<double,3,3> **dMidX;
+  RectangularSparseMat<double,3,3> **dMvdX;
+  RectangularSparseMat<double,dim,3> **dMvdV;
+  RectangularSparseMat<double,dim,3> **dMidV;
+  RectangularSparseMat<double,3,3> **dMidS;
+  RectangularSparseMat<double,3,3> **dFidGradP;
+  RectangularSparseMat<double,3,3> **dFidX;
+  RectangularSparseMat<double,3,3> **dFvdX;
+  RectangularSparseMat<double,dim,3> **dFidV;
+  RectangularSparseMat<double,dim,3> **dFvdV;
+  RectangularSparseMat<double,3,3> **dFidS;
   RectangularSparseMat<double,3,1> **dCtrlVoldX;
   RectangularSparseMat<double,3,3> **dEdgeNormdX;
   RectangularSparseMat<double,3,3> **dFaceNormdX;
@@ -793,6 +816,7 @@
   RectangularSparseMat<double,1,dim> **dFluxdFaceNormalVel;
   RectangularSparseMat<double,dim,dim> **dFluxdUb;
   RectangularSparseMat<double,3,dim> **dFluxdX;
+  RectangularSparseMat<double,3,dim> **dViscousFluxdX;
   RectangularSparseMat<double,dim,3> **dGradPdddx;
   RectangularSparseMat<double,dim,3> **dGradPdddy;
   RectangularSparseMat<double,dim,3> **dGradPdddz;
@@ -805,7 +829,9 @@
 
   // Constructor
   dRdXoperators() { dRdX = 0; dRdR = 0; dddxdX = 0; dddydX = 0; dddzdX = 0; dddxdR = 0; 
-                    dddydR = 0; dddzdR = 0; dEdgeNormdX = 0; dFaceNormdX = 0; dCtrlVoldX = 0; 
+                    dddydR = 0; dddzdR = 0; dEdgeNormdX = 0; dFaceNormdX = 0; dCtrlVoldX = 0; dViscousFluxdX = 0;
+                    dFidS = 0;  dFidX = 0;  dFvdX = 0;  dFidV = 0;  dFvdV = 0;     dFidGradP = 0;
+                    dMidS = 0;  dMidX = 0;  dMidV = 0;       dMidGradP = 0;  dMvdX = 0;  dMvdV = 0;
                     dFluxdddx = 0;  dFluxdddy = 0;  dFluxdddz = 0;  dFluxdEdgeNorm = 0;  dFluxdX = 0; 
                     dFluxdFaceNormal = 0;  dFluxdFaceNormalVel = 0;  dFluxdUb = 0;
                     dGradPdddx = 0;  dGradPdddy = 0;  dGradPdddz = 0; 
@@ -997,6 +1023,110 @@
 
       delete [] dCtrlVoldX;
     }
+    if (dViscousFluxdX) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dViscousFluxdX[iSub]) delete dViscousFluxdX[iSub];
+
+      delete [] dViscousFluxdX;
+    }
+
+    if (dMidX) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMidX[iSub]) delete dMidX[iSub];
+
+      delete [] dMidX;
+    }
+
+    if (dMvdX) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMvdX[iSub]) delete dMvdX[iSub];
+
+      delete [] dMvdX;
+    }
+
+    if (dMvdV) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMvdV[iSub]) delete dMvdV[iSub];
+
+      delete [] dMvdV;
+    }
+
+    if (dMidV) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMidV[iSub]) delete dMidV[iSub];
+
+      delete [] dMidV;
+    }
+
+    if (dMidS) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMidS[iSub]) delete dMidS[iSub];
+
+      delete [] dMidS;
+    }
+
+    if (dMidGradP) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dMidGradP[iSub]) delete dMidGradP[iSub];
+
+      delete [] dMidGradP;
+    }
+
+
+    if (dFvdX) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFvdX[iSub]) delete dFvdX[iSub];
+
+      delete [] dFvdX;
+    }
+
+    if (dFidX) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFidX[iSub]) delete dFidX[iSub];
+
+      delete [] dFidX;
+    }
+
+    if (dFidV) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFidV[iSub]) delete dFidV[iSub];
+
+      delete [] dFidV;
+    }
+
+    if (dFvdV) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFvdV[iSub]) delete dFvdV[iSub];
+
+      delete [] dFvdV;
+    }
+
+    if (dFidS) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFidS[iSub]) delete dFidS[iSub];
+
+      delete [] dFidS;
+    }
+
+    if (dFidGradP) {
+#pragma omp parallel for
+      for (int iSub = 0; iSub < this->numLocSub; ++iSub)
+        if (dFidGradP[iSub]) delete dFidGradP[iSub];
+
+      delete [] dFidGradP;
+    }
 
     if (dFluxdddx) {
 #pragma omp parallel for
@@ -1075,6 +1205,18 @@
     dFaceNormdX = new RectangularSparseMat<double,3,3>*[numLocSub];
     dEdgeNormdX = new RectangularSparseMat<double,3,3>*[numLocSub];
     dCtrlVoldX = new RectangularSparseMat<double,3,1>*[numLocSub];
+    dMidX = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dMvdX = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dMvdV = new RectangularSparseMat<double,dim,3>*[numLocSub];
+    dMidV = new RectangularSparseMat<double,dim,3>*[numLocSub];
+    dMidS = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dMidGradP = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dFidX = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dFvdX = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dFidV = new RectangularSparseMat<double,dim,3>*[numLocSub];
+    dFvdV = new RectangularSparseMat<double,dim,3>*[numLocSub];
+    dFidS = new RectangularSparseMat<double,3,3>*[numLocSub];
+    dFidGradP = new RectangularSparseMat<double,3,3>*[numLocSub];
     dRdX = new RectangularSparseMat<double,3,6>*[numLocSub];
     dRdR = new RectangularSparseMat<double,6,6>*[numLocSub];
     dddxdX = new RectangularSparseMat<double,3,dim>*[numLocSub];
@@ -1094,6 +1236,7 @@
     dFluxdFaceNormalVel = new RectangularSparseMat<double,1,dim>*[numLocSub];
     dFluxdUb = new RectangularSparseMat<double,dim,dim>*[numLocSub];
     dFluxdX = new RectangularSparseMat<double,3,dim>*[numLocSub];
+    dViscousFluxdX = new RectangularSparseMat<double,3,dim>*[numLocSub];//YC
     dGradPdddx = new RectangularSparseMat<double,dim,3>*[numLocSub];
     dGradPdddy = new RectangularSparseMat<double,dim,3>*[numLocSub];
     dGradPdddz = new RectangularSparseMat<double,dim,3>*[numLocSub];
@@ -1121,6 +1264,7 @@
   FluxFcn **fluxFcn;
   SubDomain **subDomain;
   Communicator *com;
+  IoData* iod;
 
   DistSVec<double,3> *X;
   DistVec<double> *ctrlVol;
@@ -1206,31 +1350,25 @@
 
   void initializeOperators(double);
   dRdXoperators<dim> *getdRdXop() {return dRdXop;}
-  void constructOperators(DistSVec<double,3> &X, DistVec<double> &ctrlVol, DistSVec<double,dim> &U,
+  void constructOperators(Vec3D &, DistSVec<double,3> &X, DistVec<double> &ctrlVol, DistSVec<double,dim> &U,
                           double dMach, DistSVec<double,dim> &R, DistVec<double> &, DistTimeState<dim> *timeState, PostOperator<dim> *);
-/*
-  void evaluate(int, DistSVec<double,3> &, DistVec<double> &, 
-		DistSVec<double,dim> &, DistSVec<double,dim> &);
-  void evaluate(int , DistSVec<double,3> &, DistVec<double> &,
-                DistSVec<double,dim> &, DistSVec<double,dim> &, Scalar);
-  void evaluate2(int, DistSVec<double,3> &, DistVec<double> &, 
-		 DistSVec<double,dim> &, DistSVec<double,dim> &); 
-*/
+
 
   void evaluate(int, DistSVec<double,3> &, DistVec<double> &,
-                DistSVec<double,dim> &, DistSVec<double,dim> &);
+                DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
   void evaluate(DistExactRiemannSolver<dim> &, int, DistSVec<double,3> &, DistVec<double> &,
-                DistSVec<double,dim> &, DistSVec<double,dim> &) {}
+                DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
   void evaluate(int , DistSVec<double,3> &, DistVec<double> &, 
-                DistSVec<double,dim> &, DistSVec<double,dim> &, Scalar);
-
-  // UH (09/10)
-  // The following function is never called and not implemented.
-  //void evaluate(int , DistSVec<double,3> &, DistVec<double> &, DistVec<int> &,
-  //              DistSVec<double,dim> &, DistSVec<double,dim> &, Scalar);
+                DistSVec<double,dim> &, DistSVec<double,dim> &, Scalar)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
   void evaluate2(int, DistSVec<double,3> &, DistVec<double> &,
-                 DistSVec<double,dim> &, DistSVec<double,dim> &);
+                 DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
   // UH (09/10)
   // The following functions are never called and not implemented.
@@ -1242,22 +1380,39 @@
 
   void evalH(int , DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &);
 
-  void apply(DistSVec<double,neq>        &, DistSVec<double,neq> &);
-  void apply(DistSVec<bcomp,neq>         &, DistSVec<bcomp,neq> &);
-  void apply(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &);
-  void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &) {}
+  void apply(DistSVec<double,neq>        &, DistSVec<double,neq> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
-  void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &);
-  void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y);
+  void apply(DistSVec<bcomp,neq>         &, DistSVec<bcomp,neq> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void apply(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
 // Included (MB)
-  void evaluateInviscid(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
-  void evaluateViscous(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
+  void evaluateInviscid(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
+  void evaluateViscous(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
   //void applyInviscid(DistSVec<double,neq> &, DistSVec<double,neq> &);
   //void applyViscous(DistSVec<double,neq> &, DistSVec<double,neq> &);
 
-  void rstSpaceOp(IoData &, VarFcn *, SpaceOperator<dim> *, bool, SpaceOperator<dim> * = 0);
+  void rstSpaceOp(IoData &, VarFcn *, SpaceOperator<dim> *, bool, SpaceOperator<dim> * = 0)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
 
 };
 /*
diff -r da841a06e630 -r 5d849f9519c9 MatchNode.C
--- a/MatchNode.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/MatchNode.C	Mon Jan 30 20:09:06 2017 -0800
@@ -73,3 +73,17 @@
 }
 
 //------------------------------------------------------------------------------
+
+template<int dim>
+void MatchNodeSet::sendWithMasterFlag(double scale, double (*f)[dim], double (*buffer)[dim], bool *masterFlag, int locOffset)
+{
+
+  for (int i=0; i<numNodes; ++i)
+    for (int k=0; k<dim; ++k) {
+      if(masterFlag[ locOffset + index[i][0] ])
+        buffer[ index[i][2] ][k] = scale * f[ index[i][0] ][k];
+      else
+        buffer[ index[i][2] ][k] = 0.0;
+    }
+
+}
diff -r da841a06e630 -r 5d849f9519c9 MatchNode.h
--- a/MatchNode.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/MatchNode.h	Mon Jan 30 20:09:06 2017 -0800
@@ -34,7 +34,7 @@
   void getDisplacement(int, double, double, double, bool *, double (*)[2][3], double (*)[3], 
 		       double (*)[3], double (*)[3], double (*)[3], double *,
 		       bool isEmbedded); 
-  void getDisplacementSensitivity(bool *, double (*)[2][3], double (*)[3], double *);
+  void getDisplacementSensitivity(bool *, double, double (*)[2][3], double (*)[3], double *);
                        
   void getDisplacement(double (*)[3], int (*)[3], double (*)[3], double (*)[3], double (*)[3], double);
 
@@ -42,6 +42,10 @@
 
   template<int dim>
   void send(double, double (*)[dim], double (*)[dim]);
+
+  template<int dim>
+  void sendWithMasterFlag(double, double (*)[dim], double (*)[dim], bool *, int);
+
   double (*getGap(int, int *))[3];
 
   int size() const { return numNodes; }
diff -r da841a06e630 -r 5d849f9519c9 MatchNodeCore.C
--- a/MatchNodeCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/MatchNodeCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -300,7 +300,7 @@
 
 //------------------------------------------------------------------------------
 
-void MatchNodeSet::getDisplacementSensitivity(bool *flag, double (*disp)[2][3], 
+void MatchNodeSet::getDisplacementSensitivity(bool *flag, double scale, double (*disp)[2][3],
                                               double (*dx)[3], double *norms)
 {
 
@@ -310,11 +310,11 @@
   for (int i=0; i<numNodes; ++i) {
     for (int k=0; k<3; ++k) {
       if (flag==0||flag[ index[i][0] ]) {
-        norms[0] += disp[ index[i][2] ][0][k] * disp[ index[i][2] ][0][k];
-        norms[1] += disp[ index[i][2] ][1][k] * disp[ index[i][2] ][1][k];
+    	  norms[0] += scale * scale * disp[ index[i][2] ][0][k] * disp[ index[i][2] ][0][k];
+    	  norms[1] += scale * scale * disp[ index[i][2] ][1][k] * disp[ index[i][2] ][1][k];
       }
 
-      dx[ index[i][0] ][k] = disp[ index[i][2] ][0][k]; 
+      dx[ index[i][0] ][k] = scale * disp[ index[i][2] ][0][k];
     }
   }
 }
diff -r da841a06e630 -r 5d849f9519c9 MeshMotionHandler.h
--- a/MeshMotionHandler.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/MeshMotionHandler.h	Mon Jan 30 20:09:06 2017 -0800
@@ -45,7 +45,7 @@
   MeshMotionHandler(IoData &, Domain *);
   virtual ~MeshMotionHandler() {}
 
-  virtual void sendForceSensitivity(DistSVec<double,3> *) {} 
+  virtual void sendForceSensitivity(DistSVec<double,3> *, bool applyScale = true) {}
   virtual void cmdCom(bool *) {}
   virtual void getNumParam(int &, int &, double &) {}
   virtual void sendNumParam(int) {}
@@ -53,7 +53,7 @@
   virtual double update(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &) = 0;
   virtual double updateStep1(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &, double * =0) {return 0.0;} 
   virtual double updateStep2(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &) {return 0.0;}
-  virtual void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &) {}
+  virtual void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &, bool applyScale = false) {}
   virtual void setPositionVector(DistSVec<double,3> &) {}
   virtual void storeFluidSuggestedTimestep(double dtf) {dtf0 = dtf;}
   virtual int    structureSubcycling() {return 0;}
@@ -171,7 +171,7 @@
   int getModalMotion(DistSVec<double,3> &);
   void negotiate();
 
-  void sendForceSensitivity(DistSVec<double,3> *); 
+  void sendForceSensitivity(DistSVec<double,3> *, bool applyScale = true);
   void cmdCom(bool *);
   void getNumParam(int &numParam, int &, double &steadyTol);
   void sendNumParam(int numParam);
@@ -179,7 +179,9 @@
   virtual double update(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &);
   double updateStep1(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &, double * =0);
   double updateStep2(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &);
-  void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &);
+  void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &, bool applyScale = false);
+  //void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &, bool applyScale = false);
+  //void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &);
   void setPositionVector(DistSVec<double,3> &X);
   int getAlgNum(); 
 
diff -r da841a06e630 -r 5d849f9519c9 MeshMotionHandlerCore.C
--- a/MeshMotionHandlerCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/MeshMotionHandlerCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -428,9 +428,9 @@
 
 //------------------------------------------------------------------------------
 
-void AeroMeshMotionHandler::sendForceSensitivity(DistSVec<double,3> *dFdS)
+void AeroMeshMotionHandler::sendForceSensitivity(DistSVec<double,3> *dFdS, bool applyScale)
 {
-  strExc->sendForceSensitivity(*dFdS);
+	strExc->sendForce(*dFdS, applyScale);
 }
 
 //------------------------------------------------------------------------------
@@ -673,7 +673,7 @@
   dXdSb = boundary displacement sensitivity
 */
 
-void AeroMeshMotionHandler::updateDStep2(DistSVec<double,3> &X, DistSVec<double,3> &dXdSb)
+void AeroMeshMotionHandler::updateDStep2(DistSVec<double,3> &X, DistSVec<double,3> &dXdSb, bool applyScale)
 {
   int verbose = com->getMaxVerbose();
   Timer *timer;
diff -r da841a06e630 -r 5d849f9519c9 MeshMotionSolver.C
--- a/MeshMotionSolver.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/MeshMotionSolver.C	Mon Jan 30 20:09:06 2017 -0800
@@ -28,7 +28,7 @@
   DefoMeshMotionData &data, MatchNodeSet **matchNodes, 
   Domain *dom, MemoryPool *mp
 ) 
-: domain(dom)
+: domain(dom), adjointFlag(false), stiffFlag(false), sensitivityFlag(false)
 {
 
   com = domain->getCommunicator();
@@ -119,6 +119,13 @@
   if (pc) delete pc;
 }  
 
+void TetMeshMotionSolver::applyProjectorTranspose(DistSVec<double,3> &X)
+{
+   if(meshMotionBCs) meshMotionBCs->applyPt(X);
+}
+
+//------------------------------------------------------------------------------
+
 //------------------------------------------------------------------------------
 //HB: X <- P.X where P is the projector onto the sliding type of constraints
 void
@@ -158,6 +165,27 @@
 
 //------------------------------------------------------------------------------
 
+
+//------------------------------------------------------------------------------
+
+int TetMeshMotionSolver::solveAdjoint(DistSVec<double,3> &rhs, DistSVec<double,3> &lambdaX)  {
+
+  dX0 = &rhs;
+  ns->solve(lambdaX);
+
+  return 0;
+}
+
+//------------------------------------------------------------------------------
+
+void TetMeshMotionSolver::set_dX0(DistSVec<double,3> &dX)
+{
+  dX0 = &dX;
+}
+
+//------------------------------------------------------------------------------
+
+
 void TetMeshMotionSolver::setup(DistSVec<double,3> &X)
 {
   if(cs) cs->setup(X);
@@ -198,35 +226,69 @@
 
   DistMat<PrecScalar,3> *_pc = dynamic_cast<DistMat<PrecScalar,3> *>(pc);
 
+  if(it == 0 && (typeElement == DefoMeshMotionData::NON_LINEAR_FE
+     || typeElement == DefoMeshMotionData::NL_BALL_VERTEX)
+     && adjointFlag) {
+    com->fprintf(stderr, " *** WARNING: Currently, only linear mesh motion solver is allowed for adjoint sensitivity method\n");
+    exit(-1);
+  }
+
   // PJSA FIX
   if(it == 0 && (typeElement == DefoMeshMotionData::NON_LINEAR_FE 
      || typeElement == DefoMeshMotionData::NL_BALL_VERTEX)) {
     X += *dX0; 
   }
 
-  domain->computeStiffAndForce(typeElement, X, F, *mvp, _pc, volStiff);
-
+  if((sensitivityFlag && !stiffFlag) || !sensitivityFlag) {
+    domain->computeStiffAndForce(typeElement, X, F, *mvp, _pc, volStiff);
+    stiffFlag = true;
+  }
+  if(adjointFlag) F = *dX0;  // overwrite F for adjoint method
 
   // PJSA FIX 
-  if (it == 0 && !(typeElement == DefoMeshMotionData::NON_LINEAR_FE 
-      || typeElement == DefoMeshMotionData::NL_BALL_VERTEX)) { // compute F0 <- F0 + [Kib*dXb,0] & X <- X + [0,dXb]
+    if (it == 0) {
+      if(!(typeElement == DefoMeshMotionData::NON_LINEAR_FE
+        || typeElement == DefoMeshMotionData::NL_BALL_VERTEX
+        || adjointFlag) ) { // compute F0 <- F0 + [Kib*dXb,0] & X <- X + [0,dXb]
       mvp->BCs = 0;
       mvp->apply(*dX0, *F0);
       mvp->BCs = meshMotionBCs;
       F += *F0;
       X += *dX0;
+      } else if(adjointFlag) {
+         X += *dX0;
     }
+  }
 
   // PJSA FIX
   if(meshMotionBCs) {
 //		meshMotionBCs->applyD(F);
 //		com->fprintf(stderr,"F*F in TetMeshMotionSolver::computeFunction after applyD in final PJSA FIX is %e.\n", F*F);
 //		meshMotionBCs->applyP(F);
-		meshMotionBCs->applyPD(F);
+	    if(adjointFlag) meshMotionBCs->applyPDt(F);
+	    else meshMotionBCs->applyPD(F);
 	}
 
 }
 
+
+void TetMeshMotionSolver::computeStiffnessMatrix(DistSVec<double,3> &X)
+{
+
+  DistMat<PrecScalar,3> *_pc = dynamic_cast<DistMat<PrecScalar,3> *>(pc);
+  DistSVec<double,3> F(X);
+
+  if(!stiffFlag) {
+    domain->computeStiffAndForce(typeElement, X, F, *mvp, _pc, volStiff);
+    stiffFlag = true;
+  }
+}
+
+//------------------------------------------------------------------------------
+
+
+
+
 //------------------------------------------------------------------------------
 
 void TetMeshMotionSolver::computeJacobian(int it, DistSVec<double,3> &X, 
@@ -265,7 +327,19 @@
   int lits = ksp->solve(rhs, dX);
 
   // PJSA FIX (note rhs has already been projected in computeFunction)
-  if(meshMotionBCs) meshMotionBCs->applyPD(dX);
+  if(meshMotionBCs) {
+    if(adjointFlag) meshMotionBCs->applyPDt(dX);
+    else meshMotionBCs->applyPD(dX);
+  }
+
+  if(adjointFlag) {
+    mvp->BCs = 0;
+    DistSVec<double,3> dummy(dX);
+    dummy = 0.0;
+    mvp->apply(dX, dummy);
+    dX = dummy;
+    mvp->BCs = meshMotionBCs;
+  }
 
   timer->addMeshKspTime(t0);
   
@@ -273,6 +347,15 @@
 
 }
 
+
+//------------------------------------------------------------------------------
+
+void TetMeshMotionSolver::apply(DistSVec<double,3> &b,
+                                DistSVec<double,3> &Ab)
+{
+  mvp->apply(b, Ab);
+}
+
 //--------------------------------------------------------------------------------------------------
 
 EmbeddedALETetMeshMotionSolver::EmbeddedALETetMeshMotionSolver
diff -r da841a06e630 -r 5d849f9519c9 MeshMotionSolver.h
--- a/MeshMotionSolver.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/MeshMotionSolver.h	Mon Jan 30 20:09:06 2017 -0800
@@ -33,9 +33,17 @@
   virtual ~MeshMotionSolver() {}
 
   virtual int solve(DistSVec<double,3> &, DistSVec<double,3> &) = 0;
+  virtual int solveAdjoint(DistSVec<double,3> &, DistSVec<double,3> &) = 0;
   virtual int solveSensitivity(DistSVec<double,3> &, DistSVec<double,3> &) = 0;
   virtual void setup(DistSVec<double,3> &) = 0;
-  virtual void applyProjector(DistSVec<double,3> &dX) {};
+  virtual void applyProjector(DistSVec<double,3> &dX) {}
+  virtual void applyProjectorTranspose(DistSVec<double,3> &dX) {}
+  virtual void setAdjointFlagOn() {}
+  virtual void set_dX0(DistSVec<double,3> &dX) {}
+  virtual void computeStiffnessMatrix(DistSVec<double,3> &) {}
+  virtual int solveLinearSystem(int, DistSVec<double,3> &, DistSVec<double,3> &) { return 0; }
+  virtual void setOperators(DistSVec<double,3> &) {}
+  virtual void apply(DistSVec<double,3> &, DistSVec<double,3> &) {}
 
 };
 
@@ -75,6 +83,9 @@
   Timer *timer;
 
   double volStiff;
+  bool adjointFlag;
+  bool stiffFlag;
+  bool sensitivityFlag;
 
   BCApplier* meshMotionBCs; //HB
 
@@ -85,17 +96,22 @@
   virtual ~TetMeshMotionSolver();
 
   virtual int solve(DistSVec<double,3> &, DistSVec<double,3> &);
+  virtual int solveAdjoint(DistSVec<double,3> &, DistSVec<double,3> &);
   int solveSensitivity(DistSVec<double,3> &, DistSVec<double,3> &) { return 0; };
 
   void applyProjector(DistSVec<double,3> &X);
+  void applyProjectorTranspose(DistSVec<double,3> &X);
+  void apply(DistSVec<double,3> &, DistSVec<double,3> &);
  
   void printf(int, const char *, ...);
   void fprintf(FILE *, const char *, ...);
   virtual void computeFunction(int, DistSVec<double,3> &, DistSVec<double,3> &);
   void recomputeFunction(DistSVec<double,3> &, DistSVec<double,3> &) {}
+  virtual void computeStiffnessMatrix(DistSVec<double,3> &);
   double recomputeResidual(DistSVec<double,3> &, DistSVec<double,3> &) { return 0.0; }
   void computeJacobian(int, DistSVec<double,3> &, DistSVec<double,3> &);
   void setOperators(DistSVec<double,3> &);
+  void setAdjointFlagOn() { adjointFlag = true; }
   int solveLinearSystem(int, DistSVec<double,3> &, DistSVec<double,3> &);
 
   int checkSolution(DistSVec<double,3> &X) { return 0; }
@@ -113,6 +129,7 @@
   DistInfo &getVecInfo() const { return domain->getNodeDistInfo(); }
   
   virtual void setup(DistSVec<double,3> &X);
+  virtual void set_dX0(DistSVec<double,3> &dX);
   TsParameters* getTsParams() { return NULL; }
   ErrorHandler* getErrorHandler() {return NULL; }
 
diff -r da841a06e630 -r 5d849f9519c9 MultiGridKspSolver.h
--- a/MultiGridKspSolver.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/MultiGridKspSolver.h	Mon Jan 30 20:09:06 2017 -0800
@@ -32,6 +32,9 @@
                                                                                                       
   }
 
+  void applyTranspose(DistSVec<Scalar,neq>& x, DistSVec<Scalar,neq>& b) {}
+  void applyT(DistSVec<Scalar,neq>& x, DistSVec<Scalar,neq>& b) {}
+
 };
 
 template<class Scalar,int neq,class Scalar2>                                                          
@@ -86,6 +89,9 @@
     }
     level->assemble(b);
   }
+
+  void applyTranspose(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {}
+  void applyT(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {}
 };
 
 template<class Scalar,int neq,class Scalar2>
diff -r da841a06e630 -r 5d849f9519c9 NavierStokesTerm.h
--- a/NavierStokesTerm.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/NavierStokesTerm.h	Mon Jan 30 20:09:06 2017 -0800
@@ -55,14 +55,31 @@
   double dRedMachNS;
   double dRe_mudMachNS;
   void computeDerivativeOfVelocity(double *[4], double [4][3], double [3]);
+  void computeDerivativeOperatorsOfVelocity(double [4][3][4][4], double [3][4][4]);
+
   void computeDerivativeOfTemperature(double *[4], double *[4], double [4], double &);
+  void computeDerivativeOperatorsOfTemperature(double *[4], double [4][5], double [4]);
+  void computeDerivativeOperatorsOfTemperature2(double *V[4], double dTdV[4][4][5], double dTcgdV[4][5]);
+
   void computeDerivativeOfVelocityGradient(double [4][3], double [4][3], double [4][3], double [4][3], double [3][3]);
+  void computeDerivativeOperatorsOfVelocityGradient(double [4][3], double [4][3], double [3][3][4][3], double [3][3][4][3]);
+
   void computeDerivativeOfTemperatureGradient(double [4][3], double [4][3], double [4], double [4], double [3]);
+  void computeDerivativeOperatorsOfTemperatureGradient(double [4][3], double [4], double [3][4][3], double [3][4]);
+
   void computeDerivativeOfStressTensor(double, double, double, double, double [3][3], double [3][3], double [3][3]);
+  void computeDerivativeOperatorsOfStressTensor(double, double, double[3][3], double [3][3][3][3], double [3][3], double [3][3]);
+
   void computeDerivativeOfHeatFluxVector(double, double, double [3], double [3], double [3]);
+  void computeDerivativeOperatorsOfHeatFluxVector(double, double [3], double [3][3], double [3]);
+
   template<int dim>
   void computeDerivativeOfVolumeTermNS(double, double, double, double, double, double, double [3], double [3], double [3][3], double [3][3],
 			   double [3], double [3], double (*)[dim]);
+  template<int dim>
+  void computeDerivativeOperatorsOfVolumeTermNS(double, double, double, double [3],
+         double [3][3], double [3], double [3][dim], double [3][dim], double [3][dim],
+         double [3][dim][3], double [3][dim][3][3], double [3][dim][3]);
 
   void computeDerivativeOfSurfaceTermNS(double [4][3], double [4][3], Vec3D &, Vec3D &, double *, double *, double *[4], double *[4], double, double *);
   void rstVarNS(IoData &, Communicator*);
@@ -239,6 +256,27 @@
 
 }
 
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfVelocity(double dudV[4][3][4][4], double ducgdV[3][4][4])
+{
+
+  dudV[0][2][0][3] = dudV[0][1][0][2] = dudV[0][0][0][1] = 1.0;
+  dudV[1][2][1][3] = dudV[1][1][1][2] = dudV[1][0][1][1] = 1.0;
+  dudV[2][2][2][3] = dudV[2][1][2][2] = dudV[2][0][2][1] = 1.0;
+  dudV[3][2][3][3] = dudV[3][1][3][2] = dudV[3][0][3][1] = 1.0;
+  double ducgdu[3][4][3] = {0};
+  ducgdu[0][0][0] = ducgdu[0][1][0] = ducgdu[0][2][0] = ducgdu[0][3][0] = fourth;
+  ducgdu[1][0][1] = ducgdu[1][1][1] = ducgdu[1][2][1] = ducgdu[1][3][1] = fourth;
+  ducgdu[2][0][2] = ducgdu[2][1][2] = ducgdu[2][2][2] = ducgdu[2][3][2] = fourth;
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<4; ++j)
+      for(int k=0; k<3; ++k)
+        for(int l=0; l<4; ++l)
+          for(int m=0; m<4; ++m)
+            ducgdV[i][l][m] += ducgdu[i][j][k]*dudV[j][k][l][m];
+}
+
 //------------------------------------------------------------------------------
 
 inline
@@ -272,6 +310,49 @@
 
 //------------------------------------------------------------------------------
 
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfTemperature2(double *V[4], double dTdV[4][4][5], double dTcgdV[4][5])
+{
+  double dTdV0[5] = {0};
+  varFcn->computeDerivativeOperatorsOfTemperature(V[0], dTdV0);
+  dTdV[0][0][0] = dTdV0[0];  dTdV[0][0][4] = dTdV0[4];
+  double dTdV1[5] = {0};
+  varFcn->computeDerivativeOperatorsOfTemperature(V[1], dTdV1);
+  dTdV[1][1][0] = dTdV1[0];  dTdV[1][1][4] = dTdV1[4];
+  double dTdV2[5] = {0};
+  varFcn->computeDerivativeOperatorsOfTemperature(V[2], dTdV2);
+  dTdV[2][2][0] = dTdV2[0];  dTdV[2][2][4] = dTdV2[4];
+  double dTdV3[5] = {0};
+  varFcn->computeDerivativeOperatorsOfTemperature(V[3], dTdV3);
+  dTdV[3][3][0] = dTdV3[0];  dTdV[3][3][4] = dTdV3[4];
+
+  for(int k=0; k<4; ++k)
+    for(int j=0; j<4; ++j)
+      for(int i=0; i<5; ++i)
+        dTcgdV[j][i] += dTdV[k][j][i]*fourth;
+}
+
+//------------------------------------------------------------------------------
+
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfTemperature(double *V[4], double dTdV[4][5], double dTcgdV[4])
+{
+
+  varFcn->computeDerivativeOperatorsOfTemperature(V[0], dTdV[0]);
+  varFcn->computeDerivativeOperatorsOfTemperature(V[1], dTdV[1]);
+  varFcn->computeDerivativeOperatorsOfTemperature(V[2], dTdV[2]);
+  varFcn->computeDerivativeOperatorsOfTemperature(V[3], dTdV[3]);
+
+  for(int j=0; j<4; ++j)
+    for(int i=0; i<5; ++i)
+    dTcgdV[j] = dTdV[j][i]*fourth;
+}
+
+//------------------------------------------------------------------------------
+
+
 inline
 void NavierStokesTerm::computeVelocityGradient(double dp1dxj[4][3], double u[4][3],
 					       double dudxj[3][3])
@@ -362,6 +443,44 @@
 
 //------------------------------------------------------------------------------
 
+
+
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfVelocityGradient(double dp1dxj[4][3], double u[4][3],
+                                                                    double ddudxjddp1dxj[3][3][4][3], double ddudxjdu[3][3][4][3])
+{
+
+  if(ddudxjddp1dxj) {
+    ddudxjddp1dxj[0][0][0][0] = u[0][0];  ddudxjddp1dxj[0][0][1][0] = u[1][0];  ddudxjddp1dxj[0][0][2][0] = u[2][0];  ddudxjddp1dxj[0][0][3][0] = u[3][0];
+    ddudxjddp1dxj[0][1][0][1] = u[0][0];  ddudxjddp1dxj[0][1][1][1] = u[1][0];  ddudxjddp1dxj[0][1][2][1] = u[2][0];  ddudxjddp1dxj[0][1][3][1] = u[3][0];
+    ddudxjddp1dxj[0][2][0][2] = u[0][0];  ddudxjddp1dxj[0][2][1][2] = u[1][0];  ddudxjddp1dxj[0][2][2][2] = u[2][0];  ddudxjddp1dxj[0][2][3][2] = u[3][0];
+    ddudxjddp1dxj[1][0][0][0] = u[0][1];  ddudxjddp1dxj[1][0][1][0] = u[1][1];  ddudxjddp1dxj[1][0][2][0] = u[2][1];  ddudxjddp1dxj[1][0][3][0] = u[3][1];
+    ddudxjddp1dxj[1][1][0][1] = u[0][1];  ddudxjddp1dxj[1][1][1][1] = u[1][1];  ddudxjddp1dxj[1][1][2][1] = u[2][1];  ddudxjddp1dxj[1][1][3][1] = u[3][1];
+    ddudxjddp1dxj[1][2][0][2] = u[0][1];  ddudxjddp1dxj[1][2][1][2] = u[1][1];  ddudxjddp1dxj[1][2][2][2] = u[2][1];  ddudxjddp1dxj[1][2][3][2] = u[3][1];
+    ddudxjddp1dxj[2][0][0][0] = u[0][2];  ddudxjddp1dxj[2][0][1][0] = u[1][2];  ddudxjddp1dxj[2][0][2][0] = u[2][2];  ddudxjddp1dxj[2][0][3][0] = u[3][2];
+    ddudxjddp1dxj[2][1][0][1] = u[0][2];  ddudxjddp1dxj[2][1][1][1] = u[1][2];  ddudxjddp1dxj[2][1][2][1] = u[2][2];  ddudxjddp1dxj[2][1][3][1] = u[3][2];
+    ddudxjddp1dxj[2][2][0][2] = u[0][2];  ddudxjddp1dxj[2][2][1][2] = u[1][2];  ddudxjddp1dxj[2][2][2][2] = u[2][2];  ddudxjddp1dxj[2][2][3][2] = u[3][2];
+  }
+
+  if(ddudxjdu) {
+    ddudxjdu[0][0][0][0] = dp1dxj[0][0];  ddudxjdu[0][0][1][0] = dp1dxj[1][0];  ddudxjdu[0][0][2][0] = dp1dxj[2][0];  ddudxjdu[0][0][3][0] = dp1dxj[3][0];
+    ddudxjdu[0][1][0][0] = dp1dxj[0][1];  ddudxjdu[0][1][1][0] = dp1dxj[1][1];  ddudxjdu[0][1][2][0] = dp1dxj[2][1];  ddudxjdu[0][1][3][0] = dp1dxj[3][1];
+    ddudxjdu[0][2][0][0] = dp1dxj[0][2];  ddudxjdu[0][2][1][0] = dp1dxj[1][2];  ddudxjdu[0][2][2][0] = dp1dxj[2][2];  ddudxjdu[0][2][3][0] = dp1dxj[3][2];
+    ddudxjdu[1][0][0][1] = dp1dxj[0][0];  ddudxjdu[1][0][1][1] = dp1dxj[1][0];  ddudxjdu[1][0][2][1] = dp1dxj[2][0];  ddudxjdu[1][0][3][1] = dp1dxj[3][0];
+    ddudxjdu[1][1][0][1] = dp1dxj[0][1];  ddudxjdu[1][1][1][1] = dp1dxj[1][1];  ddudxjdu[1][1][2][1] = dp1dxj[2][1];  ddudxjdu[1][1][3][1] = dp1dxj[3][1];
+    ddudxjdu[1][2][0][1] = dp1dxj[0][2];  ddudxjdu[1][2][1][1] = dp1dxj[1][2];  ddudxjdu[1][2][2][1] = dp1dxj[2][2];  ddudxjdu[1][2][3][1] = dp1dxj[3][2];
+    ddudxjdu[2][0][0][2] = dp1dxj[0][0];  ddudxjdu[2][0][1][2] = dp1dxj[1][0];  ddudxjdu[2][0][2][2] = dp1dxj[2][0];  ddudxjdu[2][0][3][2] = dp1dxj[3][0];
+    ddudxjdu[2][1][0][2] = dp1dxj[0][1];  ddudxjdu[2][1][1][2] = dp1dxj[1][1];  ddudxjdu[2][1][2][2] = dp1dxj[2][1];  ddudxjdu[2][1][3][2] = dp1dxj[3][1];
+    ddudxjdu[2][2][0][2] = dp1dxj[0][2];  ddudxjdu[2][2][1][2] = dp1dxj[1][2];  ddudxjdu[2][2][2][2] = dp1dxj[2][2];  ddudxjdu[2][2][3][2] = dp1dxj[3][2];
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
 inline
 void NavierStokesTerm::computeTemperatureGradient(double dp1dxj[4][3], double T[4],
 						  double dTdxj[3])
@@ -399,6 +518,45 @@
 
 //------------------------------------------------------------------------------
 
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfTemperatureGradient(double dp1dxj[4][3], double T[4],
+						  double ddTdxjddp1dxj[3][4][3], double ddTdxjdT[3][4])
+{
+
+  ddTdxjddp1dxj[0][0][0] = T[0];
+  ddTdxjddp1dxj[0][1][0] = T[1];
+  ddTdxjddp1dxj[0][2][0] = T[2];
+  ddTdxjddp1dxj[0][3][0] = T[3];
+  ddTdxjdT[0][0] = dp1dxj[0][0];
+  ddTdxjdT[0][1] = dp1dxj[1][0];
+  ddTdxjdT[0][2] = dp1dxj[2][0];
+  ddTdxjdT[0][3] = dp1dxj[3][0];
+
+  ddTdxjddp1dxj[1][0][1] = T[0];
+  ddTdxjddp1dxj[1][1][1] = T[1];
+  ddTdxjddp1dxj[1][2][1] = T[2];
+  ddTdxjddp1dxj[1][3][1] = T[3];
+  ddTdxjdT[1][0] = dp1dxj[0][1];
+  ddTdxjdT[1][1] = dp1dxj[1][1];
+  ddTdxjdT[1][2] = dp1dxj[2][1];
+  ddTdxjdT[1][3] = dp1dxj[3][1];
+
+  ddTdxjddp1dxj[2][0][2] = T[0];
+  ddTdxjddp1dxj[2][1][2] = T[1];
+  ddTdxjddp1dxj[2][2][2] = T[2];
+  ddTdxjddp1dxj[2][3][2] = T[3];
+  ddTdxjdT[2][0] = dp1dxj[0][2];
+  ddTdxjdT[2][1] = dp1dxj[1][2];
+  ddTdxjdT[2][2] = dp1dxj[2][2];
+  ddTdxjdT[2][3] = dp1dxj[3][2];
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
 inline
 void NavierStokesTerm::computeStressTensor(double mu, double lambda, double dudxj[3][3], double tij[3][3])
 {
@@ -441,6 +599,43 @@
 
 //------------------------------------------------------------------------------
 
+
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfStressTensor(double mu, double lambda, double dudxj[3][3],
+                                                                double dtijddudxj[3][3][3][3], double dtijdmu[3][3], double dtijdlambda[3][3])
+{
+
+  double div = dudxj[0][0] + dudxj[1][1] + dudxj[2][2];
+  if(dtijdlambda) {
+    dtijdlambda[0][0] = dtijdlambda[1][1] = dtijdlambda[2][2] = div;
+  }
+  if(dtijdmu) {
+    dtijdmu[0][0] =  2.0*dudxj[0][0];
+    dtijdmu[1][1] =  2.0*dudxj[1][1];
+    dtijdmu[2][2] =  2.0*dudxj[2][2];
+    dtijdmu[1][0] = dtijdmu[0][1] = (dudxj[1][0] + dudxj[0][1]);
+    dtijdmu[2][0] = dtijdmu[0][2] = (dudxj[2][0] + dudxj[0][2]);
+    dtijdmu[2][1] = dtijdmu[1][2] = (dudxj[2][1] + dudxj[1][2]);
+  }
+  if(dtijddudxj) {
+    dtijddudxj[0][0][0][0] = dtijddudxj[1][1][0][0] = dtijddudxj[2][2][0][0] = lambda;
+    dtijddudxj[0][0][1][1] = dtijddudxj[1][1][1][1] = dtijddudxj[2][2][1][1] = lambda;
+    dtijddudxj[0][0][2][2] = dtijddudxj[1][1][2][2] = dtijddudxj[2][2][2][2] = lambda;
+    dtijddudxj[0][0][0][0] += 2.0 * mu;
+    dtijddudxj[1][1][1][1] += 2.0 * mu;
+    dtijddudxj[2][2][2][2] += 2.0 * mu;
+    dtijddudxj[1][0][0][1] = dtijddudxj[1][0][1][0] = dtijddudxj[0][1][0][1] = dtijddudxj[0][1][1][0] = mu;
+    dtijddudxj[2][0][0][2] = dtijddudxj[2][0][2][0] = dtijddudxj[0][2][0][2] = dtijddudxj[0][2][2][0] = mu;
+    dtijddudxj[2][1][1][2] = dtijddudxj[2][1][2][1] = dtijddudxj[1][2][1][2] = dtijddudxj[1][2][2][1] = mu;
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
 inline
 void NavierStokesTerm::computeHeatFluxVector(double kappa, double dTdxj[3], double qj[3])
 {
@@ -466,6 +661,23 @@
 
 //------------------------------------------------------------------------------
 
+
+// Included (YC)
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfHeatFluxVector(double kappa, double dTdxj[3], double dqjddTdxj[3][3], double dqjdkappa[3])
+{
+
+  dqjddTdxj[2][2] = dqjddTdxj[1][1] = dqjddTdxj[0][0] = -kappa;
+  dqjdkappa[0] = -dTdxj[0];
+  dqjdkappa[1] = -dTdxj[1];
+  dqjdkappa[2] = -dTdxj[2];
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
 template<int dim>
 inline
 void NavierStokesTerm::computeVolumeTermNS(double mu, double lambda, double kappa, double u[3], 
@@ -501,6 +713,56 @@
 
 //------------------------------------------------------------------------------
 
+// Included (YC)
+template<int dim>
+inline
+void NavierStokesTerm::computeDerivativeOperatorsOfVolumeTermNS(double mu, double lambda, double kappa, double u[3],
+					   double dudxj[3][3], double dTdxj[3],
+					   double drdmu[3][dim], double drdlambda[3][dim], double drdkappa[3][dim],
+             double drdu[3][dim][3], double drddudxj[3][dim][3][3], double drddTdxj[3][dim][3])
+{
+  double tij[3][3];
+  computeStressTensor(mu, lambda, dudxj, tij);
+
+  double dtijdlambda[3][3] = {0}, dtijddudxj[3][3][3][3] = {0}, dtijdmu[3][3] = {0};
+  computeDerivativeOperatorsOfStressTensor(mu, lambda, dudxj, dtijddudxj, dtijdmu, dtijdlambda);
+
+  double dqjdkappa[3] = {0}, dqjddTdxj[3][3] = {0};
+  computeDerivativeOperatorsOfHeatFluxVector(kappa, dTdxj, dqjddTdxj, dqjdkappa);
+
+  double drdtij[3][dim][3][3] = {0};
+  drdtij[0][3][2][0] = drdtij[0][2][1][0] = drdtij[0][1][0][0] = 1.0;
+  drdtij[1][3][2][1] = drdtij[1][2][1][1] = drdtij[1][1][0][1] = 1.0;
+  drdtij[2][3][2][2] = drdtij[2][2][1][2] = drdtij[2][1][0][2] = 1.0;
+  drdtij[0][4][0][0] = drdtij[1][4][0][1] = drdtij[2][4][0][2] = u[0];
+  drdtij[0][4][1][0] = drdtij[1][4][1][1] = drdtij[2][4][1][2] = u[1];
+  drdtij[0][4][2][0] = drdtij[1][4][2][1] = drdtij[2][4][2][2] = u[2];
+  drdu[0][4][0] = tij[0][0];  drdu[0][4][1] = tij[1][0];  drdu[0][4][2] = tij[2][0];
+  drdu[1][4][0] = tij[0][1];  drdu[1][4][1] = tij[1][1];  drdu[1][4][2] = tij[2][1];
+  drdu[2][4][0] = tij[0][2];  drdu[2][4][1] = tij[1][2];  drdu[2][4][2] = tij[2][2];
+  double drdqj[3][dim][3] = {0};
+  drdqj[2][4][2] = drdqj[1][4][1] = drdqj[0][4][0] = -1.0;
+
+  for(int i=0; i<3; ++i)
+    for(int j=0; j<dim; ++j)
+      for(int k=0; k<3; ++k) {
+        drdkappa[i][j] += drdqj[i][j][k]*dqjdkappa[k];
+        for(int l=0; l<3; ++l) {
+          drddTdxj[i][j][l] += drdqj[i][j][k]*dqjddTdxj[k][l];
+          drdmu[i][j] += drdtij[i][j][k][l]*dtijdmu[k][l];
+          drdlambda[i][j] += drdtij[i][j][k][l]*dtijdlambda[k][l];
+          for(int m=0; m<3; ++m)
+            for(int n=0; n<3; ++n) {
+              drddudxj[i][j][m][n] += drdtij[i][j][k][l]*dtijddudxj[k][l][m][n];
+            }
+        }
+      }
+
+}
+
+//------------------------------------------------------------------------------
+
+
 // Included (MB)
 template<int dim>
 inline
diff -r da841a06e630 -r 5d849f9519c9 PostFcn.C
--- a/PostFcn.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/PostFcn.C	Mon Jan 30 20:09:06 2017 -0800
@@ -324,8 +324,8 @@
 // Included (MB)
 void PostFcnEuler::computeDerivativeOfForce(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],
                                             Vec3D &n, Vec3D &dn, double d2w[3], double *Vwall, double *dVwall,
-					    double *Vface[3],  double *dVface[3], double *Vtet[4], double *dVtet[4], double dS[3],  
-					    double *pin,  Vec3D &dFi0, Vec3D &dFi1, Vec3D &dFi2, Vec3D &dFv, double dPdx[3][3], double ddPdx[3][3], int hydro)
+											double *Vface[3],  double *dVface[3], double *Vtet[4], double *dVtet[4], double dS[3],
+											double *pin,  Vec3D &dFi0, Vec3D &dFi1, Vec3D &dFi2, Vec3D &dFv, double dPdx[3][3], double ddPdx[3][3], int hydro)
 {
 
   double pcg[3], p[3];
@@ -428,6 +428,325 @@
 }
 //-----------------------------------------------------------------------------------
 
+//------------------------------------------------------------------------------
+
+void PostFcnEuler::computeDerivativeOfForce2(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],
+                                             Vec3D &n, Vec3D &dn, double d2w[3], double *Vwall, double *dVwall,
+                                             double *Vface[3],  double *dVface[3], double *Vtet[4], double *dVtet[4], double dS[3],
+                                             double *pin,  Vec3D &dFi0, Vec3D &dFi1, Vec3D &dFi2, Vec3D &dFv, double dPdx[3][3], double ddPdx[3][3], int hydro)
+{
+  double pcg[3], p[3];
+  double dPcg[3];
+  double pcgin;
+  double dPcgin;
+  int i;
+
+  double dPinfty = dpinfty * dS[0];
+  double dPinftydS[3] = {0};
+  dPinftydS[0] = dpinfty;
+  double dPcgdVface[3][5] = {0};
+
+  if (hydro == 0) {
+    for(i=0;i<3;i++) {
+      pcg[i] = varFcn->getPressure(Vface[i]);
+      varFcn->computedPdV(dPcgdVface[i]);
+      dPcg[i] = 0.0;
+      for(int l=0; l<5; ++l) {
+        dPcg[i] += dPcgdVface[i][l]*dVface[i][l];
+      }
+    }
+  } else if (hydro == 1) { // hydrostatic pressure
+    for(i=0;i<3;i++) {
+      pcg[i]  = varFcn->hydrostaticPressure(Vface[i][0],Xface[i]);
+      dPcg[i] = varFcn->DerivativeHydrostaticPressure(dVface[i][0], Vface[i][0], Xface[i], dXface[i]);
+    }
+  } else if (hydro == 2){ // hydrodynamic pressure
+    for (i=0; i<3; i++) {
+      pcg[i]  = varFcn->hydrodynamicPressure(Vface[i], Xface[i]);
+      dPcg[i] = varFcn->getPressure(dVface[i])
+              - varFcn->DerivativeHydrostaticPressure(dVface[i][0], Vface[i][0], Xface[i], dXface[i]);
+    }
+  }
+
+  if (pin)
+    pcgin = *pin;
+  else
+    if (hydro == 0)
+      pcgin = pinfty;
+    else
+      pcgin = 0.0;
+
+  double dPcgindS[3] = {0};
+  double dPcgindPinfty(0);
+  if (pin) {
+    if (dimFlag) {
+//      dPcgin = (-2.0*(*pin)/mach) * dS[0];
+      dPcgindS[0] = -2.0*(*pin)/mach;
+     } else {
+//      dPcgin = dPin * dS[0];
+      dPcgindS[0] = dPin;
+     }
+  }
+  else {
+    if (hydro == 0) {
+      dPcgin = dPinfty;
+      dPcgindPinfty = 1.0;
+    } else
+      dPcgin = 0.0;
+  }
+  for(int j=0; j<3; ++j) {
+    dPcgindS[j] += dPcgindPinfty*dPinftydS[j];
+    dPcgin += dPcgindS[j]*dS[j];
+  }
+
+  p[0] = (pcg[0] - pcgin) ;
+  p[1] = (pcg[1] - pcgin) ;
+  p[2] = (pcg[2] - pcgin) ;
+
+ Vec3D xC, xS, xP, x[3];
+ Vec3D temp = 0.0;;
+ for(int i = 0; i<3; i++) {
+  xC[i] = Xface[0][i];
+  xS[i] = Xface[1][i];
+  xP[i] = Xface[2][i];
+ }
+
+ x[0] = (7.0/18.0)*(xS + xP - 2.0*xC);
+ x[1] = (7.0/18.0)*(xP + xC - 2.0*xS);
+ x[2] = (7.0/18.0)*(xC + xS - 2.0*xP);
+
+ double dx0dXface0[3] = {0};   double dx0dXface1[3] = {0};   double dx0dXface2[3] = {0};
+ double dx1dXface0[3] = {0};   double dx1dXface1[3] = {0};   double dx1dXface2[3] = {0};
+ double dx2dXface0[3] = {0};   double dx2dXface1[3] = {0};   double dx2dXface2[3] = {0};
+
+ for(int i=0; i<3; ++i) {
+   dx0dXface0[i] = -7.0/9.0;   dx0dXface1[i] = 7.0/18.0;   dx0dXface2[i] = 7.0/18.0;
+   dx1dXface0[i] = 7.0/18.0;   dx1dXface1[i] = -7.0/9.0;   dx1dXface2[i] = 7.0/18.0;
+   dx2dXface0[i] = 7.0/18.0;   dx2dXface1[i] = 7.0/18.0;   dx2dXface2[i] = -7.0/9.0;
+ }
+
+ double dTempdPcg[3] = {0}, dTempdPcgin[3] = {0};
+ double dTempdx[3][3] = {0}, dTempddPdx[3][3] = {0};
+ for(int i=0; i<3; ++i) {
+   dTempdPcg[i] = 2.0;
+   dTempdPcgin[i] = -2.0;
+   temp[i] += 2.0*p[i];
+   for(int j=0; j<3; ++j) {
+     dTempdx[i][j] = dPdx[i][j];
+     dTempddPdx[i][j] = x[i][j];
+     temp[i] += dPdx[i][j]*x[i][j];
+   }
+ }
+
+ double dFidTemp[3] = {0}, dFi0dn[3] = {0}, dFi1dn[3] = {0}, dFi2dn[3] = {0};
+
+ for(int i=0; i<3; ++i) {
+   dFidTemp[i] = 1.0/6.0*n[i];
+   dFi0dn[i] = (1.0/6.0*temp[0]);
+   dFi1dn[i] = (1.0/6.0*temp[1]);
+   dFi2dn[i] = (1.0/6.0*temp[2]);
+ }
+
+ dFi0 = 0.0;  dFi1 = 0.0;  dFi2 = 0.0;
+
+ double dFi0dPcg0[3] = {0}, dFi1dPcg1[3] = {0}, dFi2dPcg2[3] = {0};
+ double dFi0dPcgin[3] = {0}, dFi1dPcgin[3] = {0}, dFi2dPcgin[3] = {0};
+ double dFi0ddPdx[3][3] = {0}, dFi1ddPdx[3][3] = {0}, dFi2ddPdx[3][3] = {0};
+ double dFi0dXface0[3][3] = {0}, dFi0dXface1[3][3] = {0}, dFi0dXface2[3][3] = {0};
+ double dFi1dXface0[3][3] = {0}, dFi1dXface1[3][3] = {0}, dFi1dXface2[3][3] = {0};
+ double dFi2dXface0[3][3] = {0}, dFi2dXface1[3][3] = {0}, dFi2dXface2[3][3] = {0};
+ double dFi0dS[3][3] = {0}, dFi1dS[3][3] = {0}, dFi2dS[3][3] = {0};
+ double dFi0dVface[3][5] = {0}, dFi1dVface[3][5] = {0}, dFi2dVface[3][5] = {0};
+ for(int i=0; i<3; ++i) {
+   dFi0dPcg0[i] = dFidTemp[i]*dTempdPcg[0];
+   dFi1dPcg1[i] = dFidTemp[i]*dTempdPcg[1];
+   dFi2dPcg2[i] = dFidTemp[i]*dTempdPcg[2];
+   dFi0dPcgin[i] = dFidTemp[i]*dTempdPcgin[0];
+   dFi1dPcgin[i] = dFidTemp[i]*dTempdPcgin[1];
+   dFi2dPcgin[i] = dFidTemp[i]*dTempdPcgin[2];
+
+   dFi0[i] += dFi0dn[i]*dn[i];
+   dFi1[i] += dFi1dn[i]*dn[i];
+   dFi2[i] += dFi2dn[i]*dn[i];
+
+   for(int l=0; l<5; ++l) {
+     dFi0dVface[i][l] = dFi0dPcg0[i]*dPcgdVface[0][l];
+     dFi1dVface[i][l] = dFi1dPcg1[i]*dPcgdVface[1][l];
+     dFi2dVface[i][l] = dFi2dPcg2[i]*dPcgdVface[2][l];
+
+     dFi0[i] += dFi0dVface[i][l]*dVface[0][l];
+     dFi1[i] += dFi1dVface[i][l]*dVface[1][l];
+     dFi2[i] += dFi2dVface[i][l]*dVface[2][l];
+   }
+   for(int j=0; j<3; ++j) {
+     dFi0dS[i][j] = dFi0dPcgin[i]*dPcgindS[j];
+     dFi1dS[i][j] = dFi1dPcgin[i]*dPcgindS[j];
+     dFi2dS[i][j] = dFi2dPcgin[i]*dPcgindS[j];
+     dFi0ddPdx[i][j] = dFidTemp[i]*dTempddPdx[0][j];
+     dFi1ddPdx[i][j] = dFidTemp[i]*dTempddPdx[1][j];
+     dFi2ddPdx[i][j] = dFidTemp[i]*dTempddPdx[2][j];
+     dFi0dXface0[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface0[j];
+     dFi0dXface1[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface1[j];
+     dFi0dXface2[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface2[j];
+     dFi1dXface0[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface0[j];
+     dFi1dXface1[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface1[j];
+     dFi1dXface2[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface2[j];
+     dFi2dXface0[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface0[j];
+     dFi2dXface1[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface1[j];
+     dFi2dXface2[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface2[j];
+
+     dFi0[i] += dFi0ddPdx[i][j]*ddPdx[0][j] + dFi0dXface0[i][j]*dXface[0][j] + dFi0dXface1[i][j]*dXface[1][j] + dFi0dXface2[i][j]*dXface[2][j] + dFi0dS[i][j]*dS[j];
+     dFi1[i] += dFi1ddPdx[i][j]*ddPdx[1][j] + dFi1dXface0[i][j]*dXface[0][j] + dFi1dXface1[i][j]*dXface[1][j] + dFi1dXface2[i][j]*dXface[2][j] + dFi1dS[i][j]*dS[j];
+     dFi2[i] += dFi2ddPdx[i][j]*ddPdx[2][j] + dFi2dXface0[i][j]*dXface[0][j] + dFi2dXface1[i][j]*dXface[1][j] + dFi2dXface2[i][j]*dXface[2][j] + dFi2dS[i][j]*dS[j];
+   }
+ }
+
+ dFv = 0.0;
+
+}
+
+//------------------------------------------------------------------------------
+
+void PostFcnEuler::computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                     double dPdx[3][3], int hydro, double dFi0dn[3], double dFi1dn[3], double dFi2dn[3],
+                                                     double dFi0ddPdx[3][3], double dFi1ddPdx[3][3], double dFi2ddPdx[3][3],
+                                                     double dFi0dXface0[3][3], double dFi0dXface1[3][3], double dFi0dXface2[3][3],
+                                                     double dFi1dXface0[3][3], double dFi1dXface1[3][3], double dFi1dXface2[3][3],
+                                                     double dFi2dXface0[3][3], double dFi2dXface1[3][3], double dFi2dXface2[3][3],
+                                                     double dFi0dS[3][3], double dFi1dS[3][3], double dFi2dS[3][3],
+                                                     double dFi0dVface[3][5], double dFi1dVface[3][5], double dFi2dVface[3][5],
+                                                     double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5])
+{
+  double pcg[3], p[3];
+  double pcgin;
+  int i;
+
+  double dPinftydS[3] = {0};
+  dPinftydS[0] = dpinfty;
+  double dPcgdVface[3][5] = {0};
+
+  if (hydro == 0) {
+    for(i=0;i<3;i++) {
+      pcg[i] = varFcn->getPressure(Vface[i]);
+      varFcn->computedPdV(dPcgdVface[i]);
+    }
+  } else if (hydro == 1) { // hydrostatic pressure
+  } else if (hydro == 2){ // hydrodynamic pressure
+  }
+
+  if (pin)
+    pcgin = *pin;
+  else
+    if (hydro == 0)
+      pcgin = pinfty;
+    else
+      pcgin = 0.0;
+
+  double dPcgindS[3] = {0};
+  double dPcgindPinfty(0);
+  if (pin) {
+    if (dimFlag) {
+//      dPcgin = (-2.0*(*pin)/mach) * dS[0];
+      dPcgindS[0] = -2.0*(*pin)/mach;
+     } else {
+//      dPcgin = dPin * dS[0];
+      dPcgindS[0] = dPin;
+     }
+  }
+  else {
+    if (hydro == 0) {
+      dPcgindPinfty = 1.0;
+    }
+  }
+  for(int j=0; j<3; ++j) {
+    dPcgindS[j] += dPcgindPinfty*dPinftydS[j];
+  }
+
+  p[0] = (pcg[0] - pcgin) ;
+  p[1] = (pcg[1] - pcgin) ;
+  p[2] = (pcg[2] - pcgin) ;
+
+ Vec3D xC, xS, xP, x[3];
+ Vec3D temp = 0.0;;
+ for(int i = 0; i<3; i++) {
+  xC[i] = Xface[0][i];
+  xS[i] = Xface[1][i];
+  xP[i] = Xface[2][i];
+ }
+
+ x[0] = (7.0/18.0)*(xS + xP - 2.0*xC);
+ x[1] = (7.0/18.0)*(xP + xC - 2.0*xS);
+ x[2] = (7.0/18.0)*(xC + xS - 2.0*xP);
+
+ double dx0dXface0[3] = {0};   double dx0dXface1[3] = {0};   double dx0dXface2[3] = {0};
+ double dx1dXface0[3] = {0};   double dx1dXface1[3] = {0};   double dx1dXface2[3] = {0};
+ double dx2dXface0[3] = {0};   double dx2dXface1[3] = {0};   double dx2dXface2[3] = {0};
+
+ for(int i=0; i<3; ++i) {
+   dx0dXface0[i] = -7.0/9.0;   dx0dXface1[i] = 7.0/18.0;   dx0dXface2[i] = 7.0/18.0;
+   dx1dXface0[i] = 7.0/18.0;   dx1dXface1[i] = -7.0/9.0;   dx1dXface2[i] = 7.0/18.0;
+   dx2dXface0[i] = 7.0/18.0;   dx2dXface1[i] = 7.0/18.0;   dx2dXface2[i] = -7.0/9.0;
+ }
+
+ double dTempdPcg[3] = {0}, dTempdPcgin[3] = {0};
+ double dTempdx[3][3] = {0}, dTempddPdx[3][3] = {0};
+ for(int i=0; i<3; ++i) {
+   dTempdPcg[i] = 2.0;
+   dTempdPcgin[i] = -2.0;
+   temp[i] += 2.0*p[i];
+   for(int j=0; j<3; ++j) {
+     dTempdx[i][j] = dPdx[i][j];
+     dTempddPdx[i][j] = x[i][j];
+     temp[i] += dPdx[i][j]*x[i][j];
+   }
+ }
+
+ double dFidTemp[3] = {0};
+
+ for(int i=0; i<3; ++i) {
+   dFidTemp[i] = 1.0/6.0*n[i];
+   dFi0dn[i] = (1.0/6.0*temp[0]);
+   dFi1dn[i] = (1.0/6.0*temp[1]);
+   dFi2dn[i] = (1.0/6.0*temp[2]);
+ }
+
+ double dFi0dPcg0[3] = {0}, dFi1dPcg1[3] = {0}, dFi2dPcg2[3] = {0};
+ double dFi0dPcgin[3] = {0}, dFi1dPcgin[3] = {0}, dFi2dPcgin[3] = {0};
+ for(int i=0; i<3; ++i) {
+   dFi0dPcg0[i] = dFidTemp[i]*dTempdPcg[0];
+   dFi1dPcg1[i] = dFidTemp[i]*dTempdPcg[1];
+   dFi2dPcg2[i] = dFidTemp[i]*dTempdPcg[2];
+   dFi0dPcgin[i] = dFidTemp[i]*dTempdPcgin[0];
+   dFi1dPcgin[i] = dFidTemp[i]*dTempdPcgin[1];
+   dFi2dPcgin[i] = dFidTemp[i]*dTempdPcgin[2];
+
+   for(int l=0; l<5; ++l) {
+     dFi0dVface[i][l] = dFi0dPcg0[i]*dPcgdVface[0][l];
+     dFi1dVface[i][l] = dFi1dPcg1[i]*dPcgdVface[1][l];
+     dFi2dVface[i][l] = dFi2dPcg2[i]*dPcgdVface[2][l];
+   }
+   for(int j=0; j<3; ++j) {
+     dFi0dS[i][j] = dFi0dPcgin[i]*dPcgindS[j];
+     dFi1dS[i][j] = dFi1dPcgin[i]*dPcgindS[j];
+     dFi2dS[i][j] = dFi2dPcgin[i]*dPcgindS[j];
+     dFi0ddPdx[i][j] = dFidTemp[i]*dTempddPdx[0][j];
+     dFi1ddPdx[i][j] = dFidTemp[i]*dTempddPdx[1][j];
+     dFi2ddPdx[i][j] = dFidTemp[i]*dTempddPdx[2][j];
+     dFi0dXface0[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface0[j];
+     dFi0dXface1[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface1[j];
+     dFi0dXface2[i][j] = dFidTemp[i]*dTempdx[0][j]*dx0dXface2[j];
+     dFi1dXface0[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface0[j];
+     dFi1dXface1[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface1[j];
+     dFi1dXface2[i][j] = dFidTemp[i]*dTempdx[1][j]*dx1dXface2[j];
+     dFi2dXface0[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface0[j];
+     dFi2dXface1[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface1[j];
+     dFi2dXface2[i][j] = dFidTemp[i]*dTempdx[2][j]*dx2dXface2[j];
+   }
+ }
+
+}
+
+
 void PostFcnEuler::computeForceTransmitted(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3],
 					   double *Vwall, double *Vface[3], double *Vtet[4],
 					   double *pin, Vec3D &Fi0, Vec3D &Fi1, Vec3D &Fi2, Vec3D &Fv, double dPdx[3][3], int hydro,int fid)
@@ -701,471 +1020,19 @@
 //------------------------------------------------------------------------------
 
 // Included (YC)
-void PostFcnEuler::computeDerivativeOfForceTransmitted2(double *Xface[3], double *dXface[3],
-                                                        Vec3D &n, Vec3D &dn, double d2w[3], double *Vwall, double *dVwall,
-                                                        double *Vface[3],  double *dVface[3], double *Vtet[4], double *dVtet[4], double dS[3],  
-                                                        double *pin,  Vec3D &dFi0, Vec3D &dFi1, Vec3D &dFi2, Vec3D &dFv, 
-                                                        double dPdx[3][3], double ddPdx[3][3], int hydro)
-{
-
-  double pcg[3], p[3];
-  double dPcg[3];
-  double pcgin;
-  double cf[500];
-  int i;
-
-  double dPinfty = dpinfty * dS[0];
-  double dPinftydS[3] = {0};
-  dPinftydS[0] = dpinfty;
-  double dPcgdVface[3][5] = {0};
-
-  if (hydro == 0) {
-    for(i=0;i<3;i++) {
-      pcg[i] = varFcn->getPressure(Vface[i]);
-      varFcn->computedPdV(dPcgdVface[i]);
-      dPcg[i] = 0.0;
-      for(int l=0; l<5; ++l) {
-        dPcg[i] += dPcgdVface[i][l]*dVface[i][l]; 
-      } 
-    }
-  } 
-  else if (hydro == 1){ // hydrostatic pressure
-     for(i=0;i<3;i++) {
-        pcg[i]  = varFcn->hydrostaticPressure(Vface[i][0],Xface[i]);
-        dPcg[i] = varFcn->DerivativeHydrostaticPressure(dVface[i][0], Vface[i][0], Xface[i], dXface[i]);
-     }
-  }else if (hydro == 2){ // hydrodynamic pressure
-    for (i=0; i<3; i++) 
-    {
-      pcg[i]  = varFcn->hydrodynamicPressure(Vface[i], Xface[i]);
-      dPcg[i] = varFcn->getPressure(dVface[i]) 
-              - varFcn->DerivativeHydrostaticPressure(dVface[i][0], Vface[i][0], Xface[i], dXface[i]);
-    }
-  }
-
-  if (pin)
-    pcgin = *pin;
-  else
-    if (hydro == 0)
-      pcgin = pinfty;
-    else
-      pcgin = 0.0;
-
-  double dPcgindS[3] = {0};
-  double dPcgindPinfty(0);
-  if (pin) {
-    if (dimFlag) {
-      dPcgindS[0] = -2.0*(*pin)/mach;
-    } else {
-      dPcgindS[0] = dPin;
-    }
-  }
-  else {
-    if (hydro == 0)
-      dPcgindPinfty = 1.0;
-  }
-  for(int j=0; j<3; ++j) dPcgindS[j] += dPcgindPinfty*dPinftydS[j]; 
-
-  p[0] = (pcg[0] - pcgin) ;
-  p[1] = (pcg[1] - pcgin) ;
-  p[2] = (pcg[2] - pcgin) ;
-
- Vec3D xC, xS, xP, x1, x2, x3, x0, x;
- double p_1C, p_1S, p_2S, p_2P, p_3P, p_3C;
- double p_C, p_S, p_P, p_0C, p_0S, p_0P;
-
- // C to 0, S to 1 P to 2
- for(int i = 0; i<3; i++)
- {
-  xC[i] = Xface[0][i];
-  xS[i] = Xface[1][i];
-  xP[i] = Xface[2][i];
- }
-
- x1 = (xC+xS)/2.0;
- x2 = (xS+xP)/2.0;
- x3 = (xP+xC)/2.0;
- x0 = (xC+xS+xP)/3.0;
-
- p_C = p[0], p_S = p[1], p_P = p[2];
- // Computing p_1C, p_0C and p_3C, and computing dP_1C, dP_0C and dP_3C
- p_1C = p_C 
-      + dPdx[0][0]*(x1[0]-xC[0]) 
-      + dPdx[0][1]*(x1[1]-xC[1]) 
-      + dPdx[0][2]*(x1[2]-xC[2]);
- p_0C =  p_C 
-      + dPdx[0][0]*(x0[0]-xC[0]) 
-      + dPdx[0][1]*(x0[1]-xC[1]) 
-      + dPdx[0][2]*(x0[2]-xC[2]);
- p_3C =  p_C 
-      + dPdx[0][0]*(x3[0]-xC[0]) 
-      + dPdx[0][1]*(x3[1]-xC[1]) 
-      + dPdx[0][2]*(x3[2]-xC[2]);
-
- // Computing p_1S, p_0S and p_2S, and computing dP_1S, dP_0S and dP_2S
- p_1S = p_S 
-      + dPdx[1][0]*(x1[0]-xS[0]) 
-      + dPdx[1][1]*(x1[1]-xS[1]) 
-      + dPdx[1][2]*(x1[2]-xS[2]);
- p_0S =  p_S 
-      + dPdx[1][0]*(x0[0]-xS[0]) 
-      + dPdx[1][1]*(x0[1]-xS[1]) 
-      + dPdx[1][2]*(x0[2]-xS[2]);
- p_2S =  p_S 
-      + dPdx[1][0]*(x2[0]-xS[0]) 
-      + dPdx[1][1]*(x2[1]-xS[1]) 
-      + dPdx[1][2]*(x2[2]-xS[2]);
-
- // Computing p_2P, p_0P and p_3P, and computing dP_2P, dP_0P and dP_3P
- p_2P = p_P 
-      + dPdx[2][0]*(x2[0]-xP[0]) 
-      + dPdx[2][1]*(x2[1]-xP[1]) 
-      + dPdx[2][2]*(x2[2]-xP[2]);
- p_0P =  p_P 
-      + dPdx[2][0]*(x0[0]-xP[0]) 
-      + dPdx[2][1]*(x0[1]-xP[1]) 
-      + dPdx[2][2]*(x0[2]-xP[2]);
- p_3P =  p_P 
-      + dPdx[2][0]*(x3[0]-xP[0]) 
-      + dPdx[2][1]*(x3[1]-xP[1]) 
-      + dPdx[2][2]*(x3[2]-xP[2]);
-
- // computation of pressure flux
- double phi_C, phi_S, phi_P, phi_1, phi_2, phi_3, phi_0;
- phi_C = (2.0*p_C + p_0C + p_3C)/12.0 + (2.0*p_C + p_0C + p_1C)/12.0;
- cf[0] = 2.0*(x0[0]-xC[0])+x3[0]-xC[0]+x1[0]-xC[0];
- cf[1] = 2.0*(x0[1]-xC[1])+(x3[1]-xC[1])+(x1[1]-xC[1]);
- cf[2] = 2.0*(x0[2]-xC[2])+(x3[2]-xC[2])+(x1[2]-xC[2]);
- cf[3] = 2.0/3.0*dPdx[0][0]+0.5*dPdx[0][0];
- cf[4] = 2.0/3.0*dPdx[0][1]+0.5*dPdx[0][1];
- cf[5] = 2.0/3.0*dPdx[0][2]+0.5*dPdx[0][2];
- cf[6] = 2.0/3.0*dPdx[0][0]+0.5*dPdx[0][0];
- cf[7] = 2.0/3.0*dPdx[0][1]+0.5*dPdx[0][1];
- cf[8] = 2.0/3.0*dPdx[0][2]+0.5*dPdx[0][2];
- cf[9] = -4.0/3.0*dPdx[0][0] - dPdx[0][0];
- cf[10] = -4.0/3.0*dPdx[0][1] - dPdx[0][1];
- cf[11] = - 4.0/3.0*dPdx[0][2] - dPdx[0][2];
- phi_S = (2.0*p_S + p_0S + p_1S)/12.0 + (2.0*p_S + p_0S + p_2S)/12.0;
- cf[12] = 2.0*(x0[0]-xS[0]) + (x1[0]-xS[0]) + (x2[0]-xS[0]);
- cf[13] = 2.0*(x0[1]-xS[1]) + (x1[1]-xS[1]) + (x2[1]-xS[1]);
- cf[14] = 2.0*(x0[2]-xS[2]) + (x1[2]-xS[2]) + (x2[2]-xS[2]);
- cf[15] = 2.0/3.0*dPdx[1][0] + 0.5*dPdx[1][0];
- cf[16] = 2.0/3.0*dPdx[1][1] + 0.5*dPdx[1][1];
- cf[17] = 2.0/3.0*dPdx[1][2] + 0.5*dPdx[1][2];
- cf[18] = 2.0/3.0*dPdx[1][0] + 0.5*dPdx[1][0];
- cf[19] = 2.0/3.0*dPdx[1][1] + 0.5*dPdx[1][1];
- cf[20] = 2.0/3.0*dPdx[1][2] + 0.5*dPdx[1][2];
- cf[21] = - 4.0/3.0*dPdx[1][0] - dPdx[1][0];
- cf[22] = - 4.0/3.0*dPdx[1][1] - dPdx[1][1];
- cf[23] = - 4.0/3.0*dPdx[1][2] - dPdx[1][2];
- phi_P = (2.0*p_P + p_0P + p_2P)/12.0 + (2.0*p_P + p_0P + p_3P)/12.0;
- cf[24] = 2.0*(x0[0]-xP[0]) + (x2[0]-xP[0]) + (x3[0]-xP[0]);
- cf[25] = 2.0*(x0[1]-xP[1]) + (x2[1]-xP[1]) + (x3[1]-xP[1]);
- cf[26] = (x3[2]-xP[2]) + (x2[2]-xP[2]) + 2.0*(x0[2]-xP[2]);
- cf[27] = 2.0/3.0*dPdx[2][0] + 0.5*dPdx[2][0];
- cf[28] = 2.0/3.0*dPdx[2][1] + 0.5*dPdx[2][1];
- cf[29] = 2.0/3.0*dPdx[2][2] + 0.5*dPdx[2][2];
- cf[30] = 2.0/3.0*dPdx[2][0] + 0.5*dPdx[2][0];
- cf[31] = 2.0/3.0*dPdx[2][1] + 0.5*dPdx[2][1];
- cf[32] = 2.0/3.0*dPdx[2][2] + 0.5*dPdx[2][2];
- cf[33] = - 4.0/3.0*dPdx[2][0] - dPdx[2][0];
- cf[34] = - 4.0/3.0*dPdx[2][1] - dPdx[2][1];
- cf[35] = - 4.0/3.0*dPdx[2][2] - dPdx[2][2]; 
- phi_1 = (2.0*p_1C + p_0C + p_C)/12.0 + (2.0*p_1S + p_0S + p_S)/12.0;
- cf[36] = 2.0*(x1[0]-xC[0]) + (x0[0]-xC[0]);
- cf[37] = (x0[1]-xC[1]) + 2.0*(x1[1]-xC[1]);
- cf[38] = 2.0*(x1[2]-xC[2]) + (x0[2]-xC[2]);
- cf[39] = 2.0*(x1[0]-xS[0]) + (x0[0]-xS[0]);
- cf[40] = (x0[1]-xS[1]) + 2.0*(x1[1]-xS[1]);
- cf[41] = (x0[2]-xS[2]) + 2.0*(x1[2]-xS[2]);
- cf[42] = 4.0/3.0*dPdx[0][0] - 5.0/3.0*dPdx[1][0];
- cf[43] = 4.0/3.0*dPdx[0][1] - 5.0/3.0*dPdx[1][1];
- cf[44] = 4.0/3.0*dPdx[0][2] - 5.0/3.0*dPdx[1][2];
- cf[45] = 4.0/3.0*dPdx[1][0] - 5.0/3.0*dPdx[0][0];
- cf[46] = 4.0/3.0*dPdx[1][1] - 5.0/3.0*dPdx[0][1];
- cf[47] = 4.0/3.0*dPdx[1][2] - 5.0/3.0*dPdx[0][2];
- cf[48] = 1.0/3.0*dPdx[0][0] + 1.0/3.0*dPdx[1][0];
- cf[49] = 1.0/3.0*dPdx[0][1] + 1.0/3.0*dPdx[1][1];
- cf[50] = 1.0/3.0*dPdx[0][2] + 1.0/3.0*dPdx[1][2]; 
- phi_2 = (2.0*p_2S + p_0S + p_S)/12.0 + (2.0*p_2P + p_0P + p_P)/12.0;
- cf[51] = 2.0*(x2[0]-xS[0]) + (x0[0]-xS[0]);
- cf[52] = 2.0*(x2[1]-xS[1]) + (x0[1]-xS[1]);
- cf[53] = 2.0*(x2[2]-xS[2]) + (x0[2]-xS[2]);
- cf[54] = 2.0*(x2[0]-xP[0]) + (x0[0]-xP[0]);
- cf[55] = 2.0*(x2[1]-xP[1]) + (x0[1]-xP[1]);
- cf[56] = 2.0*(x2[2]-xP[2]) + (x0[2]-xP[2]);
- cf[57] = 1.0/3.0*dPdx[1][0] + 1.0/3.0*dPdx[2][0];
- cf[58] = 1.0/3.0*dPdx[1][1] + 1.0/3.0*dPdx[2][1];
- cf[59] = 1.0/3.0*dPdx[1][2] + 1.0/3.0*dPdx[2][2];
- cf[60] = 4.0/3.0*dPdx[2][0] - 5.0/3.0*dPdx[1][0];
- cf[61] = 4.0/3.0*dPdx[2][1] - 5.0/3.0*dPdx[1][1];
- cf[62] = 4.0/3.0*dPdx[2][2] - 5.0/3.0*dPdx[1][2]; 
- cf[63] = 4.0/3.0*dPdx[1][0] - 5.0/3.0*dPdx[2][0];
- cf[64] = 4.0/3.0*dPdx[1][1] - 5.0/3.0*dPdx[2][1];
- cf[65] = 4.0/3.0*dPdx[1][2] - 5.0/3.0*dPdx[2][2];
- phi_3 = (2.0*p_3P + p_0P + p_P)/12.0 + (2.0*p_3C + p_0C + p_C)/12.0;
- cf[66] = (x0[0]-xC[0]) + 2.0*(x3[0]-xC[0]);
- cf[67] = 2.0*(x3[1]-xC[1]) + (x0[1]-xC[1]);
- cf[68] = 2.0*(x3[2]-xC[2]) + (x0[2]-xC[2]);
- cf[69] = (x0[0]-xP[0]) + 2.0*(x3[0]-xP[0]);
- cf[70] = (x0[1]-xP[1]) + 2.0*(x3[1]-xP[1]);
- cf[71] = (x0[2]-xP[2]) + 2.0*(x3[2]-xP[2]);
- cf[72] = 4.0/3.0*dPdx[2][0] - 5.0/3.0*dPdx[0][0];
- cf[73] = 4.0/3.0*dPdx[2][1] - 5.0/3.0*dPdx[0][1];
- cf[74] = 4.0/3.0*dPdx[2][2] - 5.0/3.0*dPdx[0][2];
- cf[75] = 1.0/3.0*dPdx[2][0] + 1.0/3.0*dPdx[0][0];
- cf[76] = 1.0/3.0*dPdx[0][1] + 1.0/3.0*dPdx[2][1];
- cf[77] = 1.0/3.0*dPdx[0][2] + 1.0/3.0*dPdx[2][2];
- cf[78] = 4.0/3.0*dPdx[0][0] - 5.0/3.0*dPdx[2][0];
- cf[79] = 4.0/3.0*dPdx[0][1] - 5.0/3.0*dPdx[2][1];
- cf[80] = 4.0/3.0*dPdx[0][2] - 5.0/3.0*dPdx[2][2]; 
- phi_0 = (2.0*p_0C + p_1C + p_C)/12.0 + (2.0*p_0C + p_3C + p_C)/12.0 + (2.0*p_0S + p_1S + p_S)/12.0 + (2.0*p_0S + p_2S + p_S)/12.0 + (2.0*p_0P + p_2P + p_P)/12.0 + (2.0*p_0P + p_3P + p_P)/12.0;
- cf[81] = (x3[0]-xC[0]) + (x1[0]-xC[0]) + 4.0*(x0[0]-xC[0]);
- cf[82] = 4.0*(x0[1]-xC[1]) + (x1[1]-xC[1]) + (x3[1]-xC[1]);
- cf[83] = 4.0*(x0[2]-xC[2]) + (x1[2]-xC[2]) + (x3[2]-xC[2]);
- cf[84] = (x1[0]-xS[0]) + (x2[0]-xS[0]) + 4.0*(x0[0]-xS[0]);
- cf[85] = 4.0*(x0[1]-xS[1]) + (x2[1]-xS[1]) + (x1[1]-xS[1]);
- cf[86] = 4.0*(x0[2]-xS[2]) + (x2[2]-xS[2]) + (x1[2]-xS[2]);
- cf[87] = (x2[0]-xP[0]) + (x3[0]-xP[0]) + 4.0*(x0[0]-xP[0]);
- cf[88] = 4.0*(x0[1]-xP[1]) + (x3[1]-xP[1]) + (x2[1]-xP[1]);
- cf[89] = 4.0*(x0[2]-xP[2]) + (x3[2]-xP[2]) + (x2[2]-xP[2]);
- cf[90] = - 11.0/3.0*dPdx[0][0]+ 11.0/6.0*dPdx[1][0]+ 11.0/6.0*dPdx[2][0];
- cf[91] = - 11.0/3.0*dPdx[0][1] + 11.0/6.0*dPdx[1][1] + 11.0/6.0*dPdx[2][1];
- cf[92] = 11.0/6.0*dPdx[2][2] - 11.0/3.0*dPdx[0][2] + 11.0/6.0*dPdx[1][2];
- cf[93] = - 11.0/3.0*dPdx[1][0] + 11.0/6.0*dPdx[2][0] + 11.0/6.0*dPdx[0][0];
- cf[94] = 11.0/6.0*dPdx[2][1] + 11.0/6.0*dPdx[0][1] - 11.0/3.0*dPdx[1][1];
- cf[95] = 11.0/6.0*dPdx[0][2] - 11.0/3.0*dPdx[1][2] + 11.0/6.0*dPdx[2][2];
- cf[96] = 11.0/6.0*dPdx[0][0] + 11.0/6.0*dPdx[1][0] - 11.0/3.0*dPdx[2][0];
- cf[97] = 11.0/6.0*dPdx[0][1] + 11.0/6.0*dPdx[1][1] - 11.0/3.0*dPdx[2][1];
- cf[98] = 11.0/6.0*dPdx[1][2] - 11.0/3.0*dPdx[2][2] + 11.0/6.0*dPdx[0][2]; 
- cf[99] = (phi_C + phi_1/2.0 + phi_3/2.0 + phi_0/3.0)/6.0;
- cf[100] = 1.0/12.0*cf[0] + 1.0/24.0*cf[36] + 1.0/24.0*cf[66] + 1.0/36.0*cf[81];
- cf[101] = 1.0/36.0*cf[82] + 1.0/24.0*cf[67] + 1.0/24.0*cf[37] + 1.0/12.0*cf[1];
- cf[102] = 1.0/36.0*cf[83] + 1.0/24.0*cf[68] + 1.0/24.0*cf[38] + 1.0/12.0*cf[2];
- cf[103] = 1.0/24.0*cf[39] + 1.0/36.0*cf[84];
- cf[104] = 1.0/24.0*cf[40] + 1.0/36.0*cf[85];
- cf[105] = 1.0/24.0*cf[41] + 1.0/36.0*cf[86];
- cf[106] = 1.0/36.0*cf[87] + 1.0/24.0*cf[69];
- cf[107] = 1.0/36.0*cf[88] + 1.0/24.0*cf[70];
- cf[108] = 1.0/36.0*cf[89] + 1.0/24.0*cf[71];
- cf[109] = 1.0/12.0*cf[9] + 1.0/24.0*cf[72] + 1.0/24.0*cf[45] + 1.0/36.0*cf[90];
- cf[110] = 1.0/12.0*cf[10] + 1.0/24.0*cf[46] + 1.0/24.0*cf[73] + 1.0/36.0*cf[91];
- cf[111] = 1.0/36.0*cf[92] + 1.0/24.0*cf[74] + 1.0/24.0*cf[47] + 1.0/12.0*cf[11];
- cf[112] = 1.0/12.0*cf[3] + 1.0/24.0*cf[42] + 1.0/24.0*cf[75] + 1.0/36.0*cf[93];
- cf[113] = 1.0/24.0*cf[76] + 1.0/24.0*cf[43] + 1.0/12.0*cf[4] + 1.0/36.0*cf[94];
- cf[114] = 1.0/36.0*cf[95] + 1.0/24.0*cf[77] + 1.0/24.0*cf[44] + 1.0/12.0*cf[5];
- cf[115] = 1.0/12.0*cf[6] + 1.0/24.0*cf[48] + 1.0/24.0*cf[78] + 1.0/36.0*cf[96];
- cf[116] = 1.0/24.0*cf[79] + 1.0/24.0*cf[49] + 1.0/12.0*cf[7] + 1.0/36.0*cf[97];
- cf[117] = 1.0/36.0*cf[98] + 1.0/24.0*cf[80] + 1.0/24.0*cf[50] + 1.0/12.0*cf[8];
- double dFi0dPcg[3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi0dPcg[j][0] = 11.0/54.0*n[j];
-   dFi0dPcg[j][1] = 7.0/108.0*n[j];
-   dFi0dPcg[j][2] = 7.0/108.0*n[j];
- }
- double dFi0dVface[3][3][5] = {0};
- for(int j=0; j<3; ++j) 
-   for(int k=0; k<3; ++k) 
-     for(int l=0; l<5; ++l) 
-       dFi0dVface[j][k][l] += dFi0dPcg[j][k]*dPcgdVface[k][l];
-
-
- double dFi0dPcgin[3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi0dPcgin[j] = -1.0/3.0*n[j];
- }
- double dFi0ddPdx[3][3][3] = {0};
- double dFi0dXface[3][3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi0ddPdx[j][0][0] = 1.0/6.0*n[j]*cf[100];
-   dFi0ddPdx[j][0][1] = 1.0/6.0*n[j]*cf[101];
-   dFi0ddPdx[j][0][2] = 1.0/6.0*n[j]*cf[102];
-   dFi0ddPdx[j][1][0] = 1.0/6.0*n[j]*cf[103];
-   dFi0ddPdx[j][1][1] = 1.0/6.0*n[j]*cf[104];
-   dFi0ddPdx[j][1][2] = 1.0/6.0*n[j]*cf[105];
-   dFi0ddPdx[j][2][0] = 1.0/6.0*n[j]*cf[106];
-   dFi0ddPdx[j][2][1] = 1.0/6.0*n[j]*cf[107];
-   dFi0ddPdx[j][2][2] = 1.0/6.0*n[j]*cf[108];
-   dFi0dXface[j][0][0] = 1.0/6.0*n[j]*cf[109];
-   dFi0dXface[j][0][1] = 1.0/6.0*n[j]*cf[110];
-   dFi0dXface[j][0][2] = 1.0/6.0*n[j]*cf[111];
-   dFi0dXface[j][1][0] = 1.0/6.0*n[j]*cf[112];
-   dFi0dXface[j][1][1] = 1.0/6.0*n[j]*cf[113];
-   dFi0dXface[j][1][2] = 1.0/6.0*n[j]*cf[114];
-   dFi0dXface[j][2][0] = 1.0/6.0*n[j]*cf[115];
-   dFi0dXface[j][2][1] = 1.0/6.0*n[j]*cf[116];
-   dFi0dXface[j][2][2] = 1.0/6.0*n[j]*cf[117];
- }
- double dFi0dn[3] = {cf[99], cf[99], cf[99]};
- dFi0 = 0.0;
- for(int l=0; l<3; ++l) {
-   dFi0[l] += dFi0dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi0[l] += dFi0dPcgin[l]*dPcgindS[j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi0[l] += dFi0dVface[l][j][k]*dVface[j][k];   
-     for(int k=0; k<3; ++k) 
-       dFi0[l] += dFi0ddPdx[l][j][k]*ddPdx[j][k] + dFi0dXface[l][j][k]*dXface[j][k];
-   }
- }
- cf[118] = (phi_S + phi_1/2.0 + phi_2/2.0 + phi_0/3.0)/6.0;
- cf[119] = (phi_P + phi_2/2.0 + phi_3/2.0 + phi_0/3.0)/6.0;
- cf[120] = 1.0/24.0*cf[36] + 1.0/36.0*cf[81];
- cf[121] = 1.0/24.0*cf[37] + 1.0/36.0*cf[82];
- cf[122] = 1.0/24.0*cf[38] + 1.0/36.0*cf[83];
- cf[123] = 1.0/36.0*cf[84] + 1.0/12.0*cf[12] + 1.0/24.0*cf[39] + 1.0/24.0*cf[51];
- cf[124] = 1.0/24.0*cf[52] + 1.0/36.0*cf[85] + 1.0/24.0*cf[40] + 1.0/12.0*cf[13];
- cf[125] = 1.0/12.0*cf[14] + 1.0/24.0*cf[53] + 1.0/36.0*cf[86] + 1.0/24.0*cf[41];
- cf[126] = 1.0/36.0*cf[87] + 1.0/24.0*cf[54];
- cf[127] = 1.0/36.0*cf[88] + 1.0/24.0*cf[55];
- cf[128] = 1.0/36.0*cf[89] + 1.0/24.0*cf[56];
- cf[129] = 1.0/12.0*cf[15] + 1.0/24.0*cf[45] + 1.0/24.0*cf[57] + 1.0/36.0*cf[90];
- cf[130] = 1.0/36.0*cf[91] + 1.0/24.0*cf[58] + 1.0/24.0*cf[46] + 1.0/12.0*cf[16];
- cf[131] = 1.0/36.0*cf[92] + 1.0/24.0*cf[59] + 1.0/24.0*cf[47] + 1.0/12.0*cf[17];
- cf[132] = 1.0/12.0*cf[21] + 1.0/24.0*cf[60] + 1.0/24.0*cf[42] + 1.0/36.0*cf[93];
- cf[133] = 1.0/36.0*cf[94] + 1.0/24.0*cf[61] + 1.0/24.0*cf[43] + 1.0/12.0*cf[22];
- cf[134] = 1.0/36.0*cf[95] + 1.0/24.0*cf[62] + 1.0/12.0*cf[23] + 1.0/24.0*cf[44];
- cf[135] = 1.0/24.0*cf[48] + 1.0/36.0*cf[96] + 1.0/12.0*cf[18] + 1.0/24.0*cf[63];
- cf[136] = 1.0/12.0*cf[19] + 1.0/24.0*cf[64] + 1.0/36.0*cf[97] + 1.0/24.0*cf[49];
- cf[137] = 1.0/12.0*cf[20] + 1.0/24.0*cf[50] + 1.0/24.0*cf[65] + 1.0/36.0*cf[98];
-
- double dFi1dPcg[3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi1dPcg[j][0] = 7.0/108.0*n[j];
-   dFi1dPcg[j][1] = 11.0/54.0*n[j];
-   dFi1dPcg[j][2] = 7.0/108.0*n[j];
- }
- double dFi1dVface[3][3][5] = {0};
- for(int j=0; j<3; ++j) 
-   for(int k=0; k<3; ++k) 
-     for(int l=0; l<5; ++l) 
-       dFi1dVface[j][k][l] += dFi1dPcg[j][k]*dPcgdVface[k][l];
-
- double dFi1dPcgin[3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi1dPcgin[j] = -1.0/3.0*n[j];
- }
- double dFi1ddPdx[3][3][3] = {0};
- double dFi1dXface[3][3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi1ddPdx[j][0][0] = 1.0/6.0*n[j]*cf[120];
-   dFi1ddPdx[j][0][1] = 1.0/6.0*n[j]*cf[121];
-   dFi1ddPdx[j][0][2] = 1.0/6.0*n[j]*cf[122];
-   dFi1ddPdx[j][1][0] = 1.0/6.0*n[j]*cf[123];
-   dFi1ddPdx[j][1][1] = 1.0/6.0*n[j]*cf[124];
-   dFi1ddPdx[j][1][2] = 1.0/6.0*n[j]*cf[125];
-   dFi1ddPdx[j][2][0] = 1.0/6.0*n[j]*cf[126];
-   dFi1ddPdx[j][2][1] = 1.0/6.0*n[j]*cf[127];
-   dFi1ddPdx[j][2][2] = 1.0/6.0*n[j]*cf[128];
-   dFi1dXface[j][0][0] = 1.0/6.0*n[j]*cf[129];
-   dFi1dXface[j][0][1] = 1.0/6.0*n[j]*cf[130];
-   dFi1dXface[j][0][2] = 1.0/6.0*n[j]*cf[131];
-   dFi1dXface[j][1][0] = 1.0/6.0*n[j]*cf[132];
-   dFi1dXface[j][1][1] = 1.0/6.0*n[j]*cf[133];
-   dFi1dXface[j][1][2] = 1.0/6.0*n[j]*cf[134];
-   dFi1dXface[j][2][0] = 1.0/6.0*n[j]*cf[135];
-   dFi1dXface[j][2][1] = 1.0/6.0*n[j]*cf[136];
-   dFi1dXface[j][2][2] = 1.0/6.0*n[j]*cf[137];
- }
- double dFi1dn[3] = {cf[118], cf[118], cf[118]};
- dFi1 = 0.0;
- for(int l=0; l<3; ++l) {
-   dFi1[l] += dFi1dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi1[l] += dFi1dPcgin[l]*dPcgindS[j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi1[l] += dFi1dVface[l][j][k]*dVface[j][k];   
-     for(int k=0; k<3; ++k) {
-       dFi1[l] += dFi1ddPdx[l][j][k]*ddPdx[j][k] + dFi1dXface[l][j][k]*dXface[j][k];
-     }
-   }
- }
- cf[138] = 1.0/24.0*cf[66] + 1.0/36.0*cf[81] ; 
- cf[139] = 1.0/36.0*cf[82] + 1.0/24.0*cf[67]; 
- cf[140] = 1.0/36.0*cf[83] + 1.0/24.0*cf[68]; 
- cf[141] = 1.0/36.0*cf[84] + 1.0/24.0*cf[51];
- cf[142] = 1.0/24.0*cf[52] + 1.0/36.0*cf[85];
- cf[143] = 1.0/24.0*cf[53] + 1.0/36.0*cf[86];
- cf[144] = 1.0/24.0*cf[54] + 1.0/36.0*cf[87]  + 1.0/12.0*cf[24] + 1.0/24.0*cf[69];
- cf[145] = 1.0/24.0*cf[55] + 1.0/36.0*cf[88] + 1.0/12.0*cf[25] + 1.0/24.0*cf[70];
- cf[146] = 1.0/24.0*cf[56] + 1.0/36.0*cf[89] + 1.0/24.0*cf[71] + 1.0/12.0*cf[26];
- cf[147] = 1.0/12.0*cf[27] + 1.0/24.0*cf[57] + 1.0/36.0*cf[90] + 1.0/24.0*cf[72];
- cf[148] = 1.0/24.0*cf[73] + 1.0/36.0*cf[91] + 1.0/24.0*cf[58] + 1.0/12.0*cf[28];
- cf[149] = 1.0/24.0*cf[74] + 1.0/36.0*cf[92] + 1.0/24.0*cf[59] + 1.0/12.0*cf[29];
- cf[150] = 1.0/12.0*cf[30] + 1.0/24.0*cf[60] + 1.0/24.0*cf[75] + 1.0/36.0*cf[93];
- cf[151] = 1.0/36.0*cf[94] + 1.0/24.0*cf[76] + 1.0/24.0*cf[61] + 1.0/12.0*cf[31];
- cf[152] = 1.0/36.0*cf[95] + 1.0/24.0*cf[77] + 1.0/24.0*cf[62] + 1.0/12.0*cf[32];
- cf[153] = 1.0/12.0*cf[33] + 1.0/24.0*cf[63] + 1.0/24.0*cf[78] + 1.0/36.0*cf[96];
- cf[154] = 1.0/12.0*cf[34] + 1.0/24.0*cf[64] + 1.0/36.0*cf[97] + 1.0/24.0*cf[79];
- cf[155] = 1.0/12.0*cf[35] + 1.0/24.0*cf[65] + 1.0/24.0*cf[80] + 1.0/36.0*cf[98]; 
-
- double dFi2dPcg[3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi2dPcg[j][0] = 7.0/108.0*n[j];
-   dFi2dPcg[j][1] = 7.0/108.0*n[j];
-   dFi2dPcg[j][2] = 11.0/54.0*n[j];
- }
- double dFi2dVface[3][3][5] = {0};
- for(int j=0; j<3; ++j) 
-   for(int k=0; k<3; ++k) 
-     for(int l=0; l<5; ++l) 
-       dFi2dVface[j][k][l] += dFi2dPcg[j][k]*dPcgdVface[k][l];
-
- double dFi2dPcgin[3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi2dPcgin[j] = -1.0/3.0*n[j];
- }
- double dFi2ddPdx[3][3][3] = {0};
- double dFi2dXface[3][3][3] = {0};
- for(int j=0; j<3; ++j) {
-   dFi2ddPdx[j][0][0] = 1.0/6.0*n[j]*cf[138];
-   dFi2ddPdx[j][0][1] = 1.0/6.0*n[j]*cf[139];
-   dFi2ddPdx[j][0][2] = 1.0/6.0*n[j]*cf[140];
-   dFi2ddPdx[j][1][0] = 1.0/6.0*n[j]*cf[141];
-   dFi2ddPdx[j][1][1] = 1.0/6.0*n[j]*cf[142];
-   dFi2ddPdx[j][1][2] = 1.0/6.0*n[j]*cf[143];
-   dFi2ddPdx[j][2][0] = 1.0/6.0*n[j]*cf[144];
-   dFi2ddPdx[j][2][1] = 1.0/6.0*n[j]*cf[145];
-   dFi2ddPdx[j][2][2] = 1.0/6.0*n[j]*cf[146];
-   dFi2dXface[j][0][0] = 1.0/6.0*n[j]*cf[147];
-   dFi2dXface[j][0][1] = 1.0/6.0*n[j]*cf[148];
-   dFi2dXface[j][0][2] = 1.0/6.0*n[j]*cf[149];
-   dFi2dXface[j][1][0] = 1.0/6.0*n[j]*cf[150];
-   dFi2dXface[j][1][1] = 1.0/6.0*n[j]*cf[151];
-   dFi2dXface[j][1][2] = 1.0/6.0*n[j]*cf[152];
-   dFi2dXface[j][2][0] = 1.0/6.0*n[j]*cf[153];
-   dFi2dXface[j][2][1] = 1.0/6.0*n[j]*cf[154];
-   dFi2dXface[j][2][2] = 1.0/6.0*n[j]*cf[155];
- }
- double dFi2dn[3] = {cf[119], cf[119], cf[119]};
- dFi2 = 0.0;
- for(int l=0; l<3; ++l) {
-   dFi2[l] += dFi2dn[l]*dn[l];
-   for(int j=0; j<3; ++j) {
-     dFi2[l] += dFi2dPcgin[l]*dPcgindS[j]*dS[j];
-     for(int k=0; k<5; ++k)
-       dFi2[l] += dFi2dVface[l][j][k]*dVface[j][k];   
-     for(int k=0; k<3; ++k) {
-       dFi2[l] += dFi2ddPdx[l][j][k]*ddPdx[j][k] + dFi2dXface[l][j][k]*dXface[j][k];
-     }
-   }
- }
- dFv = 0.0;
-
-}
-
-//------------------------------------------------------------------------------
 
 // Included (YC)
-void PostFcnEuler::computeDerivativeOperatorsOfForceTransmitted(double *Xface[3], Vec3D &n, 
-                                                                double *Vface[3], double *pin,  
+void PostFcnEuler::computeDerivativeOperatorsOfForceTransmitted(double dp1dxj[4][3],
+                                                                double *Xface[3], Vec3D &n,
+                                                                double *Vface[3], double *Vtet[4], double *pin,
                                                                 double dPdx[3][3], int hydro,
                                                                 double dFi0dn[3], double dFi0dS[3][3], double dFi0dVface[3][3][5],
                                                                 double dFi0ddPdx[3][3][3], double dFi0dXface[3][3][3],
                                                                 double dFi1dn[3], double dFi1dS[3][3], double dFi1dVface[3][3][5],
                                                                 double dFi1ddPdx[3][3][3], double dFi1dXface[3][3][3],
                                                                 double dFi2dn[3], double dFi2dS[3][3], double dFi2dVface[3][3][5],
-                                                                double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3]
+																double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3],
+																double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5]
                                                                )
 {
 
@@ -1185,9 +1052,6 @@
       pcg[i] = varFcn->getPressure(Vface[i]);
       varFcn->computedPdV(dPcgdVface[i]);
       dPcg[i] = 0.0;
-//      for(int l=0; l<5; ++l) {
-//        dPcg[i] += dPcgdVface[i][l]*dVface[i][l]; 
-//      } 
     }
   } 
   else if (hydro == 1){ // hydrostatic pressure
@@ -1212,7 +1076,6 @@
   }
   dPcgin = 0.0;
   for(int j=0; j<3; ++j) dPcgindS[j] += dPcgindPinfty*dPinftydS[j]; 
-//  for(int j=0; j<3; ++j) dPcgin += dPcgindS[j]*dS[j]; 
 
   p[0] = (pcg[0] - pcgin) ;
   p[1] = (pcg[1] - pcgin) ;
@@ -1442,16 +1305,9 @@
    dFi0dXface[j][2][2] = 1.0/6.0*n[j]*cf[117];
  }
  dFi0dn[0] = cf[99];  dFi0dn[1] = cf[99];  dFi0dn[2] = cf[99];
-// dFi0 = 0.0;
  for(int l=0; l<3; ++l) {
-//   dFi0[l] += dFi0dn[l]*dn[l];
    for(int j=0; j<3; ++j) {
      dFi0dS[l][j] = dFi0dPcgin[l]*dPcgindS[j]; 
-//     dFi0[l] += dFi0dS[l][j]*dS[j];
-//     for(int k=0; k<5; ++k)
-//       dFi0[l] += dFi0dVface[l][j][k]*dVface[j][k];   
-//     for(int k=0; k<3; ++k) 
-//       dFi0[l] += dFi0ddPdx[l][j][k]*ddPdx[j][k] + dFi0dXface[l][j][k]*dXface[j][k];
    }
  }
  cf[118] = (phi_S + phi_1/2.0 + phi_2/2.0 + phi_0/3.0)/6.0;
@@ -1511,17 +1367,9 @@
    dFi1dXface[j][2][2] = 1.0/6.0*n[j]*cf[137];
  }
  dFi1dn[0] = cf[118];  dFi1dn[1] = cf[118];  dFi1dn[2] = cf[118];
-// dFi1 = 0.0;
  for(int l=0; l<3; ++l) {
-//   dFi1[l] += dFi1dn[l]*dn[l];
    for(int j=0; j<3; ++j) {
      dFi1dS[l][j] = dFi1dPcgin[l]*dPcgindS[j];
-//     dFi1[l] += dFi1dS[l][j]*dS[j];
-//     for(int k=0; k<5; ++k)
-//       dFi1[l] += dFi1dVface[l][j][k]*dVface[j][k];   
-//     for(int k=0; k<3; ++k) {
-//       dFi1[l] += dFi1ddPdx[l][j][k]*ddPdx[j][k] + dFi1dXface[l][j][k]*dXface[j][k];
-//     }
    }
  }
  cf[138] = 1.0/24.0*cf[66] + 1.0/36.0*cf[81] ; 
@@ -1579,25 +1427,12 @@
    dFi2dXface[j][2][2] = 1.0/6.0*n[j]*cf[155];
  }
  dFi2dn[0] = cf[119];  dFi2dn[1] = cf[119];  dFi2dn[2] = cf[119];
-// dFi2 = 0.0;
  for(int l=0; l<3; ++l) {
-//   dFi2[l] += dFi2dn[l]*dn[l];
    for(int j=0; j<3; ++j) {
      dFi2dS[l][j] = dFi2dPcgin[l]*dPcgindS[j];
-//     dFi2[l] += dFi2dPcgin[l]*dPcgindS[j]*dS[j];
-//     for(int k=0; k<5; ++k)
-//       dFi2[l] += dFi2dVface[l][j][k]*dVface[j][k];   
-//     for(int k=0; k<3; ++k) {
-//       dFi2[l] += dFi2ddPdx[l][j][k]*ddPdx[j][k] + dFi2dXface[l][j][k]*dXface[j][k];
-//     }
    }
  }
 
-
-
-
-// dFv = 0.0;
-
 }
 
 //--------------------------------------------------------------------------------------
@@ -1852,6 +1687,73 @@
 
 //------------------------------------------------------------------------------
 
+
+void PostFcnNS::computeDerivativeOperatorsOfViscousForce(double dp1dxj[4][3], Vec3D& n, double* Vtet[4],
+				                      double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdVtet[3][4][5])
+{ //YC
+
+  Vec3D dFv;
+  if (wallFcn) {
+    fprintf(stderr, " *** Error: PostFcnNS::computeDerivativeOperatorsOfViscousForce is not implemented\n"); exit(-1);
+  } else {
+    double u[4][3], ucg[3];
+    computeVelocity(Vtet, u, ucg);
+
+    double dudVtet[4][3][4][4] = {0}, ducgdVtet[3][4][4] = {0};
+    computeDerivativeOperatorsOfVelocity(dudVtet, ducgdVtet);
+
+    double T[4], Tcg;
+    computeTemperature(Vtet, T, Tcg);
+
+    double dTdVtet[4][4][5] = {0}, dTcgdVtet[4][5] = {0};
+    computeDerivativeOperatorsOfTemperature2(Vtet, dTdVtet, dTcgdVtet);
+
+    double dudxj[3][3];
+    computeVelocityGradient(dp1dxj, u, dudxj);
+
+    double ddudxjddp1dxj[3][3][4][3] = {0}, ddudxjdu[3][3][4][3] = {0};
+    computeDerivativeOperatorsOfVelocityGradient(dp1dxj, u, ddudxjddp1dxj, ddudxjdu);
+
+    double mu     = viscoFcn->compute_mu(Tcg);
+    double lambda = viscoFcn->compute_lambda(Tcg, mu);
+
+    mu     *= ooreynolds_mu;
+    lambda *= ooreynolds_mu;
+
+    double tij[3][3];
+    computeStressTensor(mu, lambda, dudxj, tij);
+
+    double dtijddudxj[3][3][3][3] = {0};
+    computeDerivativeOperatorsOfStressTensor(mu, lambda, dudxj, dtijddudxj, NULL, NULL);
+
+    double dFvdtij[3][3][3] = {0};
+    dFvdtij[2][2][0] = dFvdtij[1][1][0] = dFvdtij[0][0][0] = -n[0];
+    dFvdtij[2][2][1] = dFvdtij[1][1][1] = dFvdtij[0][0][1] = -n[1];
+    dFvdtij[2][2][2] = dFvdtij[1][1][2] = dFvdtij[0][0][2] = -n[2];
+    dFvdn[0][0] = -tij[0][0];   dFvdn[0][1] = -tij[0][1];    dFvdn[0][2] = -tij[0][2];
+    dFvdn[1][0] = -tij[1][0];   dFvdn[1][1] = -tij[1][1];    dFvdn[1][2] = -tij[1][2];
+    dFvdn[2][0] = -tij[2][0];   dFvdn[2][1] = -tij[2][1];    dFvdn[2][2] = -tij[2][2];
+
+    for(int i=0; i<3; ++i)
+      for(int j=0; j<3; ++j)
+        for(int k=0; k<3; ++k)
+          for(int l=0; l<3; ++l)
+            for(int m=0; m<3; ++m)
+              for(int n=0; n<4; ++n)
+                for(int o=0; o<3; ++o) {
+                  dFvddp1dxj[i][n][o] += dFvdtij[i][j][k]*dtijddudxj[j][k][l][m]*ddudxjddp1dxj[l][m][n][o];
+                  for(int p=0; p<4; ++p)
+                    for(int q=0; q<4; ++q)
+                      dFvdVtet[i][p][q] += dFvdtij[i][j][k]*dtijddudxj[j][k][l][m]*ddudxjdu[l][m][n][o]*dudVtet[n][o][p][q];
+                }
+
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+
 void PostFcnNS::computeForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3], 
 												     double *Vwall, double *Vface[3], double *Vtet[4], 
 					                   double *pin, Vec3D &Fi0, Vec3D &Fi1, Vec3D &Fi2, Vec3D &Fv, double dPdx[3][3], int hydro, int fid)
@@ -1929,6 +1831,44 @@
 
 //------------------------------------------------------------------------------
 
+void PostFcnNS::computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                  double dPdx[3][3], int hydro, double dFi0dn[3], double dFi1dn[3], double dFi2dn[3],
+                                                  double dFi0ddPdx[3][3], double dFi1ddPdx[3][3], double dFi2ddPdx[3][3],
+                                                  double dFi0dXface0[3][3], double dFi0dXface1[3][3], double dFi0dXface2[3][3],
+                                                  double dFi1dXface0[3][3], double dFi1dXface1[3][3], double dFi1dXface2[3][3],
+                                                  double dFi2dXface0[3][3], double dFi2dXface1[3][3], double dFi2dXface2[3][3],
+                                                  double dFi0dS[3][3], double dFi1dS[3][3], double dFi2dS[3][3],
+                                                  double dFi0dVface[3][5], double dFi1dVface[3][5], double dFi2dVface[3][5],
+                                                  double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5])
+{
+
+  PostFcnEuler::computeDerivativeOperatorsOfForce(dp1dxj, Xface, n, Vface, Vtet, pin, dPdx, hydro,
+                                                  dFi0dn, dFi1dn, dFi2dn, dFi0ddPdx, dFi1ddPdx, dFi2ddPdx,
+                                                  dFi0dXface0, dFi0dXface1, dFi0dXface2, dFi1dXface0, dFi1dXface1, dFi1dXface2,
+                                                  dFi2dXface0, dFi2dXface1, dFi2dXface2, dFi0dS, dFi1dS, dFi2dS,
+                                                  dFi0dVface, dFi1dVface, dFi2dVface, dFvddp1dxj, dFvdn, dFvdV);
+
+  computeDerivativeOperatorsOfViscousForce(dp1dxj, n, Vtet, dFvddp1dxj, dFvdn, dFvdV);
+
+}
+
+//------------------------------------------------------------------------------
+
+void PostFcnNS::computeDerivativeOperatorsOfForceTransmitted(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                             double dPdx[3][3], int hydro, double dFi0dn[3], double dFi0dS[3][3], double dFi0dVface[3][3][5],
+                                                             double dFi0ddPdx[3][3][3], double dFi0dXface[3][3][3], double dFi1dn[3], double dFi1dS[3][3], double dFi1dVface[3][3][5],
+                                                             double dFi1ddPdx[3][3][3], double dFi1dXface[3][3][3], double dFi2dn[3], double dFi2dS[3][3], double dFi2dVface[3][3][5],
+                                                             double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3], double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5])
+{
+  PostFcnEuler::computeDerivativeOperatorsOfForceTransmitted(dp1dxj, Xface, n, Vface, Vtet, pin, dPdx, hydro, dFi0dn, dFi0dS, dFi0dVface, dFi0ddPdx, dFi0dXface, dFi1dn, dFi1dS, dFi1dVface, dFi1ddPdx, dFi1dXface, dFi2dn, dFi2dS, dFi2dVface, dFi2ddPdx, dFi2dXface, dFvddp1dxj, dFvdn, dFvdV);
+
+  computeDerivativeOperatorsOfViscousForce(dp1dxj, n, Vtet, dFvddp1dxj, dFvdn, dFvdV);
+
+}
+
+
+//------------------------------------------------------------------------------
+
 double PostFcnNS::computeHeatPower(double dp1dxj[4][3], Vec3D& n, double d2w[3], 
 				   double* Vwall, double* Vface[3], double* Vtet[4])
 {
diff -r da841a06e630 -r 5d849f9519c9 PostFcn.h
--- a/PostFcn.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/PostFcn.h	Mon Jan 30 20:09:06 2017 -0800
@@ -94,19 +94,30 @@
   virtual void computeDerivativeOfForce(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
                                         double [3], double *, double *, double *[3], double *[3],
                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0) = 0;
+  virtual void computeDerivativeOfForce2(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
+                                         double [3], double *, double *, double *[3], double *[3],
+                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0) = 0;
+  virtual void computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                 double dPdx[3][3], int hydro, double dFi0dn[3], double dFi1dn[3], double dFi2dn[3],
+                                                 double dFi0ddPdx[3][3], double dFi1ddPdx[3][3], double dFi2ddPdx[3][3],
+                                                 double dFi0dXface0[3][3], double dFi0dXface1[3][3], double dFi0dXface2[3][3],
+                                                 double dFi1dXface0[3][3], double dFi1dXface1[3][3], double dFi1dXface2[3][3],
+                                                 double dFi2dXface0[3][3], double dFi2dXface1[3][3], double dFi2dXface2[3][3],
+                                                 double dFi0dS[3][3], double dFi1dS[3][3], double dFi2dS[3][3],
+                                                 double dFi0dVface[3][5], double dFi1dVface[3][5], double dFi2dVface[3][5],
+                                                 double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5]) = 0;
   virtual void computeDerivativeOfForceTransmitted(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
                                         double [3], double *, double *, double *[3], double *[3],
                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0) = 0;
-  virtual void computeDerivativeOfForceTransmitted2(double *[3], double *[3], Vec3D &, Vec3D &,
-                                        double [3], double *, double *, double *[3], double *[3],
-                                        double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0) = 0;
-  virtual void computeDerivativeOperatorsOfForceTransmitted(double *Xface[3], Vec3D &n, double *Vface[3], double *pin, double dPdx[3][3], int hydro,
+  virtual void computeDerivativeOperatorsOfForceTransmitted(double [4][3],
+                                                            double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin, double dPdx[3][3], int hydro,
                                                             double dFi0dn[3], double dFi0dS[3][3], double dFi0dVface[3][3][5],
                                                             double dFi0ddPdx[3][3][3], double dFi0dXface[3][3][3],
                                                             double dFi1dn[3], double dFi1dS[3][3], double dFi1dVface[3][3][5],
                                                             double dFi1ddPdx[3][3][3], double dFi1dXface[3][3][3],
                                                             double dFi2dn[3], double dFi2dS[3][3], double dFi2dVface[3][3][5],
-                                                            double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3]) = 0;
+															double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3],
+															double [3][4][3], double [3][3], double [3][4][5]) = 0;
   virtual void rstVar(IoData &, Communicator*) = 0;
   virtual double computeDerivativeOfHeatPower(double [4][3], double [4][3], Vec3D&, Vec3D&, double [3], double*, double*, double* [3], double* [3], double* [4], double* [4], double [3]) = 0;
 
@@ -172,19 +183,29 @@
   virtual void computeDerivativeOfForce(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
                                         double [3], double *, double *, double *[3], double *[3],
                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0);
+  virtual void computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                 double dPdx[3][3], int hydro, double dFi0dn[3], double dFi1dn[3], double dFi2dn[3],
+                                                 double dFi0ddPdx[3][3], double dFi1ddPdx[3][3], double dFi2ddPdx[3][3],
+                                                 double dFi0dXface0[3][3], double dFi0dXface1[3][3], double dFi0dXface2[3][3],
+                                                 double dFi1dXface0[3][3], double dFi1dXface1[3][3], double dFi1dXface2[3][3],
+                                                 double dFi2dXface0[3][3], double dFi2dXface1[3][3], double dFi2dXface2[3][3],
+                                                 double dFi0dS[3][3], double dFi1dS[3][3], double dFi2dS[3][3],
+                                                 double dFi0dVface[3][5], double dFi1dVface[3][5], double dFi2dVface[3][5],
+                                                 double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5]);
+  virtual void computeDerivativeOfForce2(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
+                                         double [3], double *, double *, double *[3], double *[3],
+                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0);
   virtual void computeDerivativeOfForceTransmitted(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
                                         double [3], double *, double *, double *[3], double *[3],
                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0);
-  virtual void computeDerivativeOfForceTransmitted2(double *[3], double *[3], Vec3D &, Vec3D &,
-                                        double [3], double *, double *, double *[3], double *[3],
-                                        double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0);
-  virtual void computeDerivativeOperatorsOfForceTransmitted(double *Xface[3], Vec3D &n, double *Vface[3], double *pin, double dPdx[3][3], int hydro,
+  virtual void computeDerivativeOperatorsOfForceTransmitted(double [4][3],
+                                                            double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin, double dPdx[3][3], int hydro,
                                                             double dFi0dn[3], double dFi0dS[3][3], double dFi0dVface[3][3][5],
                                                             double dFi0ddPdx[3][3][3], double dFi0dXface[3][3][3],
                                                             double dFi1dn[3], double dFi1dS[3][3], double dFi1dVface[3][3][5],
                                                             double dFi1ddPdx[3][3][3], double dFi1dXface[3][3][3],
                                                             double dFi2dn[3], double dFi2dS[3][3], double dFi2dVface[3][3][5],
-                                                            double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3]);
+															double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3], double [3][4][3], double [3][3], double [3][4][5]);
   void rstVar(IoData &, Communicator*);
   virtual double computeDerivativeOfHeatPower(double [4][3], double [4][3], Vec3D&, Vec3D&, double [3], double*, double*, double* [3], double* [3], double* [4], double* [4], double [3]);
 
@@ -202,6 +223,7 @@
 
 // Included (MB)
   Vec3D computeDerivativeOfViscousForce(double [4][3], double [4][3], Vec3D&, Vec3D&, double [3], double*, double*, double* [3], double* [3], double* [4], double* [4], double [3]);
+  void computeDerivativeOperatorsOfViscousForce(double dp1dxj[4][3], Vec3D& n, double* Vtet[4], double dFvddp1dxj[3][4][3], double dFvdn[3][3], double [3][4][5]); //YC
 
 public:
 
@@ -224,6 +246,7 @@
 
   virtual void computeForceTransmitted(double [4][3], double *[3], Vec3D &, double [3], double *, double *[3],
 				       double *[4], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], int = 0, int fid = 0);
+
   double computeHeatPower(double [4][3], Vec3D&, double [3],
 			  double*, double* [3], double* [4]);
   virtual double computeHeatFluxRelatedValues(double [4][3], Vec3D& , double [3],
@@ -241,6 +264,24 @@
   void computeDerivativeOfForceTransmitted(double [4][3], double [4][3], double *[3], double *[3], Vec3D &, Vec3D &,
                                         double [3], double *, double *, double *[3], double *[3],
                                         double *[4], double *[4], double [3], double *, Vec3D &, Vec3D &, Vec3D &, Vec3D &, double[3][3], double[3][3], int = 0);
+
+  virtual void computeDerivativeOperatorsOfForceTransmitted(double [4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin, double dPdx[3][3], int hydro,
+                                                    double dFi0dn[3], double dFi0dS[3][3], double dFi0dVface[3][3][5],
+                                                    double dFi0ddPdx[3][3][3], double dFi0dXface[3][3][3],
+                                                    double dFi1dn[3], double dFi1dS[3][3], double dFi1dVface[3][3][5],
+                                                    double dFi1ddPdx[3][3][3], double dFi1dXface[3][3][3],
+                                                    double dFi2dn[3], double dFi2dS[3][3], double dFi2dVface[3][3][5],
+                                                    double dFi2ddPdx[3][3][3], double dFi2dXface[3][3][3], double [3][4][3], double [3][3], double [3][4][5]);
+  virtual void computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,
+                                                 double dPdx[3][3], int hydro, double dFi0dn[3], double dFi1dn[3], double dFi2dn[3],
+                                                 double dFi0ddPdx[3][3], double dFi1ddPdx[3][3], double dFi2ddPdx[3][3],
+                                                 double dFi0dXface0[3][3], double dFi0dXface1[3][3], double dFi0dXface2[3][3],
+                                                 double dFi1dXface0[3][3], double dFi1dXface1[3][3], double dFi1dXface2[3][3],
+                                                 double dFi2dXface0[3][3], double dFi2dXface1[3][3], double dFi2dXface2[3][3],
+                                                 double dFi0dS[3][3], double dFi1dS[3][3], double dFi2dS[3][3],
+                                                 double dFi0dVface[3][5], double dFi1dVface[3][5], double dFi2dVface[3][5],
+                                                 double dFvddp1dxj[3][4][3], double dFvdn[3][3], double dFvdV[3][4][5]);
+
   void rstVar(IoData &, Communicator*);
   double computeDerivativeOfHeatPower(double [4][3], double [4][3], Vec3D&, Vec3D&, double [3], double*, double*, double* [3], double* [3], double* [4], double* [4], double [3]);
 
diff -r da841a06e630 -r 5d849f9519c9 PostOperator.C
--- a/PostOperator.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/PostOperator.C	Mon Jan 30 20:09:06 2017 -0800
@@ -17,13 +17,14 @@
 #include <SpaceOperator.h>
 #include <VectorSet.h>
 #include <GhostPoint.h>
+#include <MatVecProd.h>
 
 //------------------------------------------------------------------------------
 
 template<int dim>
 PostOperator<dim>::PostOperator(IoData &iod, VarFcn *vf, DistBcData<dim> *bc, 
 				DistGeoState *gs, Domain *dom, DistSVec<double,dim> *v) : 
-  varFcn(vf), bcData(bc), geoState(gs), domain(dom)
+  varFcn(vf), bcData(bc), geoState(gs), domain(dom), built_dVdU(false)
 {
 
   threshold = iod.schemes.ns.eps;
@@ -248,37 +249,15 @@
 
 #pragma omp parallel for
   for (int iSub = 0; iSub < numLocSub; ++iSub) {
-//    varFcn->conservativeToPrimitive(U(iSub), (*V)(iSub));
-//    varFcn->conservativeToPrimitiveDerivative(U(iSub), dU(iSub), (*V)(iSub), (*dV)(iSub));
     dVdU[iSub]->apply(dU(iSub), (*dV)(iSub));
 
     SVec<double,3> dSSVec(1); 
     subDomain[iSub]->computeDerivativeOfNodalForce(dForcedX[iSub], dForcedGradP[iSub], dForcedV[iSub], dForcedS[iSub],
                                                    dX(iSub), (*dV)(iSub), dS, dF(iSub), dSSVec, dGradPSVec(iSub));
-/*
-    SVec<double,3> dX2(dX(iSub)), dSSVec2(dSSVec), dGradPSVec2(dGradPSVec), dF2(dF(iSub));
-    SVec<double,dim> dU2(dU(iSub)), dV2((*dV)(iSub));
-    dX2 = 0.0;   dSSVec2 = 0.0;   dGradPSVec2 = 0.0;   dU2 = 0.0;  dV2 = 0.0;
-    dVdU[iSub]->apply(dU(iSub), dV2);
-    subDomain[iSub]->computeDerivativeOfNodalForce(dForcedX[iSub], dForcedGradP[iSub], dForcedV[iSub], dForcedS[iSub],
-                                                   dX(iSub), dV2, dS, dF2, dSSVec, dGradPSVec);
-    double aa = dF(iSub)*dF2;
-
-    dV2 = 0.0;
-    subDomain[iSub]->computeTransposeDerivativeOfNodalForce(dForcedX[iSub], dForcedGradP[iSub], dForcedV[iSub], dForcedS[iSub],
-                                                            dF(iSub), dGradPSVec2, dX2, dV2, dSSVec2);
-    dVdU[iSub]->applyTranspose(dV2, dU2);
-    double bb = dGradPSVec2*dGradPSVec + dX2*dX(iSub) + dU2*dU(iSub) + dSSVec2*dSSVec;
-    double diffnorm = sqrt((aa-bb)*(aa-bb));
-    double aanorm = sqrt(aa*aa);
-    if(aanorm != 0) fprintf(stderr, " ... rel. diff is %e\n", diffnorm/aanorm);
-    else fprintf(stderr, " ... abs. diff is %e\n", diffnorm);
-*/
-
   }
 
-  CommPattern<double> *vec3DPat = domain->getCommPat(dF);
-  domain->assemble(vec3DPat, dF);  // TODO: was not assembled originally
+//  CommPattern<double> *vec3DPat = domain->getCommPat(dF);
+//  domain->assemble(vec3DPat, dF);  // TODO: was not assembled originally
 
 }
 
@@ -310,13 +289,6 @@
     dVdU[iSub]->applyTranspose((*dV)(iSub), dU(iSub));
     for(int i=0; i<3; ++i) dS[i] = dSSVec[0][i];
   }
-/*
-  CommPattern<double> *vec3DPat = domain->getCommPat(dX);
-  domain->assemble(vec3DPat, dGradPSVec);
-  domain->assemble(vec3DPat, dX);
-  CommPattern<double> *vPat = domain->getCommPat(dU);
-  domain->assemble(vPat, dU);
-*/
 }
 
 //------------------------------------------------------------------------------
@@ -336,7 +308,10 @@
 #pragma omp parallel for
   for (int iSub = 0; iSub < numLocSub; ++iSub) { 
     varFcn->conservativeToPrimitive(U(iSub), (*V)(iSub));
-    varFcn->computeConservativeToPrimitiveDerivativeOperators(U(iSub), (*V)(iSub), *dVdU[iSub], *dVdPstiff[iSub]);
+    if(!built_dVdU) {
+      varFcn->computeConservativeToPrimitiveDerivativeOperators(U(iSub), (*V)(iSub), *dVdU[iSub], *dVdPstiff[iSub]);
+      built_dVdU = true;
+    }
     subDomain[iSub]->computeDerivativeOperatorsOfNodalForce(postFcn, X(iSub), (*V)(iSub), Pin(iSub), 
                                                             *dForcedX[iSub], *dForcedGradP[iSub],
                                                             *dForcedV[iSub], *dForcedS[iSub]);
@@ -795,7 +770,6 @@
   }
 
   map<int, int>::iterator it;
-  iSurf = 1;
   for (it = surfOutMap.begin(); it != surfOutMap.end(); it++)  {
     if (it->second > 0)  {
       dFi[0] += dFi[it->second];
@@ -812,6 +786,164 @@
 
 //------------------------------------------------------------------------------
 
+
+// Included (YC)
+// computes the derivative of non-dimensional forces and moments
+
+template<int dim>
+void PostOperator<dim>::computeDerivativeOfForceAndMoment(dRdXoperators<dim> *dRdXop, DistSVec<double,3> &dX,
+                                                          DistSVec<double,dim> &dU, double dS[3], DistSVec<double,3> &dGradP,
+                                                          Vec3D *dFi, Vec3D *dMi, Vec3D *dFv, Vec3D *dMv, int hydro)
+{
+
+  int iSurf;
+  for(iSurf = 0; iSurf < numSurf; ++iSurf) {
+    dFi[iSurf] = 0.0;
+    dMi[iSurf] = 0.0;
+    dFv[iSurf] = 0.0;
+    dMv[iSurf] = 0.0;
+  }
+
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub) {
+    dRdXop->dVdU[iSub]->apply(dU(iSub), (*dV)(iSub));
+    Vec3D *dfi = new Vec3D[numSurf];
+    Vec3D *dmi = new Vec3D[numSurf];
+    Vec3D *dfv = new Vec3D[numSurf];
+    Vec3D *dmv = new Vec3D[numSurf];
+    for(iSurf = 0; iSurf < numSurf; ++iSurf) {
+      dfi[iSurf] = 0.0;
+      dmi[iSurf] = 0.0;
+      dfv[iSurf] = 0.0;
+      dmv[iSurf] = 0.0;
+    }
+
+    subDomain[iSub]->computeDerivativeOfForceAndMoment(dRdXop->dFidGradP[iSub],
+                                                       dRdXop->dFidX[iSub], dRdXop->dFidV[iSub],
+                                                       dRdXop->dFvdX[iSub], dRdXop->dFvdV[iSub],
+                                                       dRdXop->dFidS[iSub], dRdXop->dMidGradP[iSub], dRdXop->dMidX[iSub],
+                                                       dRdXop->dMidV[iSub], dRdXop->dMidS[iSub], dRdXop->dMvdX[iSub], dRdXop->dMvdV[iSub],
+                                                       dX(iSub), (*dV)(iSub), dS, dGradP(iSub),
+                                                       dfi, dmi, dfv, dmv, hydro);
+
+    for(iSurf = 0; iSurf < numSurf; ++iSurf) {
+#pragma omp critical
+      dFi[iSurf] += dfi[iSurf];
+#pragma omp critical
+      dMi[iSurf] += dmi[iSurf];
+#pragma omp critical
+      dFv[iSurf] += dfv[iSurf];
+#pragma omp critical
+      dMv[iSurf] += dmv[iSurf];
+    }
+    delete [] dfi;
+    delete [] dmi;
+    delete [] dfv;
+    delete [] dmv;
+  }
+
+  for(iSurf = 0; iSurf < numSurf; ++iSurf) {
+//#pragma omp critical
+    {
+      double dCoef[12] = { dFi[iSurf][0], dFi[iSurf][1], dFi[iSurf][2],
+                           dMi[iSurf][0], dMi[iSurf][1], dMi[iSurf][2],
+                           dFv[iSurf][0], dFv[iSurf][1], dFv[iSurf][2],
+                           dMv[iSurf][0], dMv[iSurf][1], dMv[iSurf][2] };
+      com->globalSum(12, dCoef);
+
+      dFi[iSurf][0] = dCoef[0];
+      dFi[iSurf][1] = dCoef[1];
+      dFi[iSurf][2] = dCoef[2];
+
+      dMi[iSurf][0] = dCoef[3];
+      dMi[iSurf][1] = dCoef[4];
+      dMi[iSurf][2] = dCoef[5];
+
+      dFv[iSurf][0] = dCoef[6];
+      dFv[iSurf][1] = dCoef[7];
+      dFv[iSurf][2] = dCoef[8];
+
+      dMv[iSurf][0] = dCoef[9];
+      dMv[iSurf][1] = dCoef[10];
+      dMv[iSurf][2] = dCoef[11];
+    }
+  }
+
+  map<int, int>::iterator it;
+  for (it = surfOutMap.begin(); it != surfOutMap.end(); it++)  {
+    if (it->second > 0)  {
+      dFi[0] += dFi[it->second];
+
+      dMi[0] += dMi[it->second];
+
+      dFv[0] += dFv[it->second];
+
+      dMv[0] += dMv[it->second];
+    }
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+// Included (YC)
+// computes the transpose of derivative of non-dimensional forces and moments
+
+template<int dim>
+void PostOperator<dim>::computeTransposeDerivativeOfForceAndMoment(dRdXoperators<dim> *dRdXop, SVec<double,3> &dFi,
+                                                                   SVec<double,3> &dMi, SVec<double,3> &dFv, SVec<double,3> &dMv,
+                                                                   DistSVec<double,3> &dX, DistSVec<double,dim> &dU,
+                                                                   SVec<double,3> &dS, DistSVec<double,3> &dGradP, int hydro)
+{
+
+  *dV = 0.0;
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub) {
+    subDomain[iSub]->computeTransposeDerivativeOfForceAndMoment(dRdXop->dFidGradP[iSub], dRdXop->dFidX[iSub],
+                                                                dRdXop->dFidV[iSub], dRdXop->dFvdX[iSub],
+                                                                dRdXop->dFvdV[iSub], dRdXop->dFidS[iSub],
+                                                                dRdXop->dMidGradP[iSub], dRdXop->dMidX[iSub],
+                                                                dRdXop->dMidV[iSub], dRdXop->dMidS[iSub], dRdXop->dMvdX[iSub], dRdXop->dMvdV[iSub],
+                                                                dFi, dFv, dMi, dMv,
+                                                                dX(iSub), (*dV)(iSub), dS, dGradP(iSub), hydro);
+    dRdXop->dVdU[iSub]->applyTranspose((*dV)(iSub), dU(iSub));
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+// computes the derivative operators of non-dimensional forces and moments
+
+template<int dim>
+void PostOperator<dim>::computeDerivativeOperatorsOfForceAndMoment(dRdXoperators<dim> &dRdXop,
+                                                                   Vec3D &x0, DistSVec<double,3> &X,
+                                                                   DistSVec<double,dim> &U, int hydro)
+{
+
+#pragma omp parallel for
+  for (int iSub = 0; iSub < numLocSub; ++iSub) {
+    varFcn->conservativeToPrimitive(U(iSub), (*V)(iSub));
+    if(!built_dVdU) {
+      varFcn->computeConservativeToPrimitiveDerivativeOperators(U(iSub), (*V)(iSub), *dRdXop.dVdU[iSub], *dRdXop.dVdPstiff[iSub]);
+      built_dVdU = true;
+    }
+    subDomain[iSub]->computeDerivativeOperatorsOfForceAndMoment(surfOutMap, postFcn, (*bcData)(iSub), (*geoState)(iSub),
+                                                                X(iSub), (*V)(iSub), x0, hydro,
+                                                                *dRdXop.dFidGradP[iSub],
+                                                                *dRdXop.dFidX[iSub], *dRdXop.dFidV[iSub],
+                                                                *dRdXop.dFvdX[iSub], *dRdXop.dFvdV[iSub],
+                                                                *dRdXop.dFidS[iSub], *dRdXop.dMidGradP[iSub], *dRdXop.dMidX[iSub],
+                                                                *dRdXop.dMidV[iSub], *dRdXop.dMidS[iSub], *dRdXop.dMvdX[iSub], *dRdXop.dMvdV[iSub]);
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
+
 template<int dim>
 void PostOperator<dim>::computeDerivativeOfForceAndMoment(Vec3D &x0, DistSVec<double,3> &X, 
 							  DistSVec<double,dim> &U, 
diff -r da841a06e630 -r 5d849f9519c9 PostOperator.h
--- a/PostOperator.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/PostOperator.h	Mon Jan 30 20:09:06 2017 -0800
@@ -32,6 +32,8 @@
 template<int dim> class DistTimeState;
 template<int dim> class DistExactRiemannSolver;
 
+template<int dim> struct dRdXoperators;
+
 
 template<int dim>
 class ForceGenerator {
@@ -91,6 +93,7 @@
   DistVec<double> *Cs;
   DistVec<double> *CsDvms;
   DistVec<double> *CsDles;
+  bool built_dVdU;
 
 public:
 
@@ -211,6 +214,19 @@
 					 Vec3D *dFv, Vec3D *dMv, 
 					 int hydro=0, VecSet< DistSVec<double,3> > *mX=0, Vec<double> *genCF=0);
 
+  void computeDerivativeOfForceAndMoment(dRdXoperators<dim> *, DistSVec<double,3> &,
+                                         DistSVec<double,dim> &, double [3], DistSVec<double,3> &,
+                                         Vec3D *, Vec3D *, Vec3D *, Vec3D *, int = 0);
+  void computeTransposeDerivativeOfForceAndMoment(dRdXoperators<dim> *p, SVec<double,3> &,
+                                                SVec<double,3> &, SVec<double,3> &, SVec<double,3> &,
+                                                DistSVec<double,3> &, DistSVec<double,dim> &,
+                                                SVec<double,3> &, DistSVec<double,3> &, int = 0);
+
+  void computeDerivativeOperatorsOfForceAndMoment(dRdXoperators<dim> &dRdXop,
+                                                  Vec3D &x0, DistSVec<double,3> &X,
+                                                  DistSVec<double,dim> &U, int hydro);
+
+
   void computeDerivativeOfNodalForce(DistSVec<double,3> &, DistSVec<double,3> &,
                                      DistSVec<double,dim> &, DistSVec<double,dim> &,
                                      DistVec<double> &, double [3], DistSVec<double,3> &);
diff -r da841a06e630 -r 5d849f9519c9 RectangularSparseMatrix.C
--- a/RectangularSparseMatrix.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/RectangularSparseMatrix.C	Mon Jan 30 20:09:06 2017 -0800
@@ -158,6 +158,36 @@
 //------------------------------------------------------------------------------
 
 template<class Scalar, int dim, int dim2>
+void RectangularSparseMat<Scalar,dim,dim2>::addContrib(int row, int col, double C)
+{
+
+  int j, k, l;
+
+  int iNode = (nodeRenum) ? nodeRenum->renum[ row ] : row;
+//  fprintf(stderr, "iNode = %d, row = %d\n", iNode, row);
+  if (nodeType && nodeType[ row ] != BC_INTERNAL) {
+    int indx = find(iNode, iNode);
+    for (k = 0; k < dim2; ++k)
+      for (l = 0; l < dim; ++l)
+        a[indx][dim*k+l] = (k == l) ? 1.0 : 0.0;
+    return;
+  }
+
+  if (nodeType && nodeType[ col ] != BC_INTERNAL) return;
+  int jNode = (nodeRenum) ? nodeRenum->renum[ col ] : col;
+//  fprintf(stderr, "jNode = %d, col = %d\n", jNode, col);
+  int indx = find(iNode, jNode);
+  for (k = 0; k < dim2; ++k)
+    for (l = 0; l < dim; ++l) {
+      a[indx][dim*k+l] += (k == l) ? C : 0.0;
+    }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+template<class Scalar, int dim, int dim2>
 void RectangularSparseMat<Scalar,dim,dim2>::printFirstElementIn_a()
 {
   fprintf(stderr, "a[0] = %e\n", a.v[0][0]);
diff -r da841a06e630 -r 5d849f9519c9 RectangularSparseMatrix.h
--- a/RectangularSparseMatrix.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/RectangularSparseMatrix.h	Mon Jan 30 20:09:06 2017 -0800
@@ -79,6 +79,7 @@
 
   void addContrib(int, int *, double *);
   void addContrib(int, int, double *);
+  void addContrib(int, int, double);
 
   void createPointers(EdgeSet &);
 
diff -r da841a06e630 -r 5d849f9519c9 SpaceOperator.C
--- a/SpaceOperator.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/SpaceOperator.C	Mon Jan 30 20:09:06 2017 -0800
@@ -859,6 +859,7 @@
 template<int dim>
 void SpaceOperator<dim>::computeDerivativeOperators
 (
+  Vec3D &x0,
   DistSVec<double,3> &X,
   DistVec<double> &ctrlVol,
   DistSVec<double,dim> &U,
@@ -874,12 +875,10 @@
   geoState->computeDerivativeOperators(X, dRdXop->dEdgeNormdX, dRdXop->dFaceNormdX, dRdXop->dCtrlVoldX);
   domain->computeDerivativeOperatorOfGradP(dRdXop->dGradPdddx, dRdXop->dGradPdddy, dRdXop->dGradPdddz);
 
-//  com->printf(4," ... in SpaceOperator<dim>::computeDerivativeOperators 01\n");
   varFcn->conservativeToPrimitive(U, *V);
 
   if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)  {
     ngrad->compute(geoState->getConfig(), X, ctrlVol, *V);
-//    com->printf(4," ... in SpaceOperator<dim>::computeDerivativeOperators 02\n");
     ngrad->computeDerivativeOperators(X, ctrlVol, *V, *dRdXop);
   }
 
@@ -890,6 +889,11 @@
   *irey = 0.0;
   *direy = 0.0;
 
+  if (fet)
+  {
+    domain->computeDerivativeOperatorsOfGalerkinTerm(fet, *bcData, *geoState, X, *V, dRdXop->dViscousFluxdX);
+  }
+
   domain->computeDerivativeOperatorsOfFiniteVolumeTerm
   (
     *irey, *direy, fluxFcn, recFcn, *bcData, *geoState, 
@@ -899,6 +903,8 @@
   postOp->computeDerivativeOperatorsOfNodalForce(X, U, Pin, dRdXop->dForcedX, dRdXop->dForcedGradP, 
                                                  dRdXop->dForcedV, dRdXop->dForcedS, dRdXop->dVdU, dRdXop->dVdPstiff); 
 
+  postOp->computeDerivativeOperatorsOfForceAndMoment(*dRdXop, x0, X, U, 0);
+
 }
 
 //------------------------------------------------------------------------------
@@ -1060,20 +1066,27 @@
 void SpaceOperator<dim>::computeDerivativeOfResidual
 (
   dRdXoperators<dim> *dRdXop,
+  DistSVec<double,3> &X,
   DistSVec<double,3> &dX,
+  DistVec<double> &ctrlVol,
   DistVec<double> &dCtrlVol,
   DistVec<Vec3D> &dEdgeNormal,
   DistVec<Vec3D> &dFaceNormal,
   DistVec<double> &dFaceNormalVel,
+  DistSVec<double,dim> &R,
   DistSVec<double,dim> &dFlux_r,
   DistSVec<double,6> &dR_r,
   DistSVec<double,dim> &dddx_r,
   DistSVec<double,dim> &dddy_r,
-  DistSVec<double,dim> &dddz_r
+  DistSVec<double,dim> &dddz_r,
+  DistSVec<double,dim> &U,
+  double dMach,
+  DistTimeState<dim> *timeState
 )
 {
 
   dFlux_r = 0.0;
+  varFcn->conservativeToPrimitive(U, *V);
 //Remark: Error mesage for pointers
   if (dV == 0) {
     fprintf(stderr, "*** Error: Variable dV does not exist!\n");
@@ -1081,106 +1094,128 @@
   }
 
   *dV = 0.0;
-  if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)  {
+  if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)
     ngrad->computeDerivative(dRdXop, dX, dCtrlVol, *dV, dR_r, dddx_r, dddy_r, dddz_r);
 
-/******** individual check ****************************************
-    DistSVec<double,3> dX2(dX);  
-    DistSVec<double,dim> dddx_r2(dddx_r), dddy_r2(dddy_r), dddz_r2(dddz_r);
-    DistVec<double> dCtrlVol2(dCtrlVol);
-
-    dR_r = 0.0;   dddx_r2 = 0.0;    dddy_r2 = 0.0;     dddz_r2 = 0.0;
-    ngrad->computeDerivative(dRdXop, dX, dCtrlVol, *dV, dR_r, dddx_r2, dddy_r2, dddz_r2);
-    double aa = dddx_r2*dddx_r + dddy_r2*dddy_r + dddz_r2*dddz_r; 
-
-    dR_r = 0.0;   dCtrlVol2 = 0.0;   dX2 = 0.0;
-    ngrad->computeTransposeDerivative(dRdXop, dddx_r, dddy_r, dddz_r, dR_r, dCtrlVol2, *dV, dX2);
-    double bb = dX2*dX + dCtrlVol2*dCtrlVol;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) com->fprintf(stderr, " ... ngrad->computeDerivative ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else com->fprintf(stderr, " ... ngrad->computeDerivative ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
+  if (egrad) {
+    egrad->compute(geoState->getConfig(), X);
+    egrad->computeDerivative(geoState->getConfig(), X, dX);
   }
+
+  if (xpol){
+    xpol->compute(geoState->getConfig(),geoState->getInletNodeNorm(), X);
+    xpol->computeDerivative(geoState->getConfig(),geoState->getInletNodeNorm(), X);
+  }
+
+  if (vms) {
+    vms->compute(geoState->getConfig(), ctrlVol, X, *V, R);
+    vms->computeDerivative(geoState->getConfig(), ctrlVol, X, *V, R);
+  }
+
+  if (smag) {
+    domain->computeSmagorinskyLESTerm(smag, X, *V, R);
+    domain->computeDerivativeOfSmagorinskyLESTerm(smag, X, *V, R);
+  }
+
+  if (dles){
+    com->fprintf(stderr, "***** The equivalent derivatives of the functions dles->computeTestFilterValues and dles->computeTestFilterValues are not implemented!\n");
+    exit(1);
+  }
+
+  DistVec<double> *irey;
+  DistVec<double> *direy;
+
+  if(timeState)
+  {
+    irey = timeState->getInvReynolds();
+    direy = timeState->getDerivativeOfInvReynolds(*geoState, X, dX, ctrlVol, dCtrlVol, *V, *dV, dMach);
+  }
+  else
+  {
+    irey = new DistVec<double>(domain->getNodeDistInfo());
+    direy = new DistVec<double>(domain->getNodeDistInfo());
+    *irey = 0.0;
+    *direy = 0.0;
+  }
+
+
+  if (fet)
+  {
+    domain->computeDerivativeOfGalerkinTerm(*dRdXop, fet, *bcData, *geoState, X, dX, *V, *dV, dMach, dFlux_r);
+    bcData->computeNodeValue(X);
+    bcData->computeDerivativeOfNodeValue(X, dX);
+  }
+
+  //new source term: need dVdXj (warning for jac if limited rec -> recompute gradients)
+  //domain->computePointWiseSourceTerm(*geoState, ctrlVol, *ngrad, *V, R);
+  if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0) {
+    ngrad->limitDerivative(recFcn, X, dX, ctrlVol, dCtrlVol, *V, *dV);
+    ngrad->limit(recFcn, X, ctrlVol, *V);
+  }
+
   domain->computeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dX, *ngrad, egrad, 
                                               dddx_r, dddy_r, dddz_r, dEdgeNormal, dFaceNormal, dFaceNormalVel, dFlux_r);
 
-/* ********** two functions check **********************************************************
-    DistSVec<double,3> dX2(dX);  
-    DistSVec<double,dim> dFlux_r2(dFlux_r), dddx_r2(dddx_r), dddy_r2(dddy_r), dddz_r2(dddz_r);
-    DistVec<double> dCtrlVol2(dCtrlVol);
-    DistVec<double> dFaceNormalVel2(dFaceNormalVel);
-
-    DistVec<Vec3D> dEdgeNormal2(domain->getEdgeDistInfoMF()), dFaceNormal2(dFaceNormal);
-    dFlux_r2 = 0.0;    
-    dddx_r2 = 0.0;    dddy_r2 = 0.0;   dddz_r2 = 0.0;    dR_r = 0.0;   // intermediate terms
-    ngrad->computeDerivative(dRdXop, geoState->getConfigSA(), dX, dCtrlVol, dR_r, dddx_r2, dddy_r2, dddz_r2);
-    domain->computeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dX, *ngrad, egrad, 
-                                                dddx_r2, dddy_r2, dddz_r2, dEdgeNormal, dFaceNormal, dFaceNormalVel, dFlux_r2);
-    double aa = dFlux_r2*dFlux_r;
-
-    dX2 = 0.0;    dEdgeNormal2 = 0.0;   dFaceNormal2 = 0.0;    dFaceNormalVel2 = 0.0;   dCtrlVol2 = 0.0;  
-    dddx_r2 = 0.0;  dddy_r2 = 0.0;      dddz_r2 = 0.0;  dR_r = 0.0;    // intermediate terms 
-    domain->computeTransposeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dFlux_r, *ngrad, egrad, dX2,
-                                                         dddx_r2, dddy_r2, dddz_r2, dEdgeNormal2, dFaceNormal2, dFaceNormalVel2);
-    ngrad->computeTransposeDerivative(dRdXop, geoState->getConfigSA(), dddx_r2, dddy_r2, dddz_r2, dR_r, dCtrlVol2, dX2);
-    DistSVec<double,3> dEdgeNormalSVec(dEdgeNormal2.info()), dEdgeNormal2SVec(dEdgeNormal2.info());
-    DistSVec<double,3> dFaceNormalSVec(dFaceNormal.info()), dFaceNormal2SVec(dFaceNormal.info());
-    for(int iSub=0; iSub< dEdgeNormal.info().numLocThreads; iSub++)
-      for(int i=0; i<dEdgeNormal[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dEdgeNormalSVec(iSub)[i][j] = dEdgeNormal(iSub)[i][j];
-          dEdgeNormal2SVec(iSub)[i][j] = dEdgeNormal2(iSub)[i][j];
-        }
-    for(int iSub=0; iSub< dFaceNormal.info().numLocThreads; iSub++)
-      for(int i=0; i<dFaceNormal[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dFaceNormalSVec(iSub)[i][j] = dFaceNormal(iSub)[i][j];
-          dFaceNormal2SVec(iSub)[i][j] = dFaceNormal2(iSub)[i][j];
-        }
-
-    double bb = dX2*dX + dEdgeNormal2SVec*dEdgeNormalSVec + dFaceNormal2SVec*dFaceNormalSVec + dFaceNormalVel2*dFaceNormalVel + dCtrlVol2*dCtrlVol;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) com->fprintf(stderr, " ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else com->fprintf(stderr, " ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-
-
-/********  individual check ***************************************
-    DistSVec<double,3> dX2(dX);  
-    DistSVec<double,dim> dFlux_r2(dFlux_r), dddx_r2(dddx_r), dddy_r2(dddy_r), dddz_r2(dddz_r);
-    DistVec<double> dFaceNormalVel2(dFaceNormalVel);
-    DistVec<Vec3D> dEdgeNormal2(domain->getEdgeDistInfoMF()), dFaceNormal2(dFaceNormal);
-
-//    DistVec<Vec3D> dEdgeNormal2(dEdgeNormal), dFaceNormal2(dFaceNormal);
-    dX2 = 0.0;    dFlux_r2 = 0.0; 
-    domain->computeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dX, *ngrad, egrad, 
-                                                dddx_r, dddy_r, dddz_r, dEdgeNormal, dFaceNormal, dFaceNormalVel, dFlux_r2);
-    double aa = dFlux_r2*dFlux_r;
-
-    dddx_r2 = 0.0;   dddy_r2 = 0.0;   dddz_r2 = 0.0;   dEdgeNormal2 = 0.0;   dFaceNormal2 = 0.0;   dFaceNormalVel2 = 0.0;
-    domain->computeTransposeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dFlux_r, *ngrad, egrad, dX2,
-                                                         dddx_r2, dddy_r2, dddz_r2, dEdgeNormal2, dFaceNormal2, dFaceNormalVel2);
-    DistSVec<double,3> dEdgeNormalSVec(dEdgeNormal2.info()), dEdgeNormal2SVec(dEdgeNormal2.info());
-    DistSVec<double,3> dFaceNormalSVec(dFaceNormal.info()), dFaceNormal2SVec(dFaceNormal.info());
-    for(int iSub=0; iSub< dEdgeNormal.info().numLocThreads; iSub++)
-      for(int i=0; i<dEdgeNormal[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dEdgeNormalSVec(iSub)[i][j] = dEdgeNormal(iSub)[i][j];
-          dEdgeNormal2SVec(iSub)[i][j] = dEdgeNormal2(iSub)[i][j];
-        }
-    for(int iSub=0; iSub< dFaceNormal.info().numLocThreads; iSub++)
-      for(int i=0; i<dFaceNormal[iSub]->size(); ++i)
-        for(int j=0; j<3; ++j) { 
-          dFaceNormalSVec(iSub)[i][j] = dFaceNormal(iSub)[i][j];
-          dFaceNormal2SVec(iSub)[i][j] = dFaceNormal2(iSub)[i][j];
-        }
-
-    double bb = dX2*dX + dddx_r2*dddx_r + dddy_r2*dddy_r + dddz_r2*dddz_r + dEdgeNormal2SVec*dEdgeNormalSVec + dFaceNormal2SVec*dFaceNormalSVec + dFaceNormalVel2*dFaceNormalVel;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) com->fprintf(stderr, " ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else com->fprintf(stderr, " ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-
+  domain->getGradP(*ngrad);
+  domain->getDerivativeOfGradP(*ngrad);
+
+  if (volForce)
+  {
+    domain->computeVolumicForceTerm(volForce, ctrlVol, *V, R);
+    domain->computeDerivativeOfVolumicForceTerm(volForce, ctrlVol, dCtrlVol, *V, *dV, dFlux_r);
+  }
+
+  if(dvms) {
+    dvms->compute(fluxFcn, recFcn, fet, geoState->getConfig(), ctrlVol, *bcData, *geoState, timeState, X, U, *V, R, failsafe, rshift);
+    dvms->computeDerivative(fluxFcn, recFcn, fet, geoState->getConfig(), ctrlVol, *bcData, *geoState, timeState, X, U, *V, R, failsafe, rshift);
+  }
+
+
+  if (descriptorCase != DESCRIPTOR)  {
+    int numLocSub = dFlux_r.numLocSub();
+    int iSub;
+  #pragma omp parallel for
+    for (iSub=0; iSub<numLocSub; ++iSub) {
+      double *cv = ctrlVol.subData(iSub);
+      double *dcv = dCtrlVol.subData(iSub);
+      double (*r)[dim] = R.subData(iSub);
+      double (*dr)[dim] = dFlux_r.subData(iSub);
+      double (*drm)[dim] = (*dRm).subData(iSub);
+      switch (descriptorCase) {
+        case HYBRID:{
+          double drdcv[dim][ctrlVol.subSize(iSub)];
+          for (int i=0; i<ctrlVol.subSize(iSub); ++i) {
+            double invsqcv = 1.0 / sqrt(cv[i]);
+            for (int j=0; j<dim; ++j) {
+              drdcv[j][i] = r[i][j] * ( (-0.5) / pow(cv[i], 1.5) );
+              dr[i][j] = ( dr[i][j] * invsqcv ) +  drdcv[j][i]*dcv[i];
+            }
+          }
+          break; }
+        case NONDESCRIPTOR: {
+          double drdcv[dim][ctrlVol.subSize(iSub)];
+          for (int i=0; i<ctrlVol.subSize(iSub); ++i) {
+            double invcv = 1.0 / cv[i];
+            for (int j=0; j<dim; ++j) {
+              drdcv[j][i] = r[i][j] * ( (-1.0) / ( cv[i] * cv[i] ) );
+              dr[i][j] =  ( dr[i][j] * invcv ) +  drdcv[j][i]*dcv[i];
+            }
+          }
+          break; }
+      }
+    }
+  }
+
+  // Delete pointers for consistency
+  if (timeState == 0)
+  {
+    if (irey)
+      delete irey;
+    if (direy)
+      delete direy;
+  }
+  irey = 0;
+  direy = 0;
 }
 
 //------------------------------------------------------------------------------
@@ -1188,7 +1223,9 @@
 // Included (YC)
 template<int dim>
 void SpaceOperator<dim>::computeTransposeDerivativeOfResidual(dRdXoperators<dim> *dRdXop,
+		                                                      DistSVec<double,dim> &flux,
                                                               DistSVec<double,dim> &dFlux,
+															  DistVec<double> &ctrlVol,
                                                               DistVec<double> &dCtrlVol2,
                                                               DistSVec<double,3> &dX2,
                                                               DistSVec<double,dim> &dddx2,
@@ -1200,8 +1237,51 @@
                                                               DistSVec<double,6>& dR2)
 {
 
+	if (descriptorCase != DESCRIPTOR)  {
+	  int numLocSub = dFlux.numLocSub();
+	  int iSub;
+	 #pragma omp parallel for
+	  for (iSub=0; iSub<numLocSub; ++iSub) {
+	    double *cv = ctrlVol.subData(iSub);
+	    double *dcv = dCtrlVol2.subData(iSub);
+	    double (*r)[dim] = flux.subData(iSub);
+	    double (*dr)[dim] = dFlux.subData(iSub);
+	    double (*drm)[dim] = (*dRm).subData(iSub);
+	    switch (descriptorCase) {
+	      case HYBRID:{
+	        double drdcv[dim][ctrlVol.subSize(iSub)];
+	        for (int i=0; i<ctrlVol.subSize(iSub); ++i) {
+	          double invsqcv = 1.0 / sqrt(cv[i]);
+	          for (int j=0; j<dim; ++j) {
+	            drdcv[j][i] = r[i][j] * ( (-0.5) / pow(cv[i], 1.5) );
+	            dcv[i] += drdcv[j][i]*dr[i][j];
+	            dr[i][j] =  dr[i][j]*invsqcv;
+	 //              dr[i][j] =  dr[i][j]*invsqcv + drdcv[j][i]*dcv[i];
+	          }
+	        }
+	        break; }
+	      case NONDESCRIPTOR: {
+	        double drdcv[dim][ctrlVol.subSize(iSub)];
+	        for (int i=0; i<ctrlVol.subSize(iSub); ++i) {
+	          double invcv = 1.0 / cv[i];
+	          for (int j=0; j<dim; ++j) {
+	            drdcv[j][i] = r[i][j] * ( (-1.0) / ( cv[i] * cv[i] ) );
+	            dcv[i] += drdcv[j][i]*dr[i][j];
+	            dr[i][j] =  dr[i][j]*invcv;
+	 //              dr[i][j] =  ( dr[i][j] * invcv ) +  drdcv[j][i]*dcv[i];
+	          }
+	        }
+	        break; }
+	    }
+	  }
+	}
+
   domain->computeTransposeDerivativeOfFiniteVolumeTerm(*dRdXop, *bcData, *geoState, dFlux, *ngrad, egrad, dX2, dddx2, dddy2, dddz2, dEdgeNormal2, dFaceNormal2, dFaceNormalVel2);
 
+  if(fet) {
+    domain->computeTransposeDerivativeOfGalerkinTerm(*dRdXop, dFlux, dX2);
+
+  }
   if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)  
     ngrad->computeTransposeDerivative(dRdXop, dddx2, dddy2, dddz2, dR2, dCtrlVol2, *dV, dX2);
 
@@ -2250,7 +2330,6 @@
   *dU = 0.0;
 
   if (bcFcn) {
-    com->fprintf(stderr, "bcFCN is on ... \n");
     domain->applyBCsToDerivativeOfResidual(bcFcn, *bcData, U, *dU, dR);
   }
 }
@@ -2806,53 +2885,12 @@
 {
 
   varFcn->conservativeToPrimitiveDerivative(dRdXop->dVdU, dRdXop->dVdPstiff, dU, *dV);
-/*
-  DistSVec<double, dim> dU2(dU), dV2(*dV);
-  dU2 = 0.0;   dV2 = 0.0;
-  varFcn->conservativeToPrimitiveDerivative(dRdXop->dVdU, dRdXop->dVdPstiff, dU, dV2);
-  double aa = dV2*(*dV);
-  varFcn->conservativeToPrimitiveTransposeDerivative(dRdXop->dVdU, dRdXop->dVdPstiff, *dV, dU2);
-  double bb = dU2*dU;
-  double diffnorm = sqrt((aa-bb)*(aa-bb));
-  if( aa !=0 ) fprintf(stderr, " ... 1. rel. diff = %e\n", diffnorm/std::abs(aa));
-  else fprintf(stderr, " ... 1. abs. diff = %e\n", diffnorm);
-*/
 
   if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)  {
     ngrad->computeDerivative(dRdXop, dX, dCtrlVol, *dV, dR, dddx, dddy, dddz);  
-/*
-    DistSVec<double,dim> dddx2(dddx), dddy2(dddy), dddz2(dddz);
-    DistSVec<double,6> dR2(dR);
-    DistSVec<double,3> dX2(dX);
-    DistVec<double> dCtrlVol2(dCtrlVol);
-    dddx2 = 0;  dddy2 = 0;  dddz2 = 0;  dR2 = 0;  dX2 = 0;  dV2 = 0;  dCtrlVol2 = 0;
-   
-    ngrad->computeDerivative(dRdXop, geoState->getConfigSA(), dX, dCtrlVol, *dV, dR, dddx2, dddy2, dddz2);  
-    aa = dddx2*dddx + dddy2*dddy + dddz2*dddz;
-
-    ngrad->computeTransposeDerivative(dRdXop, geoState->getConfigSA(), dddx, dddy, dddz, dR2, dCtrlVol2, dV2, dX2);    
-    bb = dR2*dR + dCtrlVol2*dCtrlVol + dV2*(*dV) + dX2*dX;
-    diffnorm = sqrt((aa-bb)*(aa-bb));
-    if( aa !=0 ) fprintf(stderr, " ... 2. rel. diff = %e\n", diffnorm/std::abs(aa));
-    else fprintf(stderr, " ... 2. abs. diff = %e\n", diffnorm);
-*/
-//    ngrad->limitDerivative(recFcn, X, dX, ctrlVol, dCtrlVol, *V, *dV);
   }
 
   domain->getDerivativeOfGradP(dRdXop->dGradPdddx, dRdXop->dGradPdddy, dRdXop->dGradPdddz, dddx, dddy, dddz, dGradP);
-/*
-  DistSVec<double,dim> dddx2(dddx), dddy2(dddy), dddz2(dddz);
-  DistSVec<double,3> dGradP2(dGradP);
-  dddx2 = 0.0;  dddy2 = 0.0;  dddz2 = 0.0;  dGradP2 = 0.0;
-  domain->getDerivativeOfGradP(dRdXop->dGradPdddx, dRdXop->dGradPdddy, dRdXop->dGradPdddz, dddx, dddy, dddz, dGradP2);
-  aa = dGradP2*dGradP;
-
-  domain->getTransposeDerivativeOfGradP(dRdXop->dGradPdddx, dRdXop->dGradPdddy, dRdXop->dGradPdddz, dGradP, dddx2, dddy2, dddz2);
-  bb = dddx2*dddx + dddy2*dddy + dddz2*dddz;
-  diffnorm = sqrt((aa-bb)*(aa-bb));
-  if( aa !=0 ) fprintf(stderr, " ... 3. rel. diff = %e\n", diffnorm/std::abs(aa));
-  else fprintf(stderr, " ... 3. abs. diff = %e\n", diffnorm);
-*/
 }
 
 //------------------------------------------------------------------------------
@@ -2868,7 +2906,8 @@
   DistSVec<double,6> &dR,
   DistVec<double> &dCtrlVol, 
   DistSVec<double,3> &dX, 
-  DistSVec<double,dim> &dU
+  DistSVec<double,dim> &dU,
+  bool assembleDX
 )
 {
 
@@ -2878,8 +2917,7 @@
   domain->getTransposeDerivativeOfGradP(dRdXop->dGradPdddx, dRdXop->dGradPdddy, dRdXop->dGradPdddz, dGradP, dddx, dddy, dddz);
 
   if (dynamic_cast<RecFcnConstant<dim> *>(recFcn) == 0)  {
-    ngrad->computeTransposeDerivative(dRdXop, dddx, dddy, dddz, dR, dCtrlVol, *dV, dX2);    
-//    ngrad->limitDerivative(recFcn, X, dX, ctrlVol, dCtrlVol, *V, *dV);
+    ngrad->computeTransposeDerivative(dRdXop, dddx, dddy, dddz, dR, dCtrlVol, *dV, dX2);
   }
 
   varFcn->conservativeToPrimitiveTransposeDerivative(dRdXop->dVdU, dRdXop->dVdPstiff, *dV, dU2);
@@ -2891,6 +2929,10 @@
   CommPattern<double> *vec3DPat = domain->getCommPat(dX);
   domain->assemble(vPat, dU);
   domain->assemble(vec3DPat, dX);
+  if(assembleDX) {
+    CommPattern<double> *vec3DPat = domain->getCommPat(dX);
+    domain->assemble(vec3DPat, dX);
+  }
 
 }
 
diff -r da841a06e630 -r 5d849f9519c9 SpaceOperator.h
--- a/SpaceOperator.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/SpaceOperator.h	Mon Jan 30 20:09:06 2017 -0800
@@ -195,8 +195,8 @@
                        DistSVec<double,dim> &, DistSVec<double,dim> &, 
                        DistVec<int> &, DistVec<int> &, DistLevelSetStructure *,
                        bool, bool, DistVec<int> &, DistSVec<double,dim> &,
-                       DistExactRiemannSolver<dim> *, int,
-                       double, double, int it = 0, DistVec<GhostPoint<dim>*> *ghostPoints = 0);
+					   DistExactRiemannSolver<dim> *, int,
+					   double, double, int it = 0, DistVec<GhostPoint<dim>*> *ghostPoints = 0);
 
   void updateSweptNodes(DistSVec<double,3> &X,DistVec<double> &ctrlVol,
 			int phaseChangeChoice, int phaseChangeAlg,
@@ -355,17 +355,18 @@
   void rstFluxFcn(IoData &);
 
   // Included (YC)
-  void computeDerivativeOperators(DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, double, DistSVec<double,dim> &, DistVec<double> &,
+  void computeDerivativeOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, double, DistSVec<double,dim> &, DistVec<double> &,
                                   DistTimeState<dim> * = 0, PostOperator<dim> * = 0, dRdXoperators<dim> * =0);
 
   // Included (MB)
   void computeDerivativeOfResidual(DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &, DistVec<double> &,
                                DistSVec<double,dim> &, double, DistSVec<double,dim> &, DistSVec<double,dim> &, DistTimeState<dim> * = 0);
 
-  void computeDerivativeOfResidual(dRdXoperators<dim> *, DistSVec<double,3> &, DistVec<double> &, DistVec<Vec3D>&, DistVec<Vec3D>&, DistVec<double>&, 
-                                   DistSVec<double,dim> &, DistSVec<double,6> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,dim> &);
+  void computeDerivativeOfResidual(dRdXoperators<dim> *, DistSVec<double,3> &, DistSVec<double,3> &, DistVec<double> &, DistVec<double> &, DistVec<Vec3D>&, DistVec<Vec3D>&, DistVec<double>&,
+                                   DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,6> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,dim> &, double, DistTimeState<dim> *);
 
-  void computeTransposeDerivativeOfResidual(dRdXoperators<dim> *, DistSVec<double,dim> &, DistVec<double> &, DistSVec<double,3> &,
+  void computeTransposeDerivativeOfResidual(dRdXoperators<dim> *, DistSVec<double,dim> &, DistSVec<double,dim> &,
+                                            DistVec<double> &, DistVec<double> &, DistSVec<double,3> &,
                                             DistSVec<double,dim> &, DistSVec<double,dim> &, DistSVec<double,dim> &, DistVec<Vec3D>&,
                                             DistVec<Vec3D>&, DistVec<double>&, DistSVec<double,6>& );
 
@@ -478,7 +479,8 @@
     DistSVec<double,6> &dR,
     DistVec<double> &dCtrlVol,
     DistSVec<double,3> &dX,
-    DistSVec<double,dim> &dU
+	DistSVec<double,dim> &dU,
+	bool assembleDX = true
   );
 
   // Included (MB)
diff -r da841a06e630 -r 5d849f9519c9 SparseMatrix.C
--- a/SparseMatrix.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/SparseMatrix.C	Mon Jan 30 20:09:06 2017 -0800
@@ -534,9 +534,10 @@
     k2 = ku[i];
 
 #pragma ivdep
-    for (k=k1; k<k2; ++k)
+    for (k=k1; k<k2; ++k){
       DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndSubToVector(a.v, kk[k], x.v, kr[k], x.v, i);
       //subDenseMatrixTransTimesVector(a.v, kk[k], x.v, ja[k], x.v, i);
+    }
 
     //denseMatrixTransTimesVector(a.v, ju[i], x.v, i, tmp, 0);
     DenseMatrixOp<Scalar,dim,dim*dim>::applyTransToVector(a.v, ju[i], x.v, i, tmp, 0);
@@ -553,8 +554,10 @@
     k2 = kc[i+1];
 #pragma ivdep
     for (k=k1; k<k2; ++k)
-      DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndSubToVector(a.v, kk[k], x.v, kr[k], x.v,
-i);
+    	for (k=k1; k<k2; ++k) {
+    	  DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndSubToVector(a.v, kk[k], x.v, kr[k], x.v, i);
+    	  //subDenseMatrixTransTimesVector(a.v, kk[k], x.v, kr[k], x.v, i);
+    	}
       //subDenseMatrixTransTimesVector(a.v, kk[k], x.v, kr[k], x.v, i);
 
   }
diff -r da841a06e630 -r 5d849f9519c9 StiffMatrix.h
--- a/StiffMatrix.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/StiffMatrix.h	Mon Jan 30 20:09:06 2017 -0800
@@ -34,6 +34,9 @@
 
   void apply(DistSVec<double,dim> &, DistSVec<double,dim> &);
 
+  void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &)
+  {std::cout<<__FILE__<<":"<<__LINE__<<" empty header declaration called"; exit(-1);}
+
 };
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 StructExc.C
--- a/StructExc.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/StructExc.C	Mon Jan 30 20:09:06 2017 -0800
@@ -33,7 +33,6 @@
 #define CRACK_TAG3 44
 #define CRACK_TAG4 55
 
-#define FORCESENSITIVITY_TAG 15000
 //------------------------------------------------------------------------------
 
 StructExc::StructExc(IoData& iod, MatchNodeSet** mns, int bs, Communicator* sc, Communicator* fluidCom, int nSub)
@@ -405,7 +404,6 @@
 				DistSVec<double,3> &Xdot, DistSVec<double,3> &dX,
                                 bool isEmbedded) 
 {  
-//  fprintf(stderr,"[StExc] going to get displacement.\n");
   double norms[2] = {0.0, 0.0};
 
   dX = 0.0;
@@ -420,24 +418,10 @@
         int size = bufsize * numStrNodes[iCpu][0];
         double *localBuffer = buffer + bufsize * numStrNodes[iCpu][1];
         strCom->recFrom(iCpu, DISP_TAG + recParity, localBuffer, size);
-        com->printf(7, "[F] received displacement from structure\n"); 
-//        for(int i=0; i<size/3; i++)
-//          fprintf(stderr,"STEXC: %d %e %e %e\n", i+1, localBuffer[3*i], localBuffer[3*i+1], localBuffer[3*i+2]);
-
+        com->printf(7, "[F] received displacement from structure\n");
       }
     }
-/*
-    for(int i=0; i<800*2; i++)
-      fprintf(stderr,"buffer %d %e %e %e\n", i+1, buffer[3*i], buffer[3*i+1], buffer[3*i+2]);
-*/
     double (*disp)[2][3] = reinterpret_cast<double (*)[2][3]>(buffer);
-/*
-    for(int i=0; i<800; i++)
-      fprintf(stderr, "disp0 %d %e %e %e\n", i+1, disp[i][0][0], disp[i][0][1], disp[i][0][2]);
-
-    for(int i=0; i<800; i++)
-      fprintf(stderr, "disp1 %d %e %e %e\n", i+1, disp[i][1][0], disp[i][1][1], disp[i][1][2]);
-*/
 
 #pragma omp parallel for
     for (int iSub = 0; iSub < numLocSub; ++iSub) {
@@ -462,7 +446,6 @@
   com->globalSum(2, norms);
 
   com->printf(7, "Received total disp=%e and vel=%e from the structure\n", sqrt(norms[0]), sqrt(norms[1]));
-  //com->fprintf(stderr, "[StExc] Received total disp=%e and vel=%e from the structure\n", sqrt(norms[0]), sqrt(norms[1]));
 }
 
 //------------------------------------------------------------------------------
@@ -471,9 +454,8 @@
    configuration of the structure
 */
 
-void StructExc::getDisplacementSensitivity(DistSVec<double,3> &X, DistSVec<double,3> &dX) 
+void StructExc::getDisplacementSensitivity(DistSVec<double,3> &X, DistSVec<double,3> &dX, bool applyScale)
 {  
-//  fprintf(stderr,"[StExc] going to get displacement.\n");
   double norms[2] = {0.0, 0.0};
 
   dX = 0.0;
@@ -488,30 +470,17 @@
         double *localBuffer = buffer + bufsize * numStrNodes[iCpu][1];
         strCom->recFrom(iCpu, DISP_TAG + recParity, localBuffer, size);
         com->printf(7, "[F] received displacement sensitivity from structure\n"); 
-//        for(int i=0; i<size/3; i++)
-//          fprintf(stderr,"STEXC: %d %e %e %e\n", i+1, localBuffer[3*i], localBuffer[3*i+1], localBuffer[3*i+2]);
-
       }
     }
-/*
-    for(int i=0; i<800*2; i++)
-      fprintf(stderr,"buffer %d %e %e %e\n", i+1, buffer[3*i], buffer[3*i+1], buffer[3*i+2]);
-*/
     double (*disp)[2][3] = reinterpret_cast<double (*)[2][3]>(buffer);
-/*
-    for(int i=0; i<800; i++)
-      fprintf(stderr, "disp0 %d %e %e %e\n", i+1, disp[i][0][0], disp[i][0][1], disp[i][0][2]);
-
-    for(int i=0; i<800; i++)
-      fprintf(stderr, "disp1 %d %e %e %e\n", i+1, disp[i][1][0], disp[i][1][1], disp[i][1][2]);
-*/
 
 #pragma omp parallel for
     for (int iSub = 0; iSub < numLocSub; ++iSub) {
       double (*dx)[3] = dX.subData(iSub);
 
       double locNorms[2];
-      matchNodes[iSub]->getDisplacementSensitivity(X.getMasterFlag(iSub), disp, dx, locNorms);
+      if(!applyScale) matchNodes[iSub]->getDisplacementSensitivity(X.getMasterFlag(iSub), 1.0, disp, dx, locNorms);  // for adjoint sensitivity analysis
+      else matchNodes[iSub]->getDisplacementSensitivity(X.getMasterFlag(iSub), fscale, disp, dx, locNorms);  // for direct sensitivity analysis
 
 #pragma omp critical
       norms[0] += locNorms[0];
@@ -576,7 +545,7 @@
 //------------------------------------------------------------------------------
 // note: the force vector is *** NOT *** assembled
 
-void StructExc::sendForce(DistSVec<double,3> &F) 
+void StructExc::sendForce(DistSVec<double,3> &F, bool applyScale)
 {
   if (algNum == 4 || algNum == 5) sndParity = 1 - sndParity;
 
@@ -586,18 +555,27 @@
 
     double (*forces)[3] = reinterpret_cast<double (*)[3]>(buffer);
 
+    if(F.info().masterFlag) {
 #pragma omp parallel for reduction (+: norm)
-    for (int iSub = 0; iSub < numLocSub; ++iSub) {
-      SVec<double,3> &f = F(iSub);
-      norm += f*f * fscale*fscale;
-      matchNodes[iSub]->send(fscale, f.data(), forces);
+      for (int iSub = 0; iSub < numLocSub; ++iSub) {
+        SVec<double,3> &f = F(iSub);
+        if(applyScale) {
+          norm += f*f * fscale*fscale;
+          matchNodes[iSub]->send(fscale, f.data(), forces); // for the direct sensitivity analysis
+        } else {
+          int locOffset = F.info().subOffset[iSub];
+          int locLen = F.info().subLen[iSub];
+          norm += f*f;
+          matchNodes[iSub]->sendWithMasterFlag(1, f.data(), forces, F.info().masterFlag, locOffset);  // for the adjoint sensitivity analysis
+
+        }
+      }
     }
 
     for (int iCpu=0; iCpu<numStrCPU; ++iCpu) {
       if (numStrNodes[iCpu][0] > 0) {
         int size = 3 * numStrNodes[iCpu][0];
         double *localBuffer = buffer + 3 * numStrNodes[iCpu][1];
-//        fprintf(stderr,"<AERO-F> Sending the force. size = %d\n", size);
         strCom->sendTo(iCpu, FORCE_TAG + sndParity, localBuffer, size);
       }
     }
@@ -609,46 +587,6 @@
   norm = sqrt(norm);
 
   com->printf(7, "Sent fluid force=%e to the structure\n", norm);
-  //com->fprintf(stderr, "Sent fluid force=%e to the structure\n", norm);
-}
-
-//------------------------------------------------------------------------------
-// note: the force sensitivity vector is *** NOT *** assembled
-
-void StructExc::sendForceSensitivity(DistSVec<double,3> &dFdS) 
-{
-  if (algNum == 4 || algNum == 5) sndParity = 1 - sndParity;
-
-  double norm = 0.0;
-
-  if (numStrNodes) {
-
-    double (*forces)[3] = reinterpret_cast<double (*)[3]>(buffer);
-
-#pragma omp parallel for reduction (+: norm)
-    for (int iSub = 0; iSub < numLocSub; ++iSub) {
-      SVec<double,3> &f = dFdS(iSub);
-      norm += f*f * fscale*fscale;
-      matchNodes[iSub]->send(fscale, f.data(), forces);
-    }
-
-    for (int iCpu=0; iCpu<numStrCPU; ++iCpu) {
-      if (numStrNodes[iCpu][0] > 0) {
-        int size = 3 * numStrNodes[iCpu][0];
-        double *localBuffer = buffer + 3 * numStrNodes[iCpu][1];
-//        fprintf(stderr,"<AERO-F> Sending the force. size = %d\n", size);
-        strCom->sendTo(iCpu, FORCESENSITIVITY_TAG + sndParity, localBuffer, size);
-      }
-    }
-    strCom->waitForAllReq();
-  }
-
-  com->barrier();
-  com->globalSum(1, &norm);
-  norm = sqrt(norm);
-
-  com->printf(7, "Sent fluid force sensitivity=%e to the structure\n", norm);
-  //com->fprintf(stderr, "Sent fluid force=%e to the structure\n", norm);
 }
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 StructExc.h
--- a/StructExc.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/StructExc.h	Mon Jan 30 20:09:06 2017 -0800
@@ -59,11 +59,10 @@
 
   void getDisplacement(DistSVec<double,3> &, DistSVec<double,3> &, 
 		       DistSVec<double,3> &, DistSVec<double,3> &, bool isEmbedded);
-  void getDisplacementSensitivity(DistSVec<double,3> &, DistSVec<double,3> &);
+  void getDisplacementSensitivity(DistSVec<double,3> &, DistSVec<double,3> &, bool applyScale = false);
   int getSubcyclingInfo();
   void getTemperature(DistVec<double>&);
-  void sendForce(DistSVec<double,3> &);
-  void sendForceSensitivity(DistSVec<double,3> &);
+  void sendForce(DistSVec<double,3> &, bool applyScale = true);
   void getMdFreq(int &, double *&);
   void getMdStrDisp(int, DistSVec<double,3> &, DistSVec<double,3> &, DistSVec<double,3> &);
   void sendHeatPower(DistVec<double>&);
diff -r da841a06e630 -r 5d849f9519c9 SubDomain.C
--- a/SubDomain.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/SubDomain.C	Mon Jan 30 20:09:06 2017 -0800
@@ -243,57 +243,12 @@
   dWdX[0][0] =-pm*co11;  dWdX[0][1] =-pm*co12;  dWdX[0][2] =-pm*co13;  dWdX[0][3] = pm*co11;  dWdX[0][4] = pm*co12;  dWdX[0][5] = pm*co13;
   dWdX[1][0] =-pm*co21;  dWdX[1][1] =-pm*co22;  dWdX[1][2] =-pm*co23;  dWdX[1][3] = pm*co21;  dWdX[1][4] = pm*co22;  dWdX[1][5] = pm*co23;
   dWdX[2][0] =-pm*co31;  dWdX[2][1] =-pm*co32;  dWdX[2][2] =-pm*co33;  dWdX[2][3] = pm*co31;  dWdX[2][4] = pm*co32;  dWdX[2][5] = pm*co33;
-/*
-  dWdX = [-co11 -co12 -co13  co11  co12  co13 ] [dX[i][0]]
-         [-co21 -co22 -co23  co21  co22  co23 ] [dX[i][1]]
-         [-co31 -co32 -co33  co31  co32  co33 ] [dX[i][2]]
-                                                [dX[j][0]]
-                                                [dX[j][1]]
-                                                [dX[j][2]]
-*/
 
 // size of dWdR is 3x6
   dWdR[0][0] = ro11;  dWdR[0][1] = ro12;  dWdR[0][2] = ro13;  dWdR[0][3] = ro14;  dWdR[0][4] = ro15;  dWdR[0][5] = ro16; 
   dWdR[1][0] = ro21;  dWdR[1][1] = ro22;  dWdR[1][2] = ro23;  dWdR[1][3] = ro24;  dWdR[1][4] = ro25;  dWdR[1][5] = ro26; 
   dWdR[2][0] = ro31;  dWdR[2][1] = ro32;  dWdR[2][2] = ro33;  dWdR[2][3] = ro34;  dWdR[2][4] = ro35;  dWdR[2][5] = ro36; 
-/*
-  dWdR = [ cl04 cl05 cl06 cl07 cl08 cl09 ] [dR[0]]
-         [ dl04 dl05 dl06 dl07 dl08 dl09 ] [dR[1]]
-         [ bl03 bl04 bl05 bl06 bl07 bl08 ] [dR[2]]
-                                           [dR[3]]
-                                           [dR[4]]
-                                           [dR[5]]
-*/
-
-/*
-  dW[0] = cl01*ddx[0]
-        + cl02*ddx[1]
-        + cl03*ddx[2]
-        + cl04*dR[0]
-        + cl05*dR[1]
-        + cl06*dR[2]
-        + cl07*dR[3]
-        + cl08*dR[4]
-        + cl09*dR[5];
-  dW[1] = dl01*ddx[0]
-        + dl02*ddx[1]
-        + dl03*ddx[2]
-        + dl04*dR[0]
-        + dl05*dR[1]
-        + dl06*dR[2]
-        + dl07*dR[3]
-        + dl08*dR[4]
-        + dl09*dR[5];
-  dW[2] = bl01*ddx[0]
-        + bl02*ddx[1]
-        + bl00*ddx[2]
-        + bl03*dR[0]
-        + bl04*dR[1]
-        + bl05*dR[2]
-        + bl06*dR[3]
-        + bl07*dR[4]
-        + bl08*dR[5];
-*/
+
 }
 
 //------------------------------------------------------------------------------
@@ -333,30 +288,7 @@
   dW[0] = dalpha1 - dr12or11*alpha2 - r12or11*dalpha2 + dpsi*alpha3  + psi*dalpha3;
   dW[1] = dalpha2 - dr23or22*alpha3 - r23or22*dalpha3;
   dW[2] = dalpha3;
-/*
-  double dWdX[3][6];
-  double dWdR[3][6];
-  compute_dWdXAnddWdR(dx, R, W, dWdX, dWdR);
-
-  double dW2[3] = {0};
-  for (int i=0; i<3; ++i) 
-    for (int j=0; j<6; ++j) 
-      dW2[i] += dWdX[i][j]*dX[j]; 
-
-  for (int i=0; i<3; ++i) 
-    for (int j=0; j<6; ++j) 
-      dW2[i] += dWdR[i][j]*dR[j]; 
-
-  double relativeDiff = sqrt((dW[0]-dW2[0])*(dW[0]-dW2[0]) + (dW[1]-dW2[1])*(dW[1]-dW2[1]) + (dW[2]-dW2[2])*(dW[2]-dW2[2]));
-  double normOfdW = sqrt(dW[0]*dW[0] + dW[1]*dW[1] + dW[2]*dW[2]);
-  if(normOfdW != 0.0) {
-    double reldiffsquare = relativeDiff/normOfdW;
-    if(reldiffsquare > 1.0e-12)
-      fprintf(stderr," .... relativeDiff = %e\n", reldiffsquare);
-  } else
-    if(relativeDiff > 1.0e-10)
-      fprintf(stderr," ... relativeDiff = %e\n", relativeDiff);
-*/  
+
 }
 
 //------------------------------------------------------------------------------
@@ -855,35 +787,14 @@
   SVec<Scalar,dim> xxx(dddx), dddx2(dddx), uux(dddx);
   SVec<Scalar,dim> yyy(dddy), dddy2(dddy), uuy(dddy);
   SVec<Scalar,dim> zzz(dddz), dddz2(dddz), uuz(dddz);
-/*
-  if(isSparse) { 
- 
-    xxx = (Scalar) 0;    yyy = (Scalar) 0;   zzz = (Scalar) 0;
-    dddx2 = (Scalar) 0;  dddy2 = (Scalar) 0; dddz2 = (Scalar) 0;
-
-    dddxdX->apply(dX, xxx, 0);
-    dddydX->apply(dX, yyy, 0);
-    dddzdX->apply(dX, zzz, 0);
-
-    dddxdR->apply(dR, dddx, 0);
-    dddydR->apply(dR, dddy, 0);
-    dddzdR->apply(dR, dddz, 0);
-
-    dddx += xxx;    dddy += yyy;    dddz += zzz;
-    return;
-
-  }
-*/
 
   dddx = (Scalar) 0.0;
   dddy = (Scalar) 0.0;
   dddz = (Scalar) 0.0;
-//  fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 02 \n");
 
   bool *edgeFlag = edges.getMasterFlag();
   int (*edgePtr)[2] = edges.getPtr();
 
-//  fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 03 \n");
   for (int l=0; l<edges.size(); ++l) {
 
     if (!edgeFlag[l]) continue;
@@ -898,51 +809,14 @@
 
     double dx[3] = {X[j][0] - X[i][0], X[j][1] - X[i][1], X[j][2] - X[i][2]};
     double ddx[3] = {dX[j][0] - dX[i][0], dX[j][1] - dX[i][1], dX[j][2] - dX[i][2]};
-//    fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 04 \n");
+
     computeDerivativeOfLocalWeightsLeastSquares(dx, ddx, R[i], dR[i], Wi, dWi);
-/*    compute_dWdXAnddWdR( 1, dx, R[i], Wi, dWidX, dWidR);
-    for (int k=0; k<3; ++k) {
-      for (int q=0; q<6; ++q)
-        dWi2[k] += dWidR[k][q]*dR[i][q];
-      dWi2[k] += dWidX[k][0]*dX[i][0] + dWidX[k][1]*dX[i][1] + dWidX[k][2]*dX[i][2] + dWidX[k][3]*dX[j][0] + dWidX[k][4]*dX[j][1] + dWidX[k][5]*dX[j][2];
-    }
-
-    double difference(0.0), dWinorm(0.0);
-    for(int k=0; k<3; ++k) {
-      difference += (dWi[k] - dWi2[k])*(dWi[k] - dWi2[k]);
-      dWinorm += dWi[k]*dWi[k];
-    }
-    difference = sqrt(difference);
-    dWinorm = sqrt(dWinorm); 
-    if(dWinorm != 0 ) fprintf(stderr," ... rel. difference is %e\n", difference/dWinorm);
-    else fprintf(stderr," ... abs. difference is %e\n", difference);
-
-
-    double dWjdX[3][6] = {0}, dWjdR[3][6] = {0};
-*/
+
     dx[0] = -dx[0]; dx[1] = -dx[1]; dx[2] = -dx[2];
     ddx[0] = -ddx[0]; ddx[1] = -ddx[1]; ddx[2] = -ddx[2];
-//    fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 05 \n");
+
     computeDerivativeOfLocalWeightsLeastSquares(dx, ddx, R[j], dR[j], Wj, dWj);
-/*    compute_dWdXAnddWdR(-1, dx, R[j], Wj, dWjdX, dWjdR);
-    for (int k=0; k<3; ++k) {
-      for (int q=0; q<6; ++q)
-        dWj2[k] += dWjdR[k][q]*dR[j][q];
-      dWj2[k] += dWjdX[k][0]*dX[i][0] + dWjdX[k][1]*dX[i][1] + dWjdX[k][2]*dX[i][2] + dWjdX[k][3]*dX[j][0] + dWjdX[k][4]*dX[j][1] + dWjdX[k][5]*dX[j][2];
-    }
-
-    double difference2(0.0), dWjnorm(0.0);
-    for(int k=0; k<3; ++k) {
-      difference2 += (dWj[k] - dWj2[k])*(dWj[k] - dWj2[k]);
-      dWjnorm += dWj[k]*dWj[k];
-    }
-    difference2 = sqrt(difference2);
-    dWjnorm = sqrt(dWjnorm);
-    if(dWjnorm) fprintf(stderr," ... rel. difference2 is %e\n", difference2/dWjnorm);
-    else fprintf(stderr," ... abs. difference2 is %e\n", difference2);
-*/
-
-//    fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 06 \n");
+
     for (int k=0; k<dim; ++k) {
       deltaVar = var[j][k] - var[i][k];
       dDeltaVar = dvar[j][k] - dvar[i][k];
@@ -953,29 +827,8 @@
       dddy[j][k] -= (dWj[1] * deltaVar + Wj[1] * dDeltaVar);
       dddz[j][k] -= (dWj[2] * deltaVar + Wj[2] * dDeltaVar);
     }
-//    fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 07 \n");
-
-  }
-//  fprintf(stderr, " ... SubDomain::computeDerivativeOfGradientsLeastSquares 08 \n");
-/*
-  uux = dddx - dddx2;
-  uuy = dddy - dddy2;
-  uuz = dddz - dddz2;
-
-  double uuxnorm = uux.norm();
-  double uuynorm = uuy.norm();
-  double uuznorm = uuz.norm();
-  double dddxnorm = dddx.norm();
-  double dddynorm = dddy.norm();
-  double dddznorm = dddz.norm();
-
-  if(dddxnorm != 0 ) fprintf(stderr," ... (dddx2-dddx).norm()/dddx.norm() is %e\n", uuxnorm/dddxnorm );
-  else fprintf(stderr," ... (dddx2-dddx).norm() is %e\n", uuxnorm );
-  if(dddynorm != 0 ) fprintf(stderr," ... (dddy2-dddy).norm()/dddy.norm() is %e\n", uuynorm/dddynorm );
-  else fprintf(stderr," ... (dddy2-dddy).norm() is %e\n", uuynorm );
-  if(dddznorm != 0 ) fprintf(stderr," ... (dddz2-dddz).norm()/dddz.norm() is %e\n", uuznorm/dddznorm );
-  else fprintf(stderr," ... (dddz2-dddz).norm() is %e\n", uuznorm );
-*/
+
+  }
 }
 
 //------------------------------------------------------------------------------
@@ -1017,37 +870,12 @@
     double dWidX[3][6] = {0}, dWidR[3][6] = {0};
     compute_dWdXAnddWdR( 1, dx, R[i], Wi, dWidX, dWidR);
     dx[0] = -dx[0]; dx[1] = -dx[1]; dx[2] = -dx[2];
-//    ddx[0] = -ddx[0]; ddx[1] = -ddx[1]; ddx[2]  = -ddx[2];
     double dWjdX[3][6] = {0}, dWjdR[3][6] = {0};
     compute_dWdXAnddWdR(-1, dx, R[j], Wj, dWjdX, dWjdR);
-/*    computeDerivativeOfLocalWeightsLeastSquares(dx,ddx,R[j],R[j],Wj,dWj2);
-    for (int k=0; k<3; ++k) {
-      for (int q=0; q<6; ++q)
-        dWj[k] += dWjdR[k][q]*R[j][q];
-      dWj[k] += dWjdX[k][0]*X[i][0] + dWjdX[k][1]*X[i][1] + dWjdX[k][2]*X[i][2] + dWjdX[k][3]*X[j][0] + dWjdX[k][4]*X[j][1] + dWjdX[k][5]*X[j][2];
-    }
-
-    double difference2(0.0), dWjnorm(0.0);
-    for(int k=0; k<3; ++k) {
-      difference2 += (dWj[k] - dWj2[k])*(dWj[k] - dWj2[k]);
-      dWjnorm += dWj[k]*dWj[k];
-    }
-    difference2 = sqrt(difference2);
-    fprintf(stderr," ... rel. difference2 is %e\n", difference2/sqrt(dWjnorm));
-*/
+
     double dddxdVarray[2*dim][2*dim] = {0}, dddydVarray[2*dim][2*dim] = {0}, dddzdVarray[2*dim][2*dim] = {0};
 
     for (int k=0; k<dim; ++k) {
-/*
-      deltaVar = var[j][k] - var[i][k];
-      dDeltaVar = dvar[j][k] - dvar[i][k];
-      dddx[i][k] += Wi[0] * dvar[j][k] - Wi[0] * dvar[i][k];
-      dddy[i][k] += Wi[1] * dvar[j][k] - Wi[1] * dvar[i][k];
-      dddz[i][k] += Wi[2] * dvar[j][k] - Wi[2] * dvar[i][k];
-      dddx[j][k] -= Wj[0] * dvar[j][k] - Wj[0] * dvar[i][k];
-      dddy[j][k] -= Wj[1] * dvar[j][k] - Wj[1] * dvar[i][k];
-      dddz[j][k] -= Wj[2] * dvar[j][k] - Wj[2] * dvar[i][k];
-*/      
       dddxdVarray[k][k] = -Wi[0];      dddxdVarray[k][dim+k] = Wi[0];
       dddydVarray[k][k] = -Wi[1];      dddydVarray[k][dim+k] = Wi[1];
       dddzdVarray[k][k] = -Wi[2];      dddzdVarray[k][dim+k] = Wi[2];
@@ -1600,44 +1428,8 @@
                                                     NodalGrad<dim>& ngrad, EdgeGrad<dim>* egrad, double dMach,
                                                     SVec<double,dim>& dFluxes)
 {
-
-//  if(isSparse) {  
-/*
-    SVec<double,3> dX2(dX); 
-    SVec<double,dim> dFluxes2(dFluxes), dFluxes3(dFluxes);
-    dX2 = 0.0;    
-    dFluxes3 = 0.0;
-
-    Eigen::MatrixXd r(dFluxes3.size(), dim);  r.setRandom();
-    for(int i=0; i<dFluxes2.size(); ++i) for(int j=0; j<dim; ++j) dFluxes2[i][j] = r(i,j); 
-    edges.computeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
-                                              elems, geoState, dX, ngrad, egrad, dFluxes3);
-    double aa = dFluxes3*dFluxes2;
-
-    edges.computeTransposeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
-                                                       dFluxes2, ngrad, egrad, elems, geoState, dX2);
-    double bb = dX2*dX;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) fprintf(stderr, " ... rel.diff = %e, aa = %e, bb = %e\n", diff/aa, aa, bb);
-    else fprintf(stderr, " ... abs.diff = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
-//    SVec<double,dim> dFluxes2(dFluxes), diff(dFluxes);
-//    edges.computeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
-//                                              elems, geoState, dX, ngrad, egrad, dFluxes);
-/*    edges.computeDerivativeOfFiniteVolumeTerm(irey, dIrey, fluxFcn, recFcn, elems, geoState, X, dX, V, dV, ngrad, egrad, dMach, dFluxes2);
-    diff = dFluxes2 - dFluxes;
-    double diffnorm = diff.norm();
-    double dFluxesnorm = dFluxes.norm();
-    double dFluxes2norm = dFluxes2.norm();
-    if(dFluxesnorm != 0) fprintf(stderr, " ... rel. diff = %e\n", diffnorm/dFluxesnorm);
-    else fprintf(stderr, " ... abs. diff = %e\n", diffnorm);
-
-*/
-
-//  } else 
   edges.computeDerivativeOfFiniteVolumeTerm(irey, dIrey, fluxFcn, recFcn, elems, geoState, X, dX, V, dV, ngrad, egrad, dMach, dFluxes);
   faces.computeDerivativeOfFiniteVolumeTerm(fluxFcn, bcData, geoState, V, dFluxes);
-
 }
 
 //------------------------------------------------------------------------------
@@ -1666,23 +1458,6 @@
 {
   edges.computeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
                                             elems, geoState, dX, ngrad, egrad, dddx, dddy, dddz, dNormal, dFluxes);
-/*  SVec<double,3> dX2(dX);  
-  SVec<double,dim> dFluxes2(dFluxes);
-    dX2 = 0.0;    dFluxes = 0.0;
-    // fprintf(stderr, " ... norm of dFluxes is %e\n", dFluxes.norm());
-    // fprintf(stderr, " ... norm of dFluxes2 is %e\n", dFluxes2.norm());
-    edges.computeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
-                                              elems, geoState, dX, ngrad, egrad, dFluxes);
-    double aa = dFluxes2*dFluxes;
-    // fprintf(stderr, " ... norm of dFluxes is %e\n", dFluxes.norm());
-
-    edges.computeTransposeDerivativeOfFiniteVolumeTerm(dFluxdddx, dFluxdddy, dFluxdddz, dFluxdX, dFluxdEdgeNorm,
-                                                       dFluxes2, ngrad, egrad, elems, geoState, dX2);
-    double bb = dX2*dX;
-    double diff = sqrt((aa-bb)*(aa-bb));
-    if(aa != 0) fprintf(stderr, " ... relative error = %e, aa = %e, bb = %e\n", diff/abs(aa), aa, bb);
-    else fprintf(stderr, " ... absolute error = %e, aa = %e, bb = %e\n", diff, aa, bb);
-*/
   faces.computeDerivativeOfFiniteVolumeTerm(dFluxdFaceNormal, dFluxdFaceNormalVel, dFluxdUb, 
                                             bcData, geoState, dn, dndot, dFluxes);
 }
@@ -2287,6 +2062,45 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
+void SubDomain::computeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *dViscousFluxdX,
+            FemEquationTerm *fet, BcData<dim> &bcData,
+				    GeoState &geoState, SVec<double,3> &X, SVec<double,3> &dX,
+				    SVec<double,dim> &V, SVec<double,dim> &dV, double dMach, SVec<double,dim> &dR)
+{ //YC
+
+  dViscousFluxdX->apply(dX,dR);
+//  faces.computeDerivativeOfGalerkinTerm(elems, fet, bcData, geoState, X, dX, V, dV, dMach, dR2); // for Turbulent flow
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void SubDomain::computeTransposeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *dViscousFluxdX,
+				                                                 SVec<double,dim> &dR, SVec<double,3> &dX)
+{ //YC
+
+  SVec<double,3> dummy(dX);
+  dViscousFluxdX->applyTranspose(dR,dummy);
+  dX += dummy;
+
+}
+
+//------------------------------------------------------------------------------
+
+// Included (YC)
+template<int dim>
+void SubDomain::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, BcData<dim> &bcData,
+            GeoState &geoState, SVec<double,3> &X, SVec<double,dim> &V, RectangularSparseMat<double,3,dim> &dViscousFluxdX)
+{
+
+  elems.computeDerivativeOperatorsOfGalerkinTerm(fet, geoState, X, V, dViscousFluxdX);
+
+}
+
+//------------------------------------------------------------------------------
+
+
+template<int dim>
 void SubDomain::computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,
 					  SVec<double,dim> &V, SVec<double,dim> &R, 
 				          Vec<GhostPoint<dim>*> *ghostPoints,
@@ -3402,7 +3216,7 @@
 //------------------------------------------------------------------------------
 
 template<int dim, int dim2>
-RectangularSparseMat<double,dim,dim2> *SubDomain::create_ConstantBaseddRdXoperators()
+RectangularSparseMat<double,dim,dim2> *SubDomain::create_NodeToConstantBaseddRdXoperators()
 {
   Connectivity *nodeToConstant = createNodeToConstantConnectivity();
   int numNodes = nodes.size();
@@ -3417,6 +3231,37 @@
 //------------------------------------------------------------------------------
 
 template<int dim, int dim2>
+RectangularSparseMat<double,dim,dim2> *SubDomain::create_ConstantToNodeBaseddRdXoperators()
+{
+  Connectivity *constantToNode = createConstantToNodeConnectivity();
+  int numNodes = nodes.size();
+  int *ia = (*constantToNode).ptr();
+  int *ja = (*constantToNode)[0];
+  double (*a)[dim*dim2] = 0;
+
+  RectangularSparseMat<double, dim, dim2> *A = new RectangularSparseMat<double, dim, dim2>(1, ia[1], ia, ja, a, 0, 0);
+  return A;
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim, int dim2>
+RectangularSparseMat<double,dim,dim2> *SubDomain::create_ConstantToConstantBaseddRdXoperators()
+{
+  Connectivity *constantToConstant = createConstantToConstantConnectivity();
+  int numNodes = nodes.size();
+  int *ia = (*constantToConstant).ptr();
+  int *ja = (*constantToConstant)[0];
+  double (*a)[dim*dim2] = 0;
+
+  RectangularSparseMat<double, dim, dim2> *A = new RectangularSparseMat<double, dim, dim2>(1, ia[1], ia, ja, a, 0, 0);
+  return A;
+}
+
+//------------------------------------------------------------------------------
+
+
+template<int dim, int dim2>
 RectangularSparseMat<double,dim,dim2> *SubDomain::create_EdgeBaseddRdXoperators()
 {
   Connectivity *edgeToNode = createElementBasedEdgeToNodeConnectivity();
@@ -4106,8 +3951,8 @@
       i = edgePtr[l][0];
       j = edgePtr[l][1];
 
-      DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndAddToVector(a, numNodes + 2*l, p.v, j, prod.v, i);
-      DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndAddToVector(a, numNodes + 2*l + 1, p.v, i, prod.v, j);
+      DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndAddToVector(a, numNodes + 2*l, p.v, i, prod.v, j);
+      DenseMatrixOp<Scalar,dim,dim*dim>::applyTransAndAddToVector(a, numNodes + 2*l + 1, p.v, j, prod.v, i);
 
     }
 
@@ -6239,7 +6084,7 @@
 {
 
   for (int i=0; i<faces.size(); ++i)
-    faces[i].computeDerivativeOperatorsOfNodalForce(postFcn, X, V, Pin[i], gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
+	  faces[i].computeDerivativeOperatorsOfNodalForce(elems, postFcn, X, V, Pin[i], gradP, dForcedX, dForcedGradP, dForcedV, dForcedS);
 
 }
 
@@ -6443,9 +6288,9 @@
 // Included (MB)
 template<int dim>
 void SubDomain::computeDerivativeOfForceAndMoment(map<int,int> & surfOutMap, PostFcn *postFcn, BcData<dim> &bcData,
-				                  GeoState &geoState, SVec<double,3> &X, SVec<double,3> &dX,
-			                          SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
-				                  Vec3D &x0, Vec3D *dFi, Vec3D *dMi, Vec3D *dFv, Vec3D *dMv, int hydro)
+		                                          GeoState &geoState, SVec<double,3> &X, SVec<double,3> &dX,
+		                                          SVec<double,dim> &V, SVec<double,dim> &dV, double dS[3],
+		                                          Vec3D &x0, Vec3D *dFi, Vec3D *dMi, Vec3D *dFv, Vec3D *dMv, int hydro)
 {
 
   Vec<double> &d2wall = geoState.getDistanceToWall();
@@ -6467,9 +6312,195 @@
         idx = -1;
     }
 
+    if(idx >= 0){
+      faces[i].computeDerivativeOfForceAndMoment(elems, postFcn, X, dX, d2wall, Vwall[i], dVwall[i], V, dV, dS, x0, dFi[idx], dMi[idx], dFv[idx], dMv[idx], gradP, dGradP, hydro);
+    }
+  }
+
+}
+
+
+
+
+// Included (YC)
+template<int dim>
+void SubDomain::computeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,
+                                                  RectangularSparseMat<double,3,3> *dFidX,
+                                                  RectangularSparseMat<double,dim,3> *dFidV,
+                                                  RectangularSparseMat<double,3,3> *dFvdX,
+                                                  RectangularSparseMat<double,dim,3> *dFvdV,
+                                                  RectangularSparseMat<double,3,3> *dFidS,
+                                                  RectangularSparseMat<double,3,3> *dMidGradP,
+                                                  RectangularSparseMat<double,3,3> *dMidX,
+                                                  RectangularSparseMat<double,dim,3> *dMidV,
+                                                  RectangularSparseMat<double,3,3> *dMidS,
+                                                  RectangularSparseMat<double,3,3> *dMvdX,
+                                                  RectangularSparseMat<double,dim,3> *dMvdV,
+                                                  SVec<double,3> &dX,
+                                                  SVec<double,dim> &dV, double dS[3], SVec<double,3> &dGradPSVec,
+                                                  Vec3D *dFi, Vec3D *dMi, Vec3D *dFv, Vec3D *dMv, int hydro)
+{
+
+  if(hydro != 0) { fprintf(stderr, " *** Error: hydro must be zero for sparse format\n");  exit(-1); }
+
+  SVec<double,3> dFiSVec(1), dummy(1), dSSVec(1), dFvSVec(1);
+  dFiSVec[0][0] = dFi[0][0];
+  dFiSVec[0][1] = dFi[0][1];
+  dFiSVec[0][2] = dFi[0][2];
+  dFvSVec[0][0] = dFv[0][0];
+  dFvSVec[0][1] = dFv[0][1];
+  dFvSVec[0][2] = dFv[0][2];
+  dSSVec[0][0] = dS[0];
+  dSSVec[0][1] = dS[1];
+  dSSVec[0][2] = dS[2];
+  dFidV->apply(dV, dummy);
+  dFiSVec += dummy;
+  dFidGradP->apply(dGradPSVec, dummy);
+  dFiSVec += dummy;
+  dFidX->apply(dX, dummy);
+  dFiSVec += dummy;
+  dFidS->apply(dSSVec, dummy);
+  dFiSVec += dummy;
+  dFvdV->apply(dV, dummy);
+  dFvSVec += dummy;
+  dFvdX->apply(dX, dummy);
+  dFvSVec += dummy;
+
+  dFi[0][0] = dFiSVec[0][0];
+  dFi[0][1] = dFiSVec[0][1];
+  dFi[0][2] = dFiSVec[0][2];
+  dFv[0][0] = dFvSVec[0][0];
+  dFv[0][1] = dFvSVec[0][1];
+  dFv[0][2] = dFvSVec[0][2];
+
+  SVec<double,3> dMiSVec(1);
+  dMiSVec[0][0] = dMi[0][0];
+  dMiSVec[0][1] = dMi[0][1];
+  dMiSVec[0][2] = dMi[0][2];
+  dMidV->apply(dV, dummy);
+  dMiSVec += dummy;
+  dMidGradP->apply(dGradPSVec, dummy);
+  dMiSVec += dummy;
+  dMidX->apply(dX, dummy);
+  dMiSVec += dummy;
+  dMidS->apply(dSSVec, dummy);
+  dMiSVec += dummy;
+
+  dMi[0][0] = dMiSVec[0][0];
+  dMi[0][1] = dMiSVec[0][1];
+  dMi[0][2] = dMiSVec[0][2];
+
+  SVec<double,3> dMvSVec(1);
+  dMvSVec[0][0] = dMv[0][0];
+  dMvSVec[0][1] = dMv[0][1];
+  dMvSVec[0][2] = dMv[0][2];
+  dMvdX->apply(dX, dummy);
+  dMvSVec += dummy;
+  dMvdV->apply(dV, dummy);
+  dMvSVec += dummy;
+  dMv[0][0] = dMvSVec[0][0];
+  dMv[0][1] = dMvSVec[0][1];
+  dMv[0][2] = dMvSVec[0][2];
+
+}
+
+//------------------------------------------------------------------------------
+
+// Included (YC)
+template<int dim>
+void SubDomain::computeTransposeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,
+                                                           RectangularSparseMat<double,3,3> *dFidX,
+                                                           RectangularSparseMat<double,dim,3> *dFidV,
+                                                           RectangularSparseMat<double,3,3> *dFvdX,
+                                                           RectangularSparseMat<double,dim,3> *dFvdV,
+                                                           RectangularSparseMat<double,3,3> *dFidS,
+                                                           RectangularSparseMat<double,3,3> *dMidGradP,
+                                                           RectangularSparseMat<double,3,3> *dMidX,
+                                                           RectangularSparseMat<double,dim,3> *dMidV,
+                                                           RectangularSparseMat<double,3,3> *dMidS,
+                                                           RectangularSparseMat<double,3,3> *dMvdX,
+                                                           RectangularSparseMat<double,dim,3> *dMvdV,
+                                                           SVec<double,3> &dFiSVec, SVec<double,3> &dFvSVec,
+                                                           SVec<double,3> &dMiSVec, SVec<double,3> &dMvSVec, SVec<double,3> &dX,
+                                                           SVec<double,dim> &dV, SVec<double,3> &dSSVec,
+                                                           SVec<double,3> &dGradPSVec, int hydro)
+{
+
+  if(hydro != 0) { fprintf(stderr, " *** Error: hydro must be zero for sparse format\n");  exit(-1); }
+
+
+  SVec<double,3> dummy3(dGradPSVec);
+  SVec<double,dim> dVdummy(dV);
+  dFidV->applyTranspose(dFiSVec, dVdummy);
+  dV += dVdummy;
+  dFvdV->applyTranspose(dFvSVec, dVdummy);
+  dV += dVdummy;
+  dFidGradP->applyTranspose(dFiSVec, dummy3);
+  dGradPSVec += dummy3;
+  dFidX->applyTranspose(dFiSVec, dummy3);
+  dX += dummy3;
+  dFvdX->applyTranspose(dFvSVec, dummy3);
+  dX += dummy3;
+  dFidS->applyTranspose(dFiSVec, dummy3);
+  dSSVec += dummy3;
+
+  dMidV->applyTranspose(dMiSVec, dVdummy);
+  dV += dVdummy;
+  dMvdV->applyTranspose(dMvSVec, dVdummy);
+  dV += dVdummy;
+  dMidGradP->applyTranspose(dMiSVec, dummy3);
+  dGradPSVec += dummy3;
+  dMidX->applyTranspose(dMiSVec, dummy3);
+  dX += dummy3;
+  dMidS->applyTranspose(dMiSVec, dummy3);
+  dSSVec += dummy3;
+
+  dMvdX->applyTranspose(dMvSVec, dummy3);
+  dX += dummy3;
+
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void SubDomain::computeDerivativeOperatorsOfForceAndMoment(map<int,int> & surfOutMap, PostFcn *postFcn, BcData<dim> &bcData,
+                                                           GeoState &geoState, SVec<double,3> &X,
+                                                           SVec<double,dim> &V, Vec3D &x0, int hydro,
+                                                           RectangularSparseMat<double,3,3> &dFidGradP,
+                                                           RectangularSparseMat<double,3,3> &dFidX,
+                                                           RectangularSparseMat<double,dim,3> &dFidV,
+                                                           RectangularSparseMat<double,3,3> &dFvdX,
+                                                           RectangularSparseMat<double,dim,3> &dFvdV,
+                                                           RectangularSparseMat<double,3,3> &dFidS,
+                                                           RectangularSparseMat<double,3,3> &dMidGradP,
+                                                           RectangularSparseMat<double,3,3> &dMidX,
+                                                           RectangularSparseMat<double,dim,3> &dMidV,
+                                                           RectangularSparseMat<double,3,3> &dMidS,
+                                                           RectangularSparseMat<double,3,3> &dMvdX,
+                                                           RectangularSparseMat<double,dim,3> &dMvdV)
+{
+
+  Vec<double> &d2wall = geoState.getDistanceToWall();
+  SVec<double,dim> &Vwall = bcData.getFaceStateVector();
+
+  for (int i=0; i<faces.size(); ++i) {
+    int idx;
+    map<int,int>::iterator it = surfOutMap.find(faces[i].getSurfaceID());
+    if(it != surfOutMap.end() && it->second != -2)
+      idx = it->second;
+    else {
+      if(faces[i].getCode() == BC_ISOTHERMAL_WALL_MOVING ||
+         faces[i].getCode() == BC_ADIABATIC_WALL_MOVING  ||
+         faces[i].getCode() == BC_SLIP_WALL_MOVING ||
+         faces[i].getCode() == BC_POROUS_WALL_MOVING)
+        idx = 0;
+      else
+        idx = -1;
+    }
+
     if(idx >= 0)
-      faces[i].computeDerivativeOfForceAndMoment(elems, postFcn, X, dX, d2wall, Vwall[i], dVwall[i], V, dV, dS, x0, dFi[idx], dMi[idx], dFv[idx], dMv[idx], gradP, dGradP, hydro);
-
+      faces[i].computeDerivativeOperatorsOfForceAndMoment(elems, postFcn, X, d2wall, Vwall[i], V, x0, gradP, hydro,
+                                                          dFidGradP, dFidX, dFidV, dFvdX, dFvdV, dFidS, dMidGradP, dMidX, dMidV, dMidS, dMvdX, dMvdV);
   }
 
 }
diff -r da841a06e630 -r 5d849f9519c9 SubDomain.h
--- a/SubDomain.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/SubDomain.h	Mon Jan 30 20:09:06 2017 -0800
@@ -233,6 +233,8 @@
   Connectivity *createElementToNodeConnectivity();
   Connectivity *createEdgeBasedConnectivity();
   Connectivity *createNodeToConstantConnectivity();
+  Connectivity *createConstantToNodeConnectivity();
+  Connectivity *createConstantToConstantConnectivity();
   Connectivity *createElementBasedEdgeToNodeConnectivity();
   Connectivity *createElementBasedNodeToEdgeConnectivity();
   Connectivity *createFaceToNodeConnectivity();
@@ -501,11 +503,9 @@
 
   template<int dim, int dimLS>
   int computeFiniteVolumeTerm(ExactRiemannSolver<dim>&,
-                              FluxFcn**, RecFcn*, 
-										BcData<dim>&, GeoState&,
+                              FluxFcn**, RecFcn*,BcData<dim>&, GeoState&,
                               SVec<double,3>&, SVec<double,dim>&,
-                              SVec<double,dim>&, SVec<double,dim>&, 
-										LevelSetStructure&, bool,
+                              SVec<double,dim>&, SVec<double,dim>&, LevelSetStructure&, bool,
                               Vec<int> &, int, FluidSelector &,
                               NodalGrad<dim>&, EdgeGrad<dim>*,
 			      SVec<double,dimLS>& phi,
@@ -753,7 +753,13 @@
   RectangularSparseMat<double,dim,dim2> *create_NodeBaseddRdXoperators();
 
   template<int dim, int dim2>
-  RectangularSparseMat<double,dim,dim2> *create_ConstantBaseddRdXoperators();
+  RectangularSparseMat<double,dim,dim2> *create_ConstantToNodeBaseddRdXoperators();
+
+  template<int dim, int dim2>
+  RectangularSparseMat<double,dim,dim2> *create_NodeToConstantBaseddRdXoperators();
+
+  template<int dim, int dim2>
+  RectangularSparseMat<double,dim,dim2> *create_ConstantToConstantBaseddRdXoperators();
 
   template<int dim, int dim2>
   RectangularSparseMat<double,dim,dim2> *create_NodeToFaceBaseddRdXoperators();
@@ -1580,14 +1586,77 @@
 
   template<int dim>
   void computeDerivativeOfForceAndMoment(map<int,int> &surfIndexMap, PostFcn *, BcData<dim> &, GeoState &, SVec<double,3> &, SVec<double,3> &,
-                                                                           SVec<double,dim> &, SVec<double,dim> &, double [3],
-                                                                           Vec3D &, Vec3D *, Vec3D *, Vec3D *, Vec3D *, int = 0);
+                                         SVec<double,dim> &, SVec<double,dim> &, double [3],
+                                         Vec3D &, Vec3D *, Vec3D *, Vec3D *, Vec3D *, int = 0);
+
+  template<int dim>
+  void computeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,
+                                         RectangularSparseMat<double,3,3> *dFidX,
+                                         RectangularSparseMat<double,dim,3> *dFidV,
+                                         RectangularSparseMat<double,3,3> *dFvdX,
+                                         RectangularSparseMat<double,dim,3> *dFvdV,
+                                         RectangularSparseMat<double,3,3> *dFidS,
+                                         RectangularSparseMat<double,3,3> *dMidGradP,
+                                         RectangularSparseMat<double,3,3> *dMidX,
+                                         RectangularSparseMat<double,dim,3> *dMidV,
+                                         RectangularSparseMat<double,3,3> *dMidS,
+                                         RectangularSparseMat<double,3,3> *dMvdX,
+                                         RectangularSparseMat<double,dim,3> *dMvdV,
+                                         SVec<double,3> &dX,
+                                         SVec<double,dim> &dV, double dS[3], SVec<double,3> &,
+                                         Vec3D *dFi, Vec3D *dMi, Vec3D *dFv, Vec3D *dMv, int hydro = 0);
+
+  template<int dim>
+  void computeTransposeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,
+                                                  RectangularSparseMat<double,3,3> *dFidX,
+                                                  RectangularSparseMat<double,dim,3> *dFidV,
+                                                  RectangularSparseMat<double,3,3> *dFvdX,
+                                                  RectangularSparseMat<double,dim,3> *dFvdV,
+                                                  RectangularSparseMat<double,3,3> *dFidS,
+                                                  RectangularSparseMat<double,3,3> *dMidGradP,
+                                                  RectangularSparseMat<double,3,3> *dMidX,
+                                                  RectangularSparseMat<double,dim,3> *dMidV,
+                                                  RectangularSparseMat<double,3,3> *dMidS,
+                                                  RectangularSparseMat<double,3,3> *dMvdX,
+                                                  RectangularSparseMat<double,dim,3> *dMvdV,
+                                                  SVec<double,3> &dFiSVec, SVec<double,3> &dFvSVec,
+                                                  SVec<double,3> &dMiSVec, SVec<double,3> &dMvSVec, SVec<double,3> &dX,
+                                                  SVec<double,dim> &dV, SVec<double,3> &dSSVec,
+                                                  SVec<double,3> &dGradPSVec, int hydro);
+
+  template<int dim>
+  void computeDerivativeOperatorsOfForceAndMoment(map<int,int> &surfIndexMap, PostFcn *, BcData<dim> &, GeoState &, SVec<double,3> &,
+                                                  SVec<double,dim> &, Vec3D &, int,
+                                                  RectangularSparseMat<double,3,3> &dFidGradP,
+                                                  RectangularSparseMat<double,3,3> &dFidX,
+                                                  RectangularSparseMat<double,dim,3> &dFidV,
+                                                  RectangularSparseMat<double,3,3> &dFvdX,
+                                                  RectangularSparseMat<double,dim,3> &dFvdV,
+                                                  RectangularSparseMat<double,3,3> &dFidS,
+                                                  RectangularSparseMat<double,3,3> &dMidGradP,
+                                                  RectangularSparseMat<double,3,3> &dMidX,
+                                                  RectangularSparseMat<double,dim,3> &dMidV,
+                                                  RectangularSparseMat<double,3,3> &dMidS,
+                                                  RectangularSparseMat<double,3,3> &dMvdX,
+                                                  RectangularSparseMat<double,dim,3> &dMvdV);
 
   template<int dim>
   void computeDerivativeOfGalerkinTerm(FemEquationTerm *, BcData<dim> &, GeoState &,
 			   SVec<double,3> &, SVec<double,3> &, SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &);
 
   template<int dim>
+  void computeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *, FemEquationTerm *, BcData<dim> &, GeoState &,
+			   SVec<double,3> &, SVec<double,3> &, SVec<double,dim> &, SVec<double,dim> &, double, SVec<double,dim> &);
+
+  template<int dim>
+  void computeTransposeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *, SVec<double,dim> &, SVec<double,3> &);
+
+  template<int dim>
+  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *, BcData<dim> &, GeoState &,
+			   SVec<double,3> &, SVec<double,dim> &, RectangularSparseMat<double,3,dim> &);
+
+
+  template<int dim>
   void applyBCsToDerivativeOfResidual(BcFcn *, BcData<dim> &, SVec<double,dim> &, SVec<double,dim> &, SVec<double,dim> &);
 
   template<int dim>
diff -r da841a06e630 -r 5d849f9519c9 SubDomainCore.C
--- a/SubDomainCore.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/SubDomainCore.C	Mon Jan 30 20:09:06 2017 -0800
@@ -371,6 +371,104 @@
 
 }
 
+
+Connectivity *SubDomain::createConstantToNodeConnectivity()
+{
+
+  int numNodes = nodes.size();
+
+  int *numNeigh = reinterpret_cast<int *>(alloca(sizeof(int) * 1));
+
+  int i;
+  numNeigh[0] = numNodes;
+
+
+  int l;
+  int nnz = numNodes;
+
+  if (nnz != numNodes) {
+    fprintf(stderr,"*** Error: wrong number of nonzero blocks\n");
+    exit(1);
+  }
+
+  // construction of ia
+
+  int *ia = new int[2];
+
+  ia[0] = 0;
+  ia[1] = numNeigh[0];
+
+  // construction of ja
+
+  int *ja = new int[nnz];
+
+  for (l=0; l<numNodes; ++l) {
+    ja[l] = l;
+  }
+
+  for (i=0; i<1; ++i)
+#ifdef OLD_STL
+    sort(ja+ia[i], ja+ia[i+1]);
+#else
+    stable_sort(ja+ia[i], ja+ia[i+1]);
+#endif
+
+  Connectivity *constantToNode = new Connectivity(1, ia, ja);
+
+  return constantToNode;
+
+}
+
+//------------------------------------------------------------------------------
+
+Connectivity *SubDomain::createConstantToConstantConnectivity()
+{
+
+  int *numNeigh = reinterpret_cast<int *>(alloca(sizeof(int) * 1));
+
+  int i;
+  numNeigh[0] = 1;
+
+
+  int l;
+  int nnz = 1;
+
+  if (nnz != 1) {
+    fprintf(stderr,"*** Error: wrong number of nonzero blocks\n");
+    exit(1);
+  }
+
+  // construction of ia
+
+  int *ia = new int[2];
+
+  ia[0] = 0;
+  ia[1] = numNeigh[0];
+
+  // construction of ja
+
+  int *ja = new int[nnz];
+
+  for (l=0; l<1; ++l) {
+    ja[l] = l;
+  }
+
+  for (i=0; i<1; ++i)
+#ifdef OLD_STL
+    sort(ja+ia[i], ja+ia[i+1]);
+#else
+    stable_sort(ja+ia[i], ja+ia[i+1]);
+#endif
+
+  Connectivity *constantToconstant = new Connectivity(1, ia, ja);
+
+  return constantToconstant;
+
+}
+
+//------------------------------------------------------------------------------
+
+
 //------------------------------------------------------------------------------
 
 Connectivity *SubDomain::createElementBasedEdgeToNodeConnectivity()
@@ -928,22 +1026,11 @@
 {
 
   dCtrlVol = 0.0;
-//  Vec<double> dctrlvol(dCtrlVol);
-  
-//  if(isSparse) {
-//    dCtrlVoldX.apply(dX, dctrlvol);
-//    return 0;
-//  }
 
   for (int i=0; i<elems.size(); ++i) {
     double dVolume = elems[i].computeDerivativeOfControlVolumes(X, dX, dCtrlVol);
   }
-/*
-  Vec<double> diff = dctrlvol - dCtrlVol;
-  double dCtrlVolnorm = dCtrlVol.norm();
-  if(dCtrlVolnorm != 0) fprintf(stderr, " ... rel diff for dCtrlVol is %e\n",diff.norm()/dCtrlVolnorm);
-  else fprintf(stderr, " ... abs diff for dCtrlVol is %e\n",diff.norm());
-*/
+
   return 0;
 
 }
@@ -958,7 +1045,7 @@
   dCtrlVol = 0.0;
   
   dCtrlVoldX.apply(dX, dCtrlVol);
-//  fprintf(stderr, " ... norm of dCtrlVol is %e\n", dCtrlVol.norm());
+
   return 0;
 
 }
@@ -972,7 +1059,6 @@
  
   SVec<double,3> dummy(dX);
   dummy = 0.0; 
-//TODO: uncomment below
   dCtrlVoldX.applyTranspose(dCtrlVol, dummy);
   dX += dummy;
   return 0;
@@ -1079,16 +1165,9 @@
                                            Vec<Vec3D> &edgeNorm, Vec<Vec3D> &dEdgeNorm, Vec<double> &edgeNormVel, Vec<double> &dEdgeNormVel,
                                            Vec<Vec3D> &faceNorm, Vec<Vec3D> &dFaceNorm, Vec<double> &faceNormVel, Vec<double> &dFaceNormVel)
 {
-
   dEdgeNorm = 0.0;
   dEdgeNormVel = 0.0;
 
-//  if(isSparse) {
-//    dEdgeNormdX.apply(dX, dEdgeNorm);
-//    dFaceNormdX.apply(dX, dFaceNorm);
-//    return;
-//  }
-
   int i;
   for (i=0; i<elems.size(); ++i)
     elems[i].computeDerivativeOfEdgeNormals(X, dX, edgeNorm, dEdgeNorm, edgeNormVel, dEdgeNormVel);
@@ -1096,12 +1175,6 @@
 
   for (i=0; i<faces.size(); ++i)
     faces[i].computeDerivativeOfNormal(X, dX, faceNorm[i], dFaceNorm[i], faceNormVel[i], dFaceNormVel[i]);
-/*
-  Vec<Vec3D> diff = dfacenorm - dFaceNorm;
-  fprintf(stderr, " ... dfacenorm = %e, dFaceNorm = %e\n", dfacenorm.norm(), dFaceNorm.norm());
-  if(dEdgeNorm.norm() !=0 ) fprintf(stderr, " ... rel diff of dFaceNorm is %e\n", diff.norm()/dFaceNorm.norm()); 
-  else fprintf(stderr, " ... abs diff of dEdgeNorm is %e\n", diff.norm()); 
-*/
 }
 
 //------------------------------------------------------------------------------
@@ -1440,21 +1513,11 @@
 
 //------------------------------------------------------------------------------
 // Included (MB)
-// YC: if you intend to modified this routine, 
+// YC: if you intend to modified this routine,
 // you should also modify SubDomain::computeDerivativeTransposeOfWeightsLeastSquaresEdgePart accordingly
 // and                    SubDomain::compute_dRdX
 void SubDomain::computeDerivativeOfWeightsLeastSquaresEdgePart(SVec<double,3> &X, SVec<double,3> &dX, SVec<double,6> &R, SVec<double,6> &dR)
 {
-
-//  SVec<double,6> dr(dR), ur(dR);
-//  ur = 0.0; 
-/*
-  if(isSparse) {
-    dR = 0.0;
-    dRdX.apply(dX, dR, 0);
-    return;
-  }
-*/
   R = 0.0;
   dR = 0.0;
 
@@ -1527,15 +1590,7 @@
 
     dR[i][5] += ddzdz;
     dR[j][5] += ddzdz;
-
-  }
-/*
-  ur = dR - dr;
-  double urnorm = ur.norm();
-  double dRnorm = dR.norm();
-  if(dRnorm != 0) fprintf(stderr," ... norm(dR-dR2)/norm(dR2) = %e\n", urnorm/dRnorm);
-  else fprintf(stderr," ... norm(dR-dR2) = %e\n", urnorm);
-*/
+  }
 }
 
 //------------------------------------------------------------------------------
@@ -2105,15 +2160,6 @@
 // Included (MB)
 void SubDomain::computeDerivativeOfWeightsLeastSquaresNodePart(SVec<double,6> &R, SVec<double,6> &dR)
 {
-/*
-  SVec<double,6> dr(dR); //, dr2(dR), ur(dR);
-  if(isSparse) {
-    dRdR.apply(dr, dR, 0);
-//    fprintf(stderr," ... norm of dr is %e\n", dr2.norm());
-//    fprintf(stderr," ... norm of dR is %e\n", dR.norm());
-    return;
-  }
-*/
   for (int i=0; i<dR.size(); ++i) {
     double r11  = sqrt(R[i][0]);
     double dr11  = 1.0/(2.0*r11)*dR[i][0];
@@ -2136,11 +2182,7 @@
     dR[i][3] = dr22;
     dR[i][4] = dr23;
     dR[i][5] = dr33;
-
-  }
-//  ur = dR - dr2;
-//  fprintf(stderr," ... norm(dR-dR2)/norm(dR2) = %e\n", ur.norm()/dR.norm());
-
+  }
 }
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 ThermalCondFcn.h
--- a/ThermalCondFcn.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/ThermalCondFcn.h	Mon Jan 30 20:09:06 2017 -0800
@@ -19,6 +19,7 @@
 
 // Included (MB)
   virtual double computeDerivative(double, double, double) = 0;
+  virtual void computeDerivativeOperators(double, double &, double &) = 0;
   virtual void rstVar(IoData&) = 0;
 
 };
@@ -39,6 +40,7 @@
 
   double compute(double Tadim) { return thermal_conductivity_coefficient; }
   double computeDerivative(double Tadim, double dTadim, double dMach) { return 0.0; }
+  void computeDerivativeOperators(double Tadim, double &dkappadTaim, double &dkappadMach) { dkappadTaim=0.0; dkappadMach=0.0;}
   void rstVar(IoData &iod) { thermal_conductivity_coefficient = iod.eqs.thermalCondModel.conductivity; }
 
 };
@@ -71,6 +73,14 @@
     return ooPrandtl * varFcn->specificHeatCstPressure() * viscoFcn->compute_mu(Tadim);
   }
 
+  void computeDerivativeOperators(double Tadim, double &dkappadTadim, double &dkappadMach)
+  {
+    double dmudTadim(0), dmudMach(0);
+    viscoFcn->compute_muDerivativeOperators(Tadim, dmudTadim, dmudMach);
+    dkappadTadim = ooPrandtl * varFcn->specificHeatCstPressure() * dmudTadim;
+    dkappadMach = ooPrandtl * varFcn->specificHeatCstPressure() * dmudMach;
+  }
+
   double turbulentConductivity(double mut)
   { 
     return varFcn->specificHeatCstPressure() * mut * ooTurbPrandtl;
diff -r da841a06e630 -r 5d849f9519c9 TsDesc.C
--- a/TsDesc.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/TsDesc.C	Mon Jan 30 20:09:06 2017 -0800
@@ -814,10 +814,10 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
-void TsDesc<dim>::receiveBoundaryPositionSensitivityVector(DistSVec<double,3> &dXdSb)
+void TsDesc<dim>::receiveBoundaryPositionSensitivityVector(DistSVec<double,3> &dXdSb, bool applyScale)
 {
   if (mmh) {
-    mmh->updateDStep2(*Xs,dXdSb);
+	mmh->updateDStep2(*Xs,dXdSb, applyScale);
   }
 }
 
@@ -832,9 +832,9 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
-void TsDesc<dim>::sendForceSensitivity(DistSVec<double,3> *dFdS) 
+void TsDesc<dim>::sendForceSensitivity(DistSVec<double,3> *dFdS, bool applyScale)
 {
-  if (mmh)  mmh->sendForceSensitivity(dFdS);
+  if (mmh)  mmh->sendForceSensitivity(dFdS, applyScale);
 }
 
 //------------------------------------------------------------------------------
diff -r da841a06e630 -r 5d849f9519c9 TsDesc.h
--- a/TsDesc.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/TsDesc.h	Mon Jan 30 20:09:06 2017 -0800
@@ -153,7 +153,7 @@
 //  virtual double computePositionSensitivityVector(bool *, int, double);
   virtual void setMeshSensitivitySolverPositionVector();
   void negotiate();
-  void sendForceSensitivity(DistSVec<double,3> *);
+  void sendForceSensitivity(DistSVec<double,3> *, bool applyScale = true);
   void interpolatePositionVector(double, double);
   void computeMeshMetrics(int it = -1);
   virtual void updateStateVectors(DistSVec<double,dim> &, int = 0);
@@ -214,7 +214,7 @@
   TsParameters* getTsParams() {return data;}
   ErrorHandler* getErrorHandler() {return errorHandler;}
   void computeConvergenceInformation(IoData &ioData, const char* file, DistSVec<double,dim>&);
-  void receiveBoundaryPositionSensitivityVector(DistSVec<double,3> &);
+  void receiveBoundaryPositionSensitivityVector(DistSVec<double,3> &, bool applyScale = false);
 
   virtual void checkLocalRomStatus(DistSVec<double, dim> &, const int) {}
   virtual void writeBinaryVectorsToDiskRom(bool, int, int, DistSVec<double,dim> *, DistSVec<double,dim> *) {}  // state, residual
diff -r da841a06e630 -r 5d849f9519c9 TsOutput.C xx
--- a/TsOutput.C	Mon Jan 09 18:38:47 2017 -0800
+++ b/TsOutput.C	Mon Jan 30 20:09:06 2017 -0800
@@ -736,7 +736,29 @@
   else
     dLiftDrag = 0;
 
+  if (iod.output.transient.dLiftx[0] != 0) {
+    dLiftx = new char[dsp + strlen(iod.output.transient.dLiftx)];
+    sprintf(dLiftx, "%s%s", iod.output.transient.prefix, iod.output.transient.dLiftx);
+  }
+  else dLiftx = 0;
+
+  if (iod.output.transient.dLifty[0] != 0) {
+    dLifty = new char[dsp + strlen(iod.output.transient.dLifty)];
+    sprintf(dLifty, "%s%s", iod.output.transient.prefix, iod.output.transient.dLifty);
+  }
+  else dLifty = 0;
+
+  if (iod.output.transient.dLiftz[0] != 0) {
+    dLiftz = new char[dsp + strlen(iod.output.transient.dLiftz)];
+    sprintf(dLiftz, "%s%s", iod.output.transient.prefix, iod.output.transient.dLiftz);
+  }
+  else dLiftz = 0;
+
+
   fpdLiftDrag = 0;
+  fpdLiftx = 0;
+  fpdLifty = 0;
+  fpdLiftz = 0;
 
   if (iod.output.rom.dFluxNorm[0] != 0) {
     dFluxNorm = new char[sprom+ strlen(iod.output.rom.dFluxNorm)];
@@ -946,6 +968,9 @@
       delete[] dMatchPressure;
       delete[] dForces;
       delete[] dLiftDrag;
+      delete[] dLiftx;
+      delete[] dLifty;
+      delete[] dLiftz;
       delete[] dFluxNorm;
       
       int i;
@@ -1247,6 +1272,45 @@
   
       fflush(fpdLiftDrag);
     }
+    if (dLiftx) {
+      fpdLiftx = fopen(dLiftx, "w");
+      if (!fpdLiftx) {
+        fprintf(stderr, "*** Error: could not open \'%s\'\n", dLiftx);
+        exit(1);
+      }
+      if (refVal->mode == RefVal::NON_DIMENSIONAL)
+        fprintf(fpdLiftx, "dCLx\n");
+      else
+        fprintf(fpdLiftx, "dLx\n");
+
+      fflush(fpdLiftx);
+    }
+    if (dLifty) {
+      fpdLifty = fopen(dLifty, "w");
+      if (!fpdLifty) {
+        fprintf(stderr, "*** Error: could not open \'%s\'\n", dLifty);
+        exit(1);
+      }
+      if (refVal->mode == RefVal::NON_DIMENSIONAL)
+        fprintf(fpdLifty, "dCLy\n");
+      else
+        fprintf(fpdLifty, "dLy\n");
+
+      fflush(fpdLifty);
+    }
+    if (dLiftz) {
+      fpdLiftz = fopen(dLiftz, "w");
+      if (!fpdLiftz) {
+        fprintf(stderr, "*** Error: could not open \'%s\'\n", dLiftz);
+        exit(1);
+      }
+      if (refVal->mode == RefVal::NON_DIMENSIONAL)
+        fprintf(fpdLiftz, "dCLz\n");
+      else
+        fprintf(fpdLiftz, "dLz\n");
+
+      fflush(fpdLiftz);
+    }
   }
   if (hydrostaticforces) {
     if (it0 != 0){
@@ -2147,6 +2211,44 @@
 }
 
 //------------------------------------------------------------------------------
+template<int dim>
+void TsOutput<dim>::writeDerivativeOfLiftxToDisk(double& dLx)
+{
+
+  if (fpdLiftx) {
+    fprintf(fpdLiftx, "%16.13e\n", dLx);
+    fflush(fpdLiftx);
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void TsOutput<dim>::writeDerivativeOfLiftyToDisk(double& dLy)
+{
+
+  if (fpdLifty) {
+    fprintf(fpdLifty, "%16.13e\n", dLy);
+    fflush(fpdLifty);
+  }
+
+}
+
+//------------------------------------------------------------------------------
+
+template<int dim>
+void TsOutput<dim>::writeDerivativeOfLiftzToDisk(double& dLz)
+{
+
+  if (fpdLiftz) {
+    fprintf(fpdLiftz, "%16.13e\n", dLz);
+    fflush(fpdLiftz);
+  }
+
+}
+
+//------------------------------------------------------------------------------
 
 // Included (MB)
 template<int dim>
diff -r da841a06e630 -r 5d849f9519c9 TsOutput.h xx
--- a/TsOutput.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/TsOutput.h	Mon Jan 30 20:09:06 2017 -0800
@@ -156,11 +156,17 @@
   char *dMatchPressure;
   char *dForces;
   char *dLiftDrag;
+  char *dLiftx;
+  char *dLifty;
+  char *dLiftz;
   char *dFluxNorm;
 
   FILE *fpdMatchPressure;
   FILE *fpdForces;
   FILE *fpdLiftDrag;
+  FILE *fpdLiftx;
+  FILE *fpdLifty;
+  FILE *fpdLiftz;
   FILE *fpdFluxNorm;
 
   char *heatfluxes;
@@ -303,6 +309,9 @@
 
 // Included (YC)
   void writeDerivativeOfLiftDragToDisk(int it, int actvar, Vec3D & L, Vec3D & dL);
+  void writeDerivativeOfLiftxToDisk(double& dLx);
+  void writeDerivativeOfLiftyToDisk(double& dLy);
+  void writeDerivativeOfLiftzToDisk(double& dLz);
 
 // Included (MB)
   void rstVar(IoData &);
diff -r da841a06e630 -r 5d849f9519c9 VarFcn.h xx
--- a/VarFcn.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/VarFcn.h	Mon Jan 30 20:09:06 2017 -0800
@@ -209,6 +209,7 @@
   void rstVar(IoData &iod) { assert(numPhases==1); varFcn[0]->rstVar(iod); }
   Vec3D getDerivativeOfVelocity(double *dV, int tag=0) { check(tag); return varFcn[tag]->getDerivativeOfVelocity(dV); }
   double computeDerivativeOfTemperature(double *V, double *dV, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfTemperature(V,dV); }
+  void computeDerivativeOperatorsOfTemperature(double *V, double *dTdV, int tag=0) { check(tag); varFcn[tag]->computeDerivativeOperatorsOfTemperature(V,dTdV); }
   double computeDerivativeOfMachNumber(double *V, double *dV, double dMach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfMachNumber(V,dV,dMach); }
   double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfSoundSpeed(V,dV,dMach); }
   double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dmach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfTotalPressure(machr,dmachr,V,dV,dmach); }
@@ -671,8 +672,11 @@
 //------------------------------------------------------------------------------
 
 template<int dim>
-void VarFcn::computeConservativeToPrimitiveDerivativeOperators(DistSVec<double,dim> &U, DistSVec<double,dim> &V, 
-                            RectangularSparseMat<double,dim,dim> &dVdU, RectangularSparseMat<double,1,dim> &dVdPstiff, DistVec<int> *tag)
+void VarFcn::computeConservativeToPrimitiveDerivativeOperators(DistSVec<double,dim> &U,
+		                                                       DistSVec<double,dim> &V,
+		                                                       RectangularSparseMat<double,dim,dim> &dVdU,
+															   RectangularSparseMat<double,1,dim> &dVdPstiff,
+															   DistVec<int> *tag)
 {
 
   int numLocSub = U.numLocSub();
@@ -683,10 +687,8 @@
     double (*v)[dim] = V.subData(iSub);
     if(tag){
       int *loctag = tag->subData(iSub);
-      fprintf(stderr, " ... subSize is %d\n", U.subSize(iSub));
       for (int i=0; i<U.subSize(iSub); ++i) {
         varFcn[loctag[i]]->computeConservativeToPrimitiveDerivativeOperators(i, u[i], v[i], dVdU, dVdPstiff);
-        fprintf(stderr, " ... loctag[i] is %d\n", loctag[i]);
       }
     }else{
       for (int i=0; i<U.subSize(iSub); ++i)
diff -r da841a06e630 -r 5d849f9519c9 VarFcnBase.h xx
--- a/VarFcnBase.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/VarFcnBase.h	Mon Jan 30 20:09:06 2017 -0800
@@ -178,6 +178,9 @@
   virtual void rV(IoData &iod) { pmin = iod.eqs.fluidModel.pmin; }
   virtual Vec3D getDerivativeOfVelocity(double *dV) const { return Vec3D(dV[1], dV[2], dV[3]); }
   virtual double computeDerivativeOfTemperature(double *V, double *dV) const { return 0.0; }
+  virtual void computeDerivativeOperatorsOfTemperature(double *V, double dTdV[5]) const {
+    fprintf(stderr, "*** Error:  computeDerivativeOperatorsOfTemperature Function not defined\n");
+    exit(-1);  }
   virtual double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const { return 0.0; }
   virtual double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach) const { return 0.0; }
   virtual double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dmach) const { return 0.0; }
diff -r da841a06e630 -r 5d849f9519c9 VarFcnSGEuler.h xx
--- a/VarFcnSGEuler.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/VarFcnSGEuler.h	Mon Jan 30 20:09:06 2017 -0800
@@ -188,6 +188,11 @@
     return ( invgam1 * dV[4] - computeTemperature(V) * dV[0] ) /V[0];
   }
 
+  void computeDerivativeOperatorsOfTemperature(double *V, double dTdV[5]) const {
+    dTdV[0] = -computeTemperature(V)/V[0];
+    dTdV[4] = invgam1/V[0];
+  }
+
   double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const 
   {
     // Fix when the speed is 0
@@ -313,24 +318,16 @@
 void VarFcnSGEuler::computeConservativeToPrimitiveDerivativeOperators(double *U, double *V, double dVdU[5][5], double dVdPstiff[5])
 {
 
-//  dV[0] = dU[0];
 
   double invRho = 1.0 / V[0];
 
-//  dV[1] =  invRho*dU[1]  - invRho*V[1]*dU[0];
-//  dV[2] =  invRho*dU[2]  - invRho*V[2]*dU[0];
-//  dV[3] =  invRho*dU[3]  - invRho*V[3]*dU[0]; 
-
   double vel2 = V[1] * V[1] + V[2] * V[2] + V[3] * V[3];
 
-//  double dvel2 = 2.0 * V[1] * dV[1] + 2.0 * V[2] * dV[2] + 2.0 * V[3] * dV[3];
   double cf01 = gam-1.0;
   double cf02 = -0.5*cf01*vel2;
   double cf03 = -2.0*0.5*cf01*U[0]*V[1];
   double cf04 = -2.0*0.5*cf01*U[0]*V[2];
   double cf05 = -2.0*0.5*cf01*U[0]*V[3];
-//  dV[4] = cf01*dU[4] + cf03*invRho*dU[1]  + cf04*invRho*dU[2] + cf05*invRho*dU[3]  + (cf02 - cf05*invRho*V[3]- cf03*invRho*V[1] - cf04*invRho*V[2])*dU[0];
-
 
   dVdU[0][0] = 1.0;
   dVdU[1][0] = -invRho*V[1];    dVdU[1][1] = invRho;
diff -r da841a06e630 -r 5d849f9519c9 Vector3D.h
--- a/Vector3D.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/Vector3D.h	Mon Jan 30 20:09:06 2017 -0800
@@ -44,6 +44,10 @@
 
   double norm() { return(sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])); }
   double normsq() { return(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); }
+
+  void crossProductSensitivityOperator(double dReturndv2[3][3]);
+  void crossProductSensitivityOperator(const Vec3D &v2, double dReturndv1[3][3]);
+
 };
 
 //------------------------------------------------------------------------------
@@ -131,6 +135,44 @@
 }
 
 //------------------------------------------------------------------------------
+// define vector cross product sensitivity operator with respect to v2
+
+inline
+void Vec3D::crossProductSensitivityOperator(double dReturndv2[3][3])
+{
+
+  dReturndv2[0][0] = 0.0;
+  dReturndv2[0][1] = -v[2];
+  dReturndv2[0][2] = v[1];
+  dReturndv2[1][0] = v[2];
+  dReturndv2[1][1] = 0.0;
+  dReturndv2[1][2] = -v[0];
+  dReturndv2[2][0] = -v[1];
+  dReturndv2[2][1] = v[0];
+  dReturndv2[2][2] = 0.0;
+
+}
+
+//------------------------------------------------------------------------------
+// define vector cross product sensitivity operator with respect to v1
+
+inline
+void Vec3D::crossProductSensitivityOperator(const Vec3D &v2, double dReturndv1[3][3])
+{
+
+  dReturndv1[0][0] = 0.0;
+  dReturndv1[0][1] = v2.v[2];
+  dReturndv1[0][2] = -v2.v[1];
+  dReturndv1[1][0] = -v2.v[2];
+  dReturndv1[1][1] = 0.0;
+  dReturndv1[1][2] = v2.v[0];
+  dReturndv1[2][0] = v2.v[1];
+  dReturndv1[2][1] = -v2.v[0];
+  dReturndv1[2][2] = 0.0;
+
+}
+
+//------------------------------------------------------------------------------
 
 inline 
 Vec3D &Vec3D::operator*=(double cst)
diff -r da841a06e630 -r 5d849f9519c9 ViscoFcn.h
--- a/ViscoFcn.h	Mon Jan 09 18:38:47 2017 -0800
+++ b/ViscoFcn.h	Mon Jan 30 20:09:06 2017 -0800
@@ -34,7 +34,9 @@
 
 // Included (MB)
   virtual double compute_muDerivative(double, double, double) = 0;
+  virtual void compute_muDerivativeOperators(double, double&, double &) = 0;
   virtual double compute_lambdaDerivative(double, double, double) = 0;
+  virtual void compute_lambdaDerivativeOperators(double&, double&) = 0;
   virtual void rstVar(IoData &) = 0;
 
 };
@@ -54,9 +56,13 @@
 
 // Included (MB)
   double compute_muDerivative(double T, double dT, double dMach) { return 0.0; }
+  void compute_muDerivativeOperators(double T, double &dmudT, double &dmudMach) { dmudT = 0.0; dmudMach = 0.0; }
   double compute_lambdaDerivative(double mu, double dmu, double dMach) { 
     return -twothird*dmu;
   }
+  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) { //YC
+    dlambdadmu = -twothird;  dlambdadMach = 0.0;
+  }
 
   void rstVar(IoData &iod) {  
     ooreynolds_mu = 1.0/iod.ref.reynolds_mu; 
@@ -104,10 +110,23 @@
     double dT = dAlpha * Tadim + alpha * dTadim;
     return ( ( 1.5*(1.0 + Ts)*sqrt(T)*dT*(T + Ts) - T*sqrt(T)*(1.0 + Ts)*dT ) / ( (T + Ts)*(T + Ts) ) );
   }
+
+  void compute_muDerivativeOperators(double Tadim, double &dmudTadim, double &dmudMach) //YC
+  {
+    double T = alpha * Tadim;
+    double coef = 1.0/( (T + Ts)*(T + Ts) ), coef1 = 1.5*(1.0 + Ts)*sqrt(T)*(T+Ts), coef2 = - T*sqrt(T)*(1.0 + Ts);
+    dmudTadim = coef*(coef1+coef2)*alpha;
+    dmudMach = coef*(coef1+coef2)*dalpha*Tadim;
+  }
+
   double compute_lambdaDerivative(double mu, double dmu, double dMach) { 
     return -twothird*dmu;
   }
 
+  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) {//YC
+    dlambdadmu = -twothird;  dlambdadMach = 0.0;
+  }
+
   void rstVar(IoData &iod)
   {
     ooreynolds_mu = 1.0/iod.ref.reynolds_mu; 
@@ -151,10 +170,19 @@
     double dAlpha = dalpha*dMach;
     return (dAlpha * Tadim + alpha * dTadim);
   }
+  void compute_muDerivativeOperators(double Tadim, double &dmudTadim, double &dmudMach) //YC
+  {
+    dmudTadim = alpha;
+    dmudMach = dalpha*Tadim;
+  }
   double compute_lambdaDerivative(double mu, double dmu, double dMach) { 
     return -twothird*dmu;
   }
 
+  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) {//YC
+    dlambdadmu = -twothird;  dlambdadMach = 0.0;
+  }
+
   void rstVar(IoData &iod)
   {
     ooreynolds_mu = 1.0/iod.ref.reynolds_mu; 
