!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
1	f77src/printmask.f	/^ 1    continue$/;"	l	subroutine:pspltm	file:
10	f77src/computedfluxoperators.f	/^   10 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
10	f77src/dsvdc.f	/^   10       continue$/;"	l	subroutine:dsvdc	file:
10	f77src/eriemann_gg.f	/^ 10   CONTINUE$/;"	l	subroutine:ERIEMANNGG	file:
10	f77src/eriemann_gw.f	/^ 10   CONTINUE$/;"	l	subroutine:ERIEMANNGW	file:
10	f77src/eriemann_ww.f	/^ 10   CONTINUE$/;"	l	subroutine:ERIEMANNWW	file:
10	f77src/h12.f	/^   10     CL=MAX(abs(U(1,J)),CL)  $/;"	l	subroutine:H12	file:
10	f77src/printmask.f	/^ 10   format (A)$/;"	l	subroutine:pspltm	file:
10	f77src/printmask.f	/^10    continue$/;"	l	function:lenstr	file:
100	f77src/computedboundfluxoperator.f	/^  100 CONTINUE$/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
100	f77src/computedfluxoperators.f	/^  100 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
100	f77src/dsvdc.f	/^  100          continue$/;"	l	subroutine:dsvdc	file:
100	f77src/h12.f	/^  100     SM=SM*B   $/;"	l	subroutine:H12	file:
1000	f77src/computedboundfluxoperator.f	/^ 1000 CONTINUE$/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
1000	f77src/hllcflux.f	/^ 1000 continue$/;"	l	subroutine:HLLCFLUX	file:
1000	f77src/hllcflux1.f	/^ 1000 continue$/;"	l	subroutine:HLLCFLUX1	file:
1000	f77src/hllcjac.f	/^ 1000 continue$/;"	l	subroutine:HLLCJAC	file:
1010	f77src/computedboundfluxoperator.f	/^ 1010 CONTINUE$/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
1020	f77src/computedboundfluxoperator.f	/^ 1020 CONTINUE$/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
1030	f77src/computedboundfluxoperator.f	/^ 1030 CONTINUE$/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
11	f77src/printmask.f	/^ 11   format (2(I6,1x),A)$/;"	l	subroutine:pspltm	file:
110	f77src/computedfluxoperators.f	/^  110 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
110	f77src/dsvdc.f	/^  110          continue$/;"	l	subroutine:dsvdc	file:
110	f77src/h12.f	/^  110         I4=I4+ICE $/;"	l	subroutine:H12	file:
12	f77src/printmask.f	/^ 12   format (A,4(1x,F9.2))$/;"	l	subroutine:pspltm	file:
120	f77src/computedfluxoperators.f	/^  120 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
120	f77src/dsvdc.f	/^  120       continue$/;"	l	subroutine:dsvdc	file:
120	f77src/h12.f	/^  120     CONTINUE  $/;"	l	subroutine:H12	file:
120	f77src/spnnls.f	/^  120        ZZ(L)=B(L)    $/;"	l	subroutine:SPNNLS	file:
13	f77src/printmask.f	/^ 13   format (2(F9.2,1x),A)$/;"	l	subroutine:pspltm	file:
130	f77src/computedfluxoperators.f	/^  130 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
130	f77src/dsvdc.f	/^  130          continue$/;"	l	subroutine:dsvdc	file:
130	f77src/h12.f	/^  130 RETURN$/;"	l	subroutine:H12	file:
140	f77src/computedfluxoperators.f	/^  140 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
140	f77src/dsvdc.f	/^  140       continue$/;"	l	subroutine:dsvdc	file:
140	f77src/spnnls.f	/^  140 continue$/;"	l	subroutine:SPNNLS	file:
150	f77src/computedfluxoperators.f	/^  150 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
150	f77src/dsvdc.f	/^  150    continue$/;"	l	subroutine:dsvdc	file:
150	f77src/spnnls.f	/^  150    B(L)=ZZ(L)    $/;"	l	subroutine:SPNNLS	file:
160	f77src/computedfluxoperators.f	/^  160 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
160	f77src/dsvdc.f	/^  160 continue$/;"	l	subroutine:dsvdc	file:
160	f77src/spnnls.f	/^  160    continue$/;"	l	subroutine:SPNNLS	file:
170	f77src/dsvdc.f	/^  170 continue$/;"	l	subroutine:dsvdc	file:
180	f77src/dsvdc.f	/^  180       continue$/;"	l	subroutine:dsvdc	file:
180	f77src/spnnls.f	/^  180       A(L,J)=ZERO   $/;"	l	subroutine:SPNNLS	file:
190	f77src/dsvdc.f	/^  190    continue$/;"	l	subroutine:dsvdc	file:
2	f77src/printmask.f	/^ 2        continue $/;"	l	subroutine:pspltm	file:
20	f77src/computedfluxoperators.f	/^   20 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
20	f77src/dsvdc.f	/^   20    continue$/;"	l	subroutine:dsvdc	file:
20	f77src/eriemann_gg.f	/^ 20   CONTINUE$/;"	l	subroutine:ERIEMANNGG	file:
20	f77src/eriemann_gw.f	/^ 20   CONTINUE$/;"	l	subroutine:ERIEMANNGW	file:
20	f77src/eriemann_ww.f	/^ 20   CONTINUE$/;"	l	subroutine:ERIEMANNWW	file:
20	f77src/h12.f	/^   20 CLINV=ONE\/CL  $/;"	l	subroutine:H12	file:
20	f77src/spnnls.f	/^   20 CONTINUE $/;"	l	subroutine:SPNNLS	file:
200	f77src/computedboundfluxoperator.f	/^  200 CONTINUE $/;"	l	subroutine:COMPUTEDBOUNDFLUXOPERATOR	file:
200	f77src/dsvdc.f	/^  200    continue$/;"	l	subroutine:dsvdc	file:
200	f77src/spnnls.f	/^  200 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
210	f77src/dsvdc.f	/^  210          continue$/;"	l	subroutine:dsvdc	file:
210	f77src/spnnls.f	/^  210 continue  $/;"	l	subroutine:SPNNLS	file:
22	f77src/printmask.f	/^ 22     continue$/;"	l	subroutine:pspltm	file:
220	f77src/dsvdc.f	/^  220          continue$/;"	l	subroutine:dsvdc	file:
230	f77src/dsvdc.f	/^  230          continue$/;"	l	subroutine:dsvdc	file:
240	f77src/dsvdc.f	/^  240          continue$/;"	l	subroutine:dsvdc	file:
240	f77src/spnnls.f	/^  240 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
25	f77src/spnnls.f	/^   25 CONTINUE$/;"	l	subroutine:SPNNLS	file:
250	f77src/dsvdc.f	/^  250       continue$/;"	l	subroutine:dsvdc	file:
250	f77src/spnnls.f	/^  250 continue$/;"	l	subroutine:SPNNLS	file:
26	f77src/spnnls.f	/^   26       CONTINUE$/;"	l	subroutine:SPNNLS	file:
260	f77src/dsvdc.f	/^  260          continue$/;"	l	subroutine:dsvdc	file:
260	f77src/spnnls.f	/^  260 continue$/;"	l	subroutine:SPNNLS	file:
270	f77src/dsvdc.f	/^  270       continue$/;"	l	subroutine:dsvdc	file:
270	f77src/spnnls.f	/^  270       CONTINUE  $/;"	l	subroutine:SPNNLS	file:
28	f77src/spnnls.f	/^   28     SM=SM+B(I)**2$/;"	l	subroutine:SPNNLS	file:
280	f77src/dsvdc.f	/^  280    continue$/;"	l	subroutine:dsvdc	file:
280	f77src/spnnls.f	/^  280    continue$/;"	l	subroutine:SPNNLS	file:
290	f77src/dsvdc.f	/^  290    continue$/;"	l	subroutine:dsvdc	file:
3	f77src/printmask.f	/^ 3        continue          $/;"	l	subroutine:pspltm	file:
30	f77src/computedfluxoperators.f	/^   30 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
30	f77src/dsvdc.f	/^   30       continue$/;"	l	subroutine:dsvdc	file:
30	f77src/globalmatrices.f	/^30    FORMAT( 'cpu ', I3, ' failed in least squares with info: ', I3  )$/;"	l	subroutine:globalmatrices	file:
30	f77src/h12.f	/^   30     SM=SM+(U(1,J)*CLINV)**2 $/;"	l	subroutine:H12	file:
30	f77src/spnnls.f	/^   30 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
30	f77src/thinsvd.f	/^30    FORMAT( 'cpu ', I3, ' failed in svd with info: ', I3  )$/;"	l	subroutine:thinsvd	file:
300	f77src/dsvdc.f	/^  300 continue$/;"	l	subroutine:dsvdc	file:
300	f77src/spnnls.f	/^  300 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
310	f77src/dsvdc.f	/^  310          continue$/;"	l	subroutine:dsvdc	file:
310	f77src/spnnls.f	/^  310     ZZ(I)=B(I)    $/;"	l	subroutine:SPNNLS	file:
320	f77src/dsvdc.f	/^  320       continue$/;"	l	subroutine:dsvdc	file:
320	f77src/spnnls.f	/^  320 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
330	f77src/dsvdc.f	/^  330       continue$/;"	l	subroutine:dsvdc	file:
330	f77src/spnnls.f	/^  330 continue$/;"	l	subroutine:SPNNLS	file:
340	f77src/dsvdc.f	/^  340    continue$/;"	l	subroutine:dsvdc	file:
340	f77src/spnnls.f	/^  340     X(I)=ZZ(IP)   $/;"	l	subroutine:SPNNLS	file:
35	f77src/spnnls.f	/^  35     SM=SM+B(I)**2$/;"	l	subroutine:SPNNLS	file:
350	f77src/dsvdc.f	/^  350 continue$/;"	l	subroutine:dsvdc	file:
350	f77src/spnnls.f	/^  350 continue  $/;"	l	subroutine:SPNNLS	file:
360	f77src/dsvdc.f	/^  360 continue$/;"	l	subroutine:dsvdc	file:
360	f77src/spnnls.f	/^  360       SM=SM+B(I)**2 $/;"	l	subroutine:SPNNLS	file:
370	f77src/dsvdc.f	/^  370    continue$/;"	l	subroutine:dsvdc	file:
380	f77src/dsvdc.f	/^  380       continue$/;"	l	subroutine:dsvdc	file:
380	f77src/spnnls.f	/^  380       W(J)=ZERO     $/;"	l	subroutine:SPNNLS	file:
390	f77src/dsvdc.f	/^  390    continue$/;"	l	subroutine:dsvdc	file:
40	f77src/computedfluxoperators.f	/^   40 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
40	f77src/dsvdc.f	/^   40    continue$/;"	l	subroutine:dsvdc	file:
40	f77src/h12.f	/^   40 CL=-CL$/;"	l	subroutine:H12	file:
40	f77src/spnnls.f	/^   40        SM=SM+A(L,J)*B(L)     $/;"	l	subroutine:SPNNLS	file:
400	f77src/dsvdc.f	/^  400    continue$/;"	l	subroutine:dsvdc	file:
400	f77src/spnnls.f	/^  400 continue$/;"	l	subroutine:SPNNLS	file:
410	f77src/dsvdc.f	/^  410    continue$/;"	l	subroutine:dsvdc	file:
410	f77src/spnnls.f	/^  410       continue$/;"	l	subroutine:SPNNLS	file:
420	f77src/dsvdc.f	/^  420          continue$/;"	l	subroutine:dsvdc	file:
430	f77src/dsvdc.f	/^  430       continue$/;"	l	subroutine:dsvdc	file:
430	f77src/spnnls.f	/^  430 continue$/;"	l	subroutine:SPNNLS	file:
440	f77src/dsvdc.f	/^  440       continue$/;"	l	subroutine:dsvdc	file:
450	f77src/dsvdc.f	/^  450       continue$/;"	l	subroutine:dsvdc	file:
460	f77src/dsvdc.f	/^  460       continue$/;"	l	subroutine:dsvdc	file:
470	f77src/dsvdc.f	/^  470       continue$/;"	l	subroutine:dsvdc	file:
480	f77src/dsvdc.f	/^  480    continue$/;"	l	subroutine:dsvdc	file:
490	f77src/dsvdc.f	/^  490    continue$/;"	l	subroutine:dsvdc	file:
50	f77src/computedfluxoperators.f	/^   50 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
50	f77src/dsvdc.f	/^   50    continue$/;"	l	subroutine:dsvdc	file:
50	f77src/h12.f	/^   50 UP=U(1,LPIVOT)-CL $/;"	l	subroutine:H12	file:
50	f77src/spnnls.f	/^   50 continue$/;"	l	subroutine:SPNNLS	file:
500	f77src/dsvdc.f	/^  500          continue$/;"	l	subroutine:dsvdc	file:
500	f77src/spnnls.f	/^  500 FORMAT (A,I7,A,I7,2X,A,I7,2X,A,I7,A,I7,2X,A,ES13.6,4X,A,ES13.6)$/;"	l	subroutine:SPNNLS	file:
510	f77src/dsvdc.f	/^  510       continue$/;"	l	subroutine:dsvdc	file:
520	f77src/dsvdc.f	/^  520    continue$/;"	l	subroutine:dsvdc	file:
530	f77src/dsvdc.f	/^  530       continue$/;"	l	subroutine:dsvdc	file:
540	f77src/dsvdc.f	/^  540    continue$/;"	l	subroutine:dsvdc	file:
550	f77src/dsvdc.f	/^  550       continue$/;"	l	subroutine:dsvdc	file:
560	f77src/dsvdc.f	/^  560       continue$/;"	l	subroutine:dsvdc	file:
570	f77src/dsvdc.f	/^  570    continue$/;"	l	subroutine:dsvdc	file:
580	f77src/dsvdc.f	/^  580       continue$/;"	l	subroutine:dsvdc	file:
590	f77src/dsvdc.f	/^  590       if (l .eq. mm) go to 600$/;"	l	subroutine:dsvdc	file:
60	f77src/computedfluxoperators.f	/^   60 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
60	f77src/dsvdc.f	/^   60       continue$/;"	l	subroutine:dsvdc	file:
60	f77src/h12.f	/^   60 IF (CL) 130,130,70$/;"	l	subroutine:H12	file:
60	f77src/spnnls.f	/^   60 continue$/;"	l	subroutine:SPNNLS	file:
600	f77src/dsvdc.f	/^  600       continue$/;"	l	subroutine:dsvdc	file:
600	f77src/spnnls.f	/^  600 FORMAT (A,ES13.6)$/;"	l	subroutine:SPNNLS	file:
610	f77src/dsvdc.f	/^  610    continue$/;"	l	subroutine:dsvdc	file:
620	f77src/dsvdc.f	/^  620 continue$/;"	l	subroutine:dsvdc	file:
70	f77src/computedfluxoperators.f	/^   70 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
70	f77src/dsvdc.f	/^   70    continue$/;"	l	subroutine:dsvdc	file:
70	f77src/h12.f	/^   70 IF (NCV.LE.0) RETURN  $/;"	l	subroutine:H12	file:
70	f77src/hllejac.f	/^70       CONTINUE$/;"	l	subroutine:HLLEJAC	file:
70	f77src/roejac6.f	/^70       CONTINUE$/;"	l	subroutine:ROEJAC6	file:
70	f77src/roejac6jwl.f	/^70       CONTINUE$/;"	l	subroutine:ROEJAC6JWL	file:
70	f77src/spnnls.f	/^   70 CONTINUE  $/;"	l	subroutine:SPNNLS	file:
80	f77src/computedfluxoperators.f	/^   80 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
80	f77src/dsvdc.f	/^   80       continue$/;"	l	subroutine:dsvdc	file:
80	f77src/h12.f	/^   80 B=ONE\/B   $/;"	l	subroutine:H12	file:
90	f77src/computedfluxoperators.f	/^   90 CONTINUE$/;"	l	subroutine:COMPUTEDFLUXOPERATORS	file:
90	f77src/dsvdc.f	/^   90          continue$/;"	l	subroutine:dsvdc	file:
90	f77src/h12.f	/^   90         I3=I3+ICE $/;"	l	subroutine:H12	file:
90	f77src/spnnls.f	/^   90       UNORM=UNORM+A(L,J)**2     $/;"	l	subroutine:SPNNLS	file:
A	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Matrix<Scalar, 1, 1, Options, MaxRows, MaxCols> A;$/;"	t	struct:assign_coherent_impl
A	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Matrix<Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols> A;$/;"	t	struct:assign_coherent_impl
A	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Matrix<Scalar, B_Rows*B_Cols, A_Cols, A_Options, A_MaxRows, A_MaxCols> A;$/;"	t	struct:assign_coherent_impl
A	AutoDiff/SpaceDerivatives.h	/^  typedef Scalar A;$/;"	t	struct:assign_coherent_impl
A	DistMvpMatrix.h	/^  MvpMat<Scalar,dim> **A;$/;"	m	class:DistMvpMatrix
A	KspPrec.h	/^  DiagMat<Scalar,dim> **A;$/;"	m	class:JacobiPrec
A	KspPrec.h	/^  SparseMat<Scalar,dim> **A;$/;"	m	class:IluPrec
A	MatVecProd.h	/^  MvpMat<Scalar,dim> **A;  $/;"	m	class:MatVecProdH2
A	MatVecProd.h	/^  MvpMat<Scalar,neq> **A;$/;"	m	class:MatVecProdH1
A	MatVecProd.h	/^  MvpMat<double,dim> **A;$/;"	m	class:MatVecProdH1MultiPhase
A	MatVecProd.h	/^  MvpMat<double,dimLS> **A;$/;"	m	class:MatVecProdLS
A	StiffMatrix.h	/^  SparseMat<Scalar,dim> **A;$/;"	m	class:StiffMat
A	TsDesc.h	/^  VolVecType *A;$/;"	m	class:TsDesc
A	arpack++/include/arbnsmat.h	/^  ARTYPE*  A;$/;"	m	class:ARbdNonSymMatrix
A	arpack++/include/arbnspen.h	/^  ARbdNonSymMatrix<ARTYPE, ARFLOAT>* A;$/;"	m	class:ARbdNonSymPencil
A	arpack++/include/arbsmat.h	/^  ARTYPE*  A;$/;"	m	class:ARbdSymMatrix
A	arpack++/include/arbspen.h	/^  ARbdSymMatrix<ARTYPE>* A;$/;"	m	class:ARbdSymPencil
A	arpack++/include/ardnsmat.h	/^  ARTYPE*             A;$/;"	m	class:ARdsNonSymMatrix
A	arpack++/include/ardnspen.h	/^  ARdsNonSymMatrix<ARTYPE, ARFLOAT>* A;$/;"	m	class:ARdsNonSymPencil
A	arpack++/include/ardsmat.h	/^  ARTYPE*  A;$/;"	m	class:ARdsSymMatrix
A	arpack++/include/ardspen.h	/^  ARdsSymMatrix<ARTYPE>* A;$/;"	m	class:ARdsSymPencil
A	arpack++/include/arlnsmat.h	/^  SuperMatrix A;$/;"	m	class:ARluNonSymMatrix
A	arpack++/include/arlnspen.h	/^  ARluNonSymMatrix<ARTYPE, ARFLOAT>* A;$/;"	m	class:ARluNonSymPencil
A	arpack++/include/arlsmat.h	/^  SuperMatrix A;$/;"	m	class:ARluSymMatrix
A	arpack++/include/arlspen.h	/^  ARluSymMatrix<ARTYPE>* A;$/;"	m	class:ARluSymPencil
A	arpack++/include/arunspen.h	/^  ARumNonSymMatrix<ARTYPE, ARFLOAT>* A;$/;"	m	class:ARumNonSymPencil
A	arpack++/include/aruspen.h	/^  ARumSymMatrix<ARTYPE>* A;$/;"	m	class:ARumSymPencil
A1	IoData.h	/^  double A1,R1,rhoref,A2,R2;$/;"	m	struct:JWLModelData
A1	ProgrammedBurnCore.C	/^	double A1,A2,R1,R2,omega;$/;"	m	class:ProgrammedBurn_CJ::JWLEOS	file:
A1	VarFcnJwl.h	/^  double A1, A2, R1, R2, rhoref;$/;"	m	class:VarFcnJwl
A2	IoData.h	/^  double A1,R1,rhoref,A2,R2;$/;"	m	struct:JWLModelData
A2	ProgrammedBurnCore.C	/^	double A1,A2,R1,R2,omega;$/;"	m	class:ProgrammedBurn_CJ::JWLEOS	file:
A2	VarFcnJwl.h	/^  double A1, A2, R1, R2, rhoref;$/;"	m	class:VarFcnJwl
AAS	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
ABORT	arpack++/include/arlutil.h	23;"	d
ABS_VALUE	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	e	enum:TsData::Clipping
ACCELERATED	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	e	enum:ProblemData::Type
ACOUSTICBEAM	IoData.h	/^             ACOUSTICBEAM=5, SPIRALING = 6, ACOUSTICVISCOUSBEAM=7} type;$/;"	e	enum:ForcedData::Type
ACOUSTICVISCOUSBEAM	IoData.h	/^             ACOUSTICBEAM=5, SPIRALING = 6, ACOUSTICVISCOUSBEAM=7} type;$/;"	e	enum:ForcedData::Type
ADDRESS_FUNCTION	tools/alloca.cougar.c	50;"	d	file:
ADD_	arpack++/include/arlnames.h	29;"	d
ADD_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_CONST<const T>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
ADD_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_CONST{typedef const T TYPE;};$/;"	s	namespace:PhysBAM
ADD_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_REFERENCE<T&>{typedef T& TYPE;};$/;"	s	namespace:PhysBAM
ADD_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_REFERENCE{typedef T& TYPE;};$/;"	s	namespace:PhysBAM
ADD_STATE_TO_KRYLOV_OFF	IoData.h	/^  enum AddStateToKrylov {ADD_STATE_TO_KRYLOV_OFF = 0, ADD_STATE_TO_KRYLOV_ON = 1} addStateToKrylov;$/;"	e	enum:ROMOutputData::AddStateToKrylov
ADD_STATE_TO_KRYLOV_ON	IoData.h	/^  enum AddStateToKrylov {ADD_STATE_TO_KRYLOV_OFF = 0, ADD_STATE_TO_KRYLOV_ON = 1} addStateToKrylov;$/;"	e	enum:ROMOutputData::AddStateToKrylov
ADIABATIC	IoData.h	/^  enum Type { ADIABATIC = 1, ISOTHERMAL = 2 } type;$/;"	e	enum:SurfaceData::Type
ADIABATIC	IoData.h	/^  enum Type {ISOTHERMAL = 0, ADIABATIC = 1} type;$/;"	e	enum:BcsWallData::Type
ADJOINT	IoData.h	/^  enum Method {DIRECT = 0, ADJOINT = 1} method;$/;"	e	enum:SensitivityAnalysis::Method
AERO	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	e	enum:ProblemData::Type
AJ	ImplicitRomTsDesc.h	/^  VecSet<DistSVec<double, dim> > AJ; \/\/ Action of Jacobian (AJ) on reduced-order basis$/;"	m	class:ImplicitRomTsDesc
AJRestrict	ImplicitGappyTsDesc.h	/^  std::unique_ptr< VecSet < DistSVec<double, dim> > > AJRestrict;$/;"	m	class:ImplicitGappyTsDesc
ALGEBRAIC	IoData.h	/^   enum Type {PSEUDOSTRUCTURAL = 0, ALGEBRAIC = 1 } type;$/;"	e	enum:BLMeshMotionData::Type
ALIGN_SIZE	tools/alloca.cougar.c	116;"	d	file:
ALL	ErrorHandler.h	/^  enum Type {ALL = 0, SOLVER = 1};$/;"	e	enum:ErrorHandler::Type
ALL_LIFTFACE	IoData.h	/^		SPECIFIED_LIFTFACE  = 1, ALL_LIFTFACE = 2} includeLiftFaces;$/;"	e	enum:GappyConstructionData::IncludeLiftFaces
ALS_LAPACK_H	AlternatingLeastSquare/als_lapack.h	2;"	d
ALS_UTIL_H	AlternatingLeastSquare/als_util.h	2;"	d
ALWAYS	IoData.h	/^  enum FailSafe {NO = 0, YES = 1, ALWAYS = 2} failsafe;$/;"	e	enum:NewtonData::FailSafe
ALWAYSON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:BFixData::__anon10
ALWAYSON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:CFixData::__anon8
ALWAYSON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:SFixData::__anon9
ANALYTICAL	IoData.h	/^  enum SensitivityComputation {ANALYTICAL = 0, SEMIANALYTICAL = 1,  FINITEDIFFERENCE = 2} scFlag;$/;"	e	enum:SensitivityAnalysis::SensitivityComputation
AND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b1,bool b2,bool b3=true,bool b4=true> struct AND {static const bool value=b1 && b2 && b3 && b4;};$/;"	s	namespace:PhysBAM
APPROXIMATE	IoData.h	/^  enum FluxFcnJacobian {FINITE_DIFFERENCE = 0, APPROXIMATE = 1, EXACT = 2} ffjacobian;$/;"	e	enum:ImplicitData::FluxFcnJacobian
APPROX_METRIC_NL	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	e	enum:NonlinearRomOnlineData::SystemApproximation
APPROX_UPDATES_FALSE	IoData.h	/^  enum PreprocessForApproxUpdates {APPROX_UPDATES_FALSE = 0, APPROX_UPDATES_TRUE = 1} preprocessForApproxUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForApproxUpdates
APPROX_UPDATES_TRUE	IoData.h	/^  enum PreprocessForApproxUpdates {APPROX_UPDATES_FALSE = 0, APPROX_UPDATES_TRUE = 1} preprocessForApproxUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForApproxUpdates
AR	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
ARBGCOMP_H	arpack++/include/arbgcomp.h	19;"	d
ARBGNSYM_H	arpack++/include/arbgnsym.h	19;"	d
ARBGSYM_H	arpack++/include/arbgsym.h	19;"	d
ARBNSMAT_H	arpack++/include/arbnsmat.h	21;"	d
ARBNSPEN_H	arpack++/include/arbnspen.h	18;"	d
ARBSCOMP_H	arpack++/include/arbscomp.h	19;"	d
ARBSMAT_H	arpack++/include/arbsmat.h	21;"	d
ARBSNSYM_H	arpack++/include/arbsnsym.h	19;"	d
ARBSPEN_H	arpack++/include/arbspen.h	18;"	d
ARBSSYM_H	arpack++/include/arbssym.h	19;"	d
ARCH_H	arpack++/include/arch.h	20;"	d
ARCOMP_H	arpack++/include/arcomp.h	18;"	d
ARCompGenEig	arpack++/include/argcomp.h	/^  ARCompGenEig() { }$/;"	f	class:ARCompGenEig
ARCompGenEig	arpack++/include/argcomp.h	/^  ARCompGenEig(const ARCompGenEig& other) { Copy(other); }$/;"	f	class:ARCompGenEig
ARCompGenEig	arpack++/include/argcomp.h	/^ARCompGenEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARCompGenEig
ARCompGenEig	arpack++/include/argcomp.h	/^class ARCompGenEig:$/;"	c
ARCompStdEig	arpack++/include/arscomp.h	/^  ARCompStdEig() { }$/;"	f	class:ARCompStdEig
ARCompStdEig	arpack++/include/arscomp.h	/^  ARCompStdEig(const ARCompStdEig& other) { Copy(other); }$/;"	f	class:ARCompStdEig
ARCompStdEig	arpack++/include/arscomp.h	/^ARCompStdEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARCompStdEig
ARCompStdEig	arpack++/include/arscomp.h	/^class ARCompStdEig:$/;"	c
ARDFMAT_H	arpack++/include/ardfmat.h	20;"	d
ARDGCOMP_H	arpack++/include/ardgcomp.h	19;"	d
ARDGNSYM_H	arpack++/include/ardgnsym.h	19;"	d
ARDGSYM_H	arpack++/include/ardgsym.h	19;"	d
ARDNSMAT_H	arpack++/include/ardnsmat.h	21;"	d
ARDNSPEN_H	arpack++/include/ardnspen.h	18;"	d
ARDSCOMP_H	arpack++/include/ardscomp.h	19;"	d
ARDSMAT_H	arpack++/include/ardsmat.h	21;"	d
ARDSNSYM_H	arpack++/include/ardsnsym.h	19;"	d
ARDSPEN_H	arpack++/include/ardspen.h	18;"	d
ARDSSYM_H	arpack++/include/ardssym.h	19;"	d
ARERROR_H	arpack++/include/arerror.h	30;"	d
ARGCOMP_H	arpack++/include/argcomp.h	18;"	d
ARGEIG_H	arpack++/include/argeig.h	20;"	d
ARGNSYM_H	arpack++/include/argnsym.h	18;"	d
ARGSYM_H	arpack++/include/argsym.h	18;"	d
ARGenEig	arpack++/include/argeig.h	/^  ARGenEig() { }$/;"	f	class:ARGenEig
ARGenEig	arpack++/include/argeig.h	/^  ARGenEig(const ARGenEig& other) { Copy(other); }$/;"	f	class:ARGenEig
ARGenEig	arpack++/include/argeig.h	/^class ARGenEig:$/;"	c
ARHBMAT_H	arpack++/include/arhbmat.h	21;"	d
ARLGCOMP_H	arpack++/include/arlgcomp.h	19;"	d
ARLGNSYM_H	arpack++/include/arlgnsym.h	19;"	d
ARLGSYM_H	arpack++/include/arlgsym.h	20;"	d
ARLNSMAT_H	arpack++/include/arlnsmat.h	21;"	d
ARLNSPEN_H	arpack++/include/arlnspen.h	18;"	d
ARLSCOMP_H	arpack++/include/arlscomp.h	19;"	d
ARLSMAT_H	arpack++/include/arlsmat.h	21;"	d
ARLSNSYM_H	arpack++/include/arlsnsym.h	19;"	d
ARLSPEN_H	arpack++/include/arlspen.h	18;"	d
ARLSSYM_H	arpack++/include/arlssym.h	20;"	d
ARMAT_H	arpack++/include/armat.h	18;"	d
ARMatrix	arpack++/include/armat.h	/^  ARMatrix() { defined = false; }$/;"	f	class:ARMatrix
ARMatrix	arpack++/include/armat.h	/^  ARMatrix(int nrows, int ncols = 0)$/;"	f	class:ARMatrix
ARMatrix	arpack++/include/armat.h	/^class ARMatrix {$/;"	c
ARNOLDI_NOT_BUILD	arpack++/include/arerror.h	/^    ARNOLDI_NOT_BUILD   = -205,$/;"	e	enum:ArpackError::ErrorCode
ARNonSymGenEig	arpack++/include/argnsym.h	/^  ARNonSymGenEig() { part = 'R'; }$/;"	f	class:ARNonSymGenEig
ARNonSymGenEig	arpack++/include/argnsym.h	/^  ARNonSymGenEig(const ARNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARNonSymGenEig
ARNonSymGenEig	arpack++/include/argnsym.h	/^ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARNonSymGenEig
ARNonSymGenEig	arpack++/include/argnsym.h	/^class ARNonSymGenEig:$/;"	c
ARNonSymStdEig	arpack++/include/arsnsym.h	/^  ARNonSymStdEig() { }$/;"	f	class:ARNonSymStdEig
ARNonSymStdEig	arpack++/include/arsnsym.h	/^  ARNonSymStdEig(const ARNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARNonSymStdEig
ARNonSymStdEig	arpack++/include/arsnsym.h	/^ARNonSymStdEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARNonSymStdEig
ARNonSymStdEig	arpack++/include/arsnsym.h	/^class ARNonSymStdEig:$/;"	c
ARPACKF_H	arpack++/include/arpackf.h	18;"	d
ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ARRAY()$/;"	f	class:PhysBAM::ARRAY
ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ARRAY(const ARRAY& array)$/;"	f	class:PhysBAM::ARRAY
ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    explicit ARRAY(const ID m_input,const bool initialize_using_default_constructor=true)$/;"	f	class:PhysBAM::ARRAY
ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    explicit ARRAY(const T_ARRAY& array,typename ENABLE_IF<IS_SAME<T,typename T_ARRAY::ELEMENT>::value,UNUSABLE>::TYPE unused=UNUSABLE())$/;"	f	class:PhysBAM::ARRAY
ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^class ARRAY:public ARRAY_BASE<T,ARRAY<T,ID>,ID>$/;"	c	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_COPY.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/DOT_PRODUCT.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^namespace ARRAYS_COMPUTATIONS$/;"	n	namespace:PhysBAM
ARRAYS_ND_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^class ARRAYS_ND_BASE{};$/;"	c	namespace:PhysBAM
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_BASE(){}$/;"	f	class:PhysBAM::ARRAY_BASE
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_BASE(const ARRAY_BASE&){}$/;"	f	class:PhysBAM::ARRAY_BASE
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^class ARRAY_BASE$/;"	c	namespace:PhysBAM
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE()$/;"	f	class:PhysBAM::ARRAY_BASE
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE(const RANGE<TV_INT>& domain_input)$/;"	f	class:PhysBAM::ARRAY_BASE
ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^class ARRAY_BASE<T,ARRAYS_ND_BASE,VECTOR<int,dimension> >\/\/:public ARRAY_BASE<T,ARRAYS_ND_BASE<T,TV_INT>,TV_INT>$/;"	c	namespace:PhysBAM
ARRAY_COLLECTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^ARRAY_COLLECTION()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
ARRAY_COLLECTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^class ARRAY_COLLECTION:public CLONEABLE<ARRAY_COLLECTION<ID> >,public NONCOPYABLE$/;"	c	namespace:PhysBAM
ARRAY_COLLECTION_ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    ARRAY_COLLECTION_ELEMENT()$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
ARRAY_COLLECTION_ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    ARRAY_COLLECTION_ELEMENT(T_ARRAY* input_array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
ARRAY_COLLECTION_ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^class ARRAY_COLLECTION_ELEMENT:public CLONEABLE<ARRAY_COLLECTION_ELEMENT<T_ARRAY>,ARRAY_COLLECTION_ELEMENT_BASE>$/;"	c	namespace:PhysBAM
ARRAY_COLLECTION_ELEMENT_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT_BASE.h	/^class ARRAY_COLLECTION_ELEMENT_BASE:public CLONEABLE_ABSTRACT<ARRAY_COLLECTION_ELEMENT_BASE>$/;"	c	namespace:PhysBAM
ARRAY_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    ARRAY_DIFFERENCE(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	f	class:PhysBAM::ARRAY_DIFFERENCE
ARRAY_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^class ARRAY_DIFFERENCE:public ARRAY_EXPRESSION<typename SUM<typename T_ARRAY1::ELEMENT,typename T_ARRAY2::ELEMENT>::TYPE,ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2>,typename T_ARRAY1::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_EXPRESSION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_EXPRESSION.h	/^class ARRAY_EXPRESSION:public ARRAY_BASE<T,T_ARRAY,ID>$/;"	c	namespace:PhysBAM
ARRAY_LEFT_MULTIPLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    ARRAY_LEFT_MULTIPLE(const T1& c,const T_ARRAY2& array)$/;"	f	class:PhysBAM::ARRAY_LEFT_MULTIPLE
ARRAY_LEFT_MULTIPLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^class ARRAY_LEFT_MULTIPLE:public ARRAY_EXPRESSION<typename PRODUCT<T1,typename T_ARRAY2::ELEMENT>::TYPE,ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2>,typename T_ARRAY2::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    explicit ARRAY_NEGATION(const T_ARRAY& array)$/;"	f	class:PhysBAM::ARRAY_NEGATION
ARRAY_NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^class ARRAY_NEGATION:public ARRAY_EXPRESSION<typename T_ARRAY::ELEMENT,ARRAY_NEGATION<T_ARRAY>,typename T_ARRAY::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_PLUS_SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    ARRAY_PLUS_SCALAR(const T1& c,const T_ARRAY2& array)$/;"	f	class:PhysBAM::ARRAY_PLUS_SCALAR
ARRAY_PLUS_SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^class ARRAY_PLUS_SCALAR:public ARRAY_EXPRESSION<typename SUM<T1,typename T_ARRAY2::ELEMENT>::TYPE,ARRAY_PLUS_SCALAR<T1,T_ARRAY2>,typename T_ARRAY2::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_PLUS_SCALAR_VALID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T2,class ENABLE=void> struct ARRAY_PLUS_SCALAR_VALID {static const bool value=false;};$/;"	s	namespace:PhysBAM
ARRAY_PLUS_SCALAR_VALID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T2> struct ARRAY_PLUS_SCALAR_VALID<T1,T2,typename FIRST<void,typename SUM<T1,T2>::TYPE>::TYPE>$/;"	s	namespace:PhysBAM
ARRAY_PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    ARRAY_PRODUCT(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	f	class:PhysBAM::ARRAY_PRODUCT
ARRAY_PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^class ARRAY_PRODUCT:public ARRAY_EXPRESSION<typename PRODUCT<typename T_ARRAY1::ELEMENT,typename T_ARRAY2::ELEMENT>::TYPE,ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2>,typename T_ARRAY1::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T_ARRAY> struct ARRAY_RESULT_TYPE<const T_ARRAY>{typedef typename T_ARRAY::CONST_RESULT_TYPE TYPE;};$/;"	s	namespace:PhysBAM
ARRAY_RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T_ARRAY> struct ARRAY_RESULT_TYPE{typedef typename T_ARRAY::RESULT_TYPE TYPE;};$/;"	s	namespace:PhysBAM
ARRAY_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    ARRAY_SUM(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	f	class:PhysBAM::ARRAY_SUM
ARRAY_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^class ARRAY_SUM:public ARRAY_EXPRESSION<typename SUM<typename T_ARRAY1::ELEMENT,typename T_ARRAY2::ELEMENT>::TYPE,ARRAY_SUM<T_ARRAY1,T_ARRAY2>,typename T_ARRAY1::INDEX>$/;"	c	namespace:PhysBAM
ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW(T_ARRAY array,typename ENABLE_IF<IS_SAME<ELEMENT,typename T_ARRAY::ELEMENT>::value && IS_ARRAY_VIEW<T_ARRAY>::value,UNUSABLE>::TYPE unusable=UNUSABLE())$/;"	f	class:PhysBAM::ARRAY_VIEW
ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW(T_ARRAY& array,typename ENABLE_IF<IS_SAME<ELEMENT,typename T_ARRAY::ELEMENT>::value && !IS_ARRAY_VIEW<T_ARRAY>::value,UNUSABLE>::TYPE unusable=UNUSABLE())$/;"	f	class:PhysBAM::ARRAY_VIEW
ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW(const ARRAY_VIEW<typename REMOVE_CONST<T>::TYPE,ID>& array)$/;"	f	class:PhysBAM::ARRAY_VIEW
ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW(const ID m,T* raw_data)$/;"	f	class:PhysBAM::ARRAY_VIEW
ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^class ARRAY_VIEW:public ARRAY_BASE<typename REMOVE_CONST<T>::TYPE,ARRAY_VIEW<T,ID>,ID>$/;"	c	namespace:PhysBAM
ARRGCOMP_H	arpack++/include/arrgcomp.h	18;"	d
ARRGEIG_H	arpack++/include/arrgeig.h	20;"	d
ARRGNSYM_H	arpack++/include/arrgnsym.h	18;"	d
ARRGSYM_H	arpack++/include/arrgsym.h	18;"	d
ARRSCOMP_H	arpack++/include/arrscomp.h	18;"	d
ARRSEIG_H	arpack++/include/arrseig.h	20;"	d
ARRSNSYM_H	arpack++/include/arrsnsym.h	18;"	d
ARRSSYM_H	arpack++/include/arrssym.h	18;"	d
ARSCOMP_H	arpack++/include/arscomp.h	18;"	d
ARSEIG_H	arpack++/include/arseig.h	20;"	d
ARSNSYM_H	arpack++/include/arsnsym.h	18;"	d
ARSSYM_H	arpack++/include/arssym.h	18;"	d
ARStdEig	arpack++/include/arseig.h	/^  ARStdEig() { }$/;"	f	class:ARStdEig
ARStdEig	arpack++/include/arseig.h	/^  ARStdEig(const ARStdEig& other) { Copy(other); }$/;"	f	class:ARStdEig
ARStdEig	arpack++/include/arseig.h	/^class ARStdEig: virtual public ARrcStdEig<ARFLOAT, ARTYPE> {$/;"	c
ARSymGenEig	arpack++/include/argsym.h	/^  ARSymGenEig() { InvertMode = 'S'; }$/;"	f	class:ARSymGenEig
ARSymGenEig	arpack++/include/argsym.h	/^  ARSymGenEig(const ARSymGenEig& other) { Copy(other); }$/;"	f	class:ARSymGenEig
ARSymGenEig	arpack++/include/argsym.h	/^ARSymGenEig(char InvertModep, int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARSymGenEig
ARSymGenEig	arpack++/include/argsym.h	/^ARSymGenEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARSymGenEig
ARSymGenEig	arpack++/include/argsym.h	/^class ARSymGenEig:$/;"	c
ARSymStdEig	arpack++/include/arssym.h	/^  ARSymStdEig() { }$/;"	f	class:ARSymStdEig
ARSymStdEig	arpack++/include/arssym.h	/^  ARSymStdEig(const ARSymStdEig& other) { Copy(other); }$/;"	f	class:ARSymStdEig
ARSymStdEig	arpack++/include/arssym.h	/^ARSymStdEig(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARSymStdEig
ARSymStdEig	arpack++/include/arssym.h	/^class ARSymStdEig:$/;"	c
ARUGCOMP_H	arpack++/include/arugcomp.h	19;"	d
ARUGNSYM_H	arpack++/include/arugnsym.h	19;"	d
ARUGSYM_H	arpack++/include/arugsym.h	20;"	d
ARUNSMAT_H	arpack++/include/arunsmat.h	21;"	d
ARUNSPEN_H	arpack++/include/arunspen.h	18;"	d
ARUSCOMP_H	arpack++/include/aruscomp.h	19;"	d
ARUSMAT_H	arpack++/include/arusmat.h	21;"	d
ARUSNSYM_H	arpack++/include/arusnsym.h	19;"	d
ARUSPEN_H	arpack++/include/aruspen.h	18;"	d
ARUSSYM_H	arpack++/include/arussym.h	19;"	d
ARbdNonSymMatrix	arpack++/include/arbnsmat.h	/^  ARbdNonSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARbdNonSymMatrix
ARbdNonSymMatrix	arpack++/include/arbnsmat.h	/^  ARbdNonSymMatrix(const ARbdNonSymMatrix& other) { Copy(other); }$/;"	f	class:ARbdNonSymMatrix
ARbdNonSymMatrix	arpack++/include/arbnsmat.h	/^ARbdNonSymMatrix(int np, int ndiagLp, $/;"	f	class:ARbdNonSymMatrix
ARbdNonSymMatrix	arpack++/include/arbnsmat.h	/^class ARbdNonSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARbdNonSymPencil	arpack++/include/arbnspen.h	/^  ARbdNonSymPencil() { part = 'N'; }$/;"	f	class:ARbdNonSymPencil
ARbdNonSymPencil	arpack++/include/arbnspen.h	/^  ARbdNonSymPencil(const ARbdNonSymPencil& other) { Copy(other); }$/;"	f	class:ARbdNonSymPencil
ARbdNonSymPencil	arpack++/include/arbnspen.h	/^ARbdNonSymPencil(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARbdNonSymPencil
ARbdNonSymPencil	arpack++/include/arbnspen.h	/^class ARbdNonSymPencil$/;"	c
ARbdSymMatrix	arpack++/include/arbsmat.h	/^  ARbdSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARbdSymMatrix
ARbdSymMatrix	arpack++/include/arbsmat.h	/^  ARbdSymMatrix(const ARbdSymMatrix& other) { Copy(other); }$/;"	f	class:ARbdSymMatrix
ARbdSymMatrix	arpack++/include/arbsmat.h	/^ARbdSymMatrix(int np, int nsdiagp, $/;"	f	class:ARbdSymMatrix
ARbdSymMatrix	arpack++/include/arbsmat.h	/^class ARbdSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARbdSymPencil	arpack++/include/arbspen.h	/^  ARbdSymPencil() { AsB.factored = false; }$/;"	f	class:ARbdSymPencil
ARbdSymPencil	arpack++/include/arbspen.h	/^  ARbdSymPencil(const ARbdSymPencil& other) { Copy(other); }$/;"	f	class:ARbdSymPencil
ARbdSymPencil	arpack++/include/arbspen.h	/^ARbdSymPencil(ARbdSymMatrix<ARTYPE>& Ap, ARbdSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARbdSymPencil
ARbdSymPencil	arpack++/include/arbspen.h	/^class ARbdSymPencil$/;"	c
ARdfMatrix	arpack++/include/ardfmat.h	/^ARdfMatrix<ARTYPE>::ARdfMatrix()$/;"	f	class:ARdfMatrix
ARdfMatrix	arpack++/include/ardfmat.h	/^ARdfMatrix<ARTYPE>::ARdfMatrix(char* filename, int blksizep) $/;"	f	class:ARdfMatrix
ARdfMatrix	arpack++/include/ardfmat.h	/^class ARdfMatrix {$/;"	c
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^  ARdsNonSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARdsNonSymMatrix
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^  ARdsNonSymMatrix(const ARdsNonSymMatrix& other) { Copy(other); }$/;"	f	class:ARdsNonSymMatrix
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^ARdsNonSymMatrix(int mp, int np, ARTYPE* Ap) : ARMatrix<ARTYPE>(mp, np)$/;"	f	class:ARdsNonSymMatrix
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^ARdsNonSymMatrix(int np, ARTYPE* Ap) : ARMatrix<ARTYPE>(np)$/;"	f	class:ARdsNonSymMatrix
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ARdsNonSymMatrix(char* file, int blksizep)$/;"	f	class:ARdsNonSymMatrix
ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^class ARdsNonSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARdsNonSymPencil	arpack++/include/ardnspen.h	/^  ARdsNonSymPencil() { part = 'N'; }$/;"	f	class:ARdsNonSymPencil
ARdsNonSymPencil	arpack++/include/ardnspen.h	/^  ARdsNonSymPencil(const ARdsNonSymPencil& other) { Copy(other); }$/;"	f	class:ARdsNonSymPencil
ARdsNonSymPencil	arpack++/include/ardnspen.h	/^ARdsNonSymPencil(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARdsNonSymPencil
ARdsNonSymPencil	arpack++/include/ardnspen.h	/^class ARdsNonSymPencil$/;"	c
ARdsSymMatrix	arpack++/include/ardsmat.h	/^  ARdsSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARdsSymMatrix
ARdsSymMatrix	arpack++/include/ardsmat.h	/^  ARdsSymMatrix(const ARdsSymMatrix& other) { Copy(other); }$/;"	f	class:ARdsSymMatrix
ARdsSymMatrix	arpack++/include/ardsmat.h	/^ARdsSymMatrix(int np, ARTYPE* Ap, char uplop) : ARMatrix<ARTYPE>(np)$/;"	f	class:ARdsSymMatrix
ARdsSymMatrix	arpack++/include/ardsmat.h	/^class ARdsSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARdsSymPencil	arpack++/include/ardspen.h	/^  ARdsSymPencil() { AsB.factored = false; }$/;"	f	class:ARdsSymPencil
ARdsSymPencil	arpack++/include/ardspen.h	/^  ARdsSymPencil(const ARdsSymPencil& other) { Copy(other); }$/;"	f	class:ARdsSymPencil
ARdsSymPencil	arpack++/include/ardspen.h	/^ARdsSymPencil(ARdsSymMatrix<ARTYPE>& Ap, ARdsSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARdsSymPencil
ARdsSymPencil	arpack++/include/ardspen.h	/^class ARdsSymPencil$/;"	c
ARhbMatrix	arpack++/include/arhbmat.h	/^  ARhbMatrix(char* filename) { Define(filename); }$/;"	f	class:ARhbMatrix
ARhbMatrix	arpack++/include/arhbmat.h	/^ARhbMatrix<ARINT, ARTYPE>::ARhbMatrix()$/;"	f	class:ARhbMatrix
ARhbMatrix	arpack++/include/arhbmat.h	/^class ARhbMatrix {$/;"	c
ARint	arpack++/include/arch.h	/^typedef int ARint;$/;"	t
ARlogical	arpack++/include/arch.h	/^typedef int ARlogical;$/;"	t
ARluCompGenEig	arpack++/include/arbgcomp.h	/^  ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arbgcomp.h	/^  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arbgcomp.h	/^ARluCompGenEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arbgcomp.h	/^class ARluCompGenEig:$/;"	c
ARluCompGenEig	arpack++/include/ardgcomp.h	/^  ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/ardgcomp.h	/^  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/ardgcomp.h	/^ARluCompGenEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/ardgcomp.h	/^class ARluCompGenEig:$/;"	c
ARluCompGenEig	arpack++/include/arlgcomp.h	/^  ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arlgcomp.h	/^  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arlgcomp.h	/^ARluCompGenEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arlgcomp.h	/^class ARluCompGenEig:$/;"	c
ARluCompGenEig	arpack++/include/arugcomp.h	/^  ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arugcomp.h	/^  ARluCompGenEig(const ARluCompGenEig& other) { Copy(other); }$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arugcomp.h	/^ARluCompGenEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompGenEig
ARluCompGenEig	arpack++/include/arugcomp.h	/^class ARluCompGenEig:$/;"	c
ARluCompStdEig	arpack++/include/arbscomp.h	/^  ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arbscomp.h	/^  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arbscomp.h	/^ARluCompStdEig(int nevp, ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arbscomp.h	/^class ARluCompStdEig:$/;"	c
ARluCompStdEig	arpack++/include/ardscomp.h	/^  ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/ardscomp.h	/^  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/ardscomp.h	/^ARluCompStdEig(int nevp, ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/ardscomp.h	/^class ARluCompStdEig:$/;"	c
ARluCompStdEig	arpack++/include/arlscomp.h	/^  ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arlscomp.h	/^  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arlscomp.h	/^ARluCompStdEig(int nevp, ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/arlscomp.h	/^class ARluCompStdEig:$/;"	c
ARluCompStdEig	arpack++/include/aruscomp.h	/^  ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/aruscomp.h	/^  ARluCompStdEig(const ARluCompStdEig& other) { Copy(other); }$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/aruscomp.h	/^ARluCompStdEig(int nevp, ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>& A,$/;"	f	class:ARluCompStdEig
ARluCompStdEig	arpack++/include/aruscomp.h	/^class ARluCompStdEig:$/;"	c
ARluNonSymGenEig	arpack++/include/arbgnsym.h	/^  ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arbgnsym.h	/^  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arbgnsym.h	/^ARluNonSymGenEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arbgnsym.h	/^class ARluNonSymGenEig:$/;"	c
ARluNonSymGenEig	arpack++/include/ardgnsym.h	/^  ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/ardgnsym.h	/^  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/ardgnsym.h	/^ARluNonSymGenEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/ardgnsym.h	/^class ARluNonSymGenEig:$/;"	c
ARluNonSymGenEig	arpack++/include/arlgnsym.h	/^  ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arlgnsym.h	/^  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arlgnsym.h	/^ARluNonSymGenEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arlgnsym.h	/^class ARluNonSymGenEig:$/;"	c
ARluNonSymGenEig	arpack++/include/arugnsym.h	/^  ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arugnsym.h	/^  ARluNonSymGenEig(const ARluNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arugnsym.h	/^ARluNonSymGenEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymGenEig
ARluNonSymGenEig	arpack++/include/arugnsym.h	/^class ARluNonSymGenEig:$/;"	c
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^  ARluNonSymMatrix(const ARluNonSymMatrix& other) { Copy(other); }$/;"	f	class:ARluNonSymMatrix
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^ARluNonSymMatrix(char* file, double thresholdp, int orderp, bool check)$/;"	f	class:ARluNonSymMatrix
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^ARluNonSymMatrix(int mp, int np, int nnzp, ARTYPE* ap,$/;"	f	class:ARluNonSymMatrix
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^ARluNonSymMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARluNonSymMatrix
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^class ARluNonSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^inline ARluNonSymMatrix<ARTYPE, ARFLOAT>::ARluNonSymMatrix(): ARMatrix<ARTYPE>()$/;"	f	class:ARluNonSymMatrix
ARluNonSymPencil	arpack++/include/arlnspen.h	/^  ARluNonSymPencil(const ARluNonSymPencil& other) { Copy(other); }$/;"	f	class:ARluNonSymPencil
ARluNonSymPencil	arpack++/include/arlnspen.h	/^ARluNonSymPencil(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARluNonSymPencil
ARluNonSymPencil	arpack++/include/arlnspen.h	/^class ARluNonSymPencil$/;"	c
ARluNonSymPencil	arpack++/include/arlnspen.h	/^inline ARluNonSymPencil<ARTYPE, ARFLOAT>::ARluNonSymPencil()$/;"	f	class:ARluNonSymPencil
ARluNonSymStdEig	arpack++/include/arbsnsym.h	/^  ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arbsnsym.h	/^  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arbsnsym.h	/^ARluNonSymStdEig(int nevp, ARbdNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arbsnsym.h	/^class ARluNonSymStdEig:$/;"	c
ARluNonSymStdEig	arpack++/include/ardsnsym.h	/^  ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/ardsnsym.h	/^  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/ardsnsym.h	/^ARluNonSymStdEig(int nevp, ARdsNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/ardsnsym.h	/^class ARluNonSymStdEig:$/;"	c
ARluNonSymStdEig	arpack++/include/arlsnsym.h	/^  ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arlsnsym.h	/^  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arlsnsym.h	/^ARluNonSymStdEig(int nevp, ARluNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arlsnsym.h	/^class ARluNonSymStdEig:$/;"	c
ARluNonSymStdEig	arpack++/include/arusnsym.h	/^  ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arusnsym.h	/^  ARluNonSymStdEig(const ARluNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arusnsym.h	/^ARluNonSymStdEig(int nevp, ARumNonSymMatrix<ARFLOAT, ARFLOAT>& A,$/;"	f	class:ARluNonSymStdEig
ARluNonSymStdEig	arpack++/include/arusnsym.h	/^class ARluNonSymStdEig:$/;"	c
ARluSymGenEig	arpack++/include/arbgsym.h	/^  ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arbgsym.h	/^  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arbgsym.h	/^ARluSymGenEig(char InvertModep, int nevp, ARbdSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arbgsym.h	/^ARluSymGenEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arbgsym.h	/^class ARluSymGenEig:$/;"	c
ARluSymGenEig	arpack++/include/ardgsym.h	/^  ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/ardgsym.h	/^  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/ardgsym.h	/^ARluSymGenEig(char InvertModep, int nevp, ARdsSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/ardgsym.h	/^ARluSymGenEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/ardgsym.h	/^class ARluSymGenEig:$/;"	c
ARluSymGenEig	arpack++/include/arlgsym.h	/^  ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arlgsym.h	/^  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arlgsym.h	/^ARluSymGenEig(char InvertModep, int nevp, ARluSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arlgsym.h	/^ARluSymGenEig(int nevp, ARluSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arlgsym.h	/^class ARluSymGenEig:$/;"	c
ARluSymGenEig	arpack++/include/arugsym.h	/^  ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arugsym.h	/^  ARluSymGenEig(const ARluSymGenEig& other) { Copy(other); }$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arugsym.h	/^ARluSymGenEig(char InvertModep, int nevp, ARumSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arugsym.h	/^ARluSymGenEig(int nevp, ARumSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymGenEig
ARluSymGenEig	arpack++/include/arugsym.h	/^class ARluSymGenEig:$/;"	c
ARluSymMatrix	arpack++/include/arlsmat.h	/^  ARluSymMatrix(const ARluSymMatrix& other) { Copy(other); }$/;"	f	class:ARluSymMatrix
ARluSymMatrix	arpack++/include/arlsmat.h	/^ARluSymMatrix(char* file, double thresholdp, int orderp, bool check)$/;"	f	class:ARluSymMatrix
ARluSymMatrix	arpack++/include/arlsmat.h	/^ARluSymMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARluSymMatrix
ARluSymMatrix	arpack++/include/arlsmat.h	/^class ARluSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARluSymMatrix	arpack++/include/arlsmat.h	/^inline ARluSymMatrix<ARTYPE>::ARluSymMatrix(): ARMatrix<ARTYPE>()$/;"	f	class:ARluSymMatrix
ARluSymPencil	arpack++/include/arlspen.h	/^  ARluSymPencil(const ARluSymPencil& other) { Copy(other); }$/;"	f	class:ARluSymPencil
ARluSymPencil	arpack++/include/arlspen.h	/^ARluSymPencil(ARluSymMatrix<ARTYPE>& Ap, ARluSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARluSymPencil
ARluSymPencil	arpack++/include/arlspen.h	/^class ARluSymPencil$/;"	c
ARluSymPencil	arpack++/include/arlspen.h	/^inline ARluSymPencil<ARTYPE>::ARluSymPencil()$/;"	f	class:ARluSymPencil
ARluSymStdEig	arpack++/include/arbssym.h	/^  ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arbssym.h	/^  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arbssym.h	/^ARluSymStdEig(int nevp, ARbdSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arbssym.h	/^class ARluSymStdEig:$/;"	c
ARluSymStdEig	arpack++/include/ardssym.h	/^  ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/ardssym.h	/^  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/ardssym.h	/^ARluSymStdEig(int nevp, ARdsSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/ardssym.h	/^class ARluSymStdEig:$/;"	c
ARluSymStdEig	arpack++/include/arlssym.h	/^  ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arlssym.h	/^  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arlssym.h	/^ARluSymStdEig(int nevp, ARluSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arlssym.h	/^class ARluSymStdEig:$/;"	c
ARluSymStdEig	arpack++/include/arussym.h	/^  ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arussym.h	/^  ARluSymStdEig(const ARluSymStdEig& other) { Copy(other); }$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arussym.h	/^ARluSymStdEig(int nevp, ARumSymMatrix<ARFLOAT>& A,$/;"	f	class:ARluSymStdEig
ARluSymStdEig	arpack++/include/arussym.h	/^class ARluSymStdEig:$/;"	c
ARrcCompGenEig	arpack++/include/arrgcomp.h	/^  ARrcCompGenEig() { }$/;"	f	class:ARrcCompGenEig
ARrcCompGenEig	arpack++/include/arrgcomp.h	/^  ARrcCompGenEig(const ARrcCompGenEig& other) { Copy(other); }$/;"	f	class:ARrcCompGenEig
ARrcCompGenEig	arpack++/include/arrgcomp.h	/^ARrcCompGenEig(int np, int nevp, arcomplex<ARFLOAT> sigmap, char* whichp,$/;"	f	class:ARrcCompGenEig
ARrcCompGenEig	arpack++/include/arrgcomp.h	/^ARrcCompGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,$/;"	f	class:ARrcCompGenEig
ARrcCompGenEig	arpack++/include/arrgcomp.h	/^class ARrcCompGenEig:$/;"	c
ARrcCompStdEig	arpack++/include/arrscomp.h	/^  ARrcCompStdEig() { }$/;"	f	class:ARrcCompStdEig
ARrcCompStdEig	arpack++/include/arrscomp.h	/^  ARrcCompStdEig(const ARrcCompStdEig& other) { Copy(other); }$/;"	f	class:ARrcCompStdEig
ARrcCompStdEig	arpack++/include/arrscomp.h	/^ARrcCompStdEig(int np, int nevp, arcomplex<ARFLOAT> sigmap,$/;"	f	class:ARrcCompStdEig
ARrcCompStdEig	arpack++/include/arrscomp.h	/^ARrcCompStdEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,$/;"	f	class:ARrcCompStdEig
ARrcCompStdEig	arpack++/include/arrscomp.h	/^class ARrcCompStdEig: virtual public ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> > {$/;"	c
ARrcGenEig	arpack++/include/arrgeig.h	/^  ARrcGenEig(const ARrcGenEig& other) { Copy(other); }$/;"	f	class:ARrcGenEig
ARrcGenEig	arpack++/include/arrgeig.h	/^class ARrcGenEig: virtual public ARrcStdEig<ARFLOAT, ARTYPE> {$/;"	c
ARrcGenEig	arpack++/include/arrgeig.h	/^inline ARrcGenEig<ARFLOAT, ARTYPE>::ARrcGenEig()$/;"	f	class:ARrcGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^  ARrcNonSymGenEig() { part = 'R'; }$/;"	f	class:ARrcNonSymGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^  ARrcNonSymGenEig(const ARrcNonSymGenEig& other) { Copy(other); }$/;"	f	class:ARrcNonSymGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^ARrcNonSymGenEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,$/;"	f	class:ARrcNonSymGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^ARrcNonSymGenEig(int np, int nevp, char partp, ARFLOAT sigmaRp,$/;"	f	class:ARrcNonSymGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^ARrcNonSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,$/;"	f	class:ARrcNonSymGenEig
ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^class ARrcNonSymGenEig:$/;"	c
ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^  ARrcNonSymStdEig() { }$/;"	f	class:ARrcNonSymStdEig
ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^  ARrcNonSymStdEig(const ARrcNonSymStdEig& other) { Copy(other); }$/;"	f	class:ARrcNonSymStdEig
ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^ARrcNonSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp, int ncvp,$/;"	f	class:ARrcNonSymStdEig
ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^ARrcNonSymStdEig(int np, int nevp, char* whichp, int ncvp,$/;"	f	class:ARrcNonSymStdEig
ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^class ARrcNonSymStdEig: public virtual ARrcStdEig<ARFLOAT, ARFLOAT> {$/;"	c
ARrcStdEig	arpack++/include/arrseig.h	/^  ARrcStdEig(const ARrcStdEig& other) { Copy(other); }$/;"	f	class:ARrcStdEig
ARrcStdEig	arpack++/include/arrseig.h	/^class ARrcStdEig {$/;"	c
ARrcStdEig	arpack++/include/arrseig.h	/^inline ARrcStdEig<ARFLOAT, ARTYPE>::ARrcStdEig()$/;"	f	class:ARrcStdEig
ARrcSymGenEig	arpack++/include/arrgsym.h	/^  ARrcSymGenEig() { InvertMode = 'S'; }$/;"	f	class:ARrcSymGenEig
ARrcSymGenEig	arpack++/include/arrgsym.h	/^  ARrcSymGenEig(const ARrcSymGenEig& other) { Copy(other); }$/;"	f	class:ARrcSymGenEig
ARrcSymGenEig	arpack++/include/arrgsym.h	/^ARrcSymGenEig(char InvertModep, int np, int nevp,$/;"	f	class:ARrcSymGenEig
ARrcSymGenEig	arpack++/include/arrgsym.h	/^ARrcSymGenEig(int np, int nevp, char* whichp, int ncvp, ARFLOAT tolp,$/;"	f	class:ARrcSymGenEig
ARrcSymGenEig	arpack++/include/arrgsym.h	/^class ARrcSymGenEig:$/;"	c
ARrcSymStdEig	arpack++/include/arrssym.h	/^  ARrcSymStdEig() { }$/;"	f	class:ARrcSymStdEig
ARrcSymStdEig	arpack++/include/arrssym.h	/^  ARrcSymStdEig(const ARrcSymStdEig& other) { Copy(other); }$/;"	f	class:ARrcSymStdEig
ARrcSymStdEig	arpack++/include/arrssym.h	/^ARrcSymStdEig(int np, int nevp, ARFLOAT sigmap, char* whichp,$/;"	f	class:ARrcSymStdEig
ARrcSymStdEig	arpack++/include/arrssym.h	/^ARrcSymStdEig(int np, int nevp, char* whichp, int ncvp,$/;"	f	class:ARrcSymStdEig
ARrcSymStdEig	arpack++/include/arrssym.h	/^class ARrcSymStdEig: public virtual ARrcStdEig<ARFLOAT, ARFLOAT> {$/;"	c
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^  ARumNonSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARumNonSymMatrix
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^  ARumNonSymMatrix(const ARumNonSymMatrix& other) { Copy(other); }$/;"	f	class:ARumNonSymMatrix
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^ARumNonSymMatrix(char* name, double thresholdp, int fillinp,$/;"	f	class:ARumNonSymMatrix
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^ARumNonSymMatrix(int mp, int np, int nnzp, ARTYPE* ap,$/;"	f	class:ARumNonSymMatrix
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^ARumNonSymMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARumNonSymMatrix
ARumNonSymMatrix	arpack++/include/arunsmat.h	/^class ARumNonSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARumNonSymPencil	arpack++/include/arunspen.h	/^  ARumNonSymPencil() { part = 'N'; }$/;"	f	class:ARumNonSymPencil
ARumNonSymPencil	arpack++/include/arunspen.h	/^  ARumNonSymPencil(const ARumNonSymPencil& other) { Copy(other); }$/;"	f	class:ARumNonSymPencil
ARumNonSymPencil	arpack++/include/arunspen.h	/^ARumNonSymPencil(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARumNonSymPencil
ARumNonSymPencil	arpack++/include/arunspen.h	/^class ARumNonSymPencil$/;"	c
ARumSymMatrix	arpack++/include/arusmat.h	/^  ARumSymMatrix(): ARMatrix<ARTYPE>() { factored = false; }$/;"	f	class:ARumSymMatrix
ARumSymMatrix	arpack++/include/arusmat.h	/^  ARumSymMatrix(const ARumSymMatrix& other) { Copy(other); }$/;"	f	class:ARumSymMatrix
ARumSymMatrix	arpack++/include/arusmat.h	/^ARumSymMatrix(char* file, double thresholdp, int fillinp,$/;"	f	class:ARumSymMatrix
ARumSymMatrix	arpack++/include/arusmat.h	/^ARumSymMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARumSymMatrix
ARumSymMatrix	arpack++/include/arusmat.h	/^class ARumSymMatrix: public ARMatrix<ARTYPE> {$/;"	c
ARumSymPencil	arpack++/include/aruspen.h	/^  ARumSymPencil() { AsB.factored = false; }$/;"	f	class:ARumSymPencil
ARumSymPencil	arpack++/include/aruspen.h	/^  ARumSymPencil(const ARumSymPencil& other) { Copy(other); }$/;"	f	class:ARumSymPencil
ARumSymPencil	arpack++/include/aruspen.h	/^ARumSymPencil(ARumSymMatrix<ARTYPE>& Ap, ARumSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARumSymPencil
ARumSymPencil	arpack++/include/aruspen.h	/^class ARumSymPencil$/;"	c
AS	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
ASH	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
ASIS	IoData.h	/^  enum TypePhaseChange {ASIS = 0, RIEMANN_SOLUTION = 1, EXTRAPOLATION = 2} typePhaseChange;$/;"	e	enum:MultiFluidData::TypePhaseChange
ASSERT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    ASSERT_EFFICIENT(typename IF<efficient,UNUSABLE,const char*>::TYPE str)$/;"	f	struct:PhysBAM::__anon21::ASSERT_EFFICIENT
ASSERT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    ASSERT_EFFICIENT(typename IF<efficient,const char*,UNUSABLE>::TYPE str)$/;"	f	struct:PhysBAM::__anon21::ASSERT_EFFICIENT
ASSERT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<int line,class A,class B=void> struct ASSERT_EFFICIENT$/;"	s	namespace:PhysBAM::__anon21
ASSERT_SAME_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ASSERT_SAME_HELPER<T,T>{};$/;"	s	namespace:PhysBAM
ASSUME_INCR_REFSTATE_FALSE	IoData.h	/^  enum UseFirstStateAsRefStateForIncrBasis {ASSUME_INCR_REFSTATE_FALSE = 0, ASSUME_INCR_REFSTATE_TRUE = 1} useFirstStateAsRefStateForIncrBasis;$/;"	e	enum:RelativeProjectionErrorData::UseFirstStateAsRefStateForIncrBasis
ASSUME_INCR_REFSTATE_TRUE	IoData.h	/^  enum UseFirstStateAsRefStateForIncrBasis {ASSUME_INCR_REFSTATE_FALSE = 0, ASSUME_INCR_REFSTATE_TRUE = 1} useFirstStateAsRefStateForIncrBasis;$/;"	e	enum:RelativeProjectionErrorData::UseFirstStateAsRefStateForIncrBasis
AUPP_ERROR	arpack++/include/arerror.h	/^    AUPP_ERROR          = -291,$/;"	e	enum:ArpackError::ErrorCode
AUTO	IoData.h	/^  enum Integration {AUTO = 0, WALL_FUNCTION = 1, FULL = 2} integration;$/;"	e	enum:BcsWallData::Integration
AUTO	IoData.h	/^  enum InterfaceExtrapolation {EXTRAPOLATIONFIRSTORDER=0, EXTRAPOLATIONSECONDORDER=1, AUTO=2} interfaceExtrapolation;$/;"	e	enum:MultiFluidData::InterfaceExtrapolation
AUTO	IoData.h	/^  enum Normals {AUTO = 0, IMPLICIT_FIRST_ORDER_GCL = 1, IMPLICIT_SECOND_ORDER_GCL = 2,$/;"	e	enum:DGCLData::Normals
AUTO	IoData.h	/^  enum PhaseChangeAlgorithm {AVERAGE = 0, LEAST_SQUARES = 1, AUTO = 2} phaseChangeAlg;$/;"	e	enum:EmbeddedFramework::PhaseChangeAlgorithm
AUTO	IoData.h	/^  enum TypeTimeStep {AUTO = 0, LOCAL = 1, GLOBAL = 2} typeTimeStep;$/;"	e	enum:TsData::TypeTimeStep
AUTO_VEL	IoData.h	/^  enum Velocities {AUTO_VEL = 0, IMPLICIT_BACKWARD_EULER_VEL = 1, IMPLICIT_THREE_POINT_BDF_VEL = 2,$/;"	e	enum:DGCLData::Velocities
AVERAGE	IoData.h	/^  enum PhaseChangeAlgorithm {AVERAGE = 0, LEAST_SQUARES = 1, AUTO = 2} phaseChangeAlg;$/;"	e	enum:EmbeddedFramework::PhaseChangeAlgorithm
AVERAGE	IoData.h	/^  enum RestrictMethod { VOLUME_WEIGHTED = 0, AVERAGE = 1 } restrictMethod;$/;"	e	enum:MultiGridData::RestrictMethod
AVERAGED	IoData.h	/^  enum Force {LAST = 0, AVERAGED = 1, LAST_KRIS = 2} force;$/;"	e	enum:AeroelasticData::Force
AVG_INCREMENTAL_STATES_FALSE	IoData.h	/^  enum AvgIncrementalStates {AVG_INCREMENTAL_STATES_FALSE = 0, AVG_INCREMENTAL_STATES_TRUE = 1} avgIncrementalStates;$/;"	e	enum:NonlinearRomFileSystemData::AvgIncrementalStates
AVG_INCREMENTAL_STATES_TRUE	IoData.h	/^  enum AvgIncrementalStates {AVG_INCREMENTAL_STATES_FALSE = 0, AVG_INCREMENTAL_STATES_TRUE = 1} avgIncrementalStates;$/;"	e	enum:NonlinearRomFileSystemData::AvgIncrementalStates
AVG_STATE_INCREMENTS_OFF	IoData.h	/^  enum AvgStateIncrements {AVG_STATE_INCREMENTS_OFF = 0, AVG_STATE_INCREMENTS_ON = 1} avgStateIncrements;$/;"	e	enum:ROMOutputData::AvgStateIncrements
AVG_STATE_INCREMENTS_ON	IoData.h	/^  enum AvgStateIncrements {AVG_STATE_INCREMENTS_OFF = 0, AVG_STATE_INCREMENTS_ON = 1} avgStateIncrements;$/;"	e	enum:ROMOutputData::AvgStateIncrements
AVSSIZE	PostFcn.h	/^                      SKIN_FRICTIONAVG =8, AVSSIZE = 9};$/;"	e	enum:PostFcn::ScalarAvgType
AVVSIZE	PostFcn.h	/^  enum VectorAvgType {VELOCITYAVG = 0, DISPLACEMENTAVG = 1, AVVSIZE = 2};$/;"	e	enum:PostFcn::VectorAvgType
AXIS_X	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:CorotSolver::SymmetryAxis
AXIS_X	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:EmbeddedCorotSolver::SymmetryAxis
AXIS_Y	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:CorotSolver::SymmetryAxis
AXIS_Y	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:EmbeddedCorotSolver::SymmetryAxis
AXIS_Z	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:CorotSolver::SymmetryAxis
AXIS_Z	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:EmbeddedCorotSolver::SymmetryAxis
A_	EmbeddedFluidShapeOptimizationHandler.h	/^  DistVec<double> *A_;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Abs() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Abs() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Abs() const$/;"	f	class:PhysBAM::MATRIX
Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Abs() const$/;"	f	class:PhysBAM::MATRIX
Absolute	utils/Predicate.C	145;"	d	file:
AccAeroMeshMotionHandler	MeshMotionHandler.h	/^class AccAeroMeshMotionHandler : public AeroMeshMotionHandler, $/;"	c
AccAeroMeshMotionHandler	MeshMotionHandlerCore.C	/^AccAeroMeshMotionHandler::AccAeroMeshMotionHandler(IoData &iod, VarFcn *vf, double *Vin, $/;"	f	class:AccAeroMeshMotionHandler
AccDeformingMeshMotionHandler	MeshMotionHandler.h	/^class AccDeformingMeshMotionHandler : public DeformingMeshMotionHandler, $/;"	c
AccDeformingMeshMotionHandler	MeshMotionHandlerCore.C	/^AccDeformingMeshMotionHandler(IoData &iod, VarFcn *vf, double *Vin, Domain *dom) :$/;"	f	class:AccDeformingMeshMotionHandler
AccHeavingMeshMotionHandler	MeshMotionHandler.h	/^class AccHeavingMeshMotionHandler : public HeavingMeshMotionHandler, $/;"	c
AccHeavingMeshMotionHandler	MeshMotionHandlerCore.C	/^AccHeavingMeshMotionHandler(IoData &iod, VarFcn *vf, double *Vin, Domain *dom) :$/;"	f	class:AccHeavingMeshMotionHandler
AccMeshMotionHandler	MeshMotionHandler.h	/^class AccMeshMotionHandler : public MeshMotionHandler, $/;"	c
AccMeshMotionHandler	MeshMotionHandlerCore.C	/^AccMeshMotionHandler::AccMeshMotionHandler(IoData &iod, VarFcn *vf, $/;"	f	class:AccMeshMotionHandler
AccPitchingMeshMotionHandler	MeshMotionHandler.h	/^class AccPitchingMeshMotionHandler : public PitchingMeshMotionHandler, $/;"	c
AccPitchingMeshMotionHandler	MeshMotionHandlerCore.C	/^AccPitchingMeshMotionHandler(IoData &iod, VarFcn *vf, double *Vin, Domain *dom) :$/;"	f	class:AccPitchingMeshMotionHandler
Accelerated	Manual/Aerof3d.html	/^<a name="Accelerated"><\/a>$/;"	a
AcousticBeam	ExactSolution.C	/^AcousticBeam(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
AcousticBeamStructure	ExactSolution.C	/^AcousticBeamStructure(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
AcousticPressure	Manual/Aerof3d.html	/^<a name="AcousticPressure"><\/a>$/;"	a
AcousticTwoFluid	ExactSolution.C	/^AcousticTwoFluid(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
AcousticViscousBeam	ExactSolution.C	/^AcousticViscousBeam(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
AcousticViscousBeamStructure	ExactSolution.C	/^AcousticViscousBeamStructure(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
AdaptiveEpsFSI	IoData.h	/^  enum AdaptiveEpsFSI {OFF_ADAPTIVEEPSFSI = 0, ON_ADAPTIVEEPSFSI = 1} adaptiveEpsFSI;$/;"	g	struct:SensitivityAnalysis
Add	Communicator.h	/^    static const int Add=0, Min=1, Max=2;$/;"	m	class:Communication::Window
AddStateToKrylov	IoData.h	/^  enum AddStateToKrylov {ADD_STATE_TO_KRYLOV_OFF = 0, ADD_STATE_TO_KRYLOV_ON = 1} addStateToKrylov;$/;"	g	struct:ROMOutputData
Add_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> ID Add_Array(T_OTHER_ARRAY* array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> ID Add_Array(const std::string& array_name)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> ID Add_Array(const std::string& array_name,T_OTHER_ARRAY& array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> void Add_Array(const ID array_id)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> void Add_Array(const ID array_id,T_OTHER_ARRAY* array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Add_Array_Helper(ARRAY_COLLECTION_ELEMENT_BASE* array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Array_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Add_Array_Helper(const ID array_id,ARRAY_COLLECTION_ELEMENT_BASE* array)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Arrays	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Add_Arrays(const ARRAY_COLLECTION& elements)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Connectivity	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    template<class T_CONNECTIVITY> void Add_Connectivity(T_CONNECTIVITY& particle_connectivity) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Add_Dependencies	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Add_Dependencies(SEGMENT_MESH& dependency_mesh) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Add_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Add_Element()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Element_From_Deletion_List	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Add_Element_From_Deletion_List()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Element_If_Not_Already_There	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Add_Element_If_Not_Already_There(const VECTOR<int,d+1>& nodes)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Add_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    ARRAY_PLUS_SCALAR<int,IDENTITY_ARRAY<> > Add_Elements(const int new_element)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Elements_From_Deletion_List	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Add_Elements_From_Deletion_List(const int count,ARRAY<int>& added_indices)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_Entry	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Add_Entry()$/;"	f	class:PhysBAM::UNION_FIND
Add_Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    void Add_Nodes(const int new_nodes)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Add_Ordered_Neighbors	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    static void Add_Ordered_Neighbors(ARRAY<int>& nodes,ARRAY<int>& links,const int neighbor1,const int neighbor2)$/;"	f	class:PhysBAM::TRIANGLE_MESH
Add_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Add_Subvector(const int istart,const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Add_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Add_Subvector(const int istart,const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Add_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Add_Subvector(const int istart,const VECTOR_BASE<T,T_VECTOR2>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Add_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_EXPRESSION<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times(const T_MATRIX1& A,const T_MATRIX2& B,MATRIX_BASE<T,T_MATRIX3>& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times_Matrix_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times_Matrix_Helper(const T_MATRIX1& A,const T_MATRIX2& B,T_MATRIX3& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times_Transpose(const T_MATRIX1& A,const T_MATRIX2& B,MATRIX_BASE<T,T_MATRIX3>& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times_Transpose_Matrix_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times_Transpose_Matrix_Helper(const T_MATRIX1& A,const T_MATRIX2& B,T_MATRIX3& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Times_Vector_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Times_Vector_Helper(const T_MATRIX1& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_To_Deletion_List	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Add_To_Deletion_List(const int p)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Add_To_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_To_Submatrix(const int istart,const int jstart,const DIAGONAL_MATRIX<T,2>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_To_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_To_Submatrix(const int istart,const int jstart,const DIAGONAL_MATRIX<T,3>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_To_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_To_Submatrix(const int istart,const int jstart,const MATRIX_BASE<T,T_MATRIX2>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_To_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_To_Submatrix(const int istart,const int jstart,const SYMMETRIC_MATRIX<T,3>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_To_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Add_To_Submatrix(const int istart,const int jstart,const VECTOR_BASE<T,T_VECTOR>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Transpose_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Transpose_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_EXPRESSION<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Transpose_Times(const T_MATRIX1& A,const T_MATRIX2& B,MATRIX_BASE<T,T_MATRIX3>& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Transpose_Times_Matrix_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Transpose_Times_Matrix_Helper(const T_MATRIX1& A,const T_MATRIX2& B,T_MATRIX3& C)$/;"	f	class:PhysBAM::MATRIX_BASE
Add_Transpose_Times_Vector_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Add_Transpose_Times_Vector_Helper(const T_MATRIX1& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Adjacent_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Adjacent_Triangle(const int triangle,const int node1,const int node2) const$/;"	f	class:TRIANGLE_MESH
AdvectiveOperator	IoData.h	/^  enum AdvectiveOperator {FINITE_VOLUME = 0, FE_GALERKIN = 1} advectiveOperator;$/;"	g	struct:SchemeData
AeroMeshMotionHandler	MeshMotionHandler.h	/^class AeroMeshMotionHandler : public MeshMotionHandler {$/;"	c
AeroMeshMotionHandler	MeshMotionHandlerCore.C	/^AeroMeshMotionHandler::AeroMeshMotionHandler(IoData &ioData, VarFcn *varFcn, $/;"	f	class:AeroMeshMotionHandler
Aeroelastic	Manual/Aerof3d.html	/^<a name="Aeroelastic"><\/a>$/;"	a
Aeroelastic-ROM	Manual/Aerof3d.html	/^<a name="Aeroelastic-ROM"><\/a>$/;"	a
AeroelasticData	IoData.h	/^struct AeroelasticData {$/;"	s
AeroelasticData	IoDataCore.C	/^AeroelasticData::AeroelasticData()$/;"	f	class:AeroelasticData
Aerof_unordered_set	Aerof_unordered_set.h	/^struct Aerof_unordered_set {$/;"	s
AfterUm21i	arpack++/include/umfpackc.h	/^void AfterUm21i(int keep[], int icntl[], bool simest, bool reducible) $/;"	f
AgglomeratedFace	AgglomeratedFace.C	/^AgglomeratedFace::AgglomeratedFace() : node(0), code(0), normal(0.0), area(0.0),masterFlag(true) {$/;"	f	class:AgglomeratedFace
AgglomeratedFace	AgglomeratedFace.C	/^AgglomeratedFace::AgglomeratedFace(const AgglomeratedFace& oth) :$/;"	f	class:AgglomeratedFace
AgglomeratedFace	AgglomeratedFace.C	/^AgglomeratedFace::AgglomeratedFace(int node, int code) : node(node), code(code), normal(0.0),$/;"	f	class:AgglomeratedFace
AgglomeratedFace	AgglomeratedFace.h	/^class AgglomeratedFace {$/;"	c
AgglomeratedFaceSet	AgglomeratedFace.C	/^AgglomeratedFaceSet::AgglomeratedFaceSet(int size) : numFaces(size) {$/;"	f	class:AgglomeratedFaceSet
AgglomeratedFaceSet	AgglomeratedFace.h	/^class AgglomeratedFaceSet {$/;"	c
AgglomerationGlobal	MultiGridLevel.h	/^			   AgglomerationGlobal };$/;"	e	enum:MultiGridLevel::AgglomerationType
AgglomerationLocal	MultiGridLevel.h	/^  enum AgglomerationType { AgglomerationLocal,$/;"	e	enum:MultiGridLevel::AgglomerationType
AgglomerationType	MultiGridLevel.h	/^  enum AgglomerationType { AgglomerationLocal,$/;"	g	class:MultiGridLevel
Ainv	arpack++/include/arbnsmat.h	/^  ARTYPE*  Ainv;$/;"	m	class:ARbdNonSymMatrix
Ainv	arpack++/include/arbsmat.h	/^  ARTYPE*  Ainv;$/;"	m	class:ARbdSymMatrix
Ainv	arpack++/include/ardnsmat.h	/^  ARTYPE*             Ainv;$/;"	m	class:ARdsNonSymMatrix
Ainv	arpack++/include/ardsmat.h	/^  ARTYPE*  Ainv;$/;"	m	class:ARdsSymMatrix
AllType	IoData.h	/^  enum AllType {_STEADY_ = 0, _UNSTEADY_ = 1, _ACC_UNSTEADY_ = 2, _STEADY_AEROELASTIC_ = 3,$/;"	g	struct:ProblemData
All_Greater	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool All_Greater(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Greater	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool All_Greater(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Greater	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool All_Greater(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Greater_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool All_Greater_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Greater_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool All_Greater_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Greater_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool All_Greater_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool All_Less(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool All_Less(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool All_Less(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool All_Less_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool All_Less_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Less_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool All_Less_Equal(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
All_Ones_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR All_Ones_Vector()$/;"	f	class:PhysBAM::VECTOR
All_Ones_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    static VECTOR All_Ones_Vector()$/;"	f	class:PhysBAM::VECTOR
All_Ones_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR All_Ones_Vector()$/;"	f	class:PhysBAM::VECTOR
All_Ones_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR All_Ones_Vector()$/;"	f	class:PhysBAM::VECTOR
All_Ones_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR All_Ones_Vector()$/;"	f	class:PhysBAM::VECTOR
AlternatingLeastSquare	AlternatingLeastSquare/als_lapack.cpp	/^AlternatingLeastSquare::AlternatingLeastSquare(double *_X, unsigned char *_M, double *UT_init,$/;"	f	class:AlternatingLeastSquare
AlternatingLeastSquare	AlternatingLeastSquare/als_lapack.cpp	/^AlternatingLeastSquare::AlternatingLeastSquare(int _nrow, int _ncol, int _dim,$/;"	f	class:AlternatingLeastSquare
AlternatingLeastSquare	AlternatingLeastSquare/als_lapack.h	/^class AlternatingLeastSquare {$/;"	c
Am	FluidCollocationShapeOptimizationHandler.h	/^  DistVec<double> *Am;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Am	FluidGnatShapeOptimizationHandler.h	/^  DistVec<double> *Am;$/;"	m	class:FluidGnatShapeOptimizationHandler
Am	FluidMetricShapeOptimizationHandler.h	/^  DistVec<double> *Am;$/;"	m	class:FluidMetricShapeOptimizationHandler
Am	FluidRomShapeOptimizationHandler.h	/^  DistVec<double> *Am;$/;"	m	class:FluidRomShapeOptimizationHandler
Am	FluidShapeOptimizationHandler.h	/^  DistVec<double> *Am;$/;"	m	class:FluidShapeOptimizationHandler
Angle	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Angle() const$/;"	f	class:ROTATION
Angle	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    T Angle() const$/;"	f	class:PhysBAM::ROTATION
AngleRadians	IoData.h	/^  enum AngleRadians {OFF_ANGLERAD = 0, ON_ANGLERAD = 1} angleRad;$/;"	g	struct:SensitivityAnalysis
Angle_Between	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static T Angle_Between(const VECTOR& u,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Angle_Between	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static T Angle_Between(const VECTOR& u,const VECTOR& v) \/\/ 0 .. pi$/;"	f	class:PhysBAM::VECTOR
Angle_Between	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static T Angle_Between(const VECTOR_BASE<T,T_VECTOR1>& u,const VECTOR_BASE<T,T_VECTOR2>& v) \/\/ 0 .. pi$/;"	f	class:PhysBAM::VECTOR_BASE
Antisymmetric_Part_Cross_Product_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Antisymmetric_Part_Cross_Product_Vector() const$/;"	f	class:PhysBAM::MATRIX
Antisymmetric_Part_Cross_Product_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> Antisymmetric_Part_Cross_Product_Vector() const$/;"	f	class:PhysBAM::MATRIX
Ap	FluidCollocationShapeOptimizationHandler.h	/^  DistVec<double> *Ap;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Ap	FluidGnatShapeOptimizationHandler.h	/^  DistVec<double> *Ap;$/;"	m	class:FluidGnatShapeOptimizationHandler
Ap	FluidMetricShapeOptimizationHandler.h	/^  DistVec<double> *Ap;$/;"	m	class:FluidMetricShapeOptimizationHandler
Ap	FluidRomShapeOptimizationHandler.h	/^  DistVec<double> *Ap;$/;"	m	class:FluidRomShapeOptimizationHandler
Ap	FluidShapeOptimizationHandler.h	/^  DistVec<double> *Ap;$/;"	m	class:FluidShapeOptimizationHandler
Ap	KspSolver.h	/^  VecSet<VecType> p, Ap;$/;"	m	class:GcrSolver
Ap	KspSolver.h	/^  VecType r, Ap, y, p;$/;"	m	class:CgSolver
ApAp	KspSolver.h	/^  ScalarT *ApAp;$/;"	m	class:GcrSolver
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Append(const ARRAY_COLLECTION& source,int from)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Append(const ARRAY_COLLECTION& from_elements)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR<T,d+1> Append(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR<T,2> Append(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,3> Append(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Append	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR<T,4> Append(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Append_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Append_Elements(const T_ARRAY& append_array)$/;"	f	class:PhysBAM::ARRAY
Append_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    template<int d2> VECTOR<T,d+d2> Append_Elements(const VECTOR<T,d2>& elements) const$/;"	f	class:PhysBAM::VECTOR
Append_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<int d2> VECTOR<T,1+d2> Append_Elements(const VECTOR<T,d2>& elements) const$/;"	f	class:PhysBAM::VECTOR
Append_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<int d2> VECTOR<T,2+d2> Append_Elements(const VECTOR<T,d2>& elements) const$/;"	f	class:PhysBAM::VECTOR
Append_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<int d2> VECTOR<T,3+d2> Append_Elements(const VECTOR<T,d2>& elements) const$/;"	f	class:PhysBAM::VECTOR
Append_Particles_And_Create_Copy	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^Append_Particles_And_Create_Copy(GEOMETRY_PARTICLES<TV>& particles,ARRAY<int>* particle_indices) const$/;"	f	class:STRUCTURE
Append_Unique	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Append_Unique(const T& element)$/;"	f	class:PhysBAM::ARRAY
Append_Unique_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Append_Unique_Elements(const T_ARRAY& append_array)$/;"	f	class:PhysBAM::ARRAY
Apply	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,dd,Scalar1,Scalar2>::Apply$/;"	f	class:MatVecProdH2::Multiplier
Apply	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,nn,Scalar1,Scalar2>::Apply$/;"	f	class:MatVecProdH2::Multiplier
ApplyT	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,dd,Scalar1,Scalar2>::ApplyT$/;"	f	class:MatVecProdH2::Multiplier
ApplyT	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,nn,Scalar1,Scalar2>::ApplyT$/;"	f	class:MatVecProdH2::Multiplier
ApplyTranspose	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,dd,Scalar1,Scalar2>::ApplyTranspose$/;"	f	class:MatVecProdH2::Multiplier
ApplyTranspose	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::Multiplier<dd,nn,Scalar1,Scalar2>::ApplyTranspose$/;"	f	class:MatVecProdH2::Multiplier
Apply_Function_To_All_Entries	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Apply_Function_To_All_Entries(void (*function)(TK&,T_UNLESS_VOID&))$/;"	f	class:PhysBAM::HASHTABLE
ApproximatedMetricData	IoData.h	/^struct ApproximatedMetricData {$/;"	s
ApproximatedMetricData	IoDataCore.C	/^ApproximatedMetricData::ApproximatedMetricData()$/;"	f	class:ApproximatedMetricData
Area	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^Area()$/;"	f	class:POLYGON
Area	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    T Area() const $/;"	f	class:PhysBAM::TRIANGLE_3D
Area	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Area(const TV& x1,const TV& x2,const TV& x3) \/\/ always positive for clockwise vertices: x1, x2, x3 $/;"	f	class:PhysBAM::TRIANGLE_3D
Area_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Area_Squared(const TV& x1,const TV& x2,const TV& x3) \/\/ always positive for clockwise vertices: x1, x2, x3 $/;"	f	class:PhysBAM::TRIANGLE_3D
Arg_Abs_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Arg_Abs_Max() const$/;"	f	class:PhysBAM::VECTOR
Arg_Abs_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Arg_Abs_Min() const$/;"	f	class:PhysBAM::VECTOR
Arg_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Arg_Max() const$/;"	f	class:PhysBAM::VECTOR
Arg_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Arg_Max() const$/;"	f	class:PhysBAM::VECTOR
Arg_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Arg_Max() const$/;"	f	class:PhysBAM::VECTOR
Arg_Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Arg_Maximum_Magnitude() const$/;"	f	class:PhysBAM::ARRAY_BASE
Arg_Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    Arg_Maximum_Magnitude(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Arg_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Arg_Min() const$/;"	f	class:PhysBAM::VECTOR
Arg_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Arg_Min() const$/;"	f	class:PhysBAM::VECTOR
Arg_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Arg_Min() const$/;"	f	class:PhysBAM::VECTOR
Argmax	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Argmax() const$/;"	f	class:PhysBAM::ARRAY_BASE
Argmax	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    ID Argmax(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Argmin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Argmin() const$/;"	f	class:PhysBAM::ARRAY_BASE
Argmin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    ID Argmin(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
ArnoldiBasisFound	arpack++/include/arrseig.h	/^  bool ArnoldiBasisFound() { return BasisOK; }$/;"	f	class:ARrcStdEig
ArnoldiBasisVector	arpack++/include/arrseig.h	/^inline ARTYPE ARrcStdEig<ARFLOAT, ARTYPE>::ArnoldiBasisVector(int i, int j)$/;"	f	class:ARrcStdEig
ArpackError	arpack++/include/arerror.h	/^  ArpackError() { code = NO_ERRORS; };$/;"	f	class:ArpackError
ArpackError	arpack++/include/arerror.h	/^  ArpackError(ErrorCode error, char* where="AREigenProblem") {$/;"	f	class:ArpackError
ArpackError	arpack++/include/arerror.h	/^class ArpackError {$/;"	c
ArrayDesc	DistLeastSquareSolver.h	/^  typedef int ArrayDesc[9];$/;"	t	class:DistLeastSquareSolver
Array_View	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_VIEW<T,ID2> Array_View(const ID first,const ID2 length)$/;"	f	class:PhysBAM::ARRAY_BASE
Array_View	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_VIEW<const T,ID2> Array_View(const ID first,const ID2 length) const$/;"	f	class:PhysBAM::ARRAY_BASE
AsB	arpack++/include/arbnspen.h	/^  ARbdNonSymMatrix<ARTYPE, ARFLOAT>  AsB;$/;"	m	class:ARbdNonSymPencil
AsB	arpack++/include/arbspen.h	/^  ARbdSymMatrix<ARTYPE>  AsB;$/;"	m	class:ARbdSymPencil
AsB	arpack++/include/ardnspen.h	/^  ARdsNonSymMatrix<ARTYPE, ARFLOAT>  AsB;$/;"	m	class:ARdsNonSymPencil
AsB	arpack++/include/ardspen.h	/^  ARdsSymMatrix<ARTYPE>  AsB;$/;"	m	class:ARdsSymPencil
AsB	arpack++/include/arunspen.h	/^  ARumNonSymMatrix<ARTYPE, ARFLOAT>  AsB;$/;"	m	class:ARumNonSymPencil
AsB	arpack++/include/aruspen.h	/^  ARumSymMatrix<ARTYPE> AsB;$/;"	m	class:ARumSymPencil
AsBc	arpack++/include/arbnspen.h	/^  ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> AsBc;$/;"	m	class:ARbdNonSymPencil
AsBc	arpack++/include/ardnspen.h	/^  ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> AsBc;$/;"	m	class:ARdsNonSymPencil
AsBc	arpack++/include/arunspen.h	/^  ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> AsBc;$/;"	m	class:ARumNonSymPencil
Aspect_Ratio	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    T Aspect_Ratio() const$/;"	f	class:PhysBAM::TRIANGLE_3D
Aspect_Ratio	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Aspect_Ratio(const TV& x1_input,const TV& x2_input,const TV& x3_input)$/;"	f	class:PhysBAM::TRIANGLE_3D
Assert_Consistent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Assert_Consistent() const$/;"	f	class:SEGMENT_MESH
Assert_Consistent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Assert_Consistent() const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Assert_Consistent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Assert_Consistent() const$/;"	f	class:TRIANGLE_MESH
Assert_Same_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Assert_Same_Size(const VECTOR_BASE<T2,T_VECTOR2>& u,const VECTOR_BASE<T3,T_VECTOR3>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Assert_Same_Size_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Assert_Same_Size_Helper(const VECTOR<T2,p>&,const VECTOR<T3,q>&)$/;"	f	class:PhysBAM::VECTOR_BASE
Assert_Same_Size_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Assert_Same_Size_Helper(const VECTOR_BASE<T2,T_VECTOR2>& u,const VECTOR_BASE<T3,T_VECTOR3>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Assertion_Failed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Assertion_Failed(const char* function,const char* file,unsigned int line,const char* condition)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Assertion_Failed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Assertion_Failed(const char* function,const char* file,unsigned int line,const char* condition,const char* message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Assertion_Failed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Assertion_Failed(const char* function,const char* file,unsigned int line,const char* condition,const std::string& message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
AssignConnectingQuadTriangle	PolygonReconstructionData.h	/^    void AssignConnectingQuadTriangle(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2){ \/\/for PhysBAM only$/;"	f	struct:PolygonReconstructionData
AssignQuadTriangle	PolygonReconstructionData.h	/^    void AssignQuadTriangle(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2, const int l3){ \/\/for PhysBAM only$/;"	f	struct:PolygonReconstructionData
AssignQuadrilateral	PolygonReconstructionData.h	/^    void AssignQuadrilateral(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2, const int l3, const int l4){$/;"	f	struct:PolygonReconstructionData
AssignTriangleMulti	PolygonReconstructionData.h	/^    void AssignTriangleMulti(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2, const int l3){$/;"	f	struct:PolygonReconstructionData
AssignTriangleSingle	PolygonReconstructionData.h	/^    void AssignTriangleSingle(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2, const int l3){$/;"	f	struct:PolygonReconstructionData
AssignTwoEdges	PolygonReconstructionData.h	/^    void AssignTwoEdges(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2){ \/\/for PhysBAM only$/;"	f	struct:PolygonReconstructionData
AssignTwoEdgesPartTwo	PolygonReconstructionData.h	/^    void AssignTwoEdgesPartTwo(const int n1, const int n2, const int n3, const int n4, const int l1, const int l2, const int l3){ \/\/for PhysBAM only$/;"	f	struct:PolygonReconstructionData
Assign_Intersection_Information	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Assign_Intersection_Information(const ARRAY<int>& scope,const RAY<VECTOR<T,3> >& intersection_ray,const RAY<VECTOR<T,3> >& original_ray,const VECTOR<T,3>& weights,$/;"	f	namespace:__anon13
Assign_Intersection_Information	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Assign_Intersection_Information(const int triangleID,const T alpha,const VECTOR<T,3>& weights,$/;"	f	namespace:__anon13
Assignable	parser/Parser.y	/^Assignable:$/;"	l
Assigner	parser/Assigner.h	/^   Assigner(const char *n) { name = n; }$/;"	f	class:Assigner
Assigner	parser/Assigner.h	/^class Assigner {$/;"	c
Assignment	parser/Parser.y	/^Assignment: Assignable '=' Symbol ';'$/;"	l
AttachStructure	MatVecProd.h	/^  void AttachStructure(const _fsi& f) {$/;"	f	class:MatVecProd
AttachStructure	MatVecProd.h	/^  void AttachStructure(const _fsi& f) {$/;"	f	class:MatVecProdMultiPhase
Aupp	arpack++/include/arrscomp.h	/^inline void ARrcCompStdEig<ARFLOAT>::Aupp()$/;"	f	class:ARrcCompStdEig
Aupp	arpack++/include/arrseig.h	/^  virtual void Aupp() {$/;"	f	class:ARrcStdEig
Aupp	arpack++/include/arrsnsym.h	/^inline void ARrcNonSymStdEig<ARFLOAT>::Aupp()$/;"	f	class:ARrcNonSymStdEig
Aupp	arpack++/include/arrssym.h	/^inline void ARrcSymStdEig<ARFLOAT>::Aupp()$/;"	f	class:ARrcSymStdEig
AuppError	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::AuppError()$/;"	f	class:ARrcStdEig
AutoShift	arpack++/include/arrseig.h	/^  bool    AutoShift;  \/\/ Indicates if implicit shifts will be generated$/;"	m	class:ARrcStdEig
AuxilliaryIterator	GenMatrix.h	/^  struct AuxilliaryIterator {$/;"	s	class:GenMat
AuxilliaryRows	MvpMatrix.h	/^  typedef std::map< std::pair<int,int>, Scalar* > AuxilliaryRows;$/;"	t	class:MvpMat
AvQs	TsOutput.h	/^  DistVec<double>    *AvQs[PostFcn::AVSSIZE];$/;"	m	class:TsOutput
AvQv	TsOutput.h	/^  DistSVec<double,3> *AvQv[PostFcn::AVVSIZE];$/;"	m	class:TsOutput
Average	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Average(const T phi_left,const T value_left,const T phi_right,const T value_right)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Average() const$/;"	f	class:PhysBAM::ARRAY_BASE
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^    T Average(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Average() const$/;"	f	class:PhysBAM::ARRAY_BASE
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Average() const$/;"	f	class:PhysBAM::VECTOR
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Average() const$/;"	f	class:PhysBAM::VECTOR
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Average() const$/;"	f	class:PhysBAM::VECTOR
Average	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Average() const$/;"	f	class:PhysBAM::VECTOR_BASE
Average_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Average_Rotation(const ARRAY<ROTATION<TV> >& rotations)$/;"	f	class:ROTATION
Average_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION Average_Rotation(const ARRAY<ROTATION>&)$/;"	f	class:PhysBAM::ROTATION
AvgIncrementalStates	IoData.h	/^  enum AvgIncrementalStates {AVG_INCREMENTAL_STATES_FALSE = 0, AVG_INCREMENTAL_STATES_TRUE = 1} avgIncrementalStates;$/;"	g	struct:NonlinearRomFileSystemData
AvgStateIncrements	IoData.h	/^  enum AvgStateIncrements {AVG_STATE_INCREMENTS_OFF = 0, AVG_STATE_INCREMENTS_ON = 1} avgStateIncrements;$/;"	g	struct:ROMOutputData
Axis_Aligned_Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX<TV> Axis_Aligned_Bounding_Box() const$/;"	f	class:PhysBAM::BOX
Axis_Aligned_Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    RANGE<TV> Axis_Aligned_Bounding_Box() const$/;"	f	class:PhysBAM::ORIENTED_BOX
Axis_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR Axis_Vector(const int axis)$/;"	f	class:PhysBAM::VECTOR
Axis_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR Axis_Vector(const int axis)$/;"	f	class:PhysBAM::VECTOR
Axis_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Axis_Vector(const int axis)$/;"	f	class:PhysBAM::VECTOR
Axis_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Axis_Vector(const int axis)$/;"	f	class:PhysBAM::VECTOR
B	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Array<Eigen::Matrix<Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols>, 1, A_Cols, C_Options, C_MaxRows, C_MaxCols> B;$/;"	t	struct:assign_coherent_impl
B	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Matrix<Scalar, 1, 1, Options, MaxRows, MaxCols> B;$/;"	t	struct:assign_coherent_impl
B	AutoDiff/SpaceDerivatives.h	/^  typedef Eigen::Matrix<Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols> B;$/;"	t	struct:assign_coherent_impl
B	AutoDiff/SpaceDerivatives.h	/^  typedef Scalar B;$/;"	t	struct:assign_coherent_impl
B	arpack++/include/arbnspen.h	/^  ARbdNonSymMatrix<ARTYPE, ARFLOAT>* B;$/;"	m	class:ARbdNonSymPencil
B	arpack++/include/arbspen.h	/^  ARbdSymMatrix<ARTYPE>* B;$/;"	m	class:ARbdSymPencil
B	arpack++/include/ardnspen.h	/^  ARdsNonSymMatrix<ARTYPE, ARFLOAT>* B;$/;"	m	class:ARdsNonSymPencil
B	arpack++/include/ardspen.h	/^  ARdsSymMatrix<ARTYPE>* B;$/;"	m	class:ARdsSymPencil
B	arpack++/include/arlnspen.h	/^  ARluNonSymMatrix<ARTYPE, ARFLOAT>* B;$/;"	m	class:ARluNonSymPencil
B	arpack++/include/arlspen.h	/^  ARluSymMatrix<ARTYPE>* B;$/;"	m	class:ARluSymPencil
B	arpack++/include/arunspen.h	/^  ARumNonSymMatrix<ARTYPE, ARFLOAT>* B;$/;"	m	class:ARumNonSymPencil
B	arpack++/include/aruspen.h	/^  ARumSymMatrix<ARTYPE>* B;$/;"	m	class:ARumSymPencil
BACKTRACKING	IoData.h	/^  enum Type {NONE = 0, BACKTRACKING = 1} type;$/;"	e	enum:LineSearchData::Type
BACKWARD_EULER	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	e	enum:ImplicitData::Type
BAD_RIEMANN	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
BALANCED_POD	IoData.h	/^  enum Type {POD = 0, BALANCED_POD = 1} type;$/;"	e	enum:DataCompressionData::Type
BALL_VERTEX	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	e	enum:DefoMeshMotionData::Element
BARTH	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	e	enum:SchemeData::Limiter
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    typedef RANGE<TV> BASE;$/;"	t	class:PhysBAM::BOX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    typedef CLONEABLE<GEOMETRY_PARTICLES<TV>,POINT_CLOUD<TV> > BASE;$/;"	t	class:PhysBAM::GEOMETRY_PARTICLES
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    typedef BOX_HIERARCHY<VECTOR<T,3> > BASE;$/;"	t	class:PhysBAM::TRIANGLE_HIERARCHY
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    typedef SIMPLEX_MESH<1> BASE;$/;"	t	class:PhysBAM::SEGMENT_MESH
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    typedef SIMPLEX_MESH<2> BASE;$/;"	t	class:PhysBAM::TRIANGLE_MESH
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typedef ARRAY_BASE<typename REMOVE_CONST<T>::TYPE,ARRAY_VIEW<T,ID>,ID> BASE;$/;"	t	class:PhysBAM::ARRAY_VIEW
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef ARRAY_BASE<T,INDIRECT_ARRAY<T_ARRAY,T_INDICES>,ID> BASE;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,m_input,n_input> > BASE;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    typedef MATRIX_BASE<T,MATRIX<T,1> > BASE;using BASE::operator*;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    typedef MATRIX_BASE<T,MATRIX<T,1,2> > BASE;using BASE::operator*;using BASE::Transpose_Times;using BASE::Times_Transpose;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    typedef MATRIX_BASE<T,MATRIX<T,2> > BASE;using BASE::operator*;using BASE::Transpose_Times;using BASE::Times_Transpose;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    typedef TRANSPOSE_MATRIX<MATRIX<T_input,3,2> > BASE;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,3,2> > BASE;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,3> > BASE;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,4> > BASE;$/;"	t	class:PhysBAM::MATRIX
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    typedef MATRIX_BASE<T,MATRIX_MXN<T> > BASE;$/;"	t	class:PhysBAM::MATRIX_MXN
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef VECTOR_BASE<T,VECTOR<T,d> > BASE;$/;"	t	class:PhysBAM::VECTOR
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    typedef VECTOR_BASE<T,VECTOR<T,0> > BASE;$/;"	t	class:PhysBAM::VECTOR
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef VECTOR_EXPRESSION<typename SUM<T1,typename T_VECTOR::SCALAR>::TYPE,VECTOR_SCALE<T1,T_VECTOR> > BASE;$/;"	t	class:PhysBAM::VECTOR_SCALE
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef VECTOR_EXPRESSION<typename SUM<typename T_VECTOR1::SCALAR,typename T_VECTOR2::SCALAR>::TYPE,VECTOR_DIFFERENCE<T_VECTOR1,T_VECTOR2> > BASE;$/;"	t	class:PhysBAM::VECTOR_DIFFERENCE
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef VECTOR_EXPRESSION<typename SUM<typename T_VECTOR1::SCALAR,typename T_VECTOR2::SCALAR>::TYPE,VECTOR_SUM<T_VECTOR1,T_VECTOR2> > BASE;$/;"	t	class:PhysBAM::VECTOR_SUM
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef VECTOR_EXPRESSION<typename T_VECTOR::SCALAR,VECTOR_NEGATION<T_VECTOR> > BASE;$/;"	t	class:PhysBAM::VECTOR_NEGATION
BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    typedef T SCALAR;typedef VECTOR_BASE<T,VECTOR_ND<T> > BASE;$/;"	t	class:PhysBAM::VECTOR_ND
BASIC	EmbeddedCorotSolver.h	/^  enum Type {BASIC, COROTATIONAL} type;$/;"	e	enum:EmbeddedCorotSolver::Type
BASIC	IoData.h	/^  enum Type {BASIC = 0, COROTATIONAL = 1} type;$/;"	e	enum:DefoMeshMotionData::Type
BASIC_GEOMETRY_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^struct BASIC_GEOMETRY_POLICY<VECTOR<T,0> >$/;"	s	namespace:PhysBAM
BASIC_GEOMETRY_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^struct BASIC_GEOMETRY_POLICY<VECTOR<T,1> >$/;"	s	namespace:PhysBAM
BASIC_GEOMETRY_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^struct BASIC_GEOMETRY_POLICY<VECTOR<T,2> >$/;"	s	namespace:PhysBAM
BASIC_GEOMETRY_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^struct BASIC_GEOMETRY_POLICY<VECTOR<T,3> >$/;"	s	namespace:PhysBAM
BASIS_NOT_OK	arpack++/include/arerror.h	/^    BASIS_NOT_OK        = -405,$/;"	e	enum:ArpackError::ErrorCode
BC	OneDimensionalSolver.h	/^  double BC[2][5];$/;"	m	class:OneDimensional
BCApplier	BCApplier.h	/^class BCApplier {$/;"	c
BCApplier	BCApplierCore.C	/^BCApplier::BCApplier(int nLocSub, Domain* dom, IoData& ioData):domain(dom),surfaceMap(ioData.surfaces.surfaceMap.dataMap),$/;"	f	class:BCApplier
BC_ADIABATIC_WALL_FIXED	BcDef.h	20;"	d
BC_ADIABATIC_WALL_MOVING	BcDef.h	19;"	d
BC_CONSTRAINED	BcDef.h	38;"	d
BC_DIRECTSTATE_INLET_FIXED	BcDef.h	12;"	d
BC_DIRECTSTATE_INLET_MOVING	BcDef.h	11;"	d
BC_DIRECTSTATE_OUTLET_FIXED	BcDef.h	10;"	d
BC_DIRECTSTATE_OUTLET_MOVING	BcDef.h	9;"	d
BC_FIXED	BcDef.h	35;"	d
BC_FREE	BcDef.h	34;"	d
BC_INLET_FIXED	BcDef.h	18;"	d
BC_INLET_MOVING	BcDef.h	17;"	d
BC_INTERNAL	BcDef.h	25;"	d
BC_ISOTHERMAL_WALL_FIXED	BcDef.h	24;"	d
BC_ISOTHERMAL_WALL_MOVING	BcDef.h	23;"	d
BC_KIRCHHOFF_SURFACE	BcDef.h	31;"	d
BC_MASSFLOW_INLET_FIXED	BcDef.h	8;"	d
BC_MASSFLOW_INLET_MOVING	BcDef.h	7;"	d
BC_MASSFLOW_OUTLET_FIXED	BcDef.h	6;"	d
BC_MASSFLOW_OUTLET_MOVING	BcDef.h	5;"	d
BC_MATCHED	BcDef.h	36;"	d
BC_MATCHEDSLIDE	BcDef.h	37;"	d
BC_MAX_CODE	BcDef.h	28;"	d
BC_MIN_CODE	BcDef.h	27;"	d
BC_OUTLET_FIXED	BcDef.h	16;"	d
BC_OUTLET_MOVING	BcDef.h	15;"	d
BC_POROUS_WALL_FIXED	BcDef.h	14;"	d
BC_POROUS_WALL_MOVING	BcDef.h	13;"	d
BC_SLIP_WALL_FIXED	BcDef.h	22;"	d
BC_SLIP_WALL_MOVING	BcDef.h	21;"	d
BC_SYMMETRY	BcDef.h	4;"	d
BCond	BCond.h	/^struct BCond $/;"	s
BCondSet	BCond.h	/^  BCondSet(int _numBC=0) { numBC = _numBC; bcs = (numBC) ? new BCond[numBC] : 0; }$/;"	f	class:BCondSet
BCondSet	BCond.h	/^class BCondSet {$/;"	c
BCphi	OneDimensionalSolver.h	/^  double BCphi[2];$/;"	m	class:OneDimensional
BCs	KspPrec.h	/^  BCApplier* BCs; \/\/HB$/;"	m	class:JacobiPrec
BCs	KspPrec.h	/^  BCApplier* BCs;$/;"	m	class:IdentityPrec
BCs	StiffMatrix.h	/^  BCApplier* BCs; \/\/PJSA$/;"	m	class:StiffMat
BDF_SCHEME1	IoData.h	/^  enum FVMERS3PBDFSchme { BDF_SCHEME1 = 1, BDF_SCHEME2 = 0 } fvmers_3pbdf;$/;"	e	enum:ImplicitData::FVMERS3PBDFSchme
BDF_SCHEME2	IoData.h	/^  enum FVMERS3PBDFSchme { BDF_SCHEME1 = 1, BDF_SCHEME2 = 0 } fvmers_3pbdf;$/;"	e	enum:ImplicitData::FVMERS3PBDFSchme
BFixData	IoData.h	/^struct BFixData {$/;"	s
BFixData	IoDataCore.C	/^BFixData::BFixData()$/;"	f	class:BFixData
BLAS1C_H	arpack++/include/blas1c.h	21;"	d
BLAS1F_H	arpack++/include/blas1f.h	18;"	d
BLAS_H	AlternatingLeastSquare/include/blas.h	2;"	d
BLMeshMotionData	IoData.h	/^struct BLMeshMotionData {$/;"	s
BLMeshMotionData	IoDataCore.C	/^BLMeshMotionData::BLMeshMotionData()$/;"	f	class:BLMeshMotionData
BODYFITTED	IoData.h	/^  enum Framework {BODYFITTED = 0, EMBEDDED = 1, EMBEDDEDALE = 2} framework;$/;"	e	enum:ProblemData::Framework
BOUNDFLUX5	f77src/boundflux5.f	/^      SUBROUTINE BOUNDFLUX5(/;"	s
BOUNDJAC2	f77src/boundjac2.f	/^      SUBROUTINE BOUNDJAC2(/;"	s
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX()$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const BOX<TV>& box,const FRAME<VECTOR<T,1> >& frame) \/\/ allow 1d boxes to be used as oriented boxes$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const RANGE<TV>& box)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const T xmin,const T xmax)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const T xmin,const T xmax,const T ymin,const T ymax)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const T xmin,const T xmax,const T ymin,const T ymax,const T zmin,const T zmax)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const TV& minimum_corner,const TV& maximum_corner)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    BOX(const TV& point)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    template<class T2> explicit BOX(const RANGE<T2>& box)$/;"	f	class:PhysBAM::BOX
BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^class BOX:public RANGE<TV>$/;"	c	namespace:PhysBAM
BOX_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
BOX_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^BOX_HIERARCHY()$/;"	f	class:BOX_HIERARCHY
BOX_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^class BOX_HIERARCHY:public NONCOPYABLE$/;"	c	namespace:PhysBAM
BOX_VISITOR_MPI	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    BOX_VISITOR_MPI(T_NESTED_VISITOR nested_visitor,const ARRAY<char>& processors1,const ARRAY<char>& processors2)$/;"	f	struct:PhysBAM::BOX_VISITOR_MPI
BOX_VISITOR_MPI	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^struct BOX_VISITOR_MPI$/;"	s	namespace:PhysBAM
BOX_VISITOR_TRIVIAL	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    BOX_VISITOR_TRIVIAL(ARRAY<ARRAY<int> >& intersection_list)$/;"	f	struct:PhysBAM::BOX_VISITOR_TRIVIAL
BOX_VISITOR_TRIVIAL	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^struct BOX_VISITOR_TRIVIAL$/;"	s	namespace:PhysBAM
Backtrace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^void Backtrace()$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Balance_Sub_KD_Tree_Using_Internal_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Balance_Sub_KD_Tree_Using_Internal_Nodes(KD_TREE_NODE<T>* cell,const int first_index,const int last_index,ARRAY_VIEW<const TV> points,ARRAY_VIEW<int> permutation_array,RANGE<TV>& box)$/;"	f	class:KD_TREE
Balance_Sub_KD_Tree_Using_Leaf_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Balance_Sub_KD_Tree_Using_Leaf_Nodes(KD_TREE_NODE<T>* cell,const int first_index,const int last_index,ARRAY_VIEW<const TV> points,ARRAY_VIEW<int> permutation_array,RANGE<TV>& box)$/;"	f	class:KD_TREE
Balance_Sub_KD_Tree_Using_Leaf_Nodes_With_Grouping	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Balance_Sub_KD_Tree_Using_Leaf_Nodes_With_Grouping(KD_TREE_NODE<T>* cell,const int first_index,const int last_index,ARRAY_VIEW<const TV> points,ARRAY_VIEW<int> permutation_array,$/;"	f	class:KD_TREE
BallVertex	f77src/ballvertex.f	/^      subroutine BallVertex(/;"	s
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    ONE Barycentric_Coordinates(const TV& location) const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV Barycentric_Coordinates(const TV& location) const$/;"	f	class:PhysBAM::SEGMENT_2D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Barycentric_Coordinates(const TV& location,const TV& x1,const TV& x2) $/;"	f	class:PhysBAM::SEGMENT_2D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Barycentric_Coordinates(const VECTOR<T,3>& location) const$/;"	f	class:SEGMENT_3D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Barycentric_Coordinates(const VECTOR<T,3>& location,const VECTOR<T,3>& x1,const VECTOR<T,3>& x2)$/;"	f	class:SEGMENT_3D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV Barycentric_Coordinates(const TV& location) const $/;"	f	class:PhysBAM::TRIANGLE_3D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Barycentric_Coordinates(const TV& location,const TV& x1,const TV& x2,const TV& x3) \/\/ clockwise vertices$/;"	f	class:PhysBAM::TRIANGLE_3D
Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Barycentric_Coordinates(const TV& location,const T_ARRAY& X)$/;"	f	class:PhysBAM::TRIANGLE_3D
Base	AutoDiff/SpaceDerivatives.h	/^                               typename FunctionTemplate<Scalar>::ScalarConstantType> Base;$/;"	t	class:JacobianVectorProduct
BasicGeometry	BasicGeometry.h	/^class BasicGeometry {$/;"	c
BasisOK	arpack++/include/arrseig.h	/^  bool    BasisOK;    \/\/ Indicates if an Arnoldi basis was found.$/;"	m	class:ARrcStdEig
BasisUpdates	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	g	struct:NonlinearRomOnlineData
BasisUpdates	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1} basisUpdates;$/;"	g	struct:RelativeProjectionErrorData
BasisUpdatesData	IoData.h	/^struct BasisUpdatesData {$/;"	s
BasisUpdatesData	IoDataCore.C	/^BasisUpdatesData::BasisUpdatesData()$/;"	f	class:BasisUpdatesData
BcData	BcData.h	/^  BcData(SVec<double,dim> &uf, SVec<double,dim> &un, SVec<double,dim> &uin, SVec<double,dim> &ufarin, SVec<double,dim> &ufarout,  SVec<double,dim> &uporouswall, SVec<double,dim> &duf, SVec<double,dim> &dun, SVec<double,dim> &duin, SVec<double,dim> &dufarin, SVec<double,dim> &dufarout,  SVec<double,dim> &duporouswall,SVec<double,dim> &dufsa, SVec<double,dim> &dunsa)$/;"	f	class:BcData
BcData	BcData.h	/^  BcData(SVec<double,dim> &uf, SVec<double,dim> &un, SVec<double,dim> &uin, SVec<double,dim> &ufarin, SVec<double,dim> &ufarout, SVec<double,dim> &uporouswall, SVec<double,dim> &duf, SVec<double,dim> &dun, SVec<double,dim> &duin, SVec<double,dim> &dufarin, SVec<double,dim> &dufarout, SVec<double,dim> &duporouswall)$/;"	f	class:BcData
BcData	BcData.h	/^  BcData(SVec<double,dim> &uf, SVec<double,dim> &un, SVec<double,dim> &uin, SVec<double,dim> &ufarin, SVec<double,dim> &ufarout, SVec<double,dim> &uporouswall, SVec<double,dim> &dufsa, SVec<double,dim> &dunsa)$/;"	f	class:BcData
BcData	BcData.h	/^ BcData(SVec<double,dim> &uf, SVec<double,dim> &un, SVec<double,dim> &uin, SVec<double,dim> &ufarin, SVec<double,dim> &ufarout, SVec<double,dim> &uporouswall) : Uface(uf), Unode(un), Uinletnode(uin), Ufarin(ufarin), Ufarout(ufarout), Uporouswall(uporouswall), boundaryStateHH(0) {}$/;"	f	class:BcData
BcData	BcData.h	/^class BcData {$/;"	c
BcFcn	BcFcn.h	/^  BcFcn() {}$/;"	f	class:BcFcn
BcFcn	BcFcn.h	/^class BcFcn {$/;"	c
BcFcnKE	BcFcn.h	/^class BcFcnKE : public BcFcn {$/;"	c
BcFcnKE	BcFcnCore.C	/^BcFcnKE::BcFcnKE(IoData& iod)$/;"	f	class:BcFcnKE
BcFcnKEturb	BcFcn.h	/^  BcFcnKEturb() {}$/;"	f	class:BcFcnKEturb
BcFcnKEturb	BcFcn.h	/^class BcFcnKEturb : public BcFcn {$/;"	c
BcFcnNS	BcFcn.h	/^  BcFcnNS() {}$/;"	f	class:BcFcnNS
BcFcnNS	BcFcn.h	/^class BcFcnNS : public BcFcn {$/;"	c
BcFcnSA	BcFcn.h	/^class BcFcnSA : public BcFcn {$/;"	c
BcFcnSA	BcFcnCore.C	/^BcFcnSA::BcFcnSA(IoData& iod)$/;"	f	class:BcFcnSA
BcFcnSAturb	BcFcn.h	/^  BcFcnSAturb() {}$/;"	f	class:BcFcnSAturb
BcFcnSAturb	BcFcn.h	/^class BcFcnSAturb : public BcFcn {$/;"	c
BcsData	IoData.h	/^struct BcsData {$/;"	s
BcsData	IoDataCore.C	/^BcsData::BcsData()$/;"	f	class:BcsData
BcsFreeStreamData	IoData.h	/^struct BcsFreeStreamData {$/;"	s
BcsFreeStreamData	IoDataCore.C	/^BcsFreeStreamData::BcsFreeStreamData()$/;"	f	class:BcsFreeStreamData
BcsHydroData	IoData.h	/^struct BcsHydroData {$/;"	s
BcsHydroData	IoDataCore.C	/^BcsHydroData::BcsHydroData()$/;"	f	class:BcsHydroData
BcsWallData	IoData.h	/^struct BcsWallData {$/;"	s
BcsWallData	IoDataCore.C	/^BcsWallData::BcsWallData()$/;"	f	class:BcsWallData
Bilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Bilinear(const T2& u1,const T2& u2,const T2& u3,const T2& u4,const VECTOR<T,2>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Bilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Bilinear(const T2& u1,const T2& u2,const T2& u3,const T2& u4,const VECTOR<T,2>& minimum_corner,const VECTOR<T,2>& maximum_corner,const VECTOR<T,2>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Bilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Bilinear(const T2& u1,const T2& u3,T one_over_y_top_minus_y_bottom,const T x_left,const T y_bottom,const T2& slope12,const T2& slope34,const VECTOR<T,2>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
BinFileHandler	BinFileHandler.h	/^BinFileHandler::BinFileHandler(const char *name, const char *flag, double ver) :$/;"	f	class:BinFileHandler
BinFileHandler	BinFileHandler.h	/^class BinFileHandler {$/;"	c
Binary_Search	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Binary_Search(const T& value) const\/\/ lower_bound binary search$/;"	f	class:PhysBAM::ARRAY_BASE
Bisection_Newton_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Bisection_Newton_Root(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
Bisection_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Bisection_Root(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
Bisection_Secant_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Bisection_Secant_Root(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
Bisection_Secant_Root_For_Thin_Shells	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Bisection_Secant_Root_For_Thin_Shells(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
BlockAlloc	BlockAlloc.h	/^    BlockAlloc(int l = 4096) :$/;"	f	class:BlockAlloc
BlockAlloc	BlockAlloc.h	/^class BlockAlloc {$/;"	c
BlockJacobi	MultiGridSmoothingMatrix.h	/^  enum SmoothingMode { BlockJacobi, LineJacobi, RAS };$/;"	e	enum:MultiGridSmoothingMatrix::SmoothingMode
BlockSize	arpack++/include/ardfmat.h	/^  int BlockSize() const { return blksize; }$/;"	f	class:ARdfMatrix
BlockTridiagonalMatrix	BlockTridiagonalMatrix.C	/^BlockTridiagonalMatrix<Scalar,dim>::BlockTridiagonalMatrix(int n) : N(n) {$/;"	f	class:BlockTridiagonalMatrix
BlockTridiagonalMatrix	BlockTridiagonalMatrix.h	/^class BlockTridiagonalMatrix {$/;"	c
Block_Interrupt_Signal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^void Block_Interrupt_Signal(const bool block)$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Bool2Char	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::Bool2Char(DistVec<bool> &X, DistSVec<char, dim> &Y) {$/;"	f	class:EmbeddedTsDesc
Boundaries	Manual/Aerof3d.html	/^<a name="Boundaries"><\/a>$/;"	a
Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Boundary(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::PLANE
Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Boundary(const TV& location,const T thickness_over_two) const$/;"	f	class:IMPLICIT_OBJECT
Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Boundary(const T& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Boundary(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
BoundaryConditions	Manual/Aerof3d.html	/^<a name="BoundaryConditions"><\/a>$/;"	a
BoundaryData	IoData.h	/^struct BoundaryData  {$/;"	s
BoundaryData	IoDataCore.C	/^BoundaryData::BoundaryData()$/;"	f	class:BoundaryData
BoundaryData	Manual/Aerof3d.html	/^<a name="BoundaryData"><\/a>$/;"	a
BoundaryFluid	DistBcData.h	/^  enum BoundaryFluid { GAS=0, TAIT=1, JWL=2 } boundaryFluid;$/;"	g	class:DistBcData
BoundarySchemeData	IoData.h	/^struct BoundarySchemeData {$/;"	s
BoundarySchemeData	IoDataCore.C	/^BoundarySchemeData::BoundarySchemeData()$/;"	f	class:BoundarySchemeData
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    const RANGE<TV>& Bounding_Box() const \/\/ for templatization purposes$/;"	f	class:PhysBAM::BOX
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    RANGE<TV> Bounding_Box() const$/;"	f	class:PhysBAM::LINE_2D
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    RANGE<TV> Bounding_Box() const \/\/ for templatization purposes$/;"	f	class:PhysBAM::ORIENTED_BOX
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    RANGE<TV> Bounding_Box() const$/;"	f	class:PhysBAM::PLANE
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    RANGE<TV> Bounding_Box() const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    RANGE<TV> Bounding_Box() const$/;"	f	class:PhysBAM::SEGMENT_2D
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    RANGE<TV> Bounding_Box() const$/;"	f	class:PhysBAM::TRIANGLE_3D
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Bounding_Box(const T& p1,const T& p2)$/;"	f	class:PhysBAM::INTERVAL
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Bounding_Box(const T& p1,const T& p2,const T& p3)$/;"	f	class:PhysBAM::INTERVAL
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Bounding_Box(const T& p1,const T& p2,const T& p3,const T& p4)$/;"	f	class:PhysBAM::INTERVAL
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Bounding_Box(const T_ARRAY& points)$/;"	f	class:PhysBAM::INTERVAL
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Bounding_Box(const TV& p1,const TV& p2)$/;"	f	class:PhysBAM::RANGE
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Bounding_Box(const TV& p1,const TV& p2,const TV& p3)$/;"	f	class:PhysBAM::RANGE
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Bounding_Box(const TV& p1,const TV& p2,const TV& p3,const TV& p4)$/;"	f	class:PhysBAM::RANGE
Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Bounding_Box(const T_ARRAY& points)$/;"	f	class:PhysBAM::RANGE
Box	Manual/Aerof3d.html	/^<a name="Box"><\/a>$/;"	a
Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    virtual RANGE<TV>& Box()$/;"	f	class:PhysBAM::IMPLICIT_OBJECT
BoxFix	Manual/Aerof3d.html	/^<a name="BoxFix"><\/a>$/;"	a
BufferResizePolicy	DistLeastSquareSolver.h	/^  enum BufferResizePolicy { TIGHT, LOOSE };$/;"	g	class:DistLeastSquareSolver
Burn	ProgrammedBurn.h	/^    Burn() : x0subdom(-1), x0id(-1), ignited(false) {}$/;"	f	struct:ProgrammedBurn::Burn
Burn	ProgrammedBurn.h	/^  struct Burn {$/;"	s	class:ProgrammedBurn
Bwater	IoData.h	/^  double Bwater;$/;"	m	struct:LiquidModelData
C	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    struct C$/;"	s	struct:PhysBAM::IS_BASE_OF_VALUE
CANNOT_FIND_BASIS	arpack++/include/arerror.h	/^    CANNOT_FIND_BASIS   = -302,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_FIND_SCHUR	arpack++/include/arerror.h	/^    CANNOT_FIND_SCHUR   = -305,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_FIND_VALUES	arpack++/include/arerror.h	/^    CANNOT_FIND_VALUES  = -303,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_FIND_VECTORS	arpack++/include/arerror.h	/^    CANNOT_FIND_VECTORS = -304,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_GET_PROD	arpack++/include/arerror.h	/^    CANNOT_GET_PROD     = -402,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_GET_VECTOR	arpack++/include/arerror.h	/^    CANNOT_GET_VECTOR   = -401,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_OPEN_FILE	arpack++/include/arerror.h	/^    CANNOT_OPEN_FILE    = -551, $/;"	e	enum:ArpackError::ErrorCode
CANNOT_PREPARE	arpack++/include/arerror.h	/^    CANNOT_PREPARE      = -301,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_PUT_VECTOR	arpack++/include/arerror.h	/^    CANNOT_PUT_VECTOR   = -403,$/;"	e	enum:ArpackError::ErrorCode
CANNOT_READ_FILE	arpack++/include/arerror.h	/^    CANNOT_READ_FILE    = -509,$/;"	e	enum:ArpackError::ErrorCode
CANONICALIZE_CONST_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^template<class T,class ID> struct CANONICALIZE_CONST_ARRAY<ARRAY<T,ID> >:public FIRST<ARRAY_VIEW<const T,ID> >{};$/;"	s	namespace:PhysBAM
CANONICALIZE_CONST_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY,class ENABLER=void> struct CANONICALIZE_CONST_ARRAY:public FIRST<T_ARRAY>{};$/;"	s	namespace:PhysBAM
CANONICALIZE_CONST_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T_ARRAY> struct CANONICALIZE_CONST_ARRAY<T_ARRAY,typename ENABLE_IF<IS_BASE_OF<ARRAY_VIEW<typename T_ARRAY::ELEMENT,typename T_ARRAY::INDEX>,T_ARRAY>::value>::TYPE>$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct CAN_ASSIGN<T_ARRAY1,T_ARRAY2,typename ENABLE_IF<IS_ARRAY<T_ARRAY1>::value && IS_ARRAY<T_ARRAY2>::value && IS_SAME<typename T_ARRAY1::ELEMENT,typename T_ARRAY2::ELEMENT>::value && !IS_SAME<T_ARRAY1,T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<double,float>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<double,int>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<float,double>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<float,int>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<int,double>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<int,float>{static const bool value=false;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<class T> struct CAN_ASSIGN<T,T>{static const bool value=true;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct CAN_ASSIGN<TWIST<TV>,TWIST<TV> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
CAN_ASSIGN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR1,class T_VECTOR2> struct CAN_ASSIGN<T_VECTOR1,T_VECTOR2,typename ENABLE_IF<IS_VECTOR<T_VECTOR1>::value && IS_VECTOR<T_VECTOR2>::value && CAN_ASSIGN<typename T_VECTOR1::ELEMENT,typename T_VECTOR2::ELEMENT>::value && !IS_SAME<T_VECTOR1,T_VECTOR2>::value>::TYPE>$/;"	s	namespace:PhysBAM
CARTESIAN	IoData.h	/^  enum CoordinateType {CARTESIAN = 0, CYLINDRICAL = 1, SPHERICAL = 2} coordType;$/;"	e	enum:OneDimensionalInfo::CoordinateType
CAUPP_H	arpack++/include/caupp.h	18;"	d
CEUPP_H	arpack++/include/ceupp.h	18;"	d
CFL	IoData.h	/^  enum TimeStepCalculation {CFL = 0, ERRORESTIMATION = 1} timeStepCalculation;$/;"	e	enum:TsData::TimeStepCalculation
CFLData	IoData.h	/^struct CFLData {$/;"	s
CFLData	IoDataCore.C	/^CFLData::CFLData()$/;"	f	class:CFLData
CFLLaw	Manual/Aerof3d.html	/^<a name="CFLLaw"><\/a><p align="center">$/;"	a
CFixData	IoData.h	/^struct CFixData {$/;"	s
CFixData	IoDataCore.C	/^CFixData::CFixData()$/;"	f	class:CFixData
CG	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	e	enum:KspData::Type
CHANGING_AUTOSHIFT	arpack++/include/arerror.h	/^    CHANGING_AUTOSHIFT  =  301,$/;"	e	enum:ArpackError::ErrorCode
CLONEABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^class CLONEABLE:public T_BASE$/;"	c	namespace:PhysBAM
CLONEABLE_ABSTRACT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^class CLONEABLE_ABSTRACT:public T_BASE$/;"	c	namespace:PhysBAM
CLONEABLE_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^class CLONEABLE_BASE$/;"	c	namespace:PhysBAM
CLUSTER_FILES_SEPARATELY_FALSE	IoData.h	/^  enum ClusterFilesSeparately {CLUSTER_FILES_SEPARATELY_FALSE = 0, CLUSTER_FILES_SEPARATELY_TRUE = 1} clusterFilesSeparately;$/;"	e	enum:ClusteringData::ClusterFilesSeparately
CLUSTER_FILES_SEPARATELY_TRUE	IoData.h	/^  enum ClusterFilesSeparately {CLUSTER_FILES_SEPARATELY_FALSE = 0, CLUSTER_FILES_SEPARATELY_TRUE = 1} clusterFilesSeparately;$/;"	e	enum:ClusteringData::ClusterFilesSeparately
COLLOCATION	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	e	enum:NonlinearRomOnlineData::SystemApproximation
COLPERM	arpack++/include/arlutil.h	/^    COLPERM, \/* find a column ordering that minimizes fills *\/$/;"	e	enum:__anon51
COLUMN_PERMUTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef typename RIGHT_VECTOR::template REBIND<int>::TYPE COLUMN_PERMUTATION;$/;"	t	class:PhysBAM::MATRIX_BASE
COMPARE_SVD_FALSE	IoData.h	/^  enum CompareSVDMethods {COMPARE_SVD_FALSE = 0, COMPARE_SVD_TRUE = 1} compareSVDMethods;$/;"	e	enum:DataCompressionData::CompareSVDMethods
COMPARE_SVD_TRUE	IoData.h	/^  enum CompareSVDMethods {COMPARE_SVD_FALSE = 0, COMPARE_SVD_TRUE = 1} compareSVDMethods;$/;"	e	enum:DataCompressionData::CompareSVDMethods
COMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX()$/;"	f	class:PhysBAM::COMPLEX
COMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX(T re_input,T im_input)$/;"	f	class:PhysBAM::COMPLEX
COMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    explicit COMPLEX(const VECTOR<T,2>& input)$/;"	f	class:PhysBAM::COMPLEX
COMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    template<class T2> explicit COMPLEX(const COMPLEX<T2>& complex_input)$/;"	f	class:PhysBAM::COMPLEX
COMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^class COMPLEX$/;"	c	namespace:PhysBAM
COMPRESSIBLE	IoData.h	/^  enum Type { COMPRESSIBLE = 0 } type;$/;"	e	enum:LiquidModelData::Type
COMPUTEDBOUNDFLUXOPERATOR	f77src/computedboundfluxoperator.f	/^      SUBROUTINE COMPUTEDBOUNDFLUXOPERATOR(/;"	s
COMPUTEDFLUXOPERATORS	f77src/computedfluxoperators.f	/^      SUBROUTINE COMPUTEDFLUXOPERATORS(/;"	s
COMPUTE_MDS_FALSE	IoData.h	/^  enum ComputeMDS {COMPUTE_MDS_FALSE = 0, COMPUTE_MDS_TRUE = 1} computeMDS;$/;"	e	enum:ClusteringData::ComputeMDS
COMPUTE_MDS_TRUE	IoData.h	/^  enum ComputeMDS {COMPUTE_MDS_FALSE = 0, COMPUTE_MDS_TRUE = 1} computeMDS;$/;"	e	enum:ClusteringData::ComputeMDS
COMPUTE_POD_FALSE	IoData.h	/^  enum ComputePOD {COMPUTE_POD_FALSE = 0, COMPUTE_POD_TRUE = 1} computePOD;$/;"	e	enum:DataCompressionData::ComputePOD
COMPUTE_POD_TRUE	IoData.h	/^  enum ComputePOD {COMPUTE_POD_FALSE = 0, COMPUTE_POD_TRUE = 1} computePOD;$/;"	e	enum:DataCompressionData::ComputePOD
CONSERVATIVE	FluxFcnBase.h	/^  enum Type {CONSERVATIVE = 0, PRIMITIVE = 1} typeJac;$/;"	e	enum:FluxFcnBase::Type
CONSERVATIVE	IoData.h	/^  enum LevelSetMethod { CONSERVATIVE = 0, HJWENO = 1, SCALAR=2, PRIMITIVE = 3,$/;"	e	enum:MultiFluidData::LevelSetMethod
CONSTANT	IoData.h	/^  enum EpsFormula {CONSTANT = 0, EISENSTADT = 1} epsFormula;$/;"	e	enum:KspData::EpsFormula
CONSTANT	IoData.h	/^  enum Reconstruction {CONSTANT = 0, EXACT_RIEMANN = 1} reconstruction;$/;"	e	enum:BcsWallData::Reconstruction
CONSTANT	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruct;$/;"	e	enum:EmbeddedFramework::Reconstruction
CONSTANT	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruction;$/;"	e	enum:SchemeData::Reconstruction
CONSTANT	IoData.h	/^  enum Type {CONSTANT = 0, SUTHERLAND = 1, PRANDTL = 2} type;$/;"	e	enum:ViscosityModelData::Type
CONSTANT	IoData.h	/^  enum Type {CONSTANT_PRANDTL = 0, CONSTANT = 1} type;$/;"	e	enum:ThermalCondModelData::Type
CONSTANTACCELERATION	IoData.h	/^  enum LawType {VELOCITYPOINTS = 0, CONSTANTACCELERATION = 1} lawtype;$/;"	e	enum:RigidMeshMotionData::LawType
CONSTANT_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    CONSTANT_ARRAY(const ID m,const T constant)$/;"	f	class:PhysBAM::CONSTANT_ARRAY
CONSTANT_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^class CONSTANT_ARRAY:public ARRAY_BASE<T,CONSTANT_ARRAY<T,ID>,ID>$/;"	c	namespace:PhysBAM
CONSTANT_EXTRAPOLATION	IoData.h	/^              CONSTANT_EXTRAPOLATION = 1,$/;"	e	enum:BoundarySchemeData::Type
CONSTANT_PRANDTL	IoData.h	/^  enum Type {CONSTANT_PRANDTL = 0, CONSTANT = 1} type;$/;"	e	enum:ThermalCondModelData::Type
CONSTANT_VOLUME	IoData.h	/^  enum VolumeType { CONSTANT_VOLUME = 0, REAL_VOLUME = 1} volumeType;$/;"	e	enum:OneDimensionalInfo::VolumeType
CONST_RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef const T& CONST_RESULT_TYPE;$/;"	t	class:PhysBAM::ARRAY_BASE
CONST_RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_EXPRESSION.h	/^    typedef const T CONST_RESULT_TYPE;$/;"	t	class:PhysBAM::ARRAY_EXPRESSION
CONST_RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename T_ARRAY::CONST_RESULT_TYPE CONST_RESULT_TYPE;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
CONST_T_INDICES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename IF<IS_REFERENCE<T_INDICES>::value,const T_INDICES_NO_REFERENCE&,const T_INDICES_NO_REFERENCE>::TYPE CONST_T_INDICES;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/EDGE_EDGE_COLLISION.h	/^namespace CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS$/;"	n	namespace:PhysBAM
CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.h	/^namespace CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS$/;"	n	namespace:PhysBAM
CONTROL_VOLUME	PostFcn.h	/^                   SURFACE_HEAT_FLUX = 26, PRESSURECOEFFICIENT = 27, CONTROL_VOLUME = 28, FLUIDID = 29,$/;"	e	enum:PostFcn::ScalarType
CONTROL_VOLUME_BOUNDARY	IoData.h	/^  enum ForceAlgorithm {RECONSTRUCTED_SURFACE = 0, CONTROL_VOLUME_BOUNDARY = 1, EMBEDDED_SURFACE = 2} forceAlg;$/;"	e	enum:EmbeddedFramework::ForceAlgorithm
CONVTEST1	IoData.h	/^  enum Mode { NORMAL=0, CONVTEST1 = 1, CONVTEST2=2 } mode;$/;"	e	enum:OneDimensionalInfo::Mode
CONVTEST2	IoData.h	/^  enum Mode { NORMAL=0, CONVTEST1 = 1, CONVTEST2=2 } mode;$/;"	e	enum:OneDimensionalInfo::Mode
COPY_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    template<class S> struct COPY_CONST:public IF<IS_CONST<T>::value,typename ADD_CONST<S>::TYPE,S>{};$/;"	s	class:PhysBAM::ARRAY_VIEW
COROTATIONAL	EmbeddedCorotSolver.h	/^  enum Type {BASIC, COROTATIONAL} type;$/;"	e	enum:EmbeddedCorotSolver::Type
COROTATIONAL	IoData.h	/^  enum Type {BASIC = 0, COROTATIONAL = 1} type;$/;"	e	enum:DefoMeshMotionData::Type
CPair	Communicator.h	/^    CPair() {}$/;"	f	struct:SubDTopo::CPair
CPair	Communicator.h	/^    CPair(int f, int t, int c) { from =f; to = t; cpuID =c; }$/;"	f	struct:SubDTopo::CPair
CPair	Communicator.h	/^  struct CPair {$/;"	s	class:SubDTopo
CRACKINGSURFACE_H_	FSI/CrackingSurface.h	9;"	d
CRACK_TAG1	StructExc.C	31;"	d	file:
CRACK_TAG2	StructExc.C	32;"	d	file:
CRACK_TAG3	StructExc.C	33;"	d	file:
CRACK_TAG4	StructExc.C	34;"	d	file:
CRANK_NICOLSON	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	e	enum:ImplicitData::Type
CRAY_STACK	tools/alloca.cougar.c	201;"	d	file:
CREATE_RAW	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef T_OBJECT* CREATE_RAW();$/;"	t	struct:PhysBAM::FACTORY
CREATE_WITH_PARTICLES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef T_OBJECT* CREATE_WITH_PARTICLES(GEOMETRY_PARTICLES<TV>&);$/;"	t	struct:PhysBAM::FACTORY
CROSS_PRODUCT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,0,1> CROSS_PRODUCT_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
CROSS_PRODUCT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,1,2> CROSS_PRODUCT_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
CROSS_PRODUCT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,3> CROSS_PRODUCT_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
CSDLES	PostFcn.h	/^		   VORTICITY = 5, CSDLES = 6, CSDVMS = 7, SKIN_FRICTION = 8, NUT_TURB = 9, $/;"	e	enum:PostFcn::ScalarType
CSDLESAVG	PostFcn.h	/^                      TOTPRESSUREAVG = 4, VORTICITYAVG = 5, CSDLESAVG = 6, CSDVMSAVG = 7, $/;"	e	enum:PostFcn::ScalarAvgType
CSDVMS	PostFcn.h	/^		   VORTICITY = 5, CSDLES = 6, CSDVMS = 7, SKIN_FRICTION = 8, NUT_TURB = 9, $/;"	e	enum:PostFcn::ScalarType
CSDVMSAVG	PostFcn.h	/^                      TOTPRESSUREAVG = 4, VORTICITYAVG = 5, CSDLESAVG = 6, CSDVMSAVG = 7, $/;"	e	enum:PostFcn::ScalarAvgType
CUBIC	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^CUBIC(const T c3_input,const T c2_input,const T c1_input,const T c0_input)$/;"	f	class:CUBIC
CUBIC	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^class CUBIC:public NONLINEAR_FUNCTION<T(T)>$/;"	c	namespace:PhysBAM
CURVE2D_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
CURVE_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
CUTOFF	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	e	enum:TsData::Clipping
CV_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef typename REMOVE_CV<T>::TYPE CV_TYPE;$/;"	t	struct:PhysBAM::IS_EMPTY_VALUE
CXXOBJS	tools/Makefile	/^CXXOBJS  = loader.o$/;"	m
CYLINDER	KirchhoffIntegrator.h	/^  enum TypeGamma {SPHERE = 0, CYLINDER = 1} d_SurfType;$/;"	e	enum:KirchhoffIntegrator::TypeGamma
CYLINDRICAL	IoData.h	/^  enum CoordinateType {CARTESIAN = 0, CYLINDRICAL = 1, SPHERICAL = 2} coordType;$/;"	e	enum:OneDimensionalInfo::CoordinateType
CYLINDRICAL	IoData.h	/^  enum Type {CYLINDRICAL = 0, SPHERICAL = 1} d_surfaceType;$/;"	e	enum:KirchhoffData::Type
C_	VarFcnTait.h	/^  double C_;$/;"	m	class:VarFcnTait
C_CALL	arpack++/include/arlnames.h	32;"	d
Calculate_Acceleration_Constants	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Calculate_Acceleration_Constants()$/;"	f	class:PhysBAM::ARRAY_BASE
Calculate_Bounding_Box_Radii	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Calculate_Bounding_Box_Radii(const ARRAY<RANGE<TV> >& bounding_boxes,ARRAY<T>& radius) $/;"	f	class:BOX_HIERARCHY
Calculate_Bounding_Box_Radii	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Calculate_Bounding_Box_Radii(const ARRAY<RANGE<TV> >& bounding_boxes,ARRAY<T>& radius) $/;"	f	class:TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes)$/;"	f	class:TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes,const FRAME<TV>& start_frame,const FRAME<TV>& end_frame)$/;"	f	class:TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes,ARRAY_VIEW<const TV> X)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes,ARRAY_VIEW<const TV> start_X,ARRAY_VIEW<const TV> end_X)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes,INDIRECT_ARRAY<ARRAY_VIEW<const TV> > X)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Calculate_Bounding_Boxes(ARRAY<RANGE<TV> >& bounding_boxes,INDIRECT_ARRAY<ARRAY_VIEW<const TV> > start_X,INDIRECT_ARRAY<ARRAY_VIEW<const TV> > end_X)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Calculate_Bounding_Boxes_Helper(ARRAY<RANGE<TV> >& bounding_boxes,T_ARRAY_TV X) $/;"	f	class:TRIANGLE_HIERARCHY
Calculate_Bounding_Boxes_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Calculate_Bounding_Boxes_Helper(ARRAY<RANGE<TV> >& bounding_boxes,T_ARRAY_TV start_X,T_ARRAY_TV end_X)$/;"	f	class:TRIANGLE_HIERARCHY
Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    TV Center() const$/;"	f	class:PhysBAM::ORIENTED_BOX
Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    const TV& Center() const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV Center() const$/;"	f	class:PhysBAM::SEGMENT_2D
Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV Center() const \/\/ centroid$/;"	f	class:PhysBAM::TRIANGLE_3D
Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Center(const TV& x1,const TV& x2,const TV& x3) \/\/ centroid$/;"	f	class:PhysBAM::TRIANGLE_3D
Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T Center() const$/;"	f	class:PhysBAM::INTERVAL
Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Center() const$/;"	f	class:PhysBAM::RANGE
Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/CENTER.h	/^    static TV Center(const ARRAY<TV>& X)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Centroid	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    TV Centroid()$/;"	f	class:PhysBAM::POINT_CLOUD
CflLaw	Manual/Aerof3d.html	/^<a name="CflLaw"><\/a>$/;"	a
CgSolver	KspSolver.C	/^CgSolver(const typename VecType::InfoType &info, KspData &data, $/;"	f	class:CgSolver
CgSolver	KspSolver.h	/^class CgSolver : public KspSolver<VecType,MatVecProdOp,PrecOp,IoOp> {$/;"	c
ChangeInvertMode	arpack++/include/arrgsym.h	/^inline void ARrcSymGenEig<ARFLOAT>::ChangeInvertMode(char InvertModep)$/;"	f	class:ARrcSymGenEig
ChangeMaxit	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeMaxit(int maxitp)$/;"	f	class:ARrcStdEig
ChangeMultBx	arpack++/include/argeig.h	/^ChangeMultBx(ARFB* objBp, void (ARFB::* MultBxp)(ARTYPE[], ARTYPE[]))$/;"	f	class:ARGenEig
ChangeMultOPx	arpack++/include/arseig.h	/^ChangeMultOPx(ARFOP* objOPp, void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]))$/;"	f	class:ARStdEig
ChangeNcv	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeNcv(int ncvp)$/;"	f	class:ARrcStdEig
ChangeNev	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeNev(int nevp)$/;"	f	class:ARrcStdEig
ChangePart	arpack++/include/arrgnsym.h	/^inline void ARrcNonSymGenEig<ARFLOAT>::ChangePart(char partp)$/;"	f	class:ARrcNonSymGenEig
ChangeShift	arpack++/include/arbgcomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompGenEig
ChangeShift	arpack++/include/arbgnsym.h	/^ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
ChangeShift	arpack++/include/arbgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
ChangeShift	arpack++/include/arbscomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompStdEig
ChangeShift	arpack++/include/arbsnsym.h	/^ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluNonSymStdEig
ChangeShift	arpack++/include/arbssym.h	/^ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluSymStdEig
ChangeShift	arpack++/include/ardgcomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompGenEig
ChangeShift	arpack++/include/ardgnsym.h	/^ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
ChangeShift	arpack++/include/ardgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
ChangeShift	arpack++/include/ardscomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompStdEig
ChangeShift	arpack++/include/ardsnsym.h	/^ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluNonSymStdEig
ChangeShift	arpack++/include/ardssym.h	/^ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluSymStdEig
ChangeShift	arpack++/include/arlgcomp.h	/^inline void ARluCompGenEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompGenEig
ChangeShift	arpack++/include/arlgnsym.h	/^ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
ChangeShift	arpack++/include/arlgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
ChangeShift	arpack++/include/arlscomp.h	/^inline void ARluCompStdEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompStdEig
ChangeShift	arpack++/include/arlsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluNonSymStdEig
ChangeShift	arpack++/include/arlssym.h	/^inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluSymStdEig
ChangeShift	arpack++/include/arrgnsym.h	/^ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARrcNonSymGenEig
ChangeShift	arpack++/include/arrgsym.h	/^inline void ARrcSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)$/;"	f	class:ARrcSymGenEig
ChangeShift	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeShift(ARTYPE sigmaRp)$/;"	f	class:ARrcStdEig
ChangeShift	arpack++/include/arugcomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompGenEig
ChangeShift	arpack++/include/arugnsym.h	/^ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
ChangeShift	arpack++/include/arugsym.h	/^inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
ChangeShift	arpack++/include/aruscomp.h	/^ChangeShift(arcomplex<ARFLOAT> sigmaRp)$/;"	f	class:ARluCompStdEig
ChangeShift	arpack++/include/arusnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluNonSymStdEig
ChangeShift	arpack++/include/arussym.h	/^inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)$/;"	f	class:ARluSymStdEig
ChangeTol	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeTol(ARFLOAT tolp)$/;"	f	class:ARrcStdEig
ChangeWhich	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::ChangeWhich(char* whichp)$/;"	f	class:ARrcStdEig
Change_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Change_Size(const T delta)$/;"	f	class:TRIANGLE_3D
Change_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Change_Size(const T delta)$/;"	f	class:PhysBAM::INTERVAL
Change_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Change_Size(const T delta)$/;"	f	class:PhysBAM::RANGE
Change_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Change_Size(const TV& delta)$/;"	f	class:PhysBAM::RANGE
CharMat5	ParallelRomCore.C	/^typedef VecSet< DistSVec<char,5> > CharMat5;$/;"	t	file:
CharMat6	ParallelRomCore.C	/^typedef VecSet< DistSVec<char,6> > CharMat6;$/;"	t	file:
CharMat7	ParallelRomCore.C	/^typedef VecSet< DistSVec<char,7> > CharMat7;$/;"	t	file:
CheckFinalRes	IoData.h	/^  enum CheckFinalRes {NO = 0, YES = 1} checkFinalRes;$/;"	g	struct:KspData
CheckInvertMode	arpack++/include/arrgsym.h	/^inline char ARrcSymGenEig<ARFLOAT>::CheckInvertMode(char InvertModep)$/;"	f	class:ARrcSymGenEig
CheckJacobian	DebugTools.h	/^  static void CheckJacobian(const double jac[N*N], const double u[N],$/;"	f	class:DebugTools
CheckMaxit	arpack++/include/arrseig.h	/^inline int ARrcStdEig<ARFLOAT, ARTYPE>::CheckMaxit(int maxitp)$/;"	f	class:ARrcStdEig
CheckN	arpack++/include/arrseig.h	/^inline int ARrcStdEig<ARFLOAT, ARTYPE>::CheckN(int np)$/;"	f	class:ARrcStdEig
CheckNcv	arpack++/include/arrseig.h	/^inline int ARrcStdEig<ARFLOAT, ARTYPE>::CheckNcv(int ncvp)$/;"	f	class:ARrcStdEig
CheckNev	arpack++/include/arrseig.h	/^inline int ARrcStdEig<ARFLOAT, ARTYPE>::CheckNev(int nevp)$/;"	f	class:ARrcStdEig
CheckNev	arpack++/include/arrsnsym.h	/^inline int ARrcNonSymStdEig<ARFLOAT>::CheckNev(int nevp)$/;"	f	class:ARrcNonSymStdEig
CheckPart	arpack++/include/arrgnsym.h	/^inline char ARrcNonSymGenEig<ARFLOAT>::CheckPart(char partp)$/;"	f	class:ARrcNonSymGenEig
CheckWhich	arpack++/include/arrseig.h	/^char* ARrcStdEig<ARFLOAT, ARTYPE>::CheckWhich(char* whichp)$/;"	f	class:ARrcStdEig
CheckWhich	arpack++/include/arrssym.h	/^char* ARrcSymStdEig<ARFLOAT>::CheckWhich(char* whichp)$/;"	f	class:ARrcSymStdEig
Cholesky_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Cholesky_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse) const$/;"	f	class:PhysBAM::MATRIX_BASE
Cholesky_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR Cholesky_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Choose_Partition_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    int Choose_Partition_Axis(const TV& DX) const$/;"	f	class:PhysBAM::KD_TREE
Choose_Partition_Index_Using_Internal_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    int Choose_Partition_Index_Using_Internal_Nodes(const int first_index,const int last_index) const $/;"	f	class:PhysBAM::KD_TREE
Choose_Partition_Index_Using_Leaf_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    int Choose_Partition_Index_Using_Leaf_Nodes(const int first_index,const int last_index) const$/;"	f	class:PhysBAM::KD_TREE
Clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T Clamp(const T& location) const$/;"	f	class:PhysBAM::INTERVAL
Clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    T Clamp(const T& location) const$/;"	f	class:PhysBAM::RANGE
Clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Clamp(const TV& location) const$/;"	f	class:PhysBAM::RANGE
Clamp_Below	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Clamp_Below(const T& value)$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Below	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_Below(const T& value)$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp_End_Minus_One(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_End_Minus_One(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_Three	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp_End_Minus_Three(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_Three	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_End_Minus_Three(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_Two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp_End_Minus_Two(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_End_Minus_Two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_End_Minus_Two(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Interior	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp_Interior(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Interior	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_Interior(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Interior_End_Minus_One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT Clamp_Interior_End_Minus_One(const TV_INT& i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Interior_End_Minus_One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Clamp_Interior_End_Minus_One(int& i,int& j,int& ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Clamp_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Clamp_Max(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Clamp_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Clamp_Max(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Clamp_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Clamp_Max(const T a) const$/;"	f	class:PhysBAM::MATRIX
Clamp_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Clamp_Max(const T a) const$/;"	f	class:PhysBAM::MATRIX
Clamp_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Clamp_Min(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Clamp_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Clamp_Min(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Clamp_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Clamp_Min(const T a) const$/;"	f	class:PhysBAM::MATRIX
Clamp_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Clamp_Min(const T a) const$/;"	f	class:PhysBAM::MATRIX
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    Clamped_Barycentric_Coordinates(const TV& location,const T_ARRAY& X)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    static ONE Clamped_Barycentric_Coordinates(const TV& location,const TV& x1)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Clamped_Barycentric_Coordinates(const TV& location,const TV& x1,const TV& x2) $/;"	f	class:PhysBAM::SEGMENT_2D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Clamped_Barycentric_Coordinates(const TV& location,const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Clamped_Barycentric_Coordinates(const VECTOR<T,3>& location,const T tolerance) const$/;"	f	class:SEGMENT_3D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Clamped_Barycentric_Coordinates(const VECTOR<T,3>& location,const VECTOR<T,3>& x1,const VECTOR<T,3>& x2,const T tolerance)$/;"	f	class:SEGMENT_3D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Clamped_Barycentric_Coordinates(const TV& location,const TV& x1,const TV& x2,const TV& x3,const T tolerance=1e-7) \/\/ clockwise vertices$/;"	f	class:PhysBAM::TRIANGLE_3D
Clamped_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Clamped_Barycentric_Coordinates(const TV& location,const T_ARRAY& X)$/;"	f	class:PhysBAM::TRIANGLE_3D
ClassArray	parser/Assigner.C	/^ClassArray<T>::ClassArray(ClassAssigner *ca, const char *n, T *_ptr, bool (T::*_var)[T::SIZE], int nt, ...) : tk(nt), val(nt), Assigner(n)$/;"	f	class:ClassArray
ClassArray	parser/Assigner.h	/^class ClassArray : public Assigner {$/;"	c
ClassAssigner	parser/Assigner.h	/^class ClassAssigner : public Assigner {$/;"	c
ClassAssigner	parser/AssignerCore.C	/^ClassAssigner::ClassAssigner(const char *n, ClassAssigner *p) : Assigner(n)$/;"	f	class:ClassAssigner
ClassAssigner	parser/AssignerCore.C	/^ClassAssigner::ClassAssigner(const char *n, int ns, ClassAssigner *p)$/;"	f	class:ClassAssigner
ClassDouble	parser/Assigner.C	/^ClassDouble<T>::ClassDouble(ClassAssigner *ca, const char *n, T *_ptr, double T::*_sp)$/;"	f	class:ClassDouble
ClassDouble	parser/Assigner.h	/^class ClassDouble : public Assigner {$/;"	c
ClassInt	parser/Assigner.C	/^ClassInt<T>::ClassInt(ClassAssigner *ca, const char *n, T *_ptr, int T::*_sp)$/;"	f	class:ClassInt
ClassInt	parser/Assigner.h	/^class ClassInt : public Assigner {$/;"	c
ClassParseTree	parser/ParseTree.h	/^ClassParseTree<T>::ClassParseTree(ClassAssigner *ca, const char *n,$/;"	f	class:ClassParseTree
ClassParseTree	parser/ParseTree.h	/^class ClassParseTree  : public Assigner {$/;"	c
ClassStr	parser/Assigner.C	/^ClassStr<T>::ClassStr(ClassAssigner *ca, const char *n, T *_ptr, const char *T::*_sp)$/;"	f	class:ClassStr
ClassStr	parser/Assigner.h	/^class ClassStr  : public Assigner {$/;"	c
ClassToken	parser/Assigner.C	/^ClassToken(ClassAssigner *ca, const char *n, T *_ptr, int T::*_sp, int nt, ...)$/;"	f	class:ClassToken
ClassToken	parser/Assigner.h	/^class ClassToken : public Assigner {$/;"	c
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Clean_Memory()$/;"	f	class:BOX_HIERARCHY
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Clean_Memory()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Clean_Memory()$/;"	f	class:PhysBAM::ARRAY
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Clean_Memory()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Clean_Memory()$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Clean_Memory()$/;"	f	class:PhysBAM::HASHTABLE
Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Clean_Memory()$/;"	f	class:PhysBAM::STACK
Clear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Clear(const int p)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
ClearBasis	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ClearBasis()$/;"	f	class:ARrcStdEig
ClearFirst	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ClearFirst()$/;"	f	class:ARrcStdEig
ClearMem	arpack++/include/arbnsmat.h	/^inline void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()$/;"	f	class:ARbdNonSymMatrix
ClearMem	arpack++/include/arbsmat.h	/^inline void ARbdSymMatrix<ARTYPE>::ClearMem()$/;"	f	class:ARbdSymMatrix
ClearMem	arpack++/include/ardnsmat.h	/^inline void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()$/;"	f	class:ARdsNonSymMatrix
ClearMem	arpack++/include/ardsmat.h	/^inline void ARdsSymMatrix<ARTYPE>::ClearMem()$/;"	f	class:ARdsSymMatrix
ClearMem	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()$/;"	f	class:ARluNonSymMatrix
ClearMem	arpack++/include/arlnspen.h	/^void ARluNonSymPencil<ARTYPE, ARFLOAT>::ClearMem()$/;"	f	class:ARluNonSymPencil
ClearMem	arpack++/include/arlsmat.h	/^void ARluSymMatrix<ARTYPE>::ClearMem()$/;"	f	class:ARluSymMatrix
ClearMem	arpack++/include/arlspen.h	/^void ARluSymPencil<ARTYPE>::ClearMem()$/;"	f	class:ARluSymPencil
ClearMem	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::ClearMem()$/;"	f	class:ARrcStdEig
ClearMem	arpack++/include/arunsmat.h	/^inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::ClearMem()$/;"	f	class:ARumNonSymMatrix
ClearMem	arpack++/include/arusmat.h	/^inline void ARumSymMatrix<ARTYPE>::ClearMem()$/;"	f	class:ARumSymMatrix
Clear_Connectivity	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Clear_Connectivity()$/;"	f	class:PhysBAM::UNION_FIND
Clear_Range	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Clear_Range(const int start,const int end)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Clip_To_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    void Clip_To_Box(const RANGE<TV>& box,ARRAY<POINT_SIMPLEX_1D<T> >& clipped_simplices) const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Clip_To_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Clip_To_Box(const RANGE<TV>& box,ARRAY<SEGMENT_2D<T> >& clipped_simplices) const$/;"	f	class:SEGMENT_2D
Clip_To_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Clip_To_Box(const RANGE<TV>& box,ARRAY<TRIANGLE_3D<T> >& clipped_simplices) const$/;"	f	class:TRIANGLE_3D
Clipping	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	g	struct:TsData
ClippingData	IoData.h	/^struct ClippingData {$/;"	s
ClippingData	IoDataCore.C	/^ClippingData::ClippingData()$/;"	f	class:ClippingData
ClippingDynamic	Manual/Aerof3d.html	/^<a name="ClippingDynamic"><\/a>$/;"	a
ClippingDynamicVMS	Manual/Aerof3d.html	/^<a name="ClippingDynamicVMS"><\/a>$/;"	a
Clone	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    CLONEABLE_BASE* Clone() const$/;"	f	class:PhysBAM::CLONEABLE_BASE
Clone	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    T_DERIVED* Clone() const$/;"	f	class:PhysBAM::CLONEABLE
Clone	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    T_DERIVED* Clone() const$/;"	f	class:PhysBAM::CLONEABLE_ABSTRACT
Clone_Default	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    CLONEABLE_BASE* Clone_Default() const \/\/ creates a default constructed copy of the same type$/;"	f	class:PhysBAM::CLONEABLE_BASE
Clone_Default	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    T_DERIVED* Clone_Default() const \/\/ creates a default constructed copy of the same type$/;"	f	class:PhysBAM::CLONEABLE
Clone_Default	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    T_DERIVED* Clone_Default() const \/\/ creates a default constructed copy of the same type$/;"	f	class:PhysBAM::CLONEABLE_ABSTRACT
Clone_Default_Implementation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    virtual CLONEABLE_BASE* Clone_Default_Implementation() const$/;"	f	class:PhysBAM::CLONEABLE
Clone_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Clone_Helper(const ARRAY_COLLECTION& collection)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Clone_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Clone_Helper(const ARRAY_COLLECTION_ELEMENT& element)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Clone_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    void Clone_Helper(const POINT_CLOUD<TV>& particles)$/;"	f	class:PhysBAM::POINT_CLOUD
Clone_Implementation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    virtual CLONEABLE_BASE* Clone_Implementation() const$/;"	f	class:PhysBAM::CLONEABLE
ClosestNeighbor	IoData.h	/^   enum ClosestNeighbor {Fixed = 1, Variable = 0} bestNeiStrategy;$/;"	g	struct:BLMeshMotionData
ClosestPoint	LevelSet/LevelSetStructure.h	/^  ClosestPoint() {mode=-2;}$/;"	f	struct:ClosestPoint
ClosestPoint	LevelSet/LevelSetStructure.h	/^struct ClosestPoint {$/;"	s
ClosestTriangle	IntersectorFRG/IntersectorFRG.C	/^ClosestTriangle::ClosestTriangle(int (*nd)[3], Vec3D *sX, Vec3D *sN, set<int> *n2n, set<int> *n2e) {$/;"	f	class:ClosestTriangle
ClosestTriangle	IntersectorFRG/IntersectorFRG.C	/^class ClosestTriangle {$/;"	c	file:
Closest_Non_Intersecting_Point	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^template<class T> bool Closest_Non_Intersecting_Point(RAY<VECTOR<T,2> >& ray,const SEGMENT_2D<T>& segment,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Closest_Non_Intersecting_Point	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.cpp	/^template<class T> bool Closest_Non_Intersecting_Point(RAY<VECTOR<T,3> >& ray,const TRIANGLE_3D<T>& triangle, const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Closest_Point	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Closest_Point(const VECTOR<T,3>& location,VECTOR<T,3>& weights) const$/;"	f	class:TRIANGLE_3D
Closest_Point_On_Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Closest_Point_On_Boundary(const TV& location,const T tolerance,const int max_iterations,T* distance) const$/;"	f	class:IMPLICIT_OBJECT
Closest_Point_On_Line	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Closest_Point_On_Line(const VECTOR<T,2>& point) const$/;"	f	class:SEGMENT_2D
Closest_Point_On_Line	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Closest_Point_On_Line(const VECTOR<T,3>& point) const$/;"	f	class:SEGMENT_3D
Closest_Point_On_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Closest_Point_On_Segment(const VECTOR<T,2>& point) const$/;"	f	class:SEGMENT_2D
Closest_Point_On_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Closest_Point_On_Segment(const VECTOR<T,3>& point) const$/;"	f	class:SEGMENT_3D
ClusterFilesSeparately	IoData.h	/^  enum ClusterFilesSeparately {CLUSTER_FILES_SEPARATELY_FALSE = 0, CLUSTER_FILES_SEPARATELY_TRUE = 1} clusterFilesSeparately;$/;"	g	struct:ClusteringData
ClusteringAlgorithm	IoData.h	/^  enum ClusteringAlgorithm {K_MEANS_WITHOUT_BOUNDS = 0, K_MEANS_WITH_BOUNDS = 1} clusteringAlgorithm;$/;"	g	struct:ClusteringData
ClusteringData	IoData.h	/^struct ClusteringData {$/;"	s
ClusteringData	IoDataCore.C	/^ClusteringData::ClusteringData()$/;"	f	class:ClusteringData
Coalesce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Coalesce()$/;"	f	class:PhysBAM::ARRAY_BASE
CoarseningRatio	IoData.h	/^  enum CoarseningRatio { TWOTOONE = 0, FOURTOONE = 1} coarseningRatio;$/;"	g	struct:MultiGridData
Cofactor_Differential	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Cofactor_Differential(const MATRIX& dA)$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Cofactor_Matrix() const \/\/ cheap$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Cofactor_Matrix() const \/\/ 18 mults, 9 adds$/;"	f	class:PhysBAM::MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.cpp	/^Cofactor_Matrix() const$/;"	f	class:MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX Cofactor_Matrix()$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Cofactor_Matrix() \/\/ 12 mults, 6 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED Cofactor_Matrix() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Cofactor_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX Cofactor_Matrix() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
ColPtr	arpack++/include/arhbmat.h	/^  ARINT* ColPtr() { return pcol; }$/;"	f	class:ARhbMatrix
ColsInMemory	arpack++/include/ardfmat.h	/^  int ColsInMemory() const { return stcols; }$/;"	f	class:ARdfMatrix
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    VECTOR<T,m>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    const VECTOR<T,m>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    VECTOR<T,0>& Column(const int i)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    const VECTOR<T,0>& Column(const int i) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    VECTOR<T,0>& Column(const int i)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    const VECTOR<T,0>& Column(const int i) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    const VECTOR<T,1>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    VECTOR<T,1>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    const VECTOR<T,1>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    const VECTOR<T,2>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    VECTOR<T,3>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    const VECTOR<T,3>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    const VECTOR<T,3>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    VECTOR<T,4>& Column(const int j)$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    const VECTOR<T,4>& Column(const int j) const$/;"	f	class:PhysBAM::MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Column(const int axis) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Column(const int axis) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Column_Magnitudes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> Column_Magnitudes() const$/;"	f	class:PhysBAM::MATRIX
Column_Magnitudes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    VECTOR<T,2> Column_Magnitudes() const$/;"	f	class:PhysBAM::MATRIX
Column_Magnitudes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> Column_Magnitudes() const$/;"	f	class:PhysBAM::MATRIX
Column_Magnitudes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> Column_Magnitudes() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> Column_Sum() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    VECTOR<T,2> Column_Sum() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> Column_Sum() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    VECTOR<T,3> Column_Sum() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> Column_Sum() const$/;"	f	class:PhysBAM::MATRIX
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    const VECTOR& Column_Sum() const$/;"	f	class:PhysBAM::VECTOR
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    const VECTOR& Column_Sum() const$/;"	f	class:PhysBAM::VECTOR
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    const VECTOR& Column_Sum() const$/;"	f	class:PhysBAM::VECTOR
Column_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    const VECTOR& Column_Sum() const$/;"	f	class:PhysBAM::VECTOR
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    int Columns() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX_BASE
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    int Columns() const$/;"	f	class:PhysBAM::MATRIX_MXN
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    int Columns() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    int Columns() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    int Columns() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    int Columns() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Combine	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Combine(const INTERVAL& box1,const INTERVAL& box2)$/;"	f	class:PhysBAM::INTERVAL
Combine	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Combine(const RANGE<TV>& box1,const RANGE<TV>& box2)$/;"	f	class:PhysBAM::RANGE
CommPattern	Communicator.C	/^CommPattern<T>::CommPattern(CommPattern<TB> &pb, Communicator *_com,$/;"	f	class:CommPattern
CommPattern	Communicator.C	/^CommPattern<T>::CommPattern(SubDTopo *topo, Communicator *_com,$/;"	f	class:CommPattern
CommPattern	Communicator.h	/^class CommPattern {$/;"	c
CommTrace	Communicator.h	/^class CommTrace {$/;"	c
Comments	Manual/Aerof3d.html	/^<a name="Comments"><\/a>$/;"	a
Communication	Communicator.C	/^namespace Communication {$/;"	n	file:
Communication	Communicator.h	/^namespace Communication {$/;"	n
Communicator	Communicator.h	/^class Communicator {$/;"	c
Communicator	CommunicatorMPI.C	/^Communicator::Communicator()$/;"	f	class:Communicator
Communicator	CommunicatorMPI.C	/^Communicator::Communicator(MPI_Comm c1)$/;"	f	class:Communicator
Compact	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Compact()$/;"	f	class:PhysBAM::ARRAY
Compact	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Compact()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Compact	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Compact()$/;"	f	class:PhysBAM::STACK
Compact_Array_Using_Compaction_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Compact_Array_Using_Compaction_Array(ARRAY<T2,ID>& array,const ARRAY<ID,ID>& compaction_array,ARRAY<T2,ID>* temporary_array=0)$/;"	f	class:PhysBAM::ARRAY
CompareSVDMethods	IoData.h	/^  enum CompareSVDMethods {COMPARE_SVD_FALSE = 0, COMPARE_SVD_TRUE = 1} compareSVDMethods;$/;"	g	struct:DataCompressionData
Compare_File_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^int Compare_File_Times(const std::string& filename1,const std::string& filename2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Compare_File_Times_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^int Compare_File_Times_Ignoring_Compression_Suffix(const std::string& filename1,const std::string& filename2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Compare_Strings	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^int Compare_Strings(const std::string &str1,const std::string &str2,bool case_sensitive)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Compatible3D	IoData.h	/^  enum Compatible3D {OFF_COMPATIBLE3D = 0, ON_COMPATIBLE3D = 1} comp3d;$/;"	g	struct:SensitivityAnalysis
Complex	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const COMPLEX<T>& Complex() const$/;"	f	class:PhysBAM::ROTATION
ComplexAxpy	arpack++/include/arbnspen.h	/^ComplexAxpy(int n, arcomplex<ARFLOAT> da, ARTYPE dx[], int incx,$/;"	f	class:ARbdNonSymPencil
ComplexCopy	arpack++/include/arbnspen.h	/^ComplexCopy(int n, ARFLOAT dx[], int incx, arcomplex<ARFLOAT> dy[], int incy)$/;"	f	class:ARbdNonSymPencil
Componentwise_And	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static T_VECTOR1 Componentwise_And(const VECTOR_BASE<bool,T_VECTOR1>& u,const VECTOR_BASE<bool,T_VECTOR2>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Componentwise_Greater_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static typename T_VECTOR1::template REBIND<bool>::TYPE Componentwise_Greater_Equal(const VECTOR_BASE<T,T_VECTOR1>& u,const VECTOR_BASE<T,T_VECTOR2>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Componentwise_Max(const MATRIX& v1,const MATRIX& v2)$/;"	f	class:MATRIX
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Componentwise_Max(const SYMMETRIC_MATRIX& v1,const SYMMETRIC_MATRIX& v2)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Componentwise_Max(const SYMMETRIC_MATRIX& v1,const SYMMETRIC_MATRIX& v2)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR Componentwise_Max(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    static VECTOR Componentwise_Max(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR Componentwise_Max(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Componentwise_Max(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Componentwise_Max(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Componentwise_Maxabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Componentwise_Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Componentwise_Maxabs(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Componentwise_Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Componentwise_Maxabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Componentwise_Min(const MATRIX& v1,const MATRIX& v2)$/;"	f	class:MATRIX
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Componentwise_Min(const SYMMETRIC_MATRIX& v1,const SYMMETRIC_MATRIX& v2)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Componentwise_Min(const SYMMETRIC_MATRIX& v1,const SYMMETRIC_MATRIX& v2)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR Componentwise_Min(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    static VECTOR Componentwise_Min(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR Componentwise_Min(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Componentwise_Min(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Componentwise_Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Componentwise_Min(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Compute	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::Compute$/;"	f	class:KirchhoffIntegrator
ComputeForces	IoData.h	/^  enum ComputeForces {FALSE = 0, TRUE = 1 } computeForces;$/;"	g	struct:SurfaceData
ComputeGappyRes	IoData.h	/^  enum ComputeGappyRes {NO_GAPPYRES = 0, YES_GAPPYRES  = 1} computeGappyRes;$/;"	g	struct:GappyConstructionData
ComputeHeatPower	IoData.h	/^  enum ComputeHeatPower {FALSE_HF = 0, TRUE_HF = 1 } computeHeatFluxes;$/;"	g	struct:SurfaceData
ComputeMDS	IoData.h	/^  enum ComputeMDS {COMPUTE_MDS_FALSE = 0, COMPUTE_MDS_TRUE = 1} computeMDS;$/;"	g	struct:ClusteringData
ComputePOD	IoData.h	/^  enum ComputePOD {COMPUTE_POD_FALSE = 0, COMPUTE_POD_TRUE = 1} computePOD;$/;"	g	struct:DataCompressionData
ComputeSIbasedIntersections	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::ComputeSIbasedIntersections(int iSub, SVec<double,3>& X,  $/;"	f	class:IntersectorFRG
ComputeSIbasedIntersections	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::ComputeSIbasedIntersections(int iSub, SVec<double,3>& X,  $/;"	f	class:IntersectorPhysBAM
ComputeStrainAndStressTensor	ElemTetCore.C	/^void ElemTet::ComputeStrainAndStressTensor(double dudxj[3][3], $/;"	f	class:ElemTet
ComputeTetVolume	BasicGeometry.C	/^double BasicGeometry::ComputeTetVolume(const Vec3D x[4]) {$/;"	f	class:BasicGeometry
ComputeWallFunction	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::ComputeWallFunction(DistLevelSetStructure& LSS, $/;"	f	class:ReinitializeDistanceToWall
ComputeWedgeVolume	BasicGeometry.C	/^double BasicGeometry::ComputeWedgeVolume(const Vec3D x[6]) {$/;"	f	class:BasicGeometry
Compute_Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    void Compute_Bounding_Box()$/;"	f	class:PhysBAM::RAY
Compute_Bounding_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    RANGE<TV> Compute_Bounding_Box()$/;"	f	class:PhysBAM::POINT_CLOUD
Compute_Cell_Minimum_And_Maximum	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Compute_Cell_Minimum_And_Maximum(const bool recompute_if_exists){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Compute_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    int Compute_Index(const VECTOR<int,1>& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Compute_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    int Compute_Index(const VECTOR<int,2>& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Compute_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    int Compute_Index(const VECTOR<int,3>& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Compute_Intervals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Intervals(const T& a,const T& b,int& intervals,INTERVAL<T>& interval1,INTERVAL<T>& interval2,INTERVAL<T>& interval3)$/;"	f	class:CUBIC
Compute_Intervals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Intervals(int& intervals,INTERVAL<T>& interval1,INTERVAL<T>& interval2,INTERVAL<T>& interval3)$/;"	f	class:CUBIC
Compute_Lazy_Box_Intersection_Acceleration_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.cpp	/^Compute_Lazy_Box_Intersection_Acceleration_Data()$/;"	f	class:PhysBAM::RAY
Compute_Normals	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Compute_Normals(){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Compute_Range	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	/^    template<class T_ARRAY> static RANGE<typename T_ARRAY::ELEMENT> Compute_Range(const T_ARRAY& array)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Compute_Relative_Extrema	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Relative_Extrema()$/;"	f	class:CUBIC
Compute_Relative_Extrema_Bounding_Sign_Changes_In_Interval	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Relative_Extrema_Bounding_Sign_Changes_In_Interval(const T& xmin,const T& xmax)$/;"	f	class:CUBIC
Compute_Relative_Extrema_In_Interval	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Relative_Extrema_In_Interval(const T& xmin,const T& xmax)$/;"	f	class:CUBIC
Compute_Roots	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Roots()$/;"	f	class:CUBIC
Compute_Roots	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    void Compute_Roots()$/;"	f	class:PhysBAM::QUADRATIC
Compute_Roots_In_Interval	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Roots_In_Interval(const T xmin,const T xmax)$/;"	f	class:CUBIC
Compute_Roots_In_Interval	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    void Compute_Roots_In_Interval(const T xmin,const T xmax)$/;"	f	class:PhysBAM::QUADRATIC
Compute_Roots_Noniterative	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Roots_Noniterative()$/;"	f	class:CUBIC
Compute_Roots_Noniterative_In_Interval	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.cpp	/^Compute_Roots_Noniterative_In_Interval(const T xmin,const T xmax)$/;"	f	class:CUBIC
Condition_Number	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Condition_Number() const$/;"	f	class:PhysBAM::MATRIX_BASE
ConeFix	Manual/Aerof3d.html	/^<a name="ConeFix"><\/a>$/;"	a
ConjEigVec	arpack++/include/arrsnsym.h	/^bool ARrcNonSymStdEig<ARFLOAT>::ConjEigVec(int i)$/;"	f	class:ARrcNonSymStdEig
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    static MATRIX Conjugate(const MATRIX& A,const MATRIX& B)$/;"	f	class:PhysBAM::MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION Conjugate() const$/;"	f	class:PhysBAM::QUATERNION
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate(const MATRIX<T,2,3>& A,const DIAGONAL_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate(const MATRIX<T,2,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate(const MATRIX<T,2>& A,const DIAGONAL_MATRIX<T,2>& B) \/\/ 10 mults, 3 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate(const MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 12 mults, 7 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ $/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate(const MATRIX<T,3,2>& A,const DIAGONAL_MATRIX<T,2>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate(const MATRIX<T,3,2>& A,const SYMMETRIC_MATRIX<T,2>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate(const MATRIX<T,3>& A,const DIAGONAL_MATRIX<T,3>& B) \/\/ 27 mults, 12 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate(const MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate(const SYMMETRIC_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    void Conjugate()$/;"	f	class:PhysBAM::COMPLEX
Conjugate_Gradient	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Conjugate_Gradient(NONLINEAR_FUNCTION<T(T,T)>& F,T& x,T& y,const T alpha_max)$/;"	f	class:ITERATIVE_SOLVER
Conjugate_With_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Conjugate_With_Cross_Product_Matrix(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Conjugate_With_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    SYMMETRIC_MATRIX<T,2> Conjugate_With_Cross_Product_Matrix(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Conjugate_With_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Conjugate_With_Cross_Product_Matrix(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate_With_Transpose(const MATRIX<T,2>& A,const DIAGONAL_MATRIX<T,2>& B) \/\/ 10 mults, 3 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate_With_Transpose(const MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 12 mults, 7 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate_With_Transpose(const MATRIX<T,3,2>& A,const SYMMETRIC_MATRIX<T,3>& B) \/\/ 21 mults, 12 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Conjugate_With_Transpose(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 10 mults, 3 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate_With_Transpose(const MATRIX<T,3>& A,const DIAGONAL_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate_With_Transpose(const MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugate_With_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^Conjugate_With_Transpose(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Conjugated	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Conjugated() const$/;"	f	class:PhysBAM::COMPLEX
Connectivity	Connectivity.h	/^  Connectivity() { pointer = 0; target = 0; weight = 0; }$/;"	f	class:Connectivity
Connectivity	Connectivity.h	/^class Connectivity {$/;"	c
Connectivity	ConnectivityCore.C	/^Connectivity::Connectivity(BinFileHandler &file)$/;"	f	class:Connectivity
Connectivity	ConnectivityCore.C	/^Connectivity::Connectivity(ElemSet *els)$/;"	f	class:Connectivity
Connectivity	ConnectivityCore.C	/^Connectivity::Connectivity(FaceSet* fels)$/;"	f	class:Connectivity
Connectivity	ConnectivityCore.C	/^Connectivity::Connectivity(int _size, int *_count)$/;"	f	class:Connectivity
Connectivity	ConnectivityCore.C	/^Connectivity::Connectivity(int _size, int *_pointer, int *_target) $/;"	f	class:Connectivity
Const_Cast	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW<typename REMOVE_CONST<T>::TYPE>& Const_Cast() const \/\/ return reference to allow Exchange$/;"	f	class:PhysBAM::ARRAY_VIEW
ConstantPrandtlThermalCondFcn	ThermalCondFcn.h	/^  ConstantPrandtlThermalCondFcn(IoData &iod, ViscoFcn *visf, VarFcn *vfn) :$/;"	f	class:ConstantPrandtlThermalCondFcn
ConstantPrandtlThermalCondFcn	ThermalCondFcn.h	/^class ConstantPrandtlThermalCondFcn : public ThermalCondFcn {$/;"	c
ConstantThermalCondFcn	ThermalCondFcn.h	/^  ConstantThermalCondFcn(IoData &iod){$/;"	f	class:ConstantThermalCondFcn
ConstantThermalCondFcn	ThermalCondFcn.h	/^class ConstantThermalCondFcn : public ThermalCondFcn {$/;"	c
ConstantViscoFcn	ViscoFcn.h	/^  ConstantViscoFcn(IoData &iod):ViscoFcn(iod) { bulkViscosity = iod.eqs.viscosityModel.bulkViscosity;}$/;"	f	class:ConstantViscoFcn
ConstantViscoFcn	ViscoFcn.h	/^class ConstantViscoFcn : public ViscoFcn {$/;"	c
Constant_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR Constant_Vector(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Constant_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR Constant_Vector(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Constant_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Constant_Vector(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Constant_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Constant_Vector(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool Contains(const T& element) const$/;"	f	class:PhysBAM::ARRAY_BASE
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Contains(const TK& v) const$/;"	f	class:PhysBAM::HASHTABLE
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Contains(const TK& v,const int h) const$/;"	f	class:PhysBAM::HASHTABLE
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Contains(const INTERVAL& interval) const$/;"	f	class:PhysBAM::INTERVAL
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Contains(const RANGE<TV>& box) const$/;"	f	class:PhysBAM::RANGE
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool Contains(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    bool Contains(const T&) const$/;"	f	class:PhysBAM::VECTOR
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool Contains(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool Contains(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Contains	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool Contains(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Contains_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool Contains_All(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool Contains_All(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool Contains_All(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool Contains_All(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_Any	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool Contains_Any(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_Any	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool Contains_Any(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_Any	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool Contains_Any(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_Any	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool Contains_Any(const T_ARRAY& elements) const$/;"	f	class:PhysBAM::VECTOR
Contains_Only	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool Contains_Only(const T& element) const$/;"	f	class:PhysBAM::ARRAY_BASE
Context	DistLeastSquareSolver.h	/^  typedef int Context;$/;"	t	class:DistLeastSquareSolver
ConvergedEigenvalues	arpack++/include/arrseig.h	/^  int ConvergedEigenvalues() { return nconv; }$/;"	f	class:ARrcStdEig
ConvertDouble	arpack++/include/ardfmat.h	/^inline void ARdfMatrix<ARTYPE>::ConvertDouble(char* num) $/;"	f	class:ARdfMatrix
ConvertDouble	arpack++/include/arhbmat.h	/^inline void ARhbMatrix<ARINT, ARTYPE>::ConvertDouble(char* num) $/;"	f	class:ARhbMatrix
Convex_Average	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Convex_Average(const T phi_1,const T phi_2,const T value_minus,const T value_plus)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
CoordinateType	IoData.h	/^  enum CoordinateType {CARTESIAN = 0, CYLINDRICAL = 1, SPHERICAL = 2} coordType;$/;"	g	struct:OneDimensionalInfo
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy(const T2 c1,const T_ARRAY1& v1,const T2 c2,const T_ARRAY2& v2,T_ARRAY3& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy(const T2 c1,const T_ARRAY1& v1,const T2 c2,const T_ARRAY2& v2,const T2 c3,const T_ARRAY3& v3,T_ARRAY4& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy(const T2 c1,const T_ARRAY1& v1,const T_ARRAY2& v2,T_ARRAY3& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy(const T2 constant,const T_ARRAY1& array,T_ARRAY2& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy(const T_ARRAY1& old_copy,T_ARRAY2& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Copy(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Copy(const T2 c1,const ARRAY_BASE& v1,const ARRAY_BASE& v2,ARRAY_BASE& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Copy(const T2 c1,const ARRAY_BASE& v1,const T2 c2,const ARRAY_BASE& v2,ARRAY_BASE& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Copy(const T2 c1,const ARRAY_BASE& v1,const T2 c2,const ARRAY_BASE& v2,const T2 c3,const ARRAY_BASE& v3,ARRAY_BASE& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Copy(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Copy(const T2 c,const T_VECTOR1& v,T_VECTOR2& result)$/;"	f	class:PhysBAM::VECTOR_BASE
Copy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Copy(const T2 c1,const T_VECTOR1& v1,const T_VECTOR2& v2,T_VECTOR3& result)$/;"	f	class:PhysBAM::VECTOR_BASE
Copy	arpack++/include/arbgcomp.h	/^Copy(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
Copy	arpack++/include/arbgnsym.h	/^Copy(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
Copy	arpack++/include/arbgsym.h	/^Copy(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
Copy	arpack++/include/arbnsmat.h	/^Copy(const ARbdNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARbdNonSymMatrix
Copy	arpack++/include/arbnspen.h	/^Copy(const ARbdNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARbdNonSymPencil
Copy	arpack++/include/arbsmat.h	/^Copy(const ARbdSymMatrix<ARTYPE>& other)$/;"	f	class:ARbdSymMatrix
Copy	arpack++/include/arbspen.h	/^inline void ARbdSymPencil<ARTYPE>::Copy(const ARbdSymPencil<ARTYPE>& other)$/;"	f	class:ARbdSymPencil
Copy	arpack++/include/ardgcomp.h	/^Copy(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
Copy	arpack++/include/ardgnsym.h	/^Copy(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
Copy	arpack++/include/ardgsym.h	/^Copy(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
Copy	arpack++/include/ardnsmat.h	/^Copy(const ARdsNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARdsNonSymMatrix
Copy	arpack++/include/ardnspen.h	/^Copy(const ARdsNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARdsNonSymPencil
Copy	arpack++/include/ardsmat.h	/^Copy(const ARdsSymMatrix<ARTYPE>& other)$/;"	f	class:ARdsSymMatrix
Copy	arpack++/include/ardspen.h	/^inline void ARdsSymPencil<ARTYPE>::Copy(const ARdsSymPencil<ARTYPE>& other)$/;"	f	class:ARdsSymPencil
Copy	arpack++/include/argeig.h	/^Copy(const ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>& other)$/;"	f	class:ARGenEig
Copy	arpack++/include/argnsym.h	/^Copy(const ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>& other)$/;"	f	class:ARNonSymGenEig
Copy	arpack++/include/argsym.h	/^Copy(const ARSymGenEig<ARFLOAT, ARFOP, ARFB>& other)$/;"	f	class:ARSymGenEig
Copy	arpack++/include/arlgcomp.h	/^Copy(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
Copy	arpack++/include/arlgnsym.h	/^Copy(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
Copy	arpack++/include/arlgsym.h	/^Copy(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
Copy	arpack++/include/arlnsmat.h	/^Copy(const ARluNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARluNonSymMatrix
Copy	arpack++/include/arlnspen.h	/^Copy(const ARluNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARluNonSymPencil
Copy	arpack++/include/arlscomp.h	/^Copy(const ARluCompStdEig<ARFLOAT>& other)$/;"	f	class:ARluCompStdEig
Copy	arpack++/include/arlsmat.h	/^inline void ARluSymMatrix<ARTYPE>::Copy(const ARluSymMatrix<ARTYPE>& other)$/;"	f	class:ARluSymMatrix
Copy	arpack++/include/arlsnsym.h	/^Copy(const ARluNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymStdEig
Copy	arpack++/include/arlspen.h	/^Copy(const ARluSymPencil<ARTYPE>& other)$/;"	f	class:ARluSymPencil
Copy	arpack++/include/arlssym.h	/^inline void ARluSymStdEig<ARFLOAT>::Copy(const ARluSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluSymStdEig
Copy	arpack++/include/arrgnsym.h	/^Copy(const ARrcNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARrcNonSymGenEig
Copy	arpack++/include/arrgsym.h	/^inline void ARrcSymGenEig<ARFLOAT>::Copy(const ARrcSymGenEig<ARFLOAT>& other)$/;"	f	class:ARrcSymGenEig
Copy	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT,ARTYPE>::Copy(const ARrcStdEig<ARFLOAT,ARTYPE>& other)$/;"	f	class:ARrcStdEig
Copy	arpack++/include/arseig.h	/^Copy(const ARStdEig<ARFLOAT, ARTYPE, ARFOP>& other)$/;"	f	class:ARStdEig
Copy	arpack++/include/arugcomp.h	/^Copy(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
Copy	arpack++/include/arugnsym.h	/^Copy(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
Copy	arpack++/include/arugsym.h	/^Copy(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
Copy	arpack++/include/arunsmat.h	/^Copy(const ARumNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARumNonSymMatrix
Copy	arpack++/include/arunspen.h	/^Copy(const ARumNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARumNonSymPencil
Copy	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::Copy(const ARumSymMatrix<ARTYPE>& other)$/;"	f	class:ARumSymMatrix
Copy	arpack++/include/aruspen.h	/^inline void ARumSymPencil<ARTYPE>::Copy(const ARumSymPencil<ARTYPE>& other)$/;"	f	class:ARumSymPencil
CopyCloseNodes	IoData.h	/^  enum CopyCloseNodes {FALSE = 0, TRUE = 1} copyCloseNodes;$/;"	g	struct:MultiFluidData
CopyOnSend	Communicator.h	/^  enum Mode { Share, CopyOnSend };$/;"	e	enum:CommPattern::Mode
Copy_All_Elements_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Copy_All_Elements_Helper(const ARRAY_COLLECTION& from_elements,const int offset)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Copy_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Copy_Element(const ID from,const ID to)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Copy_Element(const T_ARRAY1& from_array,const ID from,const ID to)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Copy_Element(const ARRAY_COLLECTION& from_elements,const int from,const int to)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Copy_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Copy_Element(const ARRAY_COLLECTION_ELEMENT_BASE& from_attribute,const int from,const int to)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Copy_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Copy_Element(const int from,const int to)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Copy_Element_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Copy_Element_Helper(const ARRAY_COLLECTION& from_elements,const int from,const int to)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Copy_Element_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Copy_Element_Helper(const int from,const int to)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Copy_Log_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Copy_Log_To_File(const std::string& filename,const bool append)$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
Copy_Log_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A,class B> void Copy_Log_To_File(const A&,const B&){}$/;"	f	struct:PhysBAM::LOG_NULL::log_null_class
Copy_Or_Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Copy_Or_Fill(const T& constant) \/\/ for occasional templatization purposes$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_Or_Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Copy_Or_Fill(const T_ARRAY1& old_copy) \/\/ for occasional templatization purposes$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_With_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Copy_With_Offset(const T_ARRAY1& old_copy,T_ARRAY2& new_copy,const ID offset)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_With_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Copy_With_Offset(const T_ARRAY1& old_copy,const ID offset)$/;"	f	class:PhysBAM::ARRAY_BASE
Copy_With_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Copy_With_Offset(const ARRAY_COLLECTION_ELEMENT_BASE& from_attribute,const int offset)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Copy_With_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_COPY.h	/^    void Copy_With_Offset(const ARRAY_BASE<T,T_ARRAY1,ID>& old_copy,ARRAY_BASE<T2,T_ARRAY2,ID>& new_copy,const ID offset)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Corners	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Corners(ARRAY<TV,VECTOR<int,1> >& corners) const$/;"	f	class:PhysBAM::RANGE
Corners	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Corners(ARRAY<TV,VECTOR<int,2> >& corners) const$/;"	f	class:PhysBAM::RANGE
Corners	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Corners(ARRAY<TV,VECTOR<int,3> >& corners) const$/;"	f	class:PhysBAM::RANGE
CorotSolver	CorotSolver.C	/^CorotSolver::CorotSolver(DefoMeshMotionData &data, MatchNodeSet **matchNodes, Domain *dom)$/;"	f	class:CorotSolver
CorotSolver	CorotSolver.h	/^class CorotSolver {$/;"	c
Count_Matches	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    int Count_Matches(const T& value) const$/;"	f	class:PhysBAM::ARRAY_BASE
CrackingSurface	FSI/CrackingSurface.cpp	/^CrackingSurface::CrackingSurface(int eType, int nUsed, int nTotal, int nUsedNd, int nTotNodes): elemType(eType)$/;"	f	class:CrackingSurface
CrackingSurface	FSI/CrackingSurface.h	/^class CrackingSurface : public LocalLevelSet {$/;"	c
CrackingWithLevelSet	IoData.h	/^  enum CrackingWithLevelSet {OFF = 0, ON = 1} crackingWithLevelset;$/;"	g	struct:EmbeddedFramework
CreateStructure	arpack++/include/arbnsmat.h	/^inline void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()$/;"	f	class:ARbdNonSymMatrix
CreateStructure	arpack++/include/arbsmat.h	/^inline void ARbdSymMatrix<ARTYPE>::CreateStructure()$/;"	f	class:ARbdSymMatrix
CreateStructure	arpack++/include/ardnsmat.h	/^inline void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()$/;"	f	class:ARdsNonSymMatrix
CreateStructure	arpack++/include/ardsmat.h	/^inline void ARdsSymMatrix<ARTYPE>::CreateStructure()$/;"	f	class:ARdsSymMatrix
CreateStructure	arpack++/include/arunsmat.h	/^inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()$/;"	f	class:ARumNonSymMatrix
CreateStructure	arpack++/include/arusmat.h	/^inline void ARumSymMatrix<ARTYPE>::CreateStructure()$/;"	f	class:ARumSymMatrix
Create_CompCol_Matrix	arpack++/include/superluc.h	/^inline void Create_CompCol_Matrix(SuperMatrix* A, int m, int n, int nnz,$/;"	f
Create_Dense_Matrix	arpack++/include/superluc.h	/^inline void Create_Dense_Matrix(SuperMatrix* A, int m, int n, arcomplex<double>* x,$/;"	f
Create_Dense_Matrix	arpack++/include/superluc.h	/^inline void Create_Dense_Matrix(SuperMatrix* A, int m, int n, arcomplex<float>* x,$/;"	f
Create_Dense_Matrix	arpack++/include/superluc.h	/^inline void Create_Dense_Matrix(SuperMatrix* A, int m, int n, double* x,$/;"	f
Create_Dense_Matrix	arpack++/include/superluc.h	/^inline void Create_Dense_Matrix(SuperMatrix* A, int m, int n, float* x,$/;"	f
Create_Directory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^bool Create_Directory(const std::string& dirname)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Create_From_Extension	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^Create_From_Extension(const std::string& extension)$/;"	f	class:STRUCTURE
Create_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline T* Create_From_File(const STREAM_TYPE stream_type,const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Create_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Create_From_File(const STREAM_TYPE stream_type,const std::string& filename,T*& d)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Create_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Create_From_File(const std::string& filename,T*& d)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Create_From_Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^Create_From_Name(const std::string& name)$/;"	f	class:STRUCTURE
Create_From_Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^Create_From_Name(const std::string& name,GEOMETRY_PARTICLES<TV>& particles)$/;"	f	class:STRUCTURE
Create_KD_Tree	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Create_KD_Tree(ARRAY_VIEW<const TV> points)$/;"	f	class:KD_TREE
Create_Left_Balanced_KD_Tree	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Create_Left_Balanced_KD_Tree(ARRAY_VIEW<const TV> points_to_balance)$/;"	f	class:KD_TREE
Create_Left_Balanced_KD_Tree_With_Grouping	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Create_Left_Balanced_KD_Tree_With_Grouping(ARRAY_VIEW<const TV> points_to_balance,ARRAY<ARRAY<int> >& points_in_group,const int max_points_in_group)$/;"	f	class:KD_TREE
Create_Non_Degenerate_Ray	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    static bool Create_Non_Degenerate_Ray(const TV& endpoint,const TV& length_and_direction,RAY<TV>& ray)$/;"	f	class:PhysBAM::RAY
Create_Representative	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    template<class T_OBJECT> static T_OBJECT* Create_Representative()$/;"	f	class:PhysBAM::REGISTRY
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR<T,0> Cross_Product(const VECTOR&,const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR<T,1> Cross_Product(const VECTOR&,const VECTOR<T,0>)$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR<T,1> Cross_Product(const VECTOR<T,0>,const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Cross_Product(const VECTOR& v1,const VECTOR<T,1>& v2) \/\/ v2 is out of plane$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Cross_Product(const VECTOR<T,1>& v1,const VECTOR& v2) \/\/ v1 is out of plane$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR<T,1> Cross_Product(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Cross_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Cross_Product(const VECTOR& v1,const VECTOR& v2) \/\/ 6 mults, 3 adds$/;"	f	class:PhysBAM::VECTOR
Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    static MATRIX<T,0,1> Cross_Product_Matrix(const VECTOR<T,1>& vector)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    static MATRIX<T,1,2> Cross_Product_Matrix(const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX<T,3> Cross_Product_Matrix(const VECTOR<T,3>& v)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Cross_Product_Matrix_Times(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,1,n> Cross_Product_Matrix_Times(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Cross_Product_Matrix_Times(const VECTOR<T,3>& v) const \/\/ (v*) * (*this)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Cross_Product_Matrix_Times(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX_MXN
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Cross_Product_Matrix_Times(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX_MXN
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    MATRIX<T,1,2> Cross_Product_Matrix_Times(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Cross_Product_Matrix_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX<T,3> Cross_Product_Matrix_Times(const VECTOR<T,3>& v) const \/\/ (v*) * (*this)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Cross_Product_Matrix_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Cross_Product_Matrix_Times_With_Symmetric_Result(const VECTOR<T,3>& v) const \/\/ (v*) * (*this)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Cross_Product_Matrix_Transpose_Times(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,2,n> Cross_Product_Matrix_Transpose_Times(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Cross_Product_Matrix_Transpose_Times(const VECTOR<T,3>& v) const \/\/ (v*)^T * (*this)$/;"	f	class:PhysBAM::MATRIX
Cross_Product_Matrix_Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX<T,3> Cross_Product_Matrix_Transpose_Times(const VECTOR<T,3>& v) const \/\/ (v*)^T * (*this)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
CrossingEdgeRes	IntersectorFRG/IntersectorFRG.h	/^    map<int,IntersectionResult<double> > CrossingEdgeRes;$/;"	m	class:IntersectorFRG
CrossingEdgeRes	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    std::map<int,IntersectionResult<double> > CrossingEdgeRes;$/;"	m	class:IntersectorPhysBAM
Cs	DistDynamicLESTerm.h	/^  DistSVec<double,2> *Cs;$/;"	m	class:DistDynamicLESTerm
Cs	PostOperator.h	/^  DistVec<double> *Cs;$/;"	m	class:PostOperator
Cs	SmagorinskyLESTerm.h	/^  double Cs;$/;"	m	class:SmagorinskyLESTerm
CsDelSq	Domain.h	/^  DistVec<double> *CsDelSq;$/;"	m	class:Domain
CsDles	PostOperator.h	/^  DistVec<double> *CsDles;$/;"	m	class:PostOperator
CsDvms	PostOperator.h	/^  DistVec<double> *CsDvms;$/;"	m	class:PostOperator
Cull	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    bool Cull(const int box1,const int box2) const$/;"	f	struct:PhysBAM::BOX_VISITOR_MPI
Cull	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    bool Cull(const int self_box_index,const int other_box_index) const$/;"	f	struct:PhysBAM::BOX_VISITOR_TRIVIAL
Cull_Self	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    bool Cull_Self(const int box) const$/;"	f	struct:PhysBAM::BOX_VISITOR_MPI
Cull_Self	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    bool Cull_Self(const int self_box_index) const$/;"	f	struct:PhysBAM::BOX_VISITOR_TRIVIAL
CurvatureDetection	CurvatureDetection.C	/^CurvatureDetection::CurvatureDetection(Domain* domain)$/;"	f	class:CurvatureDetection
CurvatureDetection	CurvatureDetection.h	/^class CurvatureDetection {$/;"	c
Cut_With_Hyperplane_And_Discard_Outside_Simplices	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Cut_With_Hyperplane_And_Discard_Outside_Simplices(const SEGMENT_2D<T>& segment,const LINE_2D<T>& cutting_plane,ARRAY<SEGMENT_2D<T> >& negative_segments)$/;"	f	class:SEGMENT_2D
Cut_With_Hyperplane_And_Discard_Outside_Simplices	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Cut_With_Hyperplane_And_Discard_Outside_Simplices(const TRIANGLE_3D<T>& triangle,const PLANE<T>& cutting_plane,ARRAY<TRIANGLE_3D<T> >& negative_triangles)$/;"	f	class:TRIANGLE_3D
Cw	WaleLESTerm.h	/^  double Cw;$/;"	m	class:WaleLESTerm
CycleScheme	IoData.h	/^  enum CycleScheme { VCYCLE = 0, WCYCLE = 1} cycle_scheme;$/;"	g	struct:MultiGridData
CylinderData	IoData.h	/^struct CylinderData {$/;"	s
CylinderData	IoDataCore.C	/^CylinderData::CylinderData() {$/;"	f	class:CylinderData
CylinderGrid	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::CylinderGrid$/;"	f	class:KirchhoffIntegrator
Cylinder_TensorGrid	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::Cylinder_TensorGrid$/;"	f	class:KirchhoffIntegrator
CylindricalBubble	ExactSolution.C	/^CylindricalBubble(IoData& iod,double x, double y, double z,$/;"	f	class:ExactSolution
D1VMSLES	IoData.h	/^  enum Type {D1VMSLES = 0, D2VMSLES = 1, D3VMSLES = 2} type;$/;"	e	enum:DynamicVMSData::Type
D2VMSLES	IoData.h	/^  enum Type {D1VMSLES = 0, D2VMSLES = 1, D3VMSLES = 2} type;$/;"	e	enum:DynamicVMSData::Type
D2WALL	PostFcn.h	/^                   D2WALL = 30, SPATIAL_RES = 31, SSIZE = 32};$/;"	e	enum:PostFcn::ScalarType
D3VMSLES	IoData.h	/^  enum Type {D1VMSLES = 0, D2VMSLES = 1, D3VMSLES = 2} type;$/;"	e	enum:DynamicVMSData::Type
DATA	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    struct DATA$/;"	s	class:PhysBAM::TIMER
DATA_UNDEFINED	arpack++/include/arerror.h	/^    DATA_UNDEFINED      = -502,$/;"	e	enum:ArpackError::ErrorCode
DCOMPLEX_INCLUDE	arpack++/include/arlcomp.h	25;"	d
DE	Modal.h	/^    VecSet< DistSVec<double,dim> > DE;$/;"	m	class:ModalSolver
DEBUG	ImplicitEmbeddedCoupledTsDesc.C	20;"	d	file:
DEBUG	ImplicitEmbeddedRomTsDesc.cpp	13;"	d	file:
DEBUGDEFORMING	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	e	enum:ForcedData::Type
DEBUG_H	arpack++/include/debug.h	18;"	d
DEBUG_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^namespace DEBUG_UTILITIES{$/;"	n	namespace:PhysBAM	file:
DEBUG_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	/^namespace DEBUG_UTILITIES{$/;"	n	namespace:PhysBAM
DEFAULT	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
DEFAULT	IoData.h	/^  enum Type {DEFAULT = 0, ROM = 1, FORCED = 2} type;$/;"	e	enum:LinearizedData::Type
DEFAULT_BLOCK_SIZE	DistLeastSquareSolver.C	/^const int DistLeastSquareSolver::DEFAULT_BLOCK_SIZE = 32;$/;"	m	class:DistLeastSquareSolver	file:
DEFAULT_BLOCK_SIZE	DistLeastSquareSolver.h	/^  static const int DEFAULT_BLOCK_SIZE;$/;"	m	class:DistLeastSquareSolver
DEFORMING	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	e	enum:ForcedData::Type
DELTA_PLUS	PostFcn.h	/^                   K_TURB = 10, EPS_TURB = 11, EDDY_VISCOSITY = 12, DELTA_PLUS = 13, $/;"	e	enum:PostFcn::ScalarType
DENSE	DiagMatrix.h	/^  enum Type {DENSE = 0, DIAGONAL = 1} type;$/;"	e	enum:DiagMat::Type
DENSEMATRIXTIMESDENSEMATRIX1	DenseMatrixOps.h	264;"	d
DENSEMATRIXTIMESDENSEMATRIX2	DenseMatrixOps.h	267;"	d
DENSEMATRIXTIMESDENSEMATRIX3	DenseMatrixOps.h	273;"	d
DENSEMATRIXTIMESDENSEMATRIX4	DenseMatrixOps.h	284;"	d
DENSEMATRIXTIMESDENSEMATRIX5	DenseMatrixOps.h	302;"	d
DENSEMATRIXTIMESDENSEMATRIX6	DenseMatrixOps.h	329;"	d
DENSEMATRIXTIMESDENSEMATRIX7	DenseMatrixOps.h	367;"	d
DENSEMATRIXTIMESVECTOR1	DenseMatrixOps.h	420;"	d
DENSEMATRIXTIMESVECTOR2	DenseMatrixOps.h	426;"	d
DENSEMATRIXTIMESVECTOR3	DenseMatrixOps.h	430;"	d
DENSEMATRIXTIMESVECTOR4	DenseMatrixOps.h	435;"	d
DENSEMATRIXTIMESVECTOR5	DenseMatrixOps.h	441;"	d
DENSEMATRIXTIMESVECTOR6	DenseMatrixOps.h	463;"	d
DENSEMATRIXTIMESVECTOR7	DenseMatrixOps.h	471;"	d
DENSEMATRIXTIMESVECTORLS	DenseMatrixOps.h	423;"	d
DENSEMATRIXTRANSTIMESVECTOR5	DenseMatrixOps.h	448;"	d
DENSEMATRIXTRANSTIMESVECTOR6	DenseMatrixOps.h	455;"	d
DENSITY	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
DENSITY	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	e	enum:PostFcn::ScalarType
DENSITYAVG	PostFcn.h	/^  enum ScalarAvgType {DENSITYAVG = 0, MACHAVG = 1, PRESSUREAVG = 2, TEMPERATUREAVG = 3,$/;"	e	enum:PostFcn::ScalarAvgType
DENSITY_CLIPPING	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
DERIVATIVE_DENSITY	PostFcn.h	/^  enum ScalarDerivativeType {DERIVATIVE_DENSITY = 0, DERIVATIVE_MACH = 1, DERIVATIVE_PRESSURE = 2, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_DISPLACEMENT	PostFcn.h	/^  enum VectorDerivativeType {DERIVATIVE_VELOCITY_VECTOR = 0, DERIVATIVE_DISPLACEMENT = 1, DVSIZE = 2};$/;"	e	enum:PostFcn::VectorDerivativeType
DERIVATIVE_EDDY_VISCOSITY	PostFcn.h	/^                             DERIVATIVE_EDDY_VISCOSITY = 6, DERIVATIVE_VELOCITY_SCALAR = 7, DERIVATIVE_SPATIAL_RES = 8, DSSIZE = 9};$/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_MACH	PostFcn.h	/^  enum ScalarDerivativeType {DERIVATIVE_DENSITY = 0, DERIVATIVE_MACH = 1, DERIVATIVE_PRESSURE = 2, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_NUT_TURB	PostFcn.h	/^                             DERIVATIVE_TEMPERATURE = 3, DERIVATIVE_TOTPRESSURE = 4, DERIVATIVE_NUT_TURB = 5, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_PRESSURE	PostFcn.h	/^  enum ScalarDerivativeType {DERIVATIVE_DENSITY = 0, DERIVATIVE_MACH = 1, DERIVATIVE_PRESSURE = 2, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_SPATIAL_RES	PostFcn.h	/^                             DERIVATIVE_EDDY_VISCOSITY = 6, DERIVATIVE_VELOCITY_SCALAR = 7, DERIVATIVE_SPATIAL_RES = 8, DSSIZE = 9};$/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_TEMPERATURE	PostFcn.h	/^                             DERIVATIVE_TEMPERATURE = 3, DERIVATIVE_TOTPRESSURE = 4, DERIVATIVE_NUT_TURB = 5, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_TOTPRESSURE	PostFcn.h	/^                             DERIVATIVE_TEMPERATURE = 3, DERIVATIVE_TOTPRESSURE = 4, DERIVATIVE_NUT_TURB = 5, $/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_VELOCITY_SCALAR	PostFcn.h	/^                             DERIVATIVE_EDDY_VISCOSITY = 6, DERIVATIVE_VELOCITY_SCALAR = 7, DERIVATIVE_SPATIAL_RES = 8, DSSIZE = 9};$/;"	e	enum:PostFcn::ScalarDerivativeType
DERIVATIVE_VELOCITY_VECTOR	PostFcn.h	/^  enum VectorDerivativeType {DERIVATIVE_VELOCITY_VECTOR = 0, DERIVATIVE_DISPLACEMENT = 1, DVSIZE = 2};$/;"	e	enum:PostFcn::VectorDerivativeType
DERIVED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    typedef typename TRANSPOSE<T_MATRIX>::TYPE DERIVED;$/;"	t	class:PhysBAM::TRANSPOSE_MATRIX
DES	Manual/Aerof3d.html	/^<a name="DES"><\/a>$/;"	a
DESCRIPTOR	IoData.h	/^  enum Form {DESCRIPTOR = 1, NONDESCRIPTOR = 0, HYBRID = 2} form;$/;"	e	enum:TsData::Form
DESCRIPTOR	SpaceOperator.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:SpaceOperator::DescriptorCase
DESCRIPTOR	TimeState.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:TimeState::DescriptorCase
DESMESH	Manual/Aerof3d.html	/^<a name="DESMESH"><\/a>$/;"	a
DESModelData	IoData.h	/^struct DESModelData {$/;"	s
DESModelData	IoDataCore.C	/^DESModelData::DESModelData()$/;"	f	class:DESModelData
DESTerm	DESTerm.h	/^DESTerm::DESTerm(IoData &iod)$/;"	f	class:DESTerm
DESTerm	DESTerm.h	/^class DESTerm {$/;"	c
DFSPAR	EmbeddedFluidShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
DFSPAR	FluidCollocationShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:FluidCollocationShapeOptimizationHandler
DFSPAR	FluidGnatShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:FluidGnatShapeOptimizationHandler
DFSPAR	FluidMetricShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:FluidMetricShapeOptimizationHandler
DFSPAR	FluidRomShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:FluidRomShapeOptimizationHandler
DFSPAR	FluidShapeOptimizationHandler.h	/^  double DFSPAR[3];$/;"	m	class:FluidShapeOptimizationHandler
DFT	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
DFluxDs	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> DFluxDs;$/;"	m	class:FluidCollocationShapeOptimizationHandler
DFluxDs	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> DFluxDs;$/;"	m	class:FluidGnatShapeOptimizationHandler
DFluxDs	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> DFluxDs;$/;"	m	class:FluidMetricShapeOptimizationHandler
DFluxDs	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> DFluxDs;$/;"	m	class:FluidRomShapeOptimizationHandler
DGCLData	IoData.h	/^struct DGCLData{$/;"	s
DGCLData	IoDataCore.C	/^DGCLData::DGCLData()$/;"	f	class:DGCLData
DGECP	f77src/dgecp.f	/^      SUBROUTINE  DGECP /;"	s
DGERS	f77src/dgers.f	/^      SUBROUTINE  DGERS /;"	s
DIAGONAL	DiagMatrix.h	/^  enum Type {DENSE = 0, DIAGONAL = 1} type;$/;"	e	enum:DiagMat::Type
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(2),INITIAL_SIZE nn=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX(const DIAGONAL_MATRIX<T2,2>& matrix_input)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX(const T y11,const T y22)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    explicit DIAGONAL_MATRIX(const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^class DIAGONAL_MATRIX<T,2>$/;"	c	namespace:PhysBAM
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(3),INITIAL_SIZE nn=INITIAL_SIZE(3))$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX(const DIAGONAL_MATRIX<T2,3>& matrix_input)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX(const T y11,const T y22,const T y33)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    explicit DIAGONAL_MATRIX(const VECTOR<T,3>& v)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^class DIAGONAL_MATRIX<T,3>$/;"	c	namespace:PhysBAM
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef MATRIX<T,0> DIAGONAL_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef MATRIX<T,1> DIAGONAL_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::DIAGONAL_MATRIX<T,2> DIAGONAL_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::DIAGONAL_MATRIX<T,3> DIAGONAL_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
DIFF	f77src/diff.f	/^       double precision FUNCTION DIFF(/;"	f
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct DIFFERENCE<T_ARRAY1,T_ARRAY2,typename ENABLE_IF<IS_ARRAY<T_ARRAY1>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct DIFFERENCE<T_ARRAY2,T1,typename ENABLE_IF<ARRAY_PLUS_SCALAR_VALID<T1,typename T_ARRAY2::ELEMENT>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,float>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,int>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,int>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,int>{typedef int TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct DIFFERENCE<TWIST<TV>,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	12;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	17;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	15;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	26;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	25;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	22;"	d
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T_VECTOR1,class T_VECTOR2> struct DIFFERENCE<T_VECTOR1,T_VECTOR2,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR1>::value && INEFFICIENT_VECTOR<T_VECTOR2>::value>::TYPE>$/;"	s	namespace:PhysBAM
DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	14;"	d
DIFFERENT_TRIANGLES	arpack++/include/arerror.h	/^    DIFFERENT_TRIANGLES = -507,$/;"	e	enum:ArpackError::ErrorCode
DIFFPRESSURE	PostFcn.h	/^                   PSENSOR = 14, MUT_OVER_MU = 15, PHILEVEL = 16,PHILEVEL2 = 17, DIFFPRESSURE = 18, $/;"	e	enum:PostFcn::ScalarType
DIMENSIONAL	IoData.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	e	enum:ProblemData::Mode
DIMENSIONAL	IoData.h	/^  enum OptimalPressureDimensionality {NON_DIMENSIONAL=0, DIMENSIONAL=1,NONE=2} optPressureDim;$/;"	e	enum:InputData::OptimalPressureDimensionality
DIMENSIONAL	RefVal.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	e	enum:RefVal::Mode
DIRECT	IoData.h	/^  enum Method {DIRECT = 0, ADJOINT = 1} method;$/;"	e	enum:SensitivityAnalysis::Method
DIRECTION	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
DIRECTSTATE	IoData.h	/^  enum Type {DIRECTSTATE = 1, MASSFLOW = 2, POROUSWALL = 3} type;$/;"	e	enum:BoundaryData::Type
DISABLE_IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b,class T=void> struct DISABLE_IF{};$/;"	s	namespace:PhysBAM
DISABLE_IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct DISABLE_IF<false,T>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
DISCARDING_FACTORS	arpack++/include/arerror.h	/^    DISCARDING_FACTORS  =  401,$/;"	e	enum:ArpackError::ErrorCode
DISPLACEMENT	IoData.h	/^  enum InitialCondition {DISPLACEMENT = 0, VELOCITY = 1} initCond;$/;"	e	enum:LinearizedData::InitialCondition
DISPLACEMENT	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	e	enum:PostFcn::VectorType
DISPLACEMENTAVG	PostFcn.h	/^  enum VectorAvgType {VELOCITYAVG = 0, DISPLACEMENTAVG = 1, AVVSIZE = 2};$/;"	e	enum:PostFcn::VectorAvgType
DISP_TAG	StructExc.C	12;"	d	file:
DISTANCE_COMPARISONS_OFF	IoData.h	/^  enum DistanceComparisons {DISTANCE_COMPARISONS_OFF = 0, DISTANCE_COMPARISONS_ON = 1} distanceComparisons;$/;"	e	enum:NonlinearRomOnlineData::DistanceComparisons
DISTANCE_COMPARISONS_ON	IoData.h	/^  enum DistanceComparisons {DISTANCE_COMPARISONS_OFF = 0, DISTANCE_COMPARISONS_ON = 1} distanceComparisons;$/;"	e	enum:NonlinearRomOnlineData::DistanceComparisons
DISTRIBUTE_COLOR_MAP_TAG	IntersectorPhysBAM/Mpi_Utilities.h	36;"	d
DISTRIBUTE_NUMBERS_TAG	IntersectorPhysBAM/Mpi_Utilities.h	33;"	d
DISTRIBUTE_SET_TAG	IntersectorPhysBAM/Mpi_Utilities.h	35;"	d
DIST_ANGLE	IoData.h	/^  enum DistanceMetric {DIST_EUCLIDEAN = 0, DIST_ANGLE = 1 } distanceMetric;$/;"	e	enum:NonlinearRomFileSystemData::DistanceMetric
DIST_EUCLIDEAN	IoData.h	/^  enum DistanceMetric {DIST_EUCLIDEAN = 0, DIST_ANGLE = 1 } distanceMetric;$/;"	e	enum:NonlinearRomFileSystemData::DistanceMetric
DIST_LEAST_SQUARE_SOLVER_H	DistLeastSquareSolver.h	2;"	d
DN	arpack++/include/arlsupm.h	/^    DN         \/* Fortran style column-wise storage for dense matrix *\/$/;"	e	enum:__anon42
DNformat	arpack++/include/arlsupm.h	/^} DNformat;$/;"	t	typeref:struct:__anon50
DOUBLE	IoData.h	/^  enum Type {SINGLE = 0, DOUBLE = 1} type;$/;"	e	enum:RestartData::Type
DO_PREPRO_APPROX_METRIC_NL_FALSE	IoData.h	/^  enum DoPreproApproxMetricNonlinear {DO_PREPRO_APPROX_METRIC_NL_FALSE = 0, DO_PREPRO_APPROX_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinear;$/;"	e	enum:GappyConstructionData::DoPreproApproxMetricNonlinear
DO_PREPRO_APPROX_METRIC_NL_TRUE	IoData.h	/^  enum DoPreproApproxMetricNonlinear {DO_PREPRO_APPROX_METRIC_NL_FALSE = 0, DO_PREPRO_APPROX_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinear;$/;"	e	enum:GappyConstructionData::DoPreproApproxMetricNonlinear
DO_PREPRO_FALSE	IoData.h	/^  enum DoPrepro {DO_PREPRO_FALSE = 0, DO_PREPRO_TRUE = 1} doPrepro;$/;"	e	enum:GappyConstructionData::DoPrepro
DO_PREPRO_GNAT_FALSE	IoData.h	/^  enum DoPreproGNAT {DO_PREPRO_GNAT_FALSE = 0, DO_PREPRO_GNAT_TRUE = 1} doPreproGNAT;$/;"	e	enum:GappyConstructionData::DoPreproGNAT
DO_PREPRO_GNAT_TRUE	IoData.h	/^  enum DoPreproGNAT {DO_PREPRO_GNAT_FALSE = 0, DO_PREPRO_GNAT_TRUE = 1} doPreproGNAT;$/;"	e	enum:GappyConstructionData::DoPreproGNAT
DO_PREPRO_NNLS_METRIC_NL_FALSE	IoData.h	/^  enum DoPreproApproxMetricNonlinearNNLS {DO_PREPRO_NNLS_METRIC_NL_FALSE = 0, DO_PREPRO_NNLS_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinearNNLS;$/;"	e	enum:GappyConstructionData::DoPreproApproxMetricNonlinearNNLS
DO_PREPRO_NNLS_METRIC_NL_TRUE	IoData.h	/^  enum DoPreproApproxMetricNonlinearNNLS {DO_PREPRO_NNLS_METRIC_NL_FALSE = 0, DO_PREPRO_NNLS_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinearNNLS;$/;"	e	enum:GappyConstructionData::DoPreproApproxMetricNonlinearNNLS
DO_PREPRO_TRUE	IoData.h	/^  enum DoPrepro {DO_PREPRO_FALSE = 0, DO_PREPRO_TRUE = 1} doPrepro;$/;"	e	enum:GappyConstructionData::DoPrepro
DSSIZE	PostFcn.h	/^                             DERIVATIVE_EDDY_VISCOSITY = 6, DERIVATIVE_VELOCITY_SCALAR = 7, DERIVATIVE_SPATIAL_RES = 8, DSSIZE = 9};$/;"	e	enum:PostFcn::ScalarDerivativeType
DUPLICATE_SNAPSHOTS_FALSE	IoData.h	/^  enum DuplicateSnapshots {DUPLICATE_SNAPSHOTS_FALSE = 0, DUPLICATE_SNAPSHOTS_TRUE = 1} duplicateSnapshots;$/;"	e	enum:NonlinearRomFilesData::DuplicateSnapshots
DUPLICATE_SNAPSHOTS_TRUE	IoData.h	/^  enum DuplicateSnapshots {DUPLICATE_SNAPSHOTS_FALSE = 0, DUPLICATE_SNAPSHOTS_TRUE = 1} duplicateSnapshots;$/;"	e	enum:NonlinearRomFilesData::DuplicateSnapshots
DVSIZE	PostFcn.h	/^  enum VectorDerivativeType {DERIVATIVE_VELOCITY_VECTOR = 0, DERIVATIVE_DISPLACEMENT = 1, DVSIZE = 2};$/;"	e	enum:PostFcn::VectorDerivativeType
DX	Modal.h	/^    VecSet< DistSVec<double,dim> > DX;$/;"	m	class:ModalSolver
DX	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* DX[3];$/;"	m	class:MultiGridOperator
DYNAMIC	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	e	enum:LESModelData::Type
DYNAMICNODALTRANSFER_H_	FSI/DynamicNodalTransfer.h	9;"	d
DYNAMICVMS	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	e	enum:LESModelData::Type
Data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    T_UNLESS_VOID& Data()$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
Data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    const T_UNLESS_VOID& Data() const$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
DataCompressionData	IoData.h	/^struct DataCompressionData {$/;"	s
DataCompressionData	IoDataCore.C	/^DataCompressionData::DataCompressionData()$/;"	f	class:DataCompressionData
DataOK	arpack++/include/arlnsmat.h	/^bool ARluNonSymMatrix<ARTYPE, ARFLOAT>::DataOK()$/;"	f	class:ARluNonSymMatrix
DataOK	arpack++/include/arlsmat.h	/^bool ARluSymMatrix<ARTYPE>::DataOK()$/;"	f	class:ARluSymMatrix
DataOK	arpack++/include/arunsmat.h	/^bool ARumNonSymMatrix<ARTYPE, ARFLOAT>::DataOK()$/;"	f	class:ARumNonSymMatrix
DataOK	arpack++/include/arusmat.h	/^bool ARumSymMatrix<ARTYPE>::DataOK()$/;"	f	class:ARumSymMatrix
DataType	SimpleBuffer.h	/^  typedef Scalar DataType;$/;"	t	class:SimpleBuffer
DblExpr	parser/Parser.y	/^DblExpr:$/;"	l
DebugTools	DebugTools.h	/^class DebugTools {$/;"	c
Debug_Breakpoint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Debug_Breakpoint()$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Debug_Print_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.cpp	/^void Debug_Print_Helper(const char* prefix,...)$/;"	f	namespace:PhysBAM
Default	IoData.h	/^  enum SlidingSurfaceTreatment {Default = 0, PrescribedAverage = 1} slidingSurfaceTreatment;$/;"	e	enum:DefoMeshMotionData::SlidingSurfaceTreatment
Define	arpack++/include/ardfmat.h	/^void ARdfMatrix<ARTYPE>::Define(char* filename, int blksizep)$/;"	f	class:ARdfMatrix
Define	arpack++/include/arhbmat.h	/^void ARhbMatrix<ARINT, ARTYPE>::Define(char* filename)$/;"	f	class:ARhbMatrix
DefineMatrices	arpack++/include/arbnspen.h	/^DefineMatrices(ARbdNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARbdNonSymPencil
DefineMatrices	arpack++/include/arbspen.h	/^DefineMatrices(ARbdSymMatrix<ARTYPE>& Ap, ARbdSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARbdSymPencil
DefineMatrices	arpack++/include/ardnspen.h	/^DefineMatrices(ARdsNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARdsNonSymPencil
DefineMatrices	arpack++/include/ardspen.h	/^DefineMatrices(ARdsSymMatrix<ARTYPE>& Ap, ARdsSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARdsSymPencil
DefineMatrices	arpack++/include/arlnspen.h	/^DefineMatrices(ARluNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARluNonSymPencil
DefineMatrices	arpack++/include/arlspen.h	/^DefineMatrices(ARluSymMatrix<ARTYPE>& Ap, ARluSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARluSymPencil
DefineMatrices	arpack++/include/arunspen.h	/^DefineMatrices(ARumNonSymMatrix<ARTYPE, ARFLOAT>& Ap, $/;"	f	class:ARumNonSymPencil
DefineMatrices	arpack++/include/aruspen.h	/^DefineMatrices(ARumSymMatrix<ARTYPE>& Ap, ARumSymMatrix<ARTYPE>& Bp)$/;"	f	class:ARumSymPencil
DefineMatrix	arpack++/include/arbnsmat.h	/^DefineMatrix(int np, int ndiagLp, int ndiagUp, ARTYPE* Ap)$/;"	f	class:ARbdNonSymMatrix
DefineMatrix	arpack++/include/arbsmat.h	/^DefineMatrix(int np, int nsdiagp, ARTYPE* Ap, char uplop)$/;"	f	class:ARbdSymMatrix
DefineMatrix	arpack++/include/ardnsmat.h	/^DefineMatrix(int mp, int np, ARTYPE* Ap)$/;"	f	class:ARdsNonSymMatrix
DefineMatrix	arpack++/include/ardnsmat.h	/^DefineMatrix(int np, ARTYPE* Ap)$/;"	f	class:ARdsNonSymMatrix
DefineMatrix	arpack++/include/ardsmat.h	/^DefineMatrix(int np, ARTYPE* Ap, char uplop)$/;"	f	class:ARdsSymMatrix
DefineMatrix	arpack++/include/arlnsmat.h	/^DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)$/;"	f	class:ARluNonSymMatrix
DefineMatrix	arpack++/include/arlnsmat.h	/^DefineMatrix(int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp,$/;"	f	class:ARluNonSymMatrix
DefineMatrix	arpack++/include/arlsmat.h	/^DefineMatrix(int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp,$/;"	f	class:ARluSymMatrix
DefineMatrix	arpack++/include/arunsmat.h	/^DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)$/;"	f	class:ARumNonSymMatrix
DefineMatrix	arpack++/include/arunsmat.h	/^DefineMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARumNonSymMatrix
DefineMatrix	arpack++/include/arusmat.h	/^DefineMatrix(int np, int nnzp, ARTYPE* ap, int* irowp,$/;"	f	class:ARumSymMatrix
DefineParameters	arpack++/include/argeig.h	/^DefineParameters(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARGenEig
DefineParameters	arpack++/include/arrseig.h	/^DefineParameters(int np, int nevp, char* whichp, int ncvp,$/;"	f	class:ARrcStdEig
DefineParameters	arpack++/include/arseig.h	/^DefineParameters(int np, int nevp, ARFOP* objOPp,$/;"	f	class:ARStdEig
DefoMeshMotionData	IoData.h	/^struct DefoMeshMotionData {$/;"	s
DefoMeshMotionData	IoDataCore.C	/^DefoMeshMotionData::DefoMeshMotionData()$/;"	f	class:DefoMeshMotionData
Deforming	Manual/Aerof3d.html	/^<a name="Deforming"><\/a>$/;"	a
DeformingData	IoData.h	/^struct DeformingData {$/;"	s
DeformingData	IoDataCore.C	/^DeformingData::DeformingData()$/;"	f	class:DeformingData
DeformingMeshMotionHandler	MeshMotionHandler.h	/^class DeformingMeshMotionHandler : public MeshMotionHandler {$/;"	c
DeformingMeshMotionHandler	MeshMotionHandlerCore.C	/^DeformingMeshMotionHandler::DeformingMeshMotionHandler(IoData &iod, Domain *dom) :$/;"	f	class:DeformingMeshMotionHandler
Delete	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Delete(const TK& v)$/;"	f	class:PhysBAM::HASHTABLE
Delete_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    void Delete_All()$/;"	f	class:PhysBAM::POINTER_POOL
Delete_All_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Delete_All_Elements() $/;"	f	class:PhysBAM::ARRAY_COLLECTION
Delete_All_Entries	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Delete_All_Entries()$/;"	f	class:PhysBAM::HASHTABLE
Delete_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Delete_Auxiliary_Structures()$/;"	f	class:SEGMENT_MESH
Delete_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Delete_Auxiliary_Structures()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Delete_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Delete_Auxiliary_Structures()$/;"	f	class:TRIANGLE_MESH
Delete_Element	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Delete_Element(const int p) $/;"	f	class:PhysBAM::ARRAY_COLLECTION
Delete_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Delete_Elements(ARRAY<int> deletion_list)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Delete_Elements_On_Deletion_List	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Delete_Elements_On_Deletion_List(const bool preserve_order)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Delete_Elements_With_Missing_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Delete_Elements_With_Missing_Nodes()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Delete_If_Present	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Delete_If_Present(const TK& v)$/;"	f	class:PhysBAM::HASHTABLE
Delete_Pointers_And_Clean_Memory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Delete_Pointers_And_Clean_Memory() \/\/ only valid if T is a pointer type$/;"	f	class:PhysBAM::ARRAY
Delete_Pointers_Stored_In_Table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Delete_Pointers_Stored_In_Table() \/\/ of course, only valid if pointers are stored in table$/;"	f	class:PhysBAM::HASHTABLE
Delete_Sorted_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Delete_Sorted_Elements(const ARRAY<int>& deletion_list)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Delete_Sorted_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Delete_Sorted_Elements(const ARRAY<int>& deletion_list,HASHTABLE<int,int>& index_map) $/;"	f	class:PhysBAM::SIMPLEX_MESH
Delta	Domain.h	/^  DistVec<double> *Delta;$/;"	m	class:Domain
Delta	IoData.h	/^  enum Delta {VOLUME = 0, SIDE = 1} delta;$/;"	g	struct:LESModelData
Delta	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Delta(const T phi,const T half_width)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,1,1> {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,2,4> {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,3,9> {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,5,25> {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,6,36> {$/;"	c
DenseMatrixOp	DenseMatrixOps.h	/^class DenseMatrixOp<Scalar,7,49> {$/;"	c
DerivativeHydrostaticPressure	VarFcn.h	/^  double DerivativeHydrostaticPressure(const double density, const double ddensity, $/;"	f	class:VarFcn
Derivative_Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Derivative_Rotation_Matrix(const T radians)$/;"	f	class:PhysBAM::MATRIX
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& Derived()$/;"	f	class:PhysBAM::ARRAY_BASE
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    const T_ARRAY& Derived() const$/;"	f	class:PhysBAM::ARRAY_BASE
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& Derived()$/;"	f	class:PhysBAM::MATRIX_BASE
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    const T_MATRIX& Derived() const$/;"	f	class:PhysBAM::MATRIX_BASE
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED& Derived()$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T_VECTOR& Derived()$/;"	f	class:PhysBAM::VECTOR_BASE
Derived	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    const T_VECTOR& Derived() const$/;"	f	class:PhysBAM::VECTOR_BASE
DescriptorCase	SpaceOperator.h	/^  enum DescriptorCase {$/;"	g	class:SpaceOperator
DescriptorCase	TimeState.h	/^  enum DescriptorCase {$/;"	g	class:TimeState
Destroy_Singleton	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    static inline void Destroy_Singleton()$/;"	f	class:PhysBAM::TIMER
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Determinant() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Determinant() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Determinant() const$/;"	f	class:PhysBAM::MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Determinant() const$/;"	f	class:PhysBAM::MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Determinant() const$/;"	f	class:PhysBAM::MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Determinant() const$/;"	f	class:PhysBAM::MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T Determinant() const \/\/ 9 mults, 5 adds$/;"	f	class:PhysBAM::MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T Determinant() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Determinant() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Determinant() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Determinant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Determinant() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Determinant_Differential	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static T Determinant_Differential(const MATRIX& A,const MATRIX& dA)$/;"	f	class:PhysBAM::MATRIX
Deviatoric	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Deviatoric() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
DiagMat	DiagMatrix.C	/^DiagMat<Scalar,dim>::DiagMat(Type t, int nn, int *ndType) : a(nn) $/;"	f	class:DiagMat
DiagMat	DiagMatrix.h	/^class DiagMat : public GenMat<Scalar,dim> {$/;"	c
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Diagonal_Part() const$/;"	f	class:PhysBAM::MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Diagonal_Part() const$/;"	f	class:PhysBAM::MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Diagonal_Part() const$/;"	f	class:PhysBAM::MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    DIAGONAL_MATRIX<T,2> Diagonal_Part() const$/;"	f	class:PhysBAM::MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    DIAGONAL_MATRIX<T,3> Diagonal_Part() const$/;"	f	class:PhysBAM::MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    DIAGONAL_MATRIX<T,2> Diagonal_Part() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Diagonal_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    DIAGONAL_MATRIX<T,3> Diagonal_Part() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
DictMap	parser/Dictionary.h	/^typedef map<string, int> DictMap;$/;"	t
Dictionary	parser/Dictionary.h	/^   Dictionary() { nToken = 0; }$/;"	f	class:Dictionary
Dictionary	parser/Dictionary.h	/^class Dictionary {$/;"	c
Diff	Vector.h	/^  Diff(T1 aa, T2 bb, int l) : a(aa), b(bb) { len = l; }$/;"	f	class:Diff
Diff	Vector.h	/^class Diff {$/;"	c
Dilational	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Dilational() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Dilational	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Dilational() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Dilational	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Dilational() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
DirComp	IntersectorFRG/Geometry/KDTree.h	/^    DirComp(int d) : dir(d) {}$/;"	f	class:DirComp
DirComp	IntersectorFRG/Geometry/KDTree.h	/^template <class Obj> class DirComp {$/;"	c
Directory_Exists	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^bool Directory_Exists(const std::string& dirname)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Directory_Writable	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^bool Directory_Writable(const std::string& dirname) \/\/ TODO: make this nicer$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Discriminant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T Discriminant() const$/;"	f	class:PhysBAM::QUADRATIC
Dissipation	IoData.h	/^  enum Dissipation {SECOND_ORDER = 0, SIXTH_ORDER = 1} dissipation;$/;"	g	struct:SchemeData
DistBcData	DistBcData.C	/^DistBcData<dim>::DistBcData(IoData &ioData, VarFcn *varFcn, Domain *domain,$/;"	f	class:DistBcData
DistBcData	DistBcData.h	/^class DistBcData {$/;"	c
DistBcDataEuler	DistBcData.C	/^DistBcDataEuler<dim>::DistBcDataEuler(IoData &iod, VarFcn *vf, Domain *dom, DistSVec<double,3> &X) :$/;"	f	class:DistBcDataEuler
DistBcDataEuler	DistBcData.h	/^class DistBcDataEuler : public DistBcData<dim> {$/;"	c
DistBcDataKE	DistBcData.C	/^DistBcDataKE<dim>::DistBcDataKE(IoData &iod, VarFcn *vf, Domain *dom, DistSVec<double,3> &X) : $/;"	f	class:DistBcDataKE
DistBcDataKE	DistBcData.h	/^class DistBcDataKE : public DistBcDataEuler<dim> {$/;"	c
DistBcDataSA	DistBcData.C	/^DistBcDataSA<dim>::DistBcDataSA(IoData &iod, VarFcn *vf, Domain *dom, DistSVec<double,3> &X) : $/;"	f	class:DistBcDataSA
DistBcDataSA	DistBcData.h	/^class DistBcDataSA : public DistBcDataEuler<dim> {$/;"	c
DistDynamicLESTerm	DistDynamicLESTerm.C	/^DistDynamicLESTerm<dim>::DistDynamicLESTerm(VarFcn *vf, IoData &iod, Domain *dom) : domain(dom), varFcn(vf)    $/;"	f	class:DistDynamicLESTerm
DistDynamicLESTerm	DistDynamicLESTerm.h	/^class DistDynamicLESTerm {$/;"	c
DistDynamicVMSTerm	DistDynamicVMSTerm.C	/^DistDynamicVMSTerm<dim>::DistDynamicVMSTerm(VarFcn *vf, IoData &iod, Domain *dom) : domain(dom),varFcn(vf)$/;"	f	class:DistDynamicVMSTerm
DistDynamicVMSTerm	DistDynamicVMSTerm.h	/^class DistDynamicVMSTerm {$/;"	c
DistEdgeGrad	DistEdgeGrad.C	/^DistEdgeGrad<dim>::DistEdgeGrad(IoData& iod, Domain* domain)$/;"	f	class:DistEdgeGrad
DistEdgeGrad	DistEdgeGrad.h	/^class DistEdgeGrad {$/;"	c
DistEmbeddedVec	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::DistEmbeddedVec(const DistEmbeddedVec<Scalar,dim> &y) :$/;"	f	class:DistEmbeddedVec
DistEmbeddedVec	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::DistEmbeddedVec(const DistInfo &dI) : $/;"	f	class:DistEmbeddedVec
DistEmbeddedVec	DistEmbeddedVector.h	/^class DistEmbeddedVec : public EmbeddedExpr< DistEmbeddedVec<Scalar,dim>, Scalar> {$/;"	c
DistExactRiemannSolver	DistExactRiemannSolver.C	/^DistExactRiemannSolver<dim>::DistExactRiemannSolver(IoData &ioData, Domain *dom,$/;"	f	class:DistExactRiemannSolver
DistExactRiemannSolver	DistExactRiemannSolver.h	/^class DistExactRiemannSolver {$/;"	c
DistExtrapolation	DistExtrapolation.C	/^DistExtrapolation<dim>::DistExtrapolation(IoData& iod, Domain* domain, VarFcn* vf)$/;"	f	class:DistExtrapolation
DistExtrapolation	DistExtrapolation.h	/^class DistExtrapolation {$/;"	c
DistGeoState	DistGeoState.C	/^DistGeoState::DistGeoState(IoData &ioData, Domain *dom) : data(ioData), domain(dom)$/;"	f	class:DistGeoState
DistGeoState	DistGeoState.C	/^DistGeoState::DistGeoState(const GeoData& data, Domain *dom, DistInfo& nodeDistInfo, DistInfo& edgeDistInfo)$/;"	f	class:DistGeoState
DistGeoState	DistGeoState.C	/^DistGeoState::DistGeoState(const GeoData& data, Domain *dom, DistInfo& nodeDistInfo, DistInfo& edgeDistInfo,DistInfo& faceNormDistInfo)$/;"	f	class:DistGeoState
DistGeoState	DistGeoState.h	/^class DistGeoState {$/;"	c
DistInfo	DistInfo.h	/^  DistInfo(int _numLocThreads, int _numLocSub, int _numGlobSub, $/;"	f	struct:DistInfo
DistInfo	DistInfo.h	/^struct DistInfo {$/;"	s
DistIntersectorFRG	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::DistIntersectorFRG(IoData &iodata, $/;"	f	class:DistIntersectorFRG
DistIntersectorFRG	IntersectorFRG/IntersectorFRG.h	/^class DistIntersectorFRG : public DistLevelSetStructure {$/;"	c
DistIntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::DistIntersectorPhysBAM(IoData &iodata, $/;"	f	class:DistIntersectorPhysBAM
DistIntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.h	/^class DistIntersectorPhysBAM : public DistLevelSetStructure {$/;"	c
DistLeastSquareSolver	DistLeastSquareSolver.C	/^DistLeastSquareSolver::DistLeastSquareSolver(Communicator * comm, int rowCpus, int colCpus) : $/;"	f	class:DistLeastSquareSolver
DistLeastSquareSolver	DistLeastSquareSolver.h	/^class DistLeastSquareSolver {$/;"	c
DistLevelSetStructure	LevelSet/LevelSetStructure.h	/^    DistLevelSetStructure()$/;"	f	class:DistLevelSetStructure
DistLevelSetStructure	LevelSet/LevelSetStructure.h	/^class DistLevelSetStructure {$/;"	c
DistMacroCellSet	DistMacroCell.h	/^class DistMacroCellSet {$/;"	c
DistMacroCellSet	DistMacroCellCore.C	/^DistMacroCellSet::DistMacroCellSet(Domain* dom, double gamma,$/;"	f	class:DistMacroCellSet
DistMat	DistMatrix.h	/^DistMat<Scalar,dim>::DistMat(Domain *domain)$/;"	f	class:DistMat
DistMat	DistMatrix.h	/^DistMat<Scalar,dim>::DistMat(Domain* domain, CommPattern<double> * a1, CommPattern<bcomp> * a2,$/;"	f	class:DistMat
DistMat	DistMatrix.h	/^class DistMat {$/;"	c
DistMultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.C	/^DistMultiGridLevelSetStructure(IoData &iod, Communicator *comm,$/;"	f	class:DistMultiGridLevelSetStructure
DistMultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.h	/^class DistMultiGridLevelSetStructure : public DistLevelSetStructure {$/;"	c
DistMvpMatrix	DistMvpMatrix.h	/^DistMvpMatrix<Scalar,dim>::DistMvpMatrix(Domain* d, const int* nn,$/;"	f	class:DistMvpMatrix
DistMvpMatrix	DistMvpMatrix.h	/^class DistMvpMatrix : public DistMat<Scalar,dim> {$/;"	c
DistNodalGrad	DistNodalGrad.C	/^DistNodalGrad<dim, Scalar>::DistNodalGrad(IoData &ioData, Domain *dom) : domain(dom)$/;"	f	class:DistNodalGrad
DistNodalGrad	DistNodalGrad.C	/^DistNodalGrad<dim, Scalar>::DistNodalGrad(IoData &ioData, Domain *dom, int whichone) : domain(dom)$/;"	f	class:DistNodalGrad
DistNodalGrad	DistNodalGrad.h	/^class DistNodalGrad {$/;"	c
DistSVec	DistVector.h	/^DistSVec<Scalar,dim>::DistSVec(const DistInfo &dI) : $/;"	f	class:DistSVec
DistSVec	DistVector.h	/^DistSVec<Scalar,dim>::DistSVec(const DistInfo &dI, Scalar (*vv)[dim]) :$/;"	f	class:DistSVec
DistSVec	DistVector.h	/^DistSVec<Scalar,dim>::DistSVec(const DistSVec<Scalar,dim> &y) :$/;"	f	class:DistSVec
DistSVec	DistVector.h	/^class DistSVec : public SVec<Scalar,dim> {$/;"	c
DistTimeState	DistTimeState.C	/^DistTimeState<dim>::DistTimeState(IoData &ioData, SpaceOperator<dim> *spo, VarFcn *vf,$/;"	f	class:DistTimeState
DistTimeState	DistTimeState.C	/^DistTimeState<dim>::DistTimeState(const DistTimeState<dim> &ts, bool typeAlloc, IoData &ioData) $/;"	f	class:DistTimeState
DistTimeState	DistTimeState.h	/^class DistTimeState {$/;"	c
DistVMSLESTerm	DistVMSLESTerm.C	/^DistVMSLESTerm<dim>::DistVMSLESTerm(VarFcn *vf, IoData &iod, Domain *dom) : domain(dom), varFcn(vf)$/;"	f	class:DistVMSLESTerm
DistVMSLESTerm	DistVMSLESTerm.h	/^class DistVMSLESTerm {$/;"	c
DistVec	DistVector.h	/^DistVec<Scalar>::DistVec(const DistInfo &dI) : $/;"	f	class:DistVec
DistVec	DistVector.h	/^DistVec<Scalar>::DistVec(const DistInfo &dI, Scalar *vv) : $/;"	f	class:DistVec
DistVec	DistVector.h	/^DistVec<Scalar>::DistVec(const DistVec<Scalar> &v2) :$/;"	f	class:DistVec
DistVec	DistVector.h	/^class DistVec : public Vec<Scalar> {$/;"	c
DistVectorOp	DistVectorOp.h	/^class DistVectorOp {$/;"	c
Distance	IoData.h	/^   enum FractionalStrategy {Distance = 1, DotProduct = 2} fractionalStrategy;$/;"	e	enum:BLMeshMotionData::FractionalStrategy
Distance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Distance(const T_ARRAY1& a,const T_ARRAY1& b)$/;"	f	class:PhysBAM::ARRAY_BASE
DistanceComparisons	IoData.h	/^  enum DistanceComparisons {DISTANCE_COMPARISONS_OFF = 0, DISTANCE_COMPARISONS_ON = 1} distanceComparisons;$/;"	g	struct:NonlinearRomOnlineData
DistanceMetric	IoData.h	/^  enum DistanceMetric {DIST_EUCLIDEAN = 0, DIST_ANGLE = 1 } distanceMetric;$/;"	g	struct:NonlinearRomFileSystemData
DistanceToClosestPointOnMovingStructure	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::DistanceToClosestPointOnMovingStructure(DistLevelSetStructure& LSS, $/;"	f	class:ReinitializeDistanceToWall
Distance_From_Point_To_Line	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Distance_From_Point_To_Line(const VECTOR<T,2>& point) const$/;"	f	class:SEGMENT_2D
Distance_From_Point_To_Line	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Distance_From_Point_To_Line(const VECTOR<T,3>& point) const$/;"	f	class:SEGMENT_3D
Distance_From_Point_To_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Distance_From_Point_To_Segment(const VECTOR<T,2>& point) const$/;"	f	class:SEGMENT_2D
Distance_From_Point_To_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Distance_From_Point_To_Segment(const VECTOR<T,3>& point) const$/;"	f	class:SEGMENT_3D
Distance_From_Polygon_To_Point	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^Distance_From_Polygon_To_Point(const VECTOR<T,2>& X_point)$/;"	f	class:POLYGON
Distance_To_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Distance_To_Triangle(const VECTOR<T,3>& location) const$/;"	f	class:TRIANGLE_3D
Distinct_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Distinct_Vector() const$/;"	f	class:PhysBAM::VECTOR
Div	Vector.h	/^  Div(T1 aa, T2 bb, int l) : a(aa), b(bb) { len = l; }$/;"	f	class:Div
Div	Vector.h	/^class Div {$/;"	c
Divide_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Divide_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const ARRAY_BASE<T2,T_ARRAY_T2,ID>& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Divide_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Divide_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const typename T_ARRAY::SCALAR& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
DoPrepro	IoData.h	/^  enum DoPrepro {DO_PREPRO_FALSE = 0, DO_PREPRO_TRUE = 1} doPrepro;$/;"	g	struct:GappyConstructionData
DoPreproApproxMetricNonlinear	IoData.h	/^  enum DoPreproApproxMetricNonlinear {DO_PREPRO_APPROX_METRIC_NL_FALSE = 0, DO_PREPRO_APPROX_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinear;$/;"	g	struct:GappyConstructionData
DoPreproApproxMetricNonlinearNNLS	IoData.h	/^  enum DoPreproApproxMetricNonlinearNNLS {DO_PREPRO_NNLS_METRIC_NL_FALSE = 0, DO_PREPRO_NNLS_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinearNNLS;$/;"	g	struct:GappyConstructionData
DoPreproGNAT	IoData.h	/^  enum DoPreproGNAT {DO_PREPRO_GNAT_FALSE = 0, DO_PREPRO_GNAT_TRUE = 1} doPreproGNAT;$/;"	g	struct:GappyConstructionData
Domain	Domain.h	/^class Domain {$/;"	c
Domain	DomainCore.C	/^Domain::Domain()$/;"	f	class:Domain
Domain	DomainCore.C	/^Domain::Domain(Communicator *com) : com(com), subDomain(0), subTopo(0), nodeType(0), nodeFaceType(0), offWallNode(0),$/;"	f	class:Domain
Domain	IoData.h	/^  enum Domain {TIME = 0, FREQUENCY = 1} domain;$/;"	g	struct:LinearizedData
Domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	g	struct:DeformingData
Domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	g	struct:HeavingData
Domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	g	struct:PitchingData
Domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	g	struct:SpiralingData
Domain_Indices	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    const RANGE<TV_INT>& Domain_Indices() const$/;"	f	class:PhysBAM::ARRAY_BASE
Dominant_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^Dominant_Axis() const$/;"	f	class:VECTOR
Dominant_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Dominant_Axis() const$/;"	f	class:PhysBAM::VECTOR
Dominant_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Dominant_Axis() const$/;"	f	class:PhysBAM::VECTOR
Dominant_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Dominant_Axis() const$/;"	f	class:PhysBAM::VECTOR
DotProduct	IoData.h	/^   enum FractionalStrategy {Distance = 1, DotProduct = 2} fractionalStrategy;$/;"	e	enum:BLMeshMotionData::FractionalStrategy
DotTerm	Vector.h	/^complex<Scalar> DotTerm(const complex<Scalar> &a, const complex<Scalar> &b)$/;"	f
DotTerm	Vector.h	/^template<class Scalar> inline Scalar DotTerm(const Scalar &a, const Scalar &b) {return a*b; }$/;"	f
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Dot_Product(const T_ARRAY1& a1,const T_ARRAY2& a2)$/;"	f	class:PhysBAM::ARRAY_BASE
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/DOT_PRODUCT.h	/^    Dot_Product(const ARRAY_BASE<T,T_ARRAY,ID>& a1,const ARRAY_BASE<T,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static T Dot_Product(const ARRAY_BASE& a1,const ARRAY_BASE& a2)$/;"	f	class:PhysBAM::ARRAY_BASE
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    static T Dot_Product(const QUATERNION& q1,const QUATERNION& q2)$/;"	f	class:PhysBAM::QUATERNION
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    static T Dot_Product(const COMPLEX<T>& c1,const COMPLEX<T>& c2)$/;"	f	class:PhysBAM::COMPLEX
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline double Dot_Product(const double a1,const double a2)$/;"	f	namespace:PhysBAM
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline float Dot_Product(const float a1,const float a2)$/;"	f	namespace:PhysBAM
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline typename TV::SCALAR Dot_Product(const TV& v1,const TV& v2)$/;"	f	namespace:PhysBAM
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    static T Dot_Product(const VECTOR&,const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static T Dot_Product(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static T Dot_Product(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static T Dot_Product(const VECTOR& v1,const VECTOR& v2)$/;"	f	class:PhysBAM::VECTOR
Dot_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static T Dot_Product(const VECTOR_BASE<T,T_VECTOR1>& v1,const VECTOR_BASE<T,T_VECTOR2>& v2)$/;"	f	class:PhysBAM::VECTOR_BASE
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Dot_Product_Double_Precision(const T_ARRAY1& a1,const T_ARRAY2& a2)$/;"	f	class:PhysBAM::ARRAY_BASE
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/DOT_PRODUCT.h	/^    Dot_Product_Double_Precision(const ARRAY_BASE<T,T_ARRAY,ID>& a1,const ARRAY_BASE<T,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline double Dot_Product_Double_Precision(const TV& v1,const TV& v2)$/;"	f	namespace:PhysBAM
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline double Dot_Product_Double_Precision(const VECTOR<T,d>& v1,const VECTOR<T,d>& v2)$/;"	f	namespace:PhysBAM
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline double Dot_Product_Double_Precision(const double a1,const double a2)$/;"	f	namespace:PhysBAM
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^inline double Dot_Product_Double_Precision(const float a1,const float a2)$/;"	f	namespace:PhysBAM
Dot_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static double Dot_Product_Double_Precision(const VECTOR_BASE<T,T_VECTOR1>& v1,const VECTOR_BASE<T,T_VECTOR2>& v2)$/;"	f	class:PhysBAM::VECTOR_BASE
Dtype	arpack++/include/arlsupm.h	/^	Dtype_t Dtype; \/* Data type. *\/$/;"	m	struct:__anon45
Dtype_t	arpack++/include/arlsupm.h	/^} Dtype_t;$/;"	t	typeref:enum:__anon43
DualTimeStepping	IoData.h	/^  enum DualTimeStepping {OFF = 0, ON = 1} dualtimestepping;$/;"	g	struct:TsData
DummyPointData	IoData.h	/^struct DummyPointData {$/;"	s
DummyPointData	IoDataCore.C	/^DummyPointData::DummyPointData()$/;"	f	class:DummyPointData
Dump_Log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Dump_Log()$/;"	f	namespace:PhysBAM::LOG_REAL
Dump_Log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual void Dump_Log(FILE* output)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Dump_Log_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Dump_Log_Helper(LOG_CLASS& instance,const bool suppress_cout)$/;"	f	namespace:PhysBAM::LOG_REAL::__anon19
Dump_Names	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual void Dump_Names(FILE* output)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
DuplicateSnapshots	IoData.h	/^  enum DuplicateSnapshots {DUPLICATE_SNAPSHOTS_FALSE = 0, DUPLICATE_SNAPSHOTS_TRUE = 1} duplicateSnapshots;$/;"	g	struct:NonlinearRomFilesData
Dynamic	Manual/Aerof3d.html	/^<a name="Dynamic"><\/a>$/;"	a
DynamicLESData	IoData.h	/^struct DynamicLESData {$/;"	s
DynamicLESData	IoDataCore.C	/^DynamicLESData::DynamicLESData()$/;"	f	class:DynamicLESData
DynamicLESTerm	DynamicLESTerm.C	/^DynamicLESTerm::DynamicLESTerm(IoData& iod, VarFcn *vf): NavierStokesTerm(iod, vf)$/;"	f	class:DynamicLESTerm
DynamicLESTerm	DynamicLESTerm.h	/^class DynamicLESTerm: public NavierStokesTerm {$/;"	c
DynamicNodalTransfer	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::DynamicNodalTransfer(IoData& iod, Communicator &c, Communicator &sc, Timer *tim): com(c) , F(1),$/;"	f	class:DynamicNodalTransfer
DynamicNodalTransfer	FSI/DynamicNodalTransfer.h	/^class DynamicNodalTransfer {$/;"	c
DynamicVMS	Manual/Aerof3d.html	/^<a name="DynamicVMS"><\/a>$/;"	a
DynamicVMSData	IoData.h	/^struct DynamicVMSData {$/;"	s
DynamicVMSData	IoDataCore.C	/^DynamicVMSData::DynamicVMSData()$/;"	f	class:DynamicVMSData
DynamicVMSTerm	DynamicVMSTerm.C	/^DynamicVMSTerm::DynamicVMSTerm(IoData& iod, VarFcn *vf): NavierStokesTerm(iod, vf)$/;"	f	class:DynamicVMSTerm
DynamicVMSTerm	DynamicVMSTerm.h	/^class DynamicVMSTerm: public NavierStokesTerm {$/;"	c
ECROSS	f77src/hllcjac.f	/^      SUBROUTINE ECROSS(/;"	s
EDDY_VISCOSITY	IoData.h	/^  enum Type {NONE = 0, EDDY_VISCOSITY = 1, LES = 2} type;$/;"	e	enum:TurbulenceClosureData::Type
EDDY_VISCOSITY	PostFcn.h	/^                   K_TURB = 10, EPS_TURB = 11, EDDY_VISCOSITY = 12, DELTA_PLUS = 13, $/;"	e	enum:PostFcn::ScalarType
EDERIVATIVE	f77src/hllcjac.f	/^      SUBROUTINE EDERIVATIVE(/;"	s
EDGE_LENGTH	EdgeCore.C	12;"	d	file:
EDGE_LENGTH	SubDomain.h	315;"	d
EDGE_LENGTH	SubDomainCore.C	5717;"	d	file:
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,class T_MATRIX> struct EFFICIENT_MATRIX<MATRIX_BASE<T,T_MATRIX> >:public EFFICIENT_MATRIX<T_MATRIX>{};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,class T_VECTOR> struct EFFICIENT_MATRIX<VECTOR_BASE<T,T_VECTOR> >:public EFFICIENT_MATRIX<T_VECTOR>{};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<DIAGONAL_MATRIX<T,d> > {static const bool value=(d==2 || d==3);};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<SYMMETRIC_MATRIX<T,d> > {static const bool value=(d==2 || d==3);};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<VECTOR<T,d> > {static const bool value=(d<=3);};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct EFFICIENT_MATRIX<MATRIX<T,m,n> > {static const bool value=((m>=2 && m<=3 && n>=2 && n<=3) || (m==4 && n==4) || (m==0 && n==0));};$/;"	s	namespace:PhysBAM
EFFICIENT_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T_MATRIX> struct EFFICIENT_MATRIX {static const bool value=false;};$/;"	s	namespace:PhysBAM
EFFICIENT_OR_VOID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    template<class T> struct EFFICIENT_OR_VOID:public OR<EFFICIENT_MATRIX<T>::value,IS_SAME<T,void>::value>{};$/;"	s	struct:PhysBAM::__anon21::ASSERT_EFFICIENT
EFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,0> >{static const bool value=true;};$/;"	s	namespace:PhysBAM
EFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,1> >{static const bool value=true;};$/;"	s	namespace:PhysBAM
EFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,2> >{static const bool value=true;};$/;"	s	namespace:PhysBAM
EFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,3> >{static const bool value=true;};$/;"	s	namespace:PhysBAM
EFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class TV> struct EFFICIENT_VECTOR{static const bool value=false;};$/;"	s	namespace:PhysBAM
EISENSTADT	IoData.h	/^  enum EpsFormula {CONSTANT = 0, EISENSTADT = 1} epsFormula;$/;"	e	enum:KspData::EpsFormula
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    typedef T ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::ARRAY
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::ARRAY_BASE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef T_DIFFERENCE ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef T_PRODUCT ELEMENT;typedef typename T_ARRAY2::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    typedef typename NEGATION<T>::TYPE ELEMENT;typedef typename T_ARRAY::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_NEGATION
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef T_SUM ELEMENT;typedef typename T_ARRAY2::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef T_PRODUCT ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef T_SUM ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_SUM
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typedef typename REMOVE_CONST<T>::TYPE ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::ARRAY_VIEW
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::CONSTANT_ARRAY
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    typedef ID ELEMENT;$/;"	t	class:PhysBAM::IDENTITY_ARRAY
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef T ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef T ELEMENT;typedef typename T_ARRAY::INDEX INDEX;$/;"	t	class:PhysBAM::PROJECTED_ARRAY
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::HASHTABLE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::ARRAY_BASE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef SCALAR ELEMENT;$/;"	t	class:PhysBAM::VECTOR_DIFFERENCE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef SCALAR ELEMENT;$/;"	t	class:PhysBAM::VECTOR_NEGATION
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef SCALAR ELEMENT;$/;"	t	class:PhysBAM::VECTOR_SCALE
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef SCALAR ELEMENT;$/;"	t	class:PhysBAM::VECTOR_SUM
ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    typedef T ELEMENT;$/;"	t	class:PhysBAM::VECTOR_ND
ELEMENT_BASED	IoData.h	/^  enum StructureNormal {ELEMENT_BASED = 0, NODE_BASED = 1} structNormal;$/;"	e	enum:EmbeddedFramework::StructureNormal
ELEMENT_ID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ELEMENT_ID()$/;"	f	class:PhysBAM::ELEMENT_ID
ELEMENT_ID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    explicit ELEMENT_ID(T n)$/;"	f	class:PhysBAM::ELEMENT_ID
ELEMENT_ID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^class ELEMENT_ID$/;"	c	namespace:PhysBAM
ELEMENT_ID_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^namespace ELEMENT_ID_HELPER{$/;"	n	namespace:PhysBAM
ELEMENT_OF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class S> struct ELEMENT_OF{typedef typename S::ELEMENT TYPE;};$/;"	s	class:PhysBAM::ARRAY_BASE
ELEMENT_OF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    template<class S> struct ELEMENT_OF{typedef typename S::ELEMENT TYPE;};$/;"	s	class:PhysBAM::ARRAY_BASE
ELEMENT_OF_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef typename IF<IS_VECTOR<T>::value,ELEMENT_OF<T>,FIRST<UNUSABLE> >::TYPE::TYPE ELEMENT_OF_T;$/;"	t	class:PhysBAM::ARRAY_BASE
ELEMENT_OF_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    typedef typename IF<IS_VECTOR<T>::value,ELEMENT_OF<T>,FIRST<UNUSABLE> >::TYPE::TYPE ELEMENT_OF_T;$/;"	t	class:PhysBAM::ARRAY_BASE
EMBEDDED	IoData.h	/^  enum Framework {BODYFITTED = 0, EMBEDDED = 1, EMBEDDEDALE = 2} framework;$/;"	e	enum:ProblemData::Framework
EMBEDDEDALE	IoData.h	/^  enum Framework {BODYFITTED = 0, EMBEDDED = 1, EMBEDDEDALE = 2} framework;$/;"	e	enum:ProblemData::Framework
EMBEDDED_SURFACE	IoData.h	/^  enum ForceAlgorithm {RECONSTRUCTED_SURFACE = 0, CONTROL_VOLUME_BOUNDARY = 1, EMBEDDED_SURFACE = 2} forceAlg;$/;"	e	enum:EmbeddedFramework::ForceAlgorithm
EMBED_ID	DomainCore.C	33;"	d	file:
EMPTY	arpack++/include/arlutil.h	48;"	d
EMPTY_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,bool is_class=false> struct EMPTY_HELPER{static const bool value=false;};$/;"	s	namespace:PhysBAM
EMPTY_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct EMPTY_HELPER<T,true>{static const bool value=sizeof(EMPTY_HELPER_BASE_T<T>)==sizeof(EMPTY_HELPER_NOBASE);};$/;"	s	namespace:PhysBAM
EMPTY_HELPER_BASE_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct EMPTY_HELPER_BASE_T:public T{int i[256];};$/;"	s	namespace:PhysBAM
EMPTY_HELPER_NOBASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct EMPTY_HELPER_NOBASE{int i[256];};$/;"	s	namespace:PhysBAM
ENABLE_IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b,class T=void> struct ENABLE_IF{};$/;"	s	namespace:PhysBAM
ENABLE_IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ENABLE_IF<true,T>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
ENERGY_ONLY_FALSE	IoData.h	/^  enum EnergyOnly {ENERGY_ONLY_FALSE = 0, ENERGY_ONLY_TRUE = 1} energyOnly;$/;"	e	enum:DataCompressionData::EnergyOnly
ENERGY_ONLY_TRUE	IoData.h	/^  enum EnergyOnly {ENERGY_ONLY_FALSE = 0, ENERGY_ONLY_TRUE = 1} energyOnly;$/;"	e	enum:DataCompressionData::EnergyOnly
ENTRY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef HASHTABLE_ENTRY_TEMPLATE<TK,T> ENTRY; \/\/ don't store data if T is void$/;"	t	class:PhysBAM::HASHTABLE
ENTRY_ACTIVE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^enum HASHTABLE_ENTRY_STATE{ENTRY_FREE,ENTRY_ACTIVE,ENTRY_DELETED};$/;"	e	enum:PhysBAM::HASHTABLE_ENTRY_STATE
ENTRY_DELETED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^enum HASHTABLE_ENTRY_STATE{ENTRY_FREE,ENTRY_ACTIVE,ENTRY_DELETED};$/;"	e	enum:PhysBAM::HASHTABLE_ENTRY_STATE
ENTRY_FREE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^enum HASHTABLE_ENTRY_STATE{ENTRY_FREE,ENTRY_ACTIVE,ENTRY_DELETED};$/;"	e	enum:PhysBAM::HASHTABLE_ENTRY_STATE
EOSChange	IoData.h	/^  enum EOSChange {NODAL_STATE = 0, RIEMANN_SOLUTION = 1} eosChange;$/;"	g	struct:EmbeddedFramework
EPSILON	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
EPS_TURB	PostFcn.h	/^                   K_TURB = 10, EPS_TURB = 11, EDDY_VISCOSITY = 12, DELTA_PLUS = 13, $/;"	e	enum:PostFcn::ScalarType
EQUIL	arpack++/include/arlutil.h	/^    EQUIL,   \/* equilibrate the original matrix *\/$/;"	e	enum:__anon51
ERIEMANNGG	f77src/eriemann_gg.f	/^       SUBROUTINE ERIEMANNGG(/;"	s
ERIEMANNGW	f77src/eriemann_gw.f	/^      SUBROUTINE ERIEMANNGW(/;"	s
ERIEMANNWW	f77src/eriemann_ww.f	/^      SUBROUTINE ERIEMANNWW(/;"	s
ERRORESTIMATION	IoData.h	/^  enum TimeStepCalculation {CFL = 0, ERRORESTIMATION = 1} timeStepCalculation;$/;"	e	enum:TsData::TimeStepCalculation
ETREE	arpack++/include/arlutil.h	/^    ETREE,   \/* compute column etree *\/$/;"	e	enum:__anon51
EULER	EmbeddedTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	e	enum:EmbeddedTsDesc::Type
EULER	IoData.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} type;$/;"	e	enum:EquationsData::Type
EULER	MultiPhysicsTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	e	enum:MultiPhysicsTsDesc::Type
EUPP_ERROR	arpack++/include/arerror.h	/^    EUPP_ERROR          = -292,$/;"	e	enum:ArpackError::ErrorCode
EXACT	IoData.h	/^  enum FluxFcnJacobian {FINITE_DIFFERENCE = 0, APPROXIMATE = 1, EXACT = 2} ffjacobian;$/;"	e	enum:ImplicitData::FluxFcnJacobian
EXACT_RIEMANN	IoData.h	/^  enum Reconstruction {CONSTANT = 0, EXACT_RIEMANN = 1} reconstruction;$/;"	e	enum:BcsWallData::Reconstruction
EXACT_UPDATES_FALSE	IoData.h	/^  enum PreprocessForExactUpdates {EXACT_UPDATES_FALSE = 0, EXACT_UPDATES_TRUE = 1} preprocessForExactUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForExactUpdates
EXACT_UPDATES_TRUE	IoData.h	/^  enum PreprocessForExactUpdates {EXACT_UPDATES_FALSE = 0, EXACT_UPDATES_TRUE = 1} preprocessForExactUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForExactUpdates
EXCHANGE_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	/^template<class T,class ENABLE=void> struct EXCHANGE_HELPER$/;"	s	namespace:PhysBAM
EXCHANGE_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	/^template<class T> struct EXCHANGE_HELPER<T,typename ENABLE_IF<IS_ARRAY<T>::value>::TYPE>$/;"	s	namespace:PhysBAM
EXE	tools/Makefile	/^EXE        = ..\/bin\/$(PREFIX).$(THESYS)$/;"	m
EXPLICIT	IoData.h	/^  enum Type {EXPLICIT = 0, IMPLICIT = 1} type;$/;"	e	enum:TsData::Type
EXPLICIT_RK2	IoData.h	/^                IMPLICIT_CURRENT_CFG = 6, IMPLICIT_LATEST_CFG = 7, EXPLICIT_RK2 = 8} normals;$/;"	e	enum:DGCLData::Normals
EXPLICIT_RK2_VEL	IoData.h	/^                   IMPLICIT_IMPOSED_THREE_POINT_BDF_VEL = 5, IMPLICIT_ZERO = 6, EXPLICIT_RK2_VEL = 7} velocities;$/;"	e	enum:DGCLData::Velocities
EXTENDEDVANALBADA	IoData.h	/^                EXTENDEDVANALBADA = 5} limiter;$/;"	e	enum:SchemeData::Limiter
EXTERNAL	IoData.h	/^  enum SurrogateInterface{HYBRID = 0, EXTERNAL = 1} surrogateinterface;$/;"	e	enum:EmbeddedFramework::SurrogateInterface
EXTERNAL	IoData.h	/^  enum Type {EXTERNAL = 0, INTERNAL = 1} type;$/;"	e	enum:BcsFreeStreamData::Type
EXTRAPOLATION	IoData.h	/^  enum TypePhaseChange {ASIS = 0, RIEMANN_SOLUTION = 1, EXTRAPOLATION = 2} typePhaseChange;$/;"	e	enum:MultiFluidData::TypePhaseChange
EXTRAPOLATIONFIRSTORDER	IoData.h	/^  enum InterfaceExtrapolation {EXTRAPOLATIONFIRSTORDER=0, EXTRAPOLATIONSECONDORDER=1, AUTO=2} interfaceExtrapolation;$/;"	e	enum:MultiFluidData::InterfaceExtrapolation
EXTRAPOLATIONSECONDORDER	IoData.h	/^  enum InterfaceExtrapolation {EXTRAPOLATIONFIRSTORDER=0, EXTRAPOLATIONSECONDORDER=1, AUTO=2} interfaceExtrapolation;$/;"	e	enum:MultiFluidData::InterfaceExtrapolation
EdgeDef	SubDomain.h	/^  EdgeDef() { }$/;"	f	struct:EdgeDef
EdgeDef	SubDomain.h	/^  EdgeDef(const EdgeDef& oth) : glLeft(oth.glLeft), glRight(oth.glRight),$/;"	f	struct:EdgeDef
EdgeDef	SubDomain.h	/^  EdgeDef(int glLeft, int glRight, int edgeNum, $/;"	f	struct:EdgeDef
EdgeDef	SubDomain.h	/^struct EdgeDef {$/;"	s
EdgeGalerkin	EdgeGalerkin.h	/^class EdgeGalerkin {$/;"	c
EdgeGalerkin	EdgeGalerkinCore.C	/^EdgeGalerkin::EdgeGalerkin(IoData &ioData, Domain *domain) : $/;"	f	class:EdgeGalerkin
EdgeGrad	EdgeGrad.C	/^EdgeGrad<dim>::EdgeGrad(IoData& iod)$/;"	f	class:EdgeGrad
EdgeGrad	EdgeGrad.h	/^class EdgeGrad {$/;"	c
EdgePair	IntersectorFRG/IntersectorFRG.C	/^typedef pair<iipair, ibpair> EdgePair;$/;"	t	file:
EdgePair	IntersectorFRG/IntersectorFRG.h	/^  typedef pair<iipair, ibpair> EdgePair;$/;"	t	class:DistIntersectorFRG
EdgePair	IntersectorPhysBAM/IntersectorPhysBAM.C	/^typedef pair<iipair, ibpair> EdgePair;$/;"	t	file:
EdgePair	IntersectorPhysBAM/IntersectorPhysBAM.h	/^  typedef pair<iipair, ibpair> EdgePair;$/;"	t	class:DistIntersectorPhysBAM
EdgeSet	Edge.h	/^class EdgeSet {$/;"	c
EdgeSet	EdgeCore.C	/^EdgeSet::EdgeSet()$/;"	f	class:EdgeSet
Edge_Edge_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    bool Edge_Edge_Collision(const POINT_2D<T>& point,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,2>&> V_edges,const T dt,const T collision_thickness,T& collision_time,$/;"	f	class:PhysBAM::POINT_2D
Edge_Edge_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Edge_Edge_Collision(const SEGMENT_3D<T>& segment,const TV& v1,const TV& v2,const TV& v3,const TV& v4,const T dt,const T collision_thickness,T& collision_time,TV& normal,$/;"	f	class:SEGMENT_3D
Edge_Edge_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    bool Edge_Edge_Collision(const SEGMENT_3D<T>& segment,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,4>&> V_edges,const T dt,const T collision_thickness,T& collision_time,$/;"	f	class:PhysBAM::SEGMENT_3D
Edge_Edge_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/EDGE_EDGE_COLLISION.cpp	/^Edge_Edge_Collision(const POINT_2D<T>& pt,const POINT_2D<T>& point,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,2>&> V_edges,const T dt,const T collision_thickness,T& collision_time,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Edge_Edge_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/EDGE_EDGE_COLLISION.cpp	/^Edge_Edge_Collision(const SEGMENT_3D<T>& seg_fault,const SEGMENT_3D<T>& segment,const VECTOR<T,3>& v1,const VECTOR<T,3>& v2,const VECTOR<T,3>& v3,const VECTOR<T,3>& v4,const T dt,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Edge_Edge_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    bool Edge_Edge_Interaction(const POINT_2D<T>& point,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,2>&> V_edges,const T interaction_distance,$/;"	f	class:PhysBAM::POINT_2D
Edge_Edge_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    bool Edge_Edge_Interaction(const POINT_2D<T>& point,const T interaction_distance,T& distance,VECTOR<T,2>& normal) const$/;"	f	class:PhysBAM::POINT_2D
Edge_Edge_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Edge_Edge_Interaction(const SEGMENT_3D<T>& segment,const T interaction_distance,T& distance,VECTOR<T,3>& normal,VECTOR<T,2>& weights,bool allow_negative_weights) const$/;"	f	class:SEGMENT_3D
Edge_Edge_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Edge_Edge_Interaction(const SEGMENT_3D<T>& segment,const TV& v1,const TV& v2,const TV& v3,const TV& v4,const T interaction_distance,$/;"	f	class:SEGMENT_3D
Edge_Edge_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    bool Edge_Edge_Interaction(const SEGMENT_3D<T>& segment,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,4>&> V_edges,const T interaction_distance,T& distance,VECTOR<T,3>& normal,$/;"	f	class:PhysBAM::SEGMENT_3D
Edge_Edge_Interaction_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    void Edge_Edge_Interaction_Data(const POINT_2D<T>& point,const TV& v1,const TV& v2,const T& distance,TV& normal,const T small_number) const$/;"	f	class:PhysBAM::POINT_2D
Edge_Edge_Interaction_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Edge_Edge_Interaction_Data(const SEGMENT_3D<T>& segment,const TV& v1,const TV& v2,const TV& v3,const TV& v4,const T& distance,$/;"	f	class:SEGMENT_3D
Edge_Edge_Interaction_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    void Edge_Edge_Interaction_Data(const SEGMENT_3D<T>& segment,const INDIRECT_ARRAY<T_ARRAY,VECTOR<int,4>&> V_edges,const T& distance,VECTOR<T,3>& normal,const VECTOR<T,2>& weights,$/;"	f	class:PhysBAM::SEGMENT_3D
Edge_Lengths	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Edge_Lengths() const$/;"	f	class:PhysBAM::RANGE
Edge_Neighbors	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    bool Edge_Neighbors(const int triangle1,const int triangle2) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
Eig	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	e	enum:DataCompressionData::PODMethod
EigValI	arpack++/include/arrseig.h	/^  ARFLOAT *EigValI;   \/\/ Imaginary part of eigenvalues (nonsymmetric problems).$/;"	m	class:ARrcStdEig
EigValR	arpack++/include/arrseig.h	/^  ARTYPE  *EigValR;   \/\/ Eigenvalues (real part only if problem is nonsymmetric).$/;"	m	class:ARrcStdEig
EigVec	arpack++/include/arrseig.h	/^  ARTYPE  *EigVec;    \/\/ Eigenvectors.$/;"	m	class:ARrcStdEig
EigenValVectors	arpack++/include/arrscomp.h	/^EigenValVectors(arcomplex<ARFLOAT>* &EigVecp, arcomplex<ARFLOAT>* &EigValp,$/;"	f	class:ARrcCompStdEig
EigenValVectors	arpack++/include/arrsnsym.h	/^EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValRp,$/;"	f	class:ARrcNonSymStdEig
EigenValVectors	arpack++/include/arrssym.h	/^EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, bool ischur)$/;"	f	class:ARrcSymStdEig
Eigenvalue	arpack++/include/arrscomp.h	/^inline arcomplex<ARFLOAT> ARrcCompStdEig<ARFLOAT>::Eigenvalue(int i)$/;"	f	class:ARrcCompStdEig
Eigenvalue	arpack++/include/arrsnsym.h	/^inline arcomplex<ARFLOAT> ARrcNonSymStdEig<ARFLOAT>::Eigenvalue(int i)$/;"	f	class:ARrcNonSymStdEig
Eigenvalue	arpack++/include/arrssym.h	/^inline ARFLOAT ARrcSymStdEig<ARFLOAT>::Eigenvalue(int i)$/;"	f	class:ARrcSymStdEig
EigenvalueImag	arpack++/include/arrsnsym.h	/^inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>::EigenvalueImag(int i)$/;"	f	class:ARrcNonSymStdEig
EigenvalueReal	arpack++/include/arrsnsym.h	/^inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>::EigenvalueReal(int i)$/;"	f	class:ARrcNonSymStdEig
Eigenvalues	arpack++/include/arrscomp.h	/^Eigenvalues(arcomplex<ARFLOAT>* &EigValp, bool ivec, bool ischur)$/;"	f	class:ARrcCompStdEig
Eigenvalues	arpack++/include/arrsnsym.h	/^Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp, bool ivec, bool ischur)$/;"	f	class:ARrcNonSymStdEig
Eigenvalues	arpack++/include/arrssym.h	/^Eigenvalues(ARFLOAT* &EigValp, bool ivec, bool ischur)$/;"	f	class:ARrcSymStdEig
EigenvaluesFound	arpack++/include/arrseig.h	/^  bool EigenvaluesFound() { return ValuesOK; }$/;"	f	class:ARrcStdEig
Eigenvector	arpack++/include/arrscomp.h	/^Eigenvector(int i, int j)$/;"	f	class:ARrcCompStdEig
Eigenvector	arpack++/include/arrsnsym.h	/^Eigenvector(int i, int j)$/;"	f	class:ARrcNonSymStdEig
Eigenvector	arpack++/include/arrssym.h	/^inline ARFLOAT ARrcSymStdEig<ARFLOAT>::Eigenvector(int i, int j)$/;"	f	class:ARrcSymStdEig
EigenvectorImag	arpack++/include/arrsnsym.h	/^inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>::EigenvectorImag(int i, int j)$/;"	f	class:ARrcNonSymStdEig
EigenvectorReal	arpack++/include/arrsnsym.h	/^inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>::EigenvectorReal(int i, int j)$/;"	f	class:ARrcNonSymStdEig
Eigenvectors	arpack++/include/arrseig.h	/^Eigenvectors(ARTYPE* &EigVecp, bool ischur)$/;"	f	class:ARrcStdEig
EigenvectorsFound	arpack++/include/arrseig.h	/^  bool EigenvectorsFound() { return VectorsOK; }$/;"	f	class:ARrcStdEig
Eight_Four_Sum	utils/Predicate.C	294;"	d	file:
Eight_One_Sum	utils/Predicate.C	282;"	d	file:
Eight_Two_Sum	utils/Predicate.C	287;"	d	file:
Elem	Elem.h	/^class Elem {$/;"	c
ElemDummy	Elem.h	/^class ElemDummy :  public Elem {$/;"	c
ElemForceCalcValid	SubDomain.C	/^class ElemForceCalcValid {$/;"	c	file:
ElemHelper_Scalar_dim_neq	Elem.h	/^class ElemHelper_Scalar_dim_neq : public GenElemHelper_Scalar_dim_neq {$/;"	c
ElemHelper_dim	Elem.h	/^class ElemHelper_dim : public GenElemHelper_dim {$/;"	c
ElemHelper_dim_obj	Elem.h	/^class ElemHelper_dim_obj : public GenElemHelper_dim_obj {$/;"	c
ElemSearchValid	SubDomainCore.C	/^class ElemSearchValid {$/;"	c	file:
ElemSet	Elem.h	/^  ElemSet() : elems(NULL) { }$/;"	f	class:ElemSet
ElemSet	Elem.h	/^class ElemSet {$/;"	c
ElemSet	ElemCore.C	/^ElemSet::ElemSet(int value)  $/;"	f	class:ElemSet
ElemTet	ElemTet.h	/^  ElemTet() { volume_id = 0; }$/;"	f	class:ElemTet
ElemTet	ElemTet.h	/^class ElemTet : public ElemDummy {$/;"	c
ElemToElem	SubDomain.h	/^  Connectivity *ElemToElem;$/;"	m	class:SubDomain
ElemWrapper_Scalar_dim_neq	Elem.h	/^  ElemWrapper_Scalar_dim_neq(Target *tt) : t(tt) { };$/;"	f	class:ElemWrapper_Scalar_dim_neq
ElemWrapper_Scalar_dim_neq	Elem.h	/^class  ElemWrapper_Scalar_dim_neq : public $/;"	c
ElemWrapper_dim	Elem.h	/^  ElemWrapper_dim(Target *tt) : t(tt) { };$/;"	f	class:ElemWrapper_dim
ElemWrapper_dim	Elem.h	/^class  ElemWrapper_dim : public GenElemWrapper_dim<dim> {$/;"	c
ElemWrapper_dim_obj	Elem.h	/^  ElemWrapper_dim_obj(Target *tt) : t(tt) { };$/;"	f	class:ElemWrapper_dim_obj
ElemWrapper_dim_obj	Elem.h	/^class  ElemWrapper_dim_obj : public $/;"	c
Element	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	g	struct:DefoMeshMotionData
Element_Lower	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T& Element_Lower(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Lower	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    const T& Element_Lower(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Lower	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T& Element_Lower(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Lower	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    const T& Element_Lower(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Upper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T& Element_Upper(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Upper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    const T& Element_Upper(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Upper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T& Element_Upper(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Element_Upper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    const T& Element_Upper(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Elements_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool Elements_Equal() const$/;"	f	class:PhysBAM::VECTOR
Elements_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool Elements_Equal() const$/;"	f	class:PhysBAM::VECTOR
Elements_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool Elements_Equal() const$/;"	f	class:PhysBAM::VECTOR
Elements_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool Elements_Equal() const$/;"	f	class:PhysBAM::VECTOR
EmbeddedALEMeshMotionHandler	MeshMotionHandler.h	/^class EmbeddedALEMeshMotionHandler : public MeshMotionHandler {$/;"	c
EmbeddedALEMeshMotionHandler	MeshMotionHandlerCore.C	/^EmbeddedALEMeshMotionHandler::EmbeddedALEMeshMotionHandler(IoData &iod, Domain *dom,$/;"	f	class:EmbeddedALEMeshMotionHandler
EmbeddedALETetMeshMotionSolver	MeshMotionSolver.C	/^EmbeddedALETetMeshMotionSolver::EmbeddedALETetMeshMotionSolver$/;"	f	class:EmbeddedALETetMeshMotionSolver
EmbeddedALETetMeshMotionSolver	MeshMotionSolver.h	/^class EmbeddedALETetMeshMotionSolver : public TetMeshMotionSolver {$/;"	c
EmbeddedAlternatingLeastSquare	EmbeddedAlternatingLeastSquare.C	/^EmbeddedAlternatingLeastSquare<dim>::EmbeddedAlternatingLeastSquare(Communicator *_com, IoData &_ioData,$/;"	f	class:EmbeddedAlternatingLeastSquare
EmbeddedAlternatingLeastSquare	EmbeddedAlternatingLeastSquare.h	/^class EmbeddedAlternatingLeastSquare : public NonlinearRom<dim> {$/;"	c
EmbeddedAlternatingLeastSquareData	AlternatingLeastSquare/als_io.cpp	/^EmbeddedAlternatingLeastSquareData::EmbeddedAlternatingLeastSquareData() {$/;"	f	class:EmbeddedAlternatingLeastSquareData
EmbeddedAlternatingLeastSquareData	AlternatingLeastSquare/als_io.h	/^struct EmbeddedAlternatingLeastSquareData {$/;"	s
EmbeddedAlternatingLeastSquareData	IoData.h	/^struct EmbeddedAlternatingLeastSquareData {$/;"	s
EmbeddedAlternatingLeastSquareData	IoDataCore.C	/^EmbeddedAlternatingLeastSquareData::EmbeddedAlternatingLeastSquareData() {$/;"	f	class:EmbeddedAlternatingLeastSquareData
EmbeddedCorotSolver	EmbeddedCorotSolver.C	/^EmbeddedCorotSolver::EmbeddedCorotSolver(IoData &iodata, MatchNodeSet **mns, Domain *dom, double *Xstruct, int nNodes, int (*structElem)[3])$/;"	f	class:EmbeddedCorotSolver
EmbeddedCorotSolver	EmbeddedCorotSolver.h	/^class EmbeddedCorotSolver {$/;"	c
EmbeddedDiffExpr	DistEmbeddedVector.h	/^    EmbeddedDiffExpr(const T1& _x, const T2& _y) : x(_x), y(_y),$/;"	f	class:EmbeddedDiffExpr
EmbeddedDiffExpr	DistEmbeddedVector.h	/^class EmbeddedDiffExpr : public EmbeddedExpr< EmbeddedDiffExpr<T1,T2,Scalar> , Scalar> {$/;"	c
EmbeddedExpr	DistEmbeddedVector.h	/^    EmbeddedExpr(const T& _x) : x(_x) { }$/;"	f	class:EmbeddedExpr
EmbeddedExpr	DistEmbeddedVector.h	/^class EmbeddedExpr {$/;"	c
EmbeddedFluidShapeOptimizationHandler	EmbeddedFluidShapeOptimizationHandler.C	/^EmbeddedFluidShapeOptimizationHandler<dim>::EmbeddedFluidShapeOptimizationHandler$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
EmbeddedFluidShapeOptimizationHandler	EmbeddedFluidShapeOptimizationHandler.h	/^class EmbeddedFluidShapeOptimizationHandler : public ImplicitEmbeddedCoupledTsDesc<dim> {$/;"	c
EmbeddedFramework	IoData.h	/^struct EmbeddedFramework { $/;"	s
EmbeddedFramework	IoDataCore.C	/^EmbeddedFramework::EmbeddedFramework() {$/;"	f	class:EmbeddedFramework
EmbeddedFramework	Manual/Aerof3d.html	/^<a name="EmbeddedFramework"><\/a>$/;"	a
EmbeddedMeshMotionHandler	MeshMotionHandler.h	/^class EmbeddedMeshMotionHandler : public MeshMotionHandler {  \/\/<! For embedded fluid-structure interactions$/;"	c
EmbeddedMeshMotionHandler	MeshMotionHandlerCore.C	/^EmbeddedMeshMotionHandler::EmbeddedMeshMotionHandler(IoData &iod, Domain *dom, DynamicNodalTransfer *dnTran,$/;"	f	class:EmbeddedMeshMotionHandler
EmbeddedScaleExpr	DistEmbeddedVector.h	/^    EmbeddedScaleExpr(const T& _x, Scalar _a) : x(_x), a(_a),$/;"	f	class:EmbeddedScaleExpr
EmbeddedScaleExpr	DistEmbeddedVector.h	/^class EmbeddedScaleExpr : public EmbeddedExpr< EmbeddedScaleExpr<T,Scalar> , Scalar> {$/;"	c
EmbeddedStructure	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::EmbeddedStructure(IoData& iod, Communicator &comm, Communicator &strCom, Timer *tim) : com(comm), $/;"	f	class:EmbeddedStructure
EmbeddedStructure	FSI/DynamicNodalTransfer.h	/^class EmbeddedStructure {$/;"	c
EmbeddedSumExpr	DistEmbeddedVector.h	/^    EmbeddedSumExpr(const T1& _x, const T2& _y) : x(_x), y(_y), $/;"	f	class:EmbeddedSumExpr
EmbeddedSumExpr	DistEmbeddedVector.h	/^class EmbeddedSumExpr : public EmbeddedExpr< EmbeddedSumExpr<T1,T2,Scalar> , Scalar> {$/;"	c
EmbeddedTsDesc	EmbeddedTsDesc.C	/^EmbeddedTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:EmbeddedTsDesc
EmbeddedTsDesc	EmbeddedTsDesc.h	/^class EmbeddedTsDesc : public TsDesc<dim> , ForceGenerator<dim> {$/;"	c
Empty	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    bool Empty() const$/;"	f	class:PhysBAM::STACK
Empty	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Empty() const$/;"	f	class:PhysBAM::INTERVAL
Empty	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Empty() const$/;"	f	class:PhysBAM::RANGE
Empty_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Empty_Box()$/;"	f	class:PhysBAM::INTERVAL
Empty_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Empty_Box()$/;"	f	class:PhysBAM::RANGE
Ends_With	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^bool Ends_With(const std::string& input,const std::string& test)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
EnergyOnly	IoData.h	/^  enum EnergyOnly {ENERGY_ONLY_FALSE = 0, ENERGY_ONLY_TRUE = 1} energyOnly;$/;"	g	struct:DataCompressionData
Eng_Test	DistDynamicLESTerm.h	/^  DistSVec<double,8> *Eng_Test;$/;"	m	class:DistDynamicLESTerm
Enlarge_By_Sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_By_Sign(const TV& v)$/;"	f	class:PhysBAM::RANGE
Enlarge_Nonempty_Box_To_Include_Point	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_Nonempty_Box_To_Include_Point(const T& point)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_Nonempty_Box_To_Include_Point	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_Nonempty_Box_To_Include_Point(const TV& point)$/;"	f	class:PhysBAM::RANGE
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const T& p1,const T& p2)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const T& p1,const T& p2,const T& p3)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const T_ARRAY& points)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const TV& p1,const TV& p2)$/;"	f	class:PhysBAM::RANGE
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const TV& p1,const TV& p2,const TV& p3)$/;"	f	class:PhysBAM::RANGE
Enlarge_Nonempty_Box_To_Include_Points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_Nonempty_Box_To_Include_Points(const T_ARRAY& points)$/;"	f	class:PhysBAM::RANGE
Enlarge_To_Include_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_To_Include_Box(const INTERVAL& interval)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_To_Include_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_To_Include_Box(const RANGE<TV>& box)$/;"	f	class:PhysBAM::RANGE
Enlarge_To_Include_Point	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Enlarge_To_Include_Point(const T& point)$/;"	f	class:PhysBAM::INTERVAL
Enlarge_To_Include_Point	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Enlarge_To_Include_Point(const TV& point)$/;"	f	class:PhysBAM::RANGE
Entries	arpack++/include/ardfmat.h	/^  ARTYPE* Entries() const { return val; }$/;"	f	class:ARdfMatrix
Entries	arpack++/include/arhbmat.h	/^  ARTYPE* Entries() { return val; }$/;"	f	class:ARhbMatrix
EpsFormula	IoData.h	/^  enum EpsFormula {CONSTANT = 0, EISENSTADT = 1} epsFormula;$/;"	g	struct:KspData
Equal_Dimensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static bool Equal_Dimensions(const T_ARRAY1& a,const T_ARRAY2& b)$/;"	f	class:PhysBAM::ARRAY_BASE
Equal_Dimensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static bool Equal_Dimensions(const ARRAY_BASE& a,const ARRAY_BASE<T2,ARRAYS_ND_BASE,TV_INT>& b)$/;"	f	class:PhysBAM::ARRAY_BASE
Equal_Dimensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static bool Equal_Dimensions(const ARRAY_BASE& a,const int m_start,const int m_end)$/;"	f	class:PhysBAM::ARRAY_BASE
Equal_Dimensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static bool Equal_Dimensions(const ARRAY_BASE& a,const int m_start,const int m_end,const int n_start,const int n_end)$/;"	f	class:PhysBAM::ARRAY_BASE
Equal_Dimensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static bool Equal_Dimensions(const ARRAY_BASE& a,const int m_start,const int m_end,const int n_start,const int n_end,const int mn_start,const int mn_end)$/;"	f	class:PhysBAM::ARRAY_BASE
Equations	Manual/Aerof3d.html	/^<a name="Equations"><\/a>$/;"	a
EquationsData	IoData.h	/^struct EquationsData {$/;"	s
EquationsData	IoDataCore.C	/^EquationsData::EquationsData()$/;"	f	class:EquationsData
Equivalent_Oriented_Triangles	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    static bool Equivalent_Oriented_Triangles(const int tri1_a,const int tri1_b,const int tri1_c,const int tri2_a,const int tri2_b,const int tri2_c)$/;"	f	class:PhysBAM::TRIANGLE_MESH
Equivalent_Triangles	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    static bool Equivalent_Triangles(const int tri1_a,const int tri1_b,const int tri1_c,const int tri2_a,const int tri2_b,const int tri2_c)$/;"	f	class:PhysBAM::TRIANGLE_MESH
Error	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	g	struct:ErrorHandler
ErrorCode	arpack++/include/arerror.h	/^  enum ErrorCode {  \/\/ Listing all kinds of errors.$/;"	g	class:ArpackError
ErrorHandler	ErrorHandler.h	/^  ErrorHandler(Communicator *comIn){$/;"	f	struct:ErrorHandler
ErrorHandler	ErrorHandler.h	/^struct ErrorHandler{$/;"	s
ErrorIndicator	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	g	struct:LinearizedData
EulerF	OneDimensionalSolver.C	/^void OneDimensional::EulerF(double t, SVec<double,5>& y,SVec<double,5>& k) {$/;"	f	class:OneDimensional
EulerSource	OneDimensionalSolver.C	/^  EulerSource(VarFcn* _vf,Vec<int>& _fid) :  vf(_vf), fid(_fid) { }$/;"	f	class:EulerSource
EulerSource	OneDimensionalSolver.C	/^class EulerSource {$/;"	c	file:
Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Euler_Angles(T& euler_angle_x,T& euler_angle_y,T& euler_angle_z) const$/;"	f	class:ROTATION
Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Euler_Angles() const$/;"	f	class:PhysBAM::ROTATION
Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    VECTOR<T,0> Euler_Angles() const$/;"	f	class:PhysBAM::ROTATION
Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    VECTOR<T,1> Euler_Angles() const$/;"	f	class:PhysBAM::ROTATION
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    void Euler_Step(const T_INDICES& indices,const ARRAY<TV>& F,const ARRAY<T>& mass,const T dt)$/;"	f	class:PhysBAM::GEOMETRY_PARTICLES
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    void Euler_Step(const T_INDICES& indices,const T dt)$/;"	f	class:PhysBAM::GEOMETRY_PARTICLES
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    void Euler_Step(const T_INDICES& indices,const ARRAY<TV>& V,const T dt)$/;"	f	class:PhysBAM::POINT_CLOUD
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^    static void Euler_Step(const ARRAY<TV>& V,const ARRAY<TV>& F,const ARRAY<typename TV::SCALAR>& mass,const typename TV::SCALAR dt)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^    static void Euler_Step(const ARRAY<TV>& X,ARRAY<TV>& V,const typename TV::SCALAR dt)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^    static void Euler_Step(const T_INDICES& indices,ARRAY<TV>& V,const ARRAY<TV>& F,const ARRAY<typename TV::SCALAR>& mass,const typename TV::SCALAR dt)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Euler_Step	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^    static void Euler_Step(const T_INDICES& indices,const ARRAY<TV>& X,ARRAY<TV>& V,const typename TV::SCALAR dt)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Eupp	arpack++/include/arrscomp.h	/^inline void ARrcCompStdEig<ARFLOAT>::Eupp()$/;"	f	class:ARrcCompStdEig
Eupp	arpack++/include/arrseig.h	/^  virtual void Eupp() {$/;"	f	class:ARrcStdEig
Eupp	arpack++/include/arrsnsym.h	/^inline void ARrcNonSymStdEig<ARFLOAT>::Eupp()$/;"	f	class:ARrcNonSymStdEig
Eupp	arpack++/include/arrssym.h	/^inline void ARrcSymStdEig<ARFLOAT>::Eupp()$/;"	f	class:ARrcSymStdEig
EuppError	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::EuppError()$/;"	f	class:ARrcStdEig
Eval	OneDimensionalSolver.h	/^    void Eval(int node, const double* loc,double* f) {$/;"	f	class:OneDimensional::Veval
EvaluateSHSatProbes	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::EvaluateSHSatProbes$/;"	f	class:KirchhoffIntegrator
ExactRiemannSolver	ExactRiemannSolver.C	/^ExactRiemannSolver<dim>::ExactRiemannSolver(IoData &iod, SVec<double,dim> &_rupdate,$/;"	f	class:ExactRiemannSolver
ExactRiemannSolver	ExactRiemannSolver.h	/^class ExactRiemannSolver{$/;"	c
ExactSolution	ExactSolution.h	/^class ExactSolution {$/;"	c
ExactSolution	IoData.h	/^  enum ExactSolution {OFF_EXACTSOLUTION = 0, ON_EXACTSOLUTION = 1} excsol;$/;"	g	struct:SensitivityAnalysis
Exact_Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Exact_Resize(const ID m_new,const bool initialize_new_elements=true) \/\/ zero elbow room$/;"	f	class:PhysBAM::ARRAY
ExampleForcedOscillationsComputation	Manual/Aerof3d.html	/^<a name="ExampleForcedOscillationsComputation"><\/a>$/;"	a
ExampleSteadyFlowComputation	Manual/Aerof3d.html	/^<a name="ExampleSteadyFlowComputation"><\/a>$/;"	a
ExampleUnsteadyAeroelasticComputation	Manual/Aerof3d.html	/^<a name="ExampleUnsteadyAeroelasticComputation"><\/a>$/;"	a
ExampleUnsteadyFlowComputation	Manual/Aerof3d.html	/^<a name="ExampleUnsteadyFlowComputation"><\/a>$/;"	a
Examples	Manual/Aerof3d.html	/^<a name="Examples"><\/a>$/;"	a
Exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    void Exchange(ARRAY_VIEW& other)$/;"	f	class:PhysBAM::ARRAY_VIEW
Exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Exchange(const TK& x,const TK& y) \/\/ Exchange values at entries x and y; valid if x or y (or both) are not present; efficient for array values$/;"	f	class:PhysBAM::HASHTABLE
Exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Exchange(STACK& stack)$/;"	f	class:PhysBAM::STACK
Exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	/^    static void Exchange(T& a,T& b)$/;"	f	struct:PhysBAM::EXCHANGE_HELPER
Exchange_Arrays	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Exchange_Arrays(ARRAY<T,ID>& a,ARRAY<T,ID>& b)$/;"	f	class:PhysBAM::ARRAY
Exchange_Arrays	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    static void Exchange_Arrays(ARRAY_VIEW& array1,ARRAY_VIEW& array2)$/;"	f	class:PhysBAM::ARRAY_VIEW
Exchange_Hashtables	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    static void Exchange_Hashtables(HASHTABLE& hash1,HASHTABLE& hash2)$/;"	f	class:PhysBAM::HASHTABLE
ExpandA	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::ExpandA()$/;"	f	class:ARbdNonSymMatrix
ExpandA	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::ExpandA()$/;"	f	class:ARbdSymMatrix
ExpandA	arpack++/include/arlsmat.h	/^ExpandA(NCformat& A, NCformat& Aexp, ARTYPE sigma)$/;"	f	class:ARluSymMatrix
ExpandA	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::ExpandA(ARTYPE sigma)$/;"	f	class:ARumSymMatrix
ExpandAsB	arpack++/include/arlspen.h	/^void ARluSymPencil<ARTYPE>::ExpandAsB(int n, NCformat& AsB)$/;"	f	class:ARluSymPencil
ExpandAsB	arpack++/include/aruspen.h	/^void ARumSymPencil<ARTYPE>::ExpandAsB()$/;"	f	class:ARumSymPencil
Explicit	Manual/Aerof3d.html	/^<a name="Explicit"><\/a>$/;"	a
ExplicitData	IoData.h	/^struct ExplicitData {$/;"	s
ExplicitData	IoDataCore.C	/^ExplicitData::ExplicitData()$/;"	f	class:ExplicitData
ExplicitEmbeddedTsDesc	ExplicitEmbeddedTsDesc.C	/^ExplicitEmbeddedTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ExplicitEmbeddedTsDesc
ExplicitEmbeddedTsDesc	ExplicitEmbeddedTsDesc.h	/^class ExplicitEmbeddedTsDesc : public EmbeddedTsDesc<dim> {$/;"	c
ExplicitLevelSetTsDesc	ExplicitLevelSetTsDesc.C	/^ExplicitLevelSetTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ExplicitLevelSetTsDesc
ExplicitLevelSetTsDesc	ExplicitLevelSetTsDesc.h	/^class ExplicitLevelSetTsDesc : public LevelSetTsDesc<dim,dimLS> {$/;"	c
ExplicitMultiPhysicsTsDesc	ExplicitMultiPhysicsTsDesc.C	/^ExplicitMultiPhysicsTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ExplicitMultiPhysicsTsDesc
ExplicitMultiPhysicsTsDesc	ExplicitMultiPhysicsTsDesc.h	/^class ExplicitMultiPhysicsTsDesc : public MultiPhysicsTsDesc<dim,dimLS> {$/;"	c
ExplicitTsDesc	ExplicitTsDesc.C	/^ExplicitTsDesc<dim>::ExplicitTsDesc(IoData& ioData, GeoSource& geoSource, Domain* dom) $/;"	f	class:ExplicitTsDesc
ExplicitTsDesc	ExplicitTsDesc.h	/^class ExplicitTsDesc : public TsDesc<dim> {$/;"	c
Expr	Vector.h	/^  Expr(T v) : x(v) { len = x.size(); }$/;"	f	class:Expr
Expr	Vector.h	/^  Expr(T v, int l) : x(v) { len = l; }$/;"	f	class:Expr
Expr	Vector.h	/^class Expr {$/;"	c
Extended_Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> TV IMPLICIT_OBJECT<TV>::Extended_Normal(const TV& location,const int aggregate) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Extended_Phi	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Extended_Phi(const TV& location) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Extension	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    virtual std::string Extension() const {PHYSBAM_WARN_IF_NOT_OVERRIDDEN();return Static_Extension();}$/;"	f	class:PhysBAM::STRUCTURE
Extension_To_Factory	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    static FACTORY_BASE<T_BASE_OBJECT>* Extension_To_Factory(const std::string& extension)$/;"	f	class:PhysBAM::REGISTRY
Extract_Dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Extract_Dimension(const ARRAY_BASE& old_array,ARRAY_BASE<ELEMENT_OF_T,ARRAYS_ND_BASE,TV_INT>& extracted_array,int dim)$/;"	f	class:PhysBAM::ARRAY_BASE
Extract_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX<T,2> Extract_Rotation() const$/;"	f	class:PhysBAM::MATRIX
Extract_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX<T,3> Extract_Rotation() const$/;"	f	class:PhysBAM::MATRIX
ExtrapolateProlongation	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::ExtrapolateProlongation(int coarseLvl, DistSVec<Scalar2,dim>& coarseOld, $/;"	f	class:MultiGridKernel
ExtrapolateProlongation	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::ExtrapolateProlongation(MultiGridLevel<Scalar>& fineGrid, $/;"	f	class:MultiGridLevel
Extrapolation	Extrapolation.C	/^Extrapolation<dim>::Extrapolation(IoData& iod, VarFcn *varFcn) : vf(varFcn)$/;"	f	class:Extrapolation
Extrapolation	Extrapolation.h	/^class Extrapolation {$/;"	c
ExtrapolationNodeData	Extrapolation.h	/^  ExtrapolationNodeData() { tet = -1; face = -1; r = 0.0; t = 0.0; }$/;"	f	struct:ExtrapolationNodeData
ExtrapolationNodeData	Extrapolation.h	/^struct ExtrapolationNodeData {$/;"	s
Extrapolationdata	Extrapolation.h	/^  typedef ExtrapolationNodeData (*Extrapolationdata)[2];$/;"	t	class:Extrapolation
F	FSI/DynamicNodalTransfer.h	/^        SVec<double,3> F; \/\/TODO: need to be resit by resetOutputToStructure$/;"	m	class:DynamicNodalTransfer
F	FSI/DynamicNodalTransfer.h	/^  double (*F)[3]; \/\/force (received from fluid).$/;"	m	class:EmbeddedStructure
F	ImplicitRomTsDesc.h	/^  DistSVec<double, dim> F;	\/\/ residual$/;"	m	class:ImplicitRomTsDesc
F	MatVecProd.h	/^  DistSVec<double,dim> *F;$/;"	m	class:MatVecProdH2
F	MatVecProd.h	/^  DistSVec<double,dim> *F;$/;"	m	class:MatVecProd_dRdX
F	MatVecProd.h	/^  DistSVec<double,dim> F;$/;"	m	class:MatVecProdFDMultiPhase
F	MatVecProd.h	/^  DistSVec<double,dimLS> *F;$/;"	m	class:MatVecProdLS
F	MatVecProd.h	/^  DistSVec<double,neq> F;$/;"	m	class:MatVecProdFD
F	MeshMotionHandler.h	/^  DistSVec<double,3> F;$/;"	m	class:MeshMotionHandler
F	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
F	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
F	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
F	NewtonSolver.h	/^  typename ProblemDescriptor::SolVecType F;  \/\/ nonlinear function$/;"	m	class:NewtonSolver
F	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    struct UNUSABLE{void F(){}};$/;"	f	struct:PhysBAM::ELEMENT_ID::UNUSABLE
F	ProgrammedBurnCore.C	/^	double F(double rho) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
F	TsDesc.h	/^  DistSVec<double,dim> *F;$/;"	m	class:TsDesc
F0	MeshMotionHandler.h	/^  DistSVec<double,3> F0;$/;"	m	class:MeshMotionHandler
F0	MeshMotionSolver.h	/^  DistSVec<double,3> *F0;$/;"	m	class:TetMeshMotionSolver
F77NAME	LinkF77.h	3;"	d
F77NAME	LinkF77.h	5;"	d
F77NAME	arpack++/include/arch.h	65;"	d
F77NAME	arpack++/include/arch.h	69;"	d
F77_CALL	AlternatingLeastSquare/include/blas.h	8;"	d
F77_CALL_C	arpack++/include/arlnames.h	35;"	d
F77_CALL_C	arpack++/include/arlnames.h	39;"	d
F77_CALL_C	arpack++/include/arlnames.h	43;"	d
F77_CALL_C	arpack++/include/arlnames.h	47;"	d
F77_NAME	AlternatingLeastSquare/include/blas.h	9;"	d
FACT	arpack++/include/arlutil.h	/^    FACT,    \/* perform LU factorization *\/$/;"	e	enum:__anon51
FACTORY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^struct FACTORY:public FACTORY_BASE<T_BASE_OBJECT>$/;"	s	namespace:PhysBAM
FACTORY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^struct FACTORY_BASE$/;"	s	namespace:PhysBAM
FALSE	IoData.h	/^  enum ComputeForces {FALSE = 0, TRUE = 1 } computeForces;$/;"	e	enum:SurfaceData::ComputeForces
FALSE	IoData.h	/^  enum CopyCloseNodes {FALSE = 0, TRUE = 1} copyCloseNodes;$/;"	e	enum:MultiFluidData::CopyCloseNodes
FALSE	IoData.h	/^  enum InfRadius {FALSE = 0, TRUE = 1} infRadius;$/;"	e	enum:RotationData::InfRadius
FALSE	IoData.h	/^  enum PadeReconstruction {TRUE = 1, FALSE = 0} padeReconst;$/;"	e	enum:LinearizedData::PadeReconstruction
FALSE	arpack++/include/arlutil.h	50;"	d
FALSE_GS	IoData.h	/^  enum GramSchmidt {TRUE_GS = 1, FALSE_GS = 0} doGramSchmidt;$/;"	e	enum:LinearizedData::GramSchmidt
FALSE_HF	IoData.h	/^  enum ComputeHeatPower {FALSE_HF = 0, TRUE_HF = 1 } computeHeatFluxes;$/;"	e	enum:SurfaceData::ComputeHeatPower
FALSE_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct FALSE_TYPE {static const bool value=false;};$/;"	s	namespace:PhysBAM
FD	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:ImplicitData::Mvp
FD	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:SensitivityAnalysis::Mvp
FDResiduals	IoData.h	/^  enum FDResiduals {FD_RESIDUALS_OFF = 0, FD_RESIDUALS_ON = 1} fdResiduals;$/;"	g	struct:ROMOutputData
FDResidualsLimit	IoData.h	/^  enum FDResidualsLimit {FD_RESIDUALS_LIMIT_OFF = 0, FD_RESIDUALS_LIMIT_ON = 1} fdResidualsLimit;$/;"	g	struct:ROMOutputData
FD_RESIDUALS_LIMIT_OFF	IoData.h	/^  enum FDResidualsLimit {FD_RESIDUALS_LIMIT_OFF = 0, FD_RESIDUALS_LIMIT_ON = 1} fdResidualsLimit;$/;"	e	enum:ROMOutputData::FDResidualsLimit
FD_RESIDUALS_LIMIT_ON	IoData.h	/^  enum FDResidualsLimit {FD_RESIDUALS_LIMIT_OFF = 0, FD_RESIDUALS_LIMIT_ON = 1} fdResidualsLimit;$/;"	e	enum:ROMOutputData::FDResidualsLimit
FD_RESIDUALS_OFF	IoData.h	/^  enum FDResiduals {FD_RESIDUALS_OFF = 0, FD_RESIDUALS_ON = 1} fdResiduals;$/;"	e	enum:ROMOutputData::FDResiduals
FD_RESIDUALS_ON	IoData.h	/^  enum FDResiduals {FD_RESIDUALS_OFF = 0, FD_RESIDUALS_ON = 1} fdResiduals;$/;"	e	enum:ROMOutputData::FDResiduals
FE	ExplicitEmbeddedTsDesc.h	/^  bool FE;$/;"	m	class:ExplicitEmbeddedTsDesc
FE	ExplicitTsDesc.h	/^  bool FE; \/\/forward Euler$/;"	m	class:ExplicitTsDesc
FE	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	e	enum:MultiFluidData::RiemannComputation
FE	RKIntegrator.h	/^  enum Method { FE, RK2, RK4 };$/;"	e	enum:RKIntegrator::Method
FEMData_m	HigherOrderFSI.h	/^   V6NodeData (*FEMData_m);$/;"	m	class:HigherOrderFSI
FEMData_p	HigherOrderFSI.h	/^   V6NodeData (*FEMData_p);$/;"	m	class:HigherOrderFSI
FERR	arpack++/include/arlutil.h	/^    FERR,    \/* estimate error bounds after iterative refinement *\/$/;"	e	enum:__anon51
FE_GALERKIN	IoData.h	/^  enum AdvectiveOperator {FINITE_VOLUME = 0, FE_GALERKIN = 1} advectiveOperator;$/;"	e	enum:SchemeData::AdvectiveOperator
FF	IoData.h	/^  enum InterfaceType {FSF = 0, FF = 1, FSFandFF = 2} interfaceType;$/;"	e	enum:MultiFluidData::InterfaceType
FIELD_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    FIELD_COMPARE(T_FIELD T::*field_input)$/;"	f	struct:PhysBAM::FIELD_COMPARE
FIELD_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^struct FIELD_COMPARE$/;"	s	namespace:PhysBAM
FIELD_PROJECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^struct FIELD_PROJECTOR$/;"	s	namespace:PhysBAM
FILE_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	g	namespace:PhysBAM::FILE_UTILITIES
FILE_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^namespace FILE_UTILITIES{$/;"	n	namespace:PhysBAM	file:
FILE_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^namespace FILE_UTILITIES{$/;"	n	namespace:PhysBAM
FINITEDIFFERENCE	IoData.h	/^  enum SensitivityComputation {ANALYTICAL = 0, SEMIANALYTICAL = 1,  FINITEDIFFERENCE = 2} scFlag;$/;"	e	enum:SensitivityAnalysis::SensitivityComputation
FINITE_DIFFERENCE	IoData.h	/^  enum FluxFcnJacobian {FINITE_DIFFERENCE = 0, APPROXIMATE = 1, EXACT = 2} ffjacobian;$/;"	e	enum:ImplicitData::FluxFcnJacobian
FINITE_VOLUME	IoData.h	/^  enum AdvectiveOperator {FINITE_VOLUME = 0, FE_GALERKIN = 1} advectiveOperator;$/;"	e	enum:SchemeData::AdvectiveOperator
FIRST	IoData.h	/^  enum ViscousInterfaceOrder {FIRST = 0, SECOND = 1} viscousinterfaceorder;$/;"	e	enum:EmbeddedFramework::ViscousInterfaceOrder
FIRST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2=void,class T3=void,class T4=void> struct FIRST{typedef T1 TYPE;};$/;"	s	namespace:PhysBAM
FIRSTCOL_OF_SNODE	arpack++/include/arlutil.h	88;"	d
FIRSTORDER	IoData.h	/^  enum InterfaceTreatment {FIRSTORDER=0, SECONDORDER=1} interfaceTreatment;$/;"	e	enum:MultiFluidData::InterfaceTreatment
FIRST_ORDER	IoData.h	/^  enum FiniteDifferenceOrder {FIRST_ORDER = 1, SECOND_ORDER = 2} fdOrder; $/;"	e	enum:ImplicitData::FiniteDifferenceOrder
FIXEDUNSTEADY	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
FLIGHTDISPLACEMENT	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	e	enum:PostFcn::VectorType
FLOAT	arpack++/include/arlutil.h	/^    FLOAT,   \/* time spent in floating-point operations *\/$/;"	e	enum:__anon51
FLUID	IoData.h	/^  enum RiemannNormal {STRUCTURE = 0, FLUID = 1} riemannNormal;$/;"	e	enum:EmbeddedFramework::RiemannNormal
FLUID	IoData.h	/^  enum Type {FLUID = 0, POROUS = 1} type;$/;"	e	enum:VolumeData::Type
FLUIDID	PostFcn.h	/^                   SURFACE_HEAT_FLUX = 26, PRESSURECOEFFICIENT = 27, CONTROL_VOLUME = 28, FLUIDID = 29,$/;"	e	enum:PostFcn::ScalarType
FLUID_CMD_TAG	StructExc.C	20;"	d	file:
FLUID_ID	DomainCore.C	30;"	d	file:
FLUID_NUMPA_TAG	StructExc.C	17;"	d	file:
FORCED	IoData.h	/^  enum Type {DEFAULT = 0, ROM = 1, FORCED = 2} type;$/;"	e	enum:LinearizedData::Type
FORCED	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	e	enum:ProblemData::Type
FORCE_TAG	StructExc.C	11;"	d	file:
FORWARD_EULER	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	e	enum:ExplicitData::Type
FOURTOONE	IoData.h	/^  enum CoarseningRatio { TWOTOONE = 0, FOURTOONE = 1} coarseningRatio;$/;"	e	enum:MultiGridData::CoarseningRatio
FOUR_POINT_BDF	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	e	enum:ImplicitData::Type
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME()$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME(const TV& t,const ROTATION<TV>& r)$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    explicit FRAME(const MATRIX<T,d+1>& m_input)$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    explicit FRAME(const ROTATION<TV>& r)$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    explicit FRAME(const TV& t)$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    template<class T2> explicit FRAME(const FRAME<VECTOR<T2,d> >& f)$/;"	f	class:PhysBAM::FRAME
FRAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^class FRAME$/;"	c	namespace:PhysBAM
FREESTREAM	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	e	enum:TsData::Clipping
FREQUENCY	IoData.h	/^  enum Domain {TIME = 0, FREQUENCY = 1} domain;$/;"	e	enum:LinearizedData::Domain
FRG	IoData.h	/^  enum IntersectorName {PHYSBAM = 0, FRG = 1} intersectorName;$/;"	e	enum:EmbeddedFramework::IntersectorName
FSF	IoData.h	/^  enum InterfaceType {FSF = 0, FF = 1, FSFandFF = 2} interfaceType;$/;"	e	enum:MultiFluidData::InterfaceType
FSFandFF	IoData.h	/^  enum InterfaceType {FSF = 0, FF = 1, FSFandFF = 2} interfaceType;$/;"	e	enum:MultiFluidData::InterfaceType
FSI	IoData.h	/^  enum ProblemMode { MULTIFLUID=0, FSI=1} problemMode;$/;"	e	enum:OneDimensionalInfo::ProblemMode
FSI	OneDimensionalSolver.h	/^  enum ProblemMode { MultiFluid, FSI};$/;"	e	enum:OneDimensional::ProblemMode
FULL	IoData.h	/^  enum Integration {AUTO = 0, WALL_FUNCTION = 1, FULL = 2} integration;$/;"	e	enum:BcsWallData::Integration
FV3	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	e	enum:DESModelData::Form
FV3	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	e	enum:SAModelData::Form
FVMERS3PBDFSchme	IoData.h	/^  enum FVMERS3PBDFSchme { BDF_SCHEME1 = 1, BDF_SCHEME2 = 0 } fvmers_3pbdf;$/;"	g	struct:ImplicitData
Face	Face.h	/^class Face {$/;"	c
Face	FaceCore.C	/^Face::Face()$/;"	f	class:Face
FaceDummy	Face.h	/^class FaceDummy :  public Face {$/;"	c
FaceHelper_Scalar_dim_neq	Face.h	/^class FaceHelper_Scalar_dim_neq : public GenFaceHelper_Scalar_dim_neq {$/;"	c
FaceHelper_dim	Face.h	/^class FaceHelper_dim : public GenFaceHelper_dim {$/;"	c
FaceSet	Face.h	/^class FaceSet {$/;"	c
FaceSet	FaceCore.C	/^FaceSet::FaceSet(int value)$/;"	f	class:FaceSet
FaceTria	FaceTria.h	/^class FaceTria : public FaceDummy {$/;"	c
FaceWrapper_Scalar_dim_neq	Face.h	/^  FaceWrapper_Scalar_dim_neq(Target *tt) : t(tt) { };$/;"	f	class:FaceWrapper_Scalar_dim_neq
FaceWrapper_Scalar_dim_neq	Face.h	/^class  FaceWrapper_Scalar_dim_neq : public $/;"	c
FaceWrapper_dim	Face.h	/^  FaceWrapper_dim(Target *tt) : t(tt) { };$/;"	f	class:FaceWrapper_dim
FaceWrapper_dim	Face.h	/^class  FaceWrapper_dim : public GenFaceWrapper_dim<dim> {$/;"	c
Face_Reversed_In_Simplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    static bool Face_Reversed_In_Simplex(const VECTOR<int,2>& segment_nodes,const VECTOR<int,3>& triangle_nodes)$/;"	f	class:PhysBAM::TRIANGLE_MESH
Factor	DenseMatrix.C	/^GenFullM<Scalar>::Factor(double tol)$/;"	f	class:GenFullM
FactorA	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::FactorA()$/;"	f	class:ARbdNonSymMatrix
FactorA	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::FactorA()$/;"	f	class:ARbdSymMatrix
FactorA	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::FactorA()$/;"	f	class:ARdsNonSymMatrix
FactorA	arpack++/include/ardsmat.h	/^void ARdsSymMatrix<ARTYPE>::FactorA()$/;"	f	class:ARdsSymMatrix
FactorA	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::FactorA()$/;"	f	class:ARluNonSymMatrix
FactorA	arpack++/include/arlsmat.h	/^void ARluSymMatrix<ARTYPE>::FactorA()$/;"	f	class:ARluSymMatrix
FactorA	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::FactorA()$/;"	f	class:ARumNonSymMatrix
FactorA	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::FactorA()$/;"	f	class:ARumSymMatrix
FactorAsB	arpack++/include/arbnspen.h	/^FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI, char partp)$/;"	f	class:ARbdNonSymPencil
FactorAsB	arpack++/include/arbnspen.h	/^void ARbdNonSymPencil<ARTYPE, ARFLOAT>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARbdNonSymPencil
FactorAsB	arpack++/include/arbspen.h	/^void ARbdSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARbdSymPencil
FactorAsB	arpack++/include/ardnspen.h	/^FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI, char partp)$/;"	f	class:ARdsNonSymPencil
FactorAsB	arpack++/include/ardnspen.h	/^void ARdsNonSymPencil<ARTYPE, ARFLOAT>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARdsNonSymPencil
FactorAsB	arpack++/include/ardspen.h	/^void ARdsSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARdsSymPencil
FactorAsB	arpack++/include/arlnspen.h	/^FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI, char partp)$/;"	f	class:ARluNonSymPencil
FactorAsB	arpack++/include/arlnspen.h	/^void ARluNonSymPencil<ARTYPE, ARFLOAT>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARluNonSymPencil
FactorAsB	arpack++/include/arlspen.h	/^void ARluSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARluSymPencil
FactorAsB	arpack++/include/arunspen.h	/^FactorAsB(ARFLOAT sigmaR, ARFLOAT sigmaI, char partp)$/;"	f	class:ARumNonSymPencil
FactorAsB	arpack++/include/arunspen.h	/^void ARumNonSymPencil<ARTYPE, ARFLOAT>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARumNonSymPencil
FactorAsB	arpack++/include/aruspen.h	/^void ARumSymPencil<ARTYPE>::FactorAsB(ARTYPE sigma)$/;"	f	class:ARumSymPencil
FactorAsI	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARbdNonSymMatrix
FactorAsI	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARbdSymMatrix
FactorAsI	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARdsNonSymMatrix
FactorAsI	arpack++/include/ardsmat.h	/^void ARdsSymMatrix<ARTYPE>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARdsSymMatrix
FactorAsI	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARluNonSymMatrix
FactorAsI	arpack++/include/arlsmat.h	/^void ARluSymMatrix<ARTYPE>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARluSymMatrix
FactorAsI	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARumNonSymMatrix
FactorAsI	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::FactorAsI(ARTYPE sigma)$/;"	f	class:ARumSymMatrix
FailSafe	IoData.h	/^  enum FailSafe {NO = 0, YES = 1, ALWAYS = 2} failsafe;$/;"	g	struct:NewtonData
FastMarchingDistanceUpdate	Elem.h	/^  void FastMarchingDistanceUpdate(int node, Vec<int> &Tag, int level,$/;"	f	class:Elem
FastMarchingDistanceUpdate	Elem.h	/^  void FastMarchingDistanceUpdate(int node, Vec<int> &Tag, int level,$/;"	f	class:ElemDummy
FastMarchingDistanceUpdate	Elem.h	/^  void FastMarchingDistanceUpdate(int node, Vec<int> &Tag, int level,$/;"	f	class:ElemWrapper_dim
FastMarchingDistanceUpdate	ElemTet.C	/^void ElemTet::FastMarchingDistanceUpdate(int node, Vec<int> &Tag, int level,$/;"	f	class:ElemTet
Fast_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX<T,1> Fast_Eigenvalues() const$/;"	f	class:PhysBAM::MATRIX
Fast_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    DIAGONAL_MATRIX<T,2> Fast_Eigenvalues() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Fast_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.cpp	/^Fast_Eigenvalues() const \/\/ 24 mults, 20 adds, 1 atan2, 1 sincos, 2 sqrts$/;"	f	class:SYMMETRIC_MATRIX
Fast_Eigenvectors	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.cpp	/^Fast_Eigenvectors(const SYMMETRIC_MATRIX<T,3>& A,const DIAGONAL_MATRIX<T,3>& lambda) \/\/ 71 mults, 44 adds, 3 divs, 3 sqrts$/;"	f	namespace:__anon23
Fast_Indefinite_Polar_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.cpp	/^Fast_Indefinite_Polar_Decomposition(MATRIX<T,3,2>& Q,SYMMETRIC_MATRIX<T,2>& S) const$/;"	f	class:MATRIX
Fast_Indefinite_Polar_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Fast_Indefinite_Polar_Decomposition(MATRIX<T,3>& Q,SYMMETRIC_MATRIX<T,3>& S) const$/;"	f	class:MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    void Fast_Singular_Value_Decomposition(MATRIX&,MATRIX&,MATRIX&) const$/;"	f	class:PhysBAM::MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    void Fast_Singular_Value_Decomposition(MATRIX&,MATRIX&,MATRIX&) const$/;"	f	class:PhysBAM::MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    void Fast_Singular_Value_Decomposition(MATRIX& U,MATRIX& D,MATRIX& V) const$/;"	f	class:PhysBAM::MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    void Fast_Singular_Value_Decomposition(MATRIX& U,DIAGONAL_MATRIX<T,2>& singular_values,MATRIX& V) const$/;"	f	class:PhysBAM::MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    void Fast_Singular_Value_Decomposition(MATRIX<T,2>& U,DIAGONAL_MATRIX<T,2>& singular_values,MATRIX<T,3,2>& V) const$/;"	f	class:PhysBAM::MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.cpp	/^Fast_Singular_Value_Decomposition(MATRIX<T,3,2>& U,DIAGONAL_MATRIX<T,2>& singular_values,MATRIX<T,2>& V) const$/;"	f	class:MATRIX
Fast_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Fast_Singular_Value_Decomposition(MATRIX<T,3>& U,DIAGONAL_MATRIX<T,3>& singular_values,MATRIX<T,3>& V) const \/\/ 182 mults, 112 adds, 6 divs, 11 sqrts, 1 atan2, 1 sincos$/;"	f	class:MATRIX
Fast_Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    void Fast_Solve_Eigenproblem(MATRIX&,MATRIX&) const$/;"	f	class:PhysBAM::MATRIX
Fast_Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    void Fast_Solve_Eigenproblem(MATRIX&,MATRIX&) const$/;"	f	class:PhysBAM::MATRIX
Fast_Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    void Fast_Solve_Eigenproblem(MATRIX& D,MATRIX& V) const$/;"	f	class:PhysBAM::MATRIX
Fast_Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    void Fast_Solve_Eigenproblem(DIAGONAL_MATRIX<T,2>& eigenvalues,MATRIX<T,2>& eigenvectors) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Fast_Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.cpp	/^Fast_Solve_Eigenproblem(DIAGONAL_MATRIX<T,3>& eigenvalues,MATRIX<T,3>& eigenvectors) const \/\/ roughly 95 mults, 64 adds, 3 divs, 5 sqrts, 1 atan2, 1 sincos$/;"	f	class:SYMMETRIC_MATRIX
Fast_Two_Diff	utils/Predicate.C	173;"	d	file:
Fast_Two_Diff_Tail	utils/Predicate.C	169;"	d	file:
Fast_Two_Sum	utils/Predicate.C	165;"	d	file:
Fast_Two_Sum_Tail	utils/Predicate.C	161;"	d	file:
Fatal_Error	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Fatal_Error(const char* function,const char* file,unsigned int line)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Fatal_Error	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Fatal_Error(const char* function,const char* file,unsigned int line,const char* message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Fatal_Error	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Fatal_Error(const char* function,const char* file,unsigned int line,const std::string& message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Favg	MeshMotionHandler.h	/^  DistSVec<double,3>* Favg;$/;"	m	class:AeroMeshMotionHandler
FemEquationTerm	FemEquationTerm.h	/^  FemEquationTerm(map<int, VolumeData *> &volData) {$/;"	f	class:FemEquationTerm
FemEquationTerm	FemEquationTerm.h	/^class FemEquationTerm {$/;"	c
FemEquationTermDES	FemEquationTermDesc.C	/^FemEquationTermDES::FemEquationTermDES(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermDES
FemEquationTermDES	FemEquationTermDesc.h	/^class FemEquationTermDES : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermDESmean	FemEquationTermDesc.C	/^FemEquationTermDESmean::FemEquationTermDESmean(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermDESmean
FemEquationTermDESmean	FemEquationTermDesc.h	/^class FemEquationTermDESmean : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermDESturb	FemEquationTermDesc.C	/^FemEquationTermDESturb::FemEquationTermDESturb(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermDESturb
FemEquationTermDESturb	FemEquationTermDesc.h	/^class FemEquationTermDESturb : public FemEquationTerm, public NavierStokesTerm,$/;"	c
FemEquationTermKE	FemEquationTermDesc.C	/^FemEquationTermKE::FemEquationTermKE(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermKE
FemEquationTermKE	FemEquationTermDesc.h	/^class FemEquationTermKE : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermKEmean	FemEquationTermDesc.C	/^FemEquationTermKEmean::FemEquationTermKEmean(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermKEmean
FemEquationTermKEmean	FemEquationTermDesc.h	/^class FemEquationTermKEmean : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermKEturb	FemEquationTermDesc.C	/^FemEquationTermKEturb::FemEquationTermKEturb(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermKEturb
FemEquationTermKEturb	FemEquationTermDesc.h	/^class FemEquationTermKEturb : public FemEquationTerm, public NavierStokesTerm,$/;"	c
FemEquationTermNS	FemEquationTermDesc.C	/^FemEquationTermNS::FemEquationTermNS(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermNS
FemEquationTermNS	FemEquationTermDesc.h	/^class FemEquationTermNS : public FemEquationTerm, public NavierStokesTerm {$/;"	c
FemEquationTermSA	FemEquationTermDesc.C	/^FemEquationTermSA::FemEquationTermSA(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermSA
FemEquationTermSA	FemEquationTermDesc.h	/^class FemEquationTermSA : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermSAmean	FemEquationTermDesc.C	/^FemEquationTermSAmean::FemEquationTermSAmean(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermSAmean
FemEquationTermSAmean	FemEquationTermDesc.h	/^class FemEquationTermSAmean : public FemEquationTerm, public NavierStokesTerm, $/;"	c
FemEquationTermSAturb	FemEquationTermDesc.C	/^FemEquationTermSAturb::FemEquationTermSAturb(IoData &iod, VarFcn *vf) :$/;"	f	class:FemEquationTermSAturb
FemEquationTermSAturb	FemEquationTermDesc.h	/^class FemEquationTermSAturb : public FemEquationTerm, public NavierStokesTerm,$/;"	c
Feps	MatVecProd.h	/^  DistSVec<double,dim> Feps;$/;"	m	class:MatVecProdFD
Feps	MatVecProd.h	/^  DistSVec<double,dim> Feps;$/;"	m	class:MatVecProdFDMultiPhase
Feps	MatVecProd.h	/^  DistSVec<double,dimLS> Feps;$/;"	m	class:MatVecProdLS
Fepstmp	MatVecProd.h	/^  DistSVec<double,neq> Fepstmp;$/;"	m	class:MatVecProdFD
Field_Comparison	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline FIELD_COMPARE<T,T_FIELD> Field_Comparison(T_FIELD T::*field)$/;"	f	namespace:PhysBAM
File	parser/Parser.y	/^File: ValidInput EoF$/;"	l
File_Exists	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Exists(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Exists_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^bool File_Exists_Ignoring_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Extension_Matches	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Extension_Matches(const std::string& filename,const std::string& ext,const bool case_sensitive=true)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Extension_Matches_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Extension_Matches_Ignoring_Compression_Suffix(const std::string& filename,const std::string& ext,const bool case_sensitive=true)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Is_Compressed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Is_Compressed(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Type_Matches	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Type_Matches(const std::string& filename,FILE_TYPE type)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Type_Matches_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Type_Matches_Ignoring_Compression_Suffix(const std::string& filename,FILE_TYPE type)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Writable	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool File_Writable(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
File_Writable_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^bool File_Writable_Ignoring_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Filename	arpack++/include/ardfmat.h	/^  char* Filename() const { return datafile; }$/;"	f	class:ARdfMatrix
Filename	arpack++/include/arhbmat.h	/^  char* Filename() { return datafile; }$/;"	f	class:ARhbMatrix
Fill	ExactSolution.h	/^    static void Fill(DistSVec<double,dim>& U, DistSVec<double,3>& X,$/;"	f	class:ExactSolution
Fill	ExactSolution.h	/^    static void Fill(DistSVec<double,dim>& U, DistVec<int>& fid,$/;"	f	class:ExactSolution
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::ARRAY_BASE
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_COPY.h	/^    void Fill(ARRAY_BASE<T,T_ARRAY,ID>& a,const T& constant)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::ARRAY_BASE
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::VECTOR
Fill	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Fill(const T& constant)$/;"	f	class:PhysBAM::VECTOR_BASE
FillFact	arpack++/include/arunsmat.h	/^  int  FillFact() { return fillin; }$/;"	f	class:ARumNonSymMatrix
FillFact	arpack++/include/arusmat.h	/^  int  FillFact() { return fillin; }$/;"	f	class:ARumSymMatrix
FillPrimitive	ExactSolution.h	/^    static void FillPrimitive(DistSVec<double,dim>& V, DistSVec<double,3>& X,$/;"	f	class:ExactSolution
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(DIAGONAL_MATRIX<T,d>& m,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(MATRIX_BASE<T,T_MATRIX>& m,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(SYMMETRIC_MATRIX<T,d>& m,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(T& x,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(TWIST<TV>& m,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(UPPER_TRIANGULAR_MATRIX<T,d>& m,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Fill_Uniform(VECTOR_BASE<T,T_VECTOR>& v,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Fill_Uniform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^    template<class T2,class T_ARRAY,class ID> void Fill_Uniform(ARRAY_BASE<T2,T_ARRAY,ID>& array,const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Find(const T& element) const$/;"	f	class:PhysBAM::ARRAY_BASE
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool Find(const T& element,ID& index) const \/\/ returns the first occurence of an element in an array$/;"	f	class:PhysBAM::ARRAY_BASE
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool Find(const T& element,const ID start_index,ID& index) const \/\/ returns the first occurence after start_index of an element in an array$/;"	f	class:PhysBAM::ARRAY_BASE
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Find(const ID i) const$/;"	f	class:PhysBAM::UNION_FIND
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    int Find(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Find(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Find(const T& element) const$/;"	f	class:PhysBAM::VECTOR
Find	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Find(const T& element) const$/;"	f	class:PhysBAM::VECTOR
FindArnoldiBasis	arpack++/include/argeig.h	/^int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::FindArnoldiBasis()$/;"	f	class:ARGenEig
FindArnoldiBasis	arpack++/include/argsym.h	/^int ARSymGenEig<ARFLOAT, ARFOP, ARFB>::FindArnoldiBasis()$/;"	f	class:ARSymGenEig
FindArnoldiBasis	arpack++/include/arrseig.h	/^inline int ARrcStdEig<ARFLOAT, ARTYPE>::FindArnoldiBasis()$/;"	f	class:ARrcStdEig
FindArnoldiBasis	arpack++/include/arseig.h	/^int ARStdEig<ARFLOAT, ARTYPE, ARFOP>::FindArnoldiBasis()$/;"	f	class:ARStdEig
FindEigenvalues	arpack++/include/argnsym.h	/^inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvalues()$/;"	f	class:ARNonSymGenEig
FindEigenvalues	arpack++/include/arrseig.h	/^int ARrcStdEig<ARFLOAT, ARTYPE>::FindEigenvalues()$/;"	f	class:ARrcStdEig
FindEigenvectors	arpack++/include/argnsym.h	/^inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvectors(bool schurp)$/;"	f	class:ARNonSymGenEig
FindEigenvectors	arpack++/include/arrseig.h	/^int ARrcStdEig<ARFLOAT, ARTYPE>::FindEigenvectors(bool schurp)$/;"	f	class:ARrcStdEig
FindSchurVectors	arpack++/include/argnsym.h	/^int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindSchurVectors()$/;"	f	class:ARNonSymGenEig
FindSchurVectors	arpack++/include/arrseig.h	/^int ARrcStdEig<ARFLOAT, ARTYPE>::FindSchurVectors()$/;"	f	class:ARrcStdEig
FindSchurVectors	arpack++/include/arrssym.h	/^  int FindSchurVectors() {$/;"	f	class:ARrcSymStdEig
Find_And_Append_Adjacent_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Find_And_Append_Adjacent_Elements(const int simplex,const VECTOR<int,0>& face)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Find_And_Append_Adjacent_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Find_And_Append_Adjacent_Elements(const int simplex,const VECTOR<int,d>& face)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Find_Closest_Point_On_Polygon	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^Find_Closest_Point_On_Polygon(const VECTOR<T,2>& X_point,int& side)$/;"	f	class:POLYGON
Find_Common_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Find_Common_Elements(const T_ARRAY& a,const T_ARRAY& b,T_ARRAY& result)$/;"	f	class:PhysBAM::ARRAY_BASE
Find_Elements_Inside_Range	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	/^    template<class T_ARRAY> static void Find_Elements_Inside_Range(const T_ARRAY& array,const RANGE<typename T_ARRAY::ELEMENT>& range,ARRAY<typename T_ARRAY::INDEX>& inside)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Find_Elements_Outside_Range	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	/^    template<class T_ARRAY> static void Find_Elements_Outside_Range(const T_ARRAY& array,const RANGE<typename T_ARRAY::ELEMENT>& range,ARRAY<typename T_ARRAY::INDEX>& outside)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Find_First_Nonexistent_Directory_In_Sequence	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::string Find_First_Nonexistent_Directory_In_Sequence(std::string directory_pattern,const int id_start,int* id_final)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Find_First_Nonexistent_File_In_Sequence	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::string Find_First_Nonexistent_File_In_Sequence(std::string filename_pattern,const int id_start,int* id_result)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Find_Points_Within_Radius	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Find_Points_Within_Radius(const TV& location,const T max_distance_squared,ARRAY<int>& points_found,ARRAY<T>& distance_squared_of_points_found,$/;"	f	class:KD_TREE
Find_Points_Within_Radius_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Find_Points_Within_Radius_Helper(const KD_TREE_NODE<T>* cell,const TV& location,const T max_distance_squared,ARRAY<int>& points_found,$/;"	f	class:KD_TREE
Find_Without_Path_Compression	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Find_Without_Path_Compression(const ID i) const$/;"	f	class:PhysBAM::UNION_FIND
Finish_Logging	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Finish_Logging()$/;"	f	namespace:PhysBAM::LOG_REAL
Finish_Logging	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^inline void Finish_Logging(){}$/;"	f	namespace:PhysBAM::LOG_NULL
FiniteDifferenceOrder	IoData.h	/^  enum FiniteDifferenceOrder {FIRST_ORDER = 1, SECOND_ORDER = 2} fdOrder; $/;"	g	struct:ImplicitData
Finlet	NewtonSolver.h	/^  typename ProblemDescriptor::SolVecType Finlet;  \/\/ nonlinear function at inlet nodes$/;"	m	class:NewtonSolver
First	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T First() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
First	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T First() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
FirstIndex	arpack++/include/ardfmat.h	/^  int FirstIndex() const { return first; }$/;"	f	class:ARdfMatrix
FirstPartialSpaceDerivatives	AutoDiff/SpaceDerivatives.h	/^    FirstPartialSpaceDerivatives(const Eigen::Array<typename FunctionTemplate<Scalar>::ScalarConstantType,$/;"	f	class:FirstPartialSpaceDerivatives
FirstPartialSpaceDerivatives	AutoDiff/SpaceDerivatives.h	/^class FirstPartialSpaceDerivatives$/;"	c
First_Eigenvector_From_Ordered_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> First_Eigenvector_From_Ordered_Eigenvalues(const DIAGONAL_MATRIX<T,2>& eigenvalues) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
First_Eigenvector_From_Ordered_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> First_Eigenvector_From_Ordered_Eigenvalues(const DIAGONAL_MATRIX<T,3>& eigenvalues,const T tolerance=1e-5) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
FixSolution	IoData.h	/^  enum FixSolution {NONEFIX = 0, PREVIOUSVALEUSFIX = 1} fixsol;$/;"	g	struct:SensitivityAnalysis
Fixed	IoData.h	/^   enum ClosestNeighbor {Fixed = 1, Variable = 0} bestNeiStrategy;$/;"	e	enum:BLMeshMotionData::ClosestNeighbor
Fixes	Manual/Aerof3d.html	/^<a name="Fixes"><\/a>$/;"	a
Flattened	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_VIEW<ELEMENT_OF_T> Flattened() \/\/ valid only for contiguous arrays of VECTOR<T,d>$/;"	f	class:PhysBAM::ARRAY_BASE
Flattened	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ARRAY_VIEW<const ELEMENT_OF_T> Flattened() const \/\/ valid only for contiguous arrays of VECTOR<T,d>$/;"	f	class:PhysBAM::ARRAY_BASE
FloodFill	IntersectorPhysBAM/FloodFill.h	/^FloodFill() : nGlobalSubDomains(-1),subDomainToProcessorMap(0)$/;"	f	class:FloodFill
FloodFill	IntersectorPhysBAM/FloodFill.h	/^class FloodFill {$/;"	c
Fluid	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	g	struct:FluidModelData
Fluid-ROM	Manual/Aerof3d.html	/^<a name="Fluid-ROM"><\/a>$/;"	a
FluidCollocationShapeOptimizationHandler	FluidCollocationShapeOptimizationHandler.C	/^FluidCollocationShapeOptimizationHandler<dim>::FluidCollocationShapeOptimizationHandler$/;"	f	class:FluidCollocationShapeOptimizationHandler
FluidCollocationShapeOptimizationHandler	FluidCollocationShapeOptimizationHandler.h	/^class FluidCollocationShapeOptimizationHandler : public ImplicitCollocationTsDesc<dim> {$/;"	c
FluidGnatShapeOptimizationHandler	FluidGnatShapeOptimizationHandler.C	/^FluidGnatShapeOptimizationHandler<dim>::FluidGnatShapeOptimizationHandler$/;"	f	class:FluidGnatShapeOptimizationHandler
FluidGnatShapeOptimizationHandler	FluidGnatShapeOptimizationHandler.h	/^class FluidGnatShapeOptimizationHandler : public ImplicitGnatTsDesc<dim> {$/;"	c
FluidIDMap	Manual/Aerof3d.html	/^<a name="FluidIDMap"><\/a>$/;"	a
FluidId	MatVecProd.h	/^  DistVec<int> *FluidId;$/;"	m	class:MatVecProdLS
FluidMetricShapeOptimizationHandler	FluidMetricShapeOptimizationHandler.C	/^FluidMetricShapeOptimizationHandler<dim>::FluidMetricShapeOptimizationHandler$/;"	f	class:FluidMetricShapeOptimizationHandler
FluidMetricShapeOptimizationHandler	FluidMetricShapeOptimizationHandler.h	/^class FluidMetricShapeOptimizationHandler : public ImplicitMetricTsDesc<dim> {$/;"	c
FluidModel	Manual/Aerof3d.html	/^<a name="FluidModel"><\/a>$/;"	a
FluidModelData	IoData.h	/^struct FluidModelData {$/;"	s
FluidModelData	IoDataCore.C	/^FluidModelData::FluidModelData()$/;"	f	class:FluidModelData
FluidRemapData	IoData.h	/^struct FluidRemapData {$/;"	s
FluidRemapData	IoDataCore.C	/^FluidRemapData::FluidRemapData() {$/;"	f	class:FluidRemapData
FluidRomShapeOptimizationHandler	FluidRomShapeOptimizationHandler.C	/^FluidRomShapeOptimizationHandler<dim>::FluidRomShapeOptimizationHandler$/;"	f	class:FluidRomShapeOptimizationHandler
FluidRomShapeOptimizationHandler	FluidRomShapeOptimizationHandler.h	/^class FluidRomShapeOptimizationHandler : public ImplicitPGTsDesc<dim> {$/;"	c
FluidSelector	FluidSelector.h	/^class FluidSelector {$/;"	c
FluidSelector	FluidSelectorCore.C	/^FluidSelector::FluidSelector(DistVec<int>& nodeTag, Domain* dom) : domain(dom) {$/;"	f	class:FluidSelector
FluidSelector	FluidSelectorCore.C	/^FluidSelector::FluidSelector(const int nPhases, IoData &ioData, Domain *dom) : iodp(&ioData)$/;"	f	class:FluidSelector
FluidShapeOptimizationHandler	FluidShapeOptimizationHandler.C	/^FluidShapeOptimizationHandler<dim>::FluidShapeOptimizationHandler$/;"	f	class:FluidShapeOptimizationHandler
FluidShapeOptimizationHandler	FluidShapeOptimizationHandler.h	/^class FluidShapeOptimizationHandler : public ImplicitCoupledTsDesc<dim> {$/;"	c
Flux	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Flux	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Flux	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:FluidGnatShapeOptimizationHandler
Flux	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:FluidMetricShapeOptimizationHandler
Flux	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:FluidRomShapeOptimizationHandler
Flux	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> Flux;$/;"	m	class:FluidShapeOptimizationHandler
Flux	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	g	struct:SchemeData
FluxFD	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
FluxFD	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:FluidCollocationShapeOptimizationHandler
FluxFD	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:FluidGnatShapeOptimizationHandler
FluxFD	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:FluidMetricShapeOptimizationHandler
FluxFD	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:FluidRomShapeOptimizationHandler
FluxFD	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> FluxFD;$/;"	m	class:FluidShapeOptimizationHandler
FluxFcn	FluxFcn.h	/^  FluxFcn() {}$/;"	f	class:FluxFcn
FluxFcn	FluxFcn.h	/^FluxFcn::FluxFcn(int rshift, int ffType, IoData &iod, VarFcn *vf, FluxFcnBase::Type typeJac) : vf_(vf){$/;"	f	class:FluxFcn
FluxFcn	FluxFcn.h	/^FluxFcn::FluxFcn(int rshift, int ffType, IoData &iod, VarFcn *vf, int segPart, FluxFcnBase::Type typeJac) : vf_(vf){$/;"	f	class:FluxFcn
FluxFcn	FluxFcn.h	/^class FluxFcn {$/;"	c
FluxFcnApprJacHLLCEuler3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLCEuler3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnApprJacHLLCEuler3D
FluxFcnApprJacHLLCEuler3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLCEuler3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacHLLCKE3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLCKE3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnApprJacHLLCKE3D
FluxFcnApprJacHLLCKE3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLCKE3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacHLLCSA3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLCSA3D(IoData &ioData, int rs, double gg, VarFcnBase* vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnApprJacHLLCSA3D
FluxFcnApprJacHLLCSA3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLCSA3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacHLLEEuler3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLEEuler3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnApprJacHLLEEuler3D
FluxFcnApprJacHLLEEuler3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLEEuler3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacHLLEKE3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLEKE3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnApprJacHLLEKE3D
FluxFcnApprJacHLLEKE3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLEKE3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacHLLESA3D	FluxFcnDesc.h	/^  FluxFcnApprJacHLLESA3D(IoData &ioData, int rs, double gg, VarFcnBase* vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnApprJacHLLESA3D
FluxFcnApprJacHLLESA3D	FluxFcnDesc.h	/^class FluxFcnApprJacHLLESA3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacRoeEuler3D	FluxFcnDesc.h	/^  FluxFcnApprJacRoeEuler3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnApprJacRoeEuler3D
FluxFcnApprJacRoeEuler3D	FluxFcnDesc.h	/^class FluxFcnApprJacRoeEuler3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacRoeKE3D	FluxFcnDesc.h	/^  FluxFcnApprJacRoeKE3D(IoData &ioData, int rs, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnApprJacRoeKE3D
FluxFcnApprJacRoeKE3D	FluxFcnDesc.h	/^class FluxFcnApprJacRoeKE3D : public FluxFcnBase {$/;"	c
FluxFcnApprJacRoeSA3D	FluxFcnDesc.h	/^  FluxFcnApprJacRoeSA3D(IoData &ioData, int rs, double gg, VarFcnBase* vf, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnApprJacRoeSA3D
FluxFcnApprJacRoeSA3D	FluxFcnDesc.h	/^class FluxFcnApprJacRoeSA3D : public FluxFcnBase {$/;"	c
FluxFcnBase	FluxFcnBase.h	/^FluxFcnBase::FluxFcnBase(VarFcnBase *varFcn,Type tp) : vf(varFcn) {$/;"	f	class:FluxFcnBase
FluxFcnBase	FluxFcnBase.h	/^class FluxFcnBase {$/;"	c
FluxFcnDirectStateInflowEuler3D	FluxFcnDesc.h	/^  FluxFcnDirectStateInflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnDirectStateInflowEuler3D
FluxFcnDirectStateInflowEuler3D	FluxFcnDesc.h	/^class FluxFcnDirectStateInflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnDirectStateInflowKE3D	FluxFcnDesc.h	/^  FluxFcnDirectStateInflowKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateInflowKE3D
FluxFcnDirectStateInflowKE3D	FluxFcnDesc.h	/^class FluxFcnDirectStateInflowKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnDirectStateInflowKEturb3D	FluxFcnDesc.h	/^  FluxFcnDirectStateInflowKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateInflowKEturb3D
FluxFcnDirectStateInflowKEturb3D	FluxFcnDesc.h	/^class FluxFcnDirectStateInflowKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnDirectStateInflowSA3D	FluxFcnDesc.h	/^  FluxFcnDirectStateInflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateInflowSA3D
FluxFcnDirectStateInflowSA3D	FluxFcnDesc.h	/^class FluxFcnDirectStateInflowSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnDirectStateInflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnDirectStateInflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateInflowSAturb3D
FluxFcnDirectStateInflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnDirectStateInflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnDirectStateOutflowEuler3D	FluxFcnDesc.h	/^  FluxFcnDirectStateOutflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnDirectStateOutflowEuler3D
FluxFcnDirectStateOutflowEuler3D	FluxFcnDesc.h	/^class FluxFcnDirectStateOutflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnDirectStateOutflowKE3D	FluxFcnDesc.h	/^  FluxFcnDirectStateOutflowKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateOutflowKE3D
FluxFcnDirectStateOutflowKE3D	FluxFcnDesc.h	/^class FluxFcnDirectStateOutflowKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnDirectStateOutflowKEturb3D	FluxFcnDesc.h	/^  FluxFcnDirectStateOutflowKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateOutflowKEturb3D
FluxFcnDirectStateOutflowKEturb3D	FluxFcnDesc.h	/^class FluxFcnDirectStateOutflowKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnDirectStateOutflowSA3D	FluxFcnDesc.h	/^  FluxFcnDirectStateOutflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateOutflowSA3D
FluxFcnDirectStateOutflowSA3D	FluxFcnDesc.h	/^class FluxFcnDirectStateOutflowSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnDirectStateOutflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnDirectStateOutflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnDirectStateOutflowSAturb3D
FluxFcnDirectStateOutflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnDirectStateOutflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnExactJacRoeEuler3D	FluxFcnDesc.h	/^  FluxFcnExactJacRoeEuler3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp) : $/;"	f	class:FluxFcnExactJacRoeEuler3D
FluxFcnExactJacRoeEuler3D	FluxFcnDesc.h	/^class FluxFcnExactJacRoeEuler3D : public FluxFcnBase {$/;"	c
FluxFcnExactJacRoeKE3D	FluxFcnDesc.h	/^  FluxFcnExactJacRoeKE3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnExactJacRoeKE3D
FluxFcnExactJacRoeKE3D	FluxFcnDesc.h	/^class FluxFcnExactJacRoeKE3D : public FluxFcnBase {$/;"	c
FluxFcnExactJacRoeSA3D	FluxFcnDesc.h	/^  FluxFcnExactJacRoeSA3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnExactJacRoeSA3D
FluxFcnExactJacRoeSA3D	FluxFcnDesc.h	/^class FluxFcnExactJacRoeSA3D : public FluxFcnBase {$/;"	c
FluxFcnFD	FluxFcnBase.h	/^  FluxFcnFD(VarFcnBase *vf,Type tp) : FluxFcnBase(vf,tp) {}$/;"	f	class:FluxFcnFD
FluxFcnFD	FluxFcnBase.h	/^class FluxFcnFD : public FluxFcnBase {$/;"	c
FluxFcnFDJacHLLCEuler3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLCEuler3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnFDJacHLLCEuler3D
FluxFcnFDJacHLLCEuler3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLCEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnFDJacHLLCKE3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLCKE3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacHLLCKE3D
FluxFcnFDJacHLLCKE3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLCKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnFDJacHLLCSA3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLCSA3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacHLLCSA3D
FluxFcnFDJacHLLCSA3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLCSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnFDJacHLLEEuler3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLEEuler3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnFDJacHLLEEuler3D
FluxFcnFDJacHLLEEuler3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLEEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnFDJacHLLEKE3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLEKE3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacHLLEKE3D
FluxFcnFDJacHLLEKE3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLEKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnFDJacHLLESA3D	FluxFcnDesc.h	/^  FluxFcnFDJacHLLESA3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacHLLESA3D
FluxFcnFDJacHLLESA3D	FluxFcnDesc.h	/^class FluxFcnFDJacHLLESA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnFDJacRoeEuler3D	FluxFcnDesc.h	/^  FluxFcnFDJacRoeEuler3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp):$/;"	f	class:FluxFcnFDJacRoeEuler3D
FluxFcnFDJacRoeEuler3D	FluxFcnDesc.h	/^class FluxFcnFDJacRoeEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnFDJacRoeKE3D	FluxFcnDesc.h	/^  FluxFcnFDJacRoeKE3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacRoeKE3D
FluxFcnFDJacRoeKE3D	FluxFcnDesc.h	/^class FluxFcnFDJacRoeKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnFDJacRoeSA3D	FluxFcnDesc.h	/^  FluxFcnFDJacRoeSA3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnFDJacRoeSA3D
FluxFcnFDJacRoeSA3D	FluxFcnDesc.h	/^class FluxFcnFDJacRoeSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnGhidagliaEuler3D	FluxFcnDesc.h	/^  FluxFcnGhidagliaEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnGhidagliaEuler3D
FluxFcnGhidagliaEuler3D	FluxFcnDesc.h	/^class FluxFcnGhidagliaEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnGhidagliaKE3D	FluxFcnDesc.h	/^  FluxFcnGhidagliaKE3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnGhidagliaKE3D
FluxFcnGhidagliaKE3D	FluxFcnDesc.h	/^class FluxFcnGhidagliaKE3D : public FluxFcnFD<7>{$/;"	c
FluxFcnGhidagliaKEturb3D	FluxFcnDesc.h	/^  FluxFcnGhidagliaKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnGhidagliaKEturb3D
FluxFcnGhidagliaKEturb3D	FluxFcnDesc.h	/^class FluxFcnGhidagliaKEturb3D : public FluxFcnBase{$/;"	c
FluxFcnGhidagliaSA3D	FluxFcnDesc.h	/^  FluxFcnGhidagliaSA3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnGhidagliaSA3D
FluxFcnGhidagliaSA3D	FluxFcnDesc.h	/^class FluxFcnGhidagliaSA3D : public FluxFcnFD<6>{$/;"	c
FluxFcnGhidagliaSAturb3D	FluxFcnDesc.h	/^  FluxFcnGhidagliaSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnGhidagliaSAturb3D
FluxFcnGhidagliaSAturb3D	FluxFcnDesc.h	/^class FluxFcnGhidagliaSAturb3D : public FluxFcnBase{$/;"	c
FluxFcnInflowEuler3D	FluxFcnDesc.h	/^  FluxFcnInflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnInflowEuler3D
FluxFcnInflowEuler3D	FluxFcnDesc.h	/^class FluxFcnInflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnInternalInflowEuler3D	FluxFcnDesc.h	/^  FluxFcnInternalInflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnInternalInflowEuler3D
FluxFcnInternalInflowEuler3D	FluxFcnDesc.h	/^class FluxFcnInternalInflowEuler3D : public FluxFcnBase {$/;"	c
FluxFcnInternalInflowSA3D	FluxFcnDesc.h	/^  FluxFcnInternalInflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnInternalInflowSA3D
FluxFcnInternalInflowSA3D	FluxFcnDesc.h	/^class FluxFcnInternalInflowSA3D : public FluxFcnBase {$/;"	c
FluxFcnInternalInflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnInternalInflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnInternalInflowSAturb3D
FluxFcnInternalInflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnInternalInflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnInternalOutflowEuler3D	FluxFcnDesc.h	/^  FluxFcnInternalOutflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnInternalOutflowEuler3D
FluxFcnInternalOutflowEuler3D	FluxFcnDesc.h	/^class FluxFcnInternalOutflowEuler3D : public FluxFcnBase {$/;"	c
FluxFcnInternalOutflowSA3D	FluxFcnDesc.h	/^  FluxFcnInternalOutflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnInternalOutflowSA3D
FluxFcnInternalOutflowSA3D	FluxFcnDesc.h	/^class FluxFcnInternalOutflowSA3D : public FluxFcnBase {$/;"	c
FluxFcnInternalOutflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnInternalOutflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnInternalOutflowSAturb3D
FluxFcnInternalOutflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnInternalOutflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnJacobian	IoData.h	/^  enum FluxFcnJacobian {FINITE_DIFFERENCE = 0, APPROXIMATE = 1, EXACT = 2} ffjacobian;$/;"	g	struct:ImplicitData
FluxFcnJwlApprJacRoeEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlApprJacRoeEuler3D(int rs, double gg, IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnJwlApprJacRoeEuler3D
FluxFcnJwlApprJacRoeEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlApprJacRoeEuler3D : public FluxFcnApprJacRoeEuler3D {$/;"	c
FluxFcnJwlExactJacRoeEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlExactJacRoeEuler3D(double gg, IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnJwlExactJacRoeEuler3D
FluxFcnJwlExactJacRoeEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlExactJacRoeEuler3D : public FluxFcnExactJacRoeEuler3D {$/;"	c
FluxFcnJwlFDJacRoeEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlFDJacRoeEuler3D(double gg, IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnJwlFDJacRoeEuler3D
FluxFcnJwlFDJacRoeEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlFDJacRoeEuler3D : public FluxFcnFDJacRoeEuler3D {$/;"	c
FluxFcnJwlGhidagliaEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlGhidagliaEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnJwlGhidagliaEuler3D
FluxFcnJwlGhidagliaEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlGhidagliaEuler3D : public FluxFcnGhidagliaEuler3D {$/;"	c
FluxFcnJwlInflowEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlInflowEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnJwlInflowEuler3D
FluxFcnJwlInflowEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlInflowEuler3D : public FluxFcnInflowEuler3D {$/;"	c
FluxFcnJwlInternalInflowEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlInternalInflowEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnJwlInternalInflowEuler3D
FluxFcnJwlInternalInflowEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlInternalInflowEuler3D : public FluxFcnInternalInflowEuler3D {$/;"	c
FluxFcnJwlInternalOutflowEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlInternalOutflowEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnJwlInternalOutflowEuler3D
FluxFcnJwlInternalOutflowEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlInternalOutflowEuler3D : public FluxFcnInternalOutflowEuler3D {$/;"	c
FluxFcnJwlOutflowEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlOutflowEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnJwlOutflowEuler3D
FluxFcnJwlOutflowEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlOutflowEuler3D : public FluxFcnOutflowEuler3D {$/;"	c
FluxFcnJwlWallEuler3D	FluxFcnDescJwl.h	/^  FluxFcnJwlWallEuler3D(IoData &ioData, VarFcnJwl *varFcnJwl, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnJwlWallEuler3D
FluxFcnJwlWallEuler3D	FluxFcnDescJwl.h	/^class FluxFcnJwlWallEuler3D : public FluxFcnWallEuler3D {$/;"	c
FluxFcnMassFlowInflowEuler3D	FluxFcnDesc.h	/^  FluxFcnMassFlowInflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnMassFlowInflowEuler3D
FluxFcnMassFlowInflowEuler3D	FluxFcnDesc.h	/^class FluxFcnMassFlowInflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnMassFlowInflowKE3D	FluxFcnDesc.h	/^  FluxFcnMassFlowInflowKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowInflowKE3D
FluxFcnMassFlowInflowKE3D	FluxFcnDesc.h	/^class FluxFcnMassFlowInflowKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnMassFlowInflowKEturb3D	FluxFcnDesc.h	/^  FluxFcnMassFlowInflowKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowInflowKEturb3D
FluxFcnMassFlowInflowKEturb3D	FluxFcnDesc.h	/^class FluxFcnMassFlowInflowKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnMassFlowInflowSA3D	FluxFcnDesc.h	/^  FluxFcnMassFlowInflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowInflowSA3D
FluxFcnMassFlowInflowSA3D	FluxFcnDesc.h	/^class FluxFcnMassFlowInflowSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnMassFlowInflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnMassFlowInflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowInflowSAturb3D
FluxFcnMassFlowInflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnMassFlowInflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnMassFlowOutflowEuler3D	FluxFcnDesc.h	/^  FluxFcnMassFlowOutflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnMassFlowOutflowEuler3D
FluxFcnMassFlowOutflowEuler3D	FluxFcnDesc.h	/^class FluxFcnMassFlowOutflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnMassFlowOutflowKE3D	FluxFcnDesc.h	/^  FluxFcnMassFlowOutflowKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowOutflowKE3D
FluxFcnMassFlowOutflowKE3D	FluxFcnDesc.h	/^class FluxFcnMassFlowOutflowKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnMassFlowOutflowKEturb3D	FluxFcnDesc.h	/^  FluxFcnMassFlowOutflowKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowOutflowKEturb3D
FluxFcnMassFlowOutflowKEturb3D	FluxFcnDesc.h	/^class FluxFcnMassFlowOutflowKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnMassFlowOutflowSA3D	FluxFcnDesc.h	/^  FluxFcnMassFlowOutflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowOutflowSA3D
FluxFcnMassFlowOutflowSA3D	FluxFcnDesc.h	/^class FluxFcnMassFlowOutflowSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnMassFlowOutflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnMassFlowOutflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnMassFlowOutflowSAturb3D
FluxFcnMassFlowOutflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnMassFlowOutflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnModifiedGhidagliaEuler3D	FluxFcnDesc.h	/^  FluxFcnModifiedGhidagliaEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnModifiedGhidagliaEuler3D
FluxFcnModifiedGhidagliaEuler3D	FluxFcnDesc.h	/^class FluxFcnModifiedGhidagliaEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnOutflowEuler3D	FluxFcnDesc.h	/^  FluxFcnOutflowEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnOutflowEuler3D
FluxFcnOutflowEuler3D	FluxFcnDesc.h	/^class FluxFcnOutflowEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnOutflowKE3D	FluxFcnDesc.h	/^  FluxFcnOutflowKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnOutflowKE3D
FluxFcnOutflowKE3D	FluxFcnDesc.h	/^class FluxFcnOutflowKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnOutflowKEturb3D	FluxFcnDesc.h	/^  FluxFcnOutflowKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnOutflowKEturb3D
FluxFcnOutflowKEturb3D	FluxFcnDesc.h	/^class FluxFcnOutflowKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnOutflowSA3D	FluxFcnDesc.h	/^  FluxFcnOutflowSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnOutflowSA3D
FluxFcnOutflowSA3D	FluxFcnDesc.h	/^class FluxFcnOutflowSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnOutflowSAturb3D	FluxFcnDesc.h	/^  FluxFcnOutflowSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnOutflowSAturb3D
FluxFcnOutflowSAturb3D	FluxFcnDesc.h	/^class FluxFcnOutflowSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnPorousWallEuler3D	FluxFcnDesc.h	/^  FluxFcnPorousWallEuler3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnPorousWallEuler3D
FluxFcnPorousWallEuler3D	FluxFcnDesc.h	/^class FluxFcnPorousWallEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnPorousWallKE3D	FluxFcnDesc.h	/^  FluxFcnPorousWallKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnPorousWallKE3D
FluxFcnPorousWallKE3D	FluxFcnDesc.h	/^class FluxFcnPorousWallKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnPorousWallKEturb3D	FluxFcnDesc.h	/^  FluxFcnPorousWallKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnPorousWallKEturb3D
FluxFcnPorousWallKEturb3D	FluxFcnDesc.h	/^class FluxFcnPorousWallKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnPorousWallSA3D	FluxFcnDesc.h	/^  FluxFcnPorousWallSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnPorousWallSA3D
FluxFcnPorousWallSA3D	FluxFcnDesc.h	/^class FluxFcnPorousWallSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnPorousWallSAturb3D	FluxFcnDesc.h	/^  FluxFcnPorousWallSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnPorousWallSAturb3D
FluxFcnPorousWallSAturb3D	FluxFcnDesc.h	/^class FluxFcnPorousWallSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnRoeKEturb3D	FluxFcnDesc.h	/^  FluxFcnRoeKEturb3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnRoeKEturb3D
FluxFcnRoeKEturb3D	FluxFcnDesc.h	/^class FluxFcnRoeKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnRoeSAturb3D	FluxFcnDesc.h	/^  FluxFcnRoeSAturb3D(IoData &ioData, double gg, VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnRoeSAturb3D
FluxFcnRoeSAturb3D	FluxFcnDesc.h	/^class FluxFcnRoeSAturb3D : public FluxFcnBase {$/;"	c
FluxFcnSGApprJacHLLCEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLCEuler3D(int rs, double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLCEuler3D
FluxFcnSGApprJacHLLCEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLCEuler3D : public FluxFcnApprJacHLLCEuler3D {$/;"	c
FluxFcnSGApprJacHLLCKE3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLCKE3D(int rs, double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLCKE3D
FluxFcnSGApprJacHLLCKE3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLCKE3D : public FluxFcnApprJacHLLCKE3D {$/;"	c
FluxFcnSGApprJacHLLCSA3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLCSA3D(int rs, double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLCSA3D
FluxFcnSGApprJacHLLCSA3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLCSA3D : public FluxFcnApprJacHLLCSA3D {$/;"	c
FluxFcnSGApprJacHLLEEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLEEuler3D(int rs, double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLEEuler3D
FluxFcnSGApprJacHLLEEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLEEuler3D : public FluxFcnApprJacHLLEEuler3D {$/;"	c
FluxFcnSGApprJacHLLEKE3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLEKE3D(int rs, double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLEKE3D
FluxFcnSGApprJacHLLEKE3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLEKE3D : public FluxFcnApprJacHLLEKE3D {$/;"	c
FluxFcnSGApprJacHLLESA3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacHLLESA3D(int rs, double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacHLLESA3D
FluxFcnSGApprJacHLLESA3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacHLLESA3D : public FluxFcnApprJacHLLESA3D {$/;"	c
FluxFcnSGApprJacRoeEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacRoeEuler3D(int rs, double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGApprJacRoeEuler3D
FluxFcnSGApprJacRoeEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacRoeEuler3D : public FluxFcnApprJacRoeEuler3D {$/;"	c
FluxFcnSGApprJacRoeKE3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacRoeKE3D(int rs, double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGApprJacRoeKE3D
FluxFcnSGApprJacRoeKE3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacRoeKE3D : public FluxFcnApprJacRoeKE3D {$/;"	c
FluxFcnSGApprJacRoeSA3D	FluxFcnDescSG.h	/^  FluxFcnSGApprJacRoeSA3D(int rs, double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGApprJacRoeSA3D
FluxFcnSGApprJacRoeSA3D	FluxFcnDescSG.h	/^class FluxFcnSGApprJacRoeSA3D : public FluxFcnApprJacRoeSA3D {$/;"	c
FluxFcnSGDirectStateInflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateInflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
FluxFcnSGDirectStateInflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateInflowEuler3D : public FluxFcnDirectStateInflowEuler3D {$/;"	c
FluxFcnSGDirectStateInflowKE3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateInflowKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateInflowKE3D
FluxFcnSGDirectStateInflowKE3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateInflowKE3D : public FluxFcnDirectStateInflowKE3D {$/;"	c
FluxFcnSGDirectStateInflowKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateInflowKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateInflowKEturb3D
FluxFcnSGDirectStateInflowKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateInflowKEturb3D : public FluxFcnDirectStateInflowKEturb3D {$/;"	c
FluxFcnSGDirectStateInflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateInflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateInflowSA3D
FluxFcnSGDirectStateInflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateInflowSA3D : public FluxFcnDirectStateInflowSA3D {$/;"	c
FluxFcnSGDirectStateInflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateInflowSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateInflowSAturb3D
FluxFcnSGDirectStateInflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateInflowSAturb3D : public FluxFcnDirectStateInflowSAturb3D {$/;"	c
FluxFcnSGDirectStateOutflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateOutflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGDirectStateOutflowEuler3D
FluxFcnSGDirectStateOutflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateOutflowEuler3D : public FluxFcnDirectStateOutflowEuler3D {$/;"	c
FluxFcnSGDirectStateOutflowKE3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateOutflowKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateOutflowKE3D
FluxFcnSGDirectStateOutflowKE3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateOutflowKE3D : public FluxFcnDirectStateOutflowKE3D {$/;"	c
FluxFcnSGDirectStateOutflowKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateOutflowKEturb3D(IoData  &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateOutflowKEturb3D
FluxFcnSGDirectStateOutflowKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateOutflowKEturb3D : public FluxFcnDirectStateOutflowKEturb3D {$/;"	c
FluxFcnSGDirectStateOutflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateOutflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateOutflowSA3D
FluxFcnSGDirectStateOutflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateOutflowSA3D : public FluxFcnDirectStateOutflowSA3D {$/;"	c
FluxFcnSGDirectStateOutflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGDirectStateOutflowSAturb3D(IoData  &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGDirectStateOutflowSAturb3D
FluxFcnSGDirectStateOutflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGDirectStateOutflowSAturb3D : public FluxFcnDirectStateOutflowSAturb3D {$/;"	c
FluxFcnSGExactJacRoeEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGExactJacRoeEuler3D(double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGExactJacRoeEuler3D
FluxFcnSGExactJacRoeEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGExactJacRoeEuler3D : public FluxFcnExactJacRoeEuler3D {$/;"	c
FluxFcnSGExactJacRoeKE3D	FluxFcnDescSG.h	/^  FluxFcnSGExactJacRoeKE3D(double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGExactJacRoeKE3D
FluxFcnSGExactJacRoeKE3D	FluxFcnDescSG.h	/^class FluxFcnSGExactJacRoeKE3D : public FluxFcnExactJacRoeKE3D {$/;"	c
FluxFcnSGExactJacRoeSA3D	FluxFcnDescSG.h	/^  FluxFcnSGExactJacRoeSA3D(double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGExactJacRoeSA3D
FluxFcnSGExactJacRoeSA3D	FluxFcnDescSG.h	/^class FluxFcnSGExactJacRoeSA3D : public FluxFcnExactJacRoeSA3D {$/;"	c
FluxFcnSGFDJacHLLCEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLCEuler3D(double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLCEuler3D
FluxFcnSGFDJacHLLCEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLCEuler3D : public FluxFcnFDJacHLLCEuler3D {$/;"	c
FluxFcnSGFDJacHLLCKE3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLCKE3D(double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLCKE3D
FluxFcnSGFDJacHLLCKE3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLCKE3D : public FluxFcnFDJacHLLCKE3D{$/;"	c
FluxFcnSGFDJacHLLCSA3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLCSA3D(double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLCSA3D
FluxFcnSGFDJacHLLCSA3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLCSA3D : public FluxFcnFDJacHLLCSA3D {$/;"	c
FluxFcnSGFDJacHLLEEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLEEuler3D(double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLEEuler3D
FluxFcnSGFDJacHLLEEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLEEuler3D : public FluxFcnFDJacHLLEEuler3D {$/;"	c
FluxFcnSGFDJacHLLEKE3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLEKE3D(double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLEKE3D
FluxFcnSGFDJacHLLEKE3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLEKE3D : public FluxFcnFDJacHLLEKE3D{$/;"	c
FluxFcnSGFDJacHLLESA3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacHLLESA3D(double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacHLLESA3D
FluxFcnSGFDJacHLLESA3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacHLLESA3D : public FluxFcnFDJacHLLESA3D {$/;"	c
FluxFcnSGFDJacRoeEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacRoeEuler3D(double gg, IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
FluxFcnSGFDJacRoeEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacRoeEuler3D : public FluxFcnFDJacRoeEuler3D {$/;"	c
FluxFcnSGFDJacRoeKE3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacRoeKE3D(double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacRoeKE3D
FluxFcnSGFDJacRoeKE3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacRoeKE3D : public FluxFcnFDJacRoeKE3D{$/;"	c
FluxFcnSGFDJacRoeSA3D	FluxFcnDescSG.h	/^  FluxFcnSGFDJacRoeSA3D(double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGFDJacRoeSA3D
FluxFcnSGFDJacRoeSA3D	FluxFcnDescSG.h	/^class FluxFcnSGFDJacRoeSA3D : public FluxFcnFDJacRoeSA3D {$/;"	c
FluxFcnSGGhidagliaEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGGhidagliaEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGGhidagliaEuler3D
FluxFcnSGGhidagliaEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGGhidagliaEuler3D : public FluxFcnGhidagliaEuler3D {$/;"	c
FluxFcnSGGhidagliaKE3D	FluxFcnDescSG.h	/^  FluxFcnSGGhidagliaKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGGhidagliaKE3D
FluxFcnSGGhidagliaKE3D	FluxFcnDescSG.h	/^class FluxFcnSGGhidagliaKE3D : public FluxFcnGhidagliaKE3D {$/;"	c
FluxFcnSGGhidagliaKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGGhidagliaKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGGhidagliaKEturb3D
FluxFcnSGGhidagliaKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGGhidagliaKEturb3D : public FluxFcnGhidagliaKEturb3D {$/;"	c
FluxFcnSGGhidagliaSA3D	FluxFcnDescSG.h	/^  FluxFcnSGGhidagliaSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGGhidagliaSA3D
FluxFcnSGGhidagliaSA3D	FluxFcnDescSG.h	/^class FluxFcnSGGhidagliaSA3D : public FluxFcnGhidagliaSA3D {$/;"	c
FluxFcnSGGhidagliaSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGGhidagliaSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGGhidagliaSAturb3D
FluxFcnSGGhidagliaSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGGhidagliaSAturb3D : public FluxFcnGhidagliaSAturb3D {$/;"	c
FluxFcnSGInflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGInflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGInflowEuler3D
FluxFcnSGInflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGInflowEuler3D : public FluxFcnInflowEuler3D {$/;"	c
FluxFcnSGInternalInflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalInflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGInternalInflowEuler3D
FluxFcnSGInternalInflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalInflowEuler3D : public FluxFcnInternalInflowEuler3D {$/;"	c
FluxFcnSGInternalInflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalInflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGInternalInflowSA3D
FluxFcnSGInternalInflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalInflowSA3D : public FluxFcnInternalInflowSA3D {$/;"	c
FluxFcnSGInternalInflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalInflowSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGInternalInflowSAturb3D
FluxFcnSGInternalInflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalInflowSAturb3D : public FluxFcnInternalInflowSAturb3D {$/;"	c
FluxFcnSGInternalOutflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalOutflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGInternalOutflowEuler3D
FluxFcnSGInternalOutflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalOutflowEuler3D : public FluxFcnInternalOutflowEuler3D {$/;"	c
FluxFcnSGInternalOutflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalOutflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGInternalOutflowSA3D
FluxFcnSGInternalOutflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalOutflowSA3D : public FluxFcnInternalOutflowSA3D {$/;"	c
FluxFcnSGInternalOutflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGInternalOutflowSAturb3D(IoData  &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGInternalOutflowSAturb3D
FluxFcnSGInternalOutflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGInternalOutflowSAturb3D : public FluxFcnInternalOutflowSAturb3D {$/;"	c
FluxFcnSGMassFlowInflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowInflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
FluxFcnSGMassFlowInflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowInflowEuler3D : public FluxFcnMassFlowInflowEuler3D {$/;"	c
FluxFcnSGMassFlowInflowKE3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowInflowKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowInflowKE3D
FluxFcnSGMassFlowInflowKE3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowInflowKE3D : public FluxFcnMassFlowInflowKE3D {$/;"	c
FluxFcnSGMassFlowInflowKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowInflowKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowInflowKEturb3D
FluxFcnSGMassFlowInflowKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowInflowKEturb3D : public FluxFcnMassFlowInflowKEturb3D {$/;"	c
FluxFcnSGMassFlowInflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowInflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowInflowSA3D
FluxFcnSGMassFlowInflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowInflowSA3D : public FluxFcnMassFlowInflowSA3D {$/;"	c
FluxFcnSGMassFlowInflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowInflowSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowInflowSAturb3D
FluxFcnSGMassFlowInflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowInflowSAturb3D : public FluxFcnMassFlowInflowSAturb3D {$/;"	c
FluxFcnSGMassFlowOutflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowOutflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGMassFlowOutflowEuler3D
FluxFcnSGMassFlowOutflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowOutflowEuler3D : public FluxFcnMassFlowOutflowEuler3D {$/;"	c
FluxFcnSGMassFlowOutflowKE3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowOutflowKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowOutflowKE3D
FluxFcnSGMassFlowOutflowKE3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowOutflowKE3D : public FluxFcnMassFlowOutflowKE3D {$/;"	c
FluxFcnSGMassFlowOutflowKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowOutflowKEturb3D(IoData  &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowOutflowKEturb3D
FluxFcnSGMassFlowOutflowKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowOutflowKEturb3D : public FluxFcnMassFlowOutflowKEturb3D {$/;"	c
FluxFcnSGMassFlowOutflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowOutflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowOutflowSA3D
FluxFcnSGMassFlowOutflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowOutflowSA3D : public FluxFcnMassFlowOutflowSA3D {$/;"	c
FluxFcnSGMassFlowOutflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGMassFlowOutflowSAturb3D(IoData  &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGMassFlowOutflowSAturb3D
FluxFcnSGMassFlowOutflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGMassFlowOutflowSAturb3D : public FluxFcnMassFlowOutflowSAturb3D {$/;"	c
FluxFcnSGModifiedGhidagliaEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGModifiedGhidagliaEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGModifiedGhidagliaEuler3D
FluxFcnSGModifiedGhidagliaEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGModifiedGhidagliaEuler3D : public FluxFcnModifiedGhidagliaEuler3D {$/;"	c
FluxFcnSGOutflowEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGOutflowEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGOutflowEuler3D
FluxFcnSGOutflowEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGOutflowEuler3D : public FluxFcnOutflowEuler3D {$/;"	c
FluxFcnSGOutflowKE3D	FluxFcnDescSG.h	/^  FluxFcnSGOutflowKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGOutflowKE3D
FluxFcnSGOutflowKE3D	FluxFcnDescSG.h	/^class FluxFcnSGOutflowKE3D : public FluxFcnOutflowKE3D {$/;"	c
FluxFcnSGOutflowKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGOutflowKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGOutflowKEturb3D
FluxFcnSGOutflowKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGOutflowKEturb3D : public FluxFcnOutflowKEturb3D{$/;"	c
FluxFcnSGOutflowSA3D	FluxFcnDescSG.h	/^  FluxFcnSGOutflowSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGOutflowSA3D
FluxFcnSGOutflowSA3D	FluxFcnDescSG.h	/^class FluxFcnSGOutflowSA3D : public FluxFcnOutflowSA3D {$/;"	c
FluxFcnSGOutflowSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGOutflowSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGOutflowSAturb3D
FluxFcnSGOutflowSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGOutflowSAturb3D : public FluxFcnOutflowSAturb3D {$/;"	c
FluxFcnSGPorousWallEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGPorousWallEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnSGPorousWallEuler3D
FluxFcnSGPorousWallEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGPorousWallEuler3D : public FluxFcnPorousWallEuler3D {$/;"	c
FluxFcnSGPorousWallKE3D	FluxFcnDescSG.h	/^  FluxFcnSGPorousWallKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGPorousWallKE3D
FluxFcnSGPorousWallKE3D	FluxFcnDescSG.h	/^class FluxFcnSGPorousWallKE3D : public FluxFcnPorousWallKE3D {$/;"	c
FluxFcnSGPorousWallKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGPorousWallKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGPorousWallKEturb3D
FluxFcnSGPorousWallKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGPorousWallKEturb3D : public FluxFcnPorousWallKEturb3D {$/;"	c
FluxFcnSGPorousWallSA3D	FluxFcnDescSG.h	/^  FluxFcnSGPorousWallSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGPorousWallSA3D
FluxFcnSGPorousWallSA3D	FluxFcnDescSG.h	/^class FluxFcnSGPorousWallSA3D : public FluxFcnPorousWallSA3D {$/;"	c
FluxFcnSGPorousWallSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGPorousWallSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGPorousWallSAturb3D
FluxFcnSGPorousWallSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGPorousWallSAturb3D : public FluxFcnPorousWallSAturb3D {$/;"	c
FluxFcnSGRoeKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGRoeKEturb3D(double gg, IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGRoeKEturb3D
FluxFcnSGRoeKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGRoeKEturb3D : public FluxFcnRoeKEturb3D {$/;"	c
FluxFcnSGRoeSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGRoeSAturb3D(double gg, IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGRoeSAturb3D
FluxFcnSGRoeSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGRoeSAturb3D : public FluxFcnRoeSAturb3D {$/;"	c
FluxFcnSGVanLeerEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGVanLeerEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnSGVanLeerEuler3D
FluxFcnSGVanLeerEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGVanLeerEuler3D : public FluxFcnVanLeerEuler3D {$/;"	c
FluxFcnSGWallEuler3D	FluxFcnDescSG.h	/^  FluxFcnSGWallEuler3D(IoData &ioData, VarFcnSGEuler *varFcnSGEuler, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnSGWallEuler3D
FluxFcnSGWallEuler3D	FluxFcnDescSG.h	/^class FluxFcnSGWallEuler3D : public FluxFcnWallEuler3D {$/;"	c
FluxFcnSGWallKE3D	FluxFcnDescSG.h	/^  FluxFcnSGWallKE3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGWallKE3D
FluxFcnSGWallKE3D	FluxFcnDescSG.h	/^class FluxFcnSGWallKE3D : public FluxFcnWallKE3D {$/;"	c
FluxFcnSGWallKEturb3D	FluxFcnDescSG.h	/^  FluxFcnSGWallKEturb3D(IoData &ioData, VarFcnSGKE *varFcnSGKE, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGWallKEturb3D
FluxFcnSGWallKEturb3D	FluxFcnDescSG.h	/^class FluxFcnSGWallKEturb3D : public FluxFcnWallKEturb3D {$/;"	c
FluxFcnSGWallSA3D	FluxFcnDescSG.h	/^  FluxFcnSGWallSA3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGWallSA3D
FluxFcnSGWallSA3D	FluxFcnDescSG.h	/^class FluxFcnSGWallSA3D : public FluxFcnWallSA3D {$/;"	c
FluxFcnSGWallSAturb3D	FluxFcnDescSG.h	/^  FluxFcnSGWallSAturb3D(IoData &ioData, VarFcnSGSA *varFcnSGSA, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnSGWallSAturb3D
FluxFcnSGWallSAturb3D	FluxFcnDescSG.h	/^class FluxFcnSGWallSAturb3D : public FluxFcnWallSAturb3D {$/;"	c
FluxFcnTaitApprJacRoeEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitApprJacRoeEuler3D(int rs, double gg, IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnTaitApprJacRoeEuler3D
FluxFcnTaitApprJacRoeEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitApprJacRoeEuler3D : public FluxFcnApprJacRoeEuler3D {$/;"	c
FluxFcnTaitApprJacRoeKE3D	FluxFcnDescTait.h	/^  FluxFcnTaitApprJacRoeKE3D(int rs, double gg, IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitApprJacRoeKE3D
FluxFcnTaitApprJacRoeKE3D	FluxFcnDescTait.h	/^class FluxFcnTaitApprJacRoeKE3D : public FluxFcnApprJacRoeKE3D {$/;"	c
FluxFcnTaitApprJacRoeSA3D	FluxFcnDescTait.h	/^  FluxFcnTaitApprJacRoeSA3D(int rs, double gg, IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitApprJacRoeSA3D
FluxFcnTaitApprJacRoeSA3D	FluxFcnDescTait.h	/^class FluxFcnTaitApprJacRoeSA3D : public FluxFcnApprJacRoeSA3D {$/;"	c
FluxFcnTaitExactJacRoeEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitExactJacRoeEuler3D(double gg, IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnTaitExactJacRoeEuler3D
FluxFcnTaitExactJacRoeEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitExactJacRoeEuler3D : public FluxFcnExactJacRoeEuler3D {$/;"	c
FluxFcnTaitFDJacRoeEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitFDJacRoeEuler3D(double gg, IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitFDJacRoeEuler3D
FluxFcnTaitFDJacRoeEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitFDJacRoeEuler3D : public FluxFcnFDJacRoeEuler3D {$/;"	c
FluxFcnTaitGhidagliaEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitGhidagliaEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitGhidagliaEuler3D
FluxFcnTaitGhidagliaEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitGhidagliaEuler3D : public FluxFcnGhidagliaEuler3D {$/;"	c
FluxFcnTaitGhidagliaKE3D	FluxFcnDescTait.h	/^  FluxFcnTaitGhidagliaKE3D(IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitGhidagliaKE3D
FluxFcnTaitGhidagliaKE3D	FluxFcnDescTait.h	/^class FluxFcnTaitGhidagliaKE3D : public FluxFcnGhidagliaKE3D {$/;"	c
FluxFcnTaitGhidagliaKEturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitGhidagliaKEturb3D(IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitGhidagliaKEturb3D
FluxFcnTaitGhidagliaKEturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitGhidagliaKEturb3D : public FluxFcnGhidagliaKEturb3D {$/;"	c
FluxFcnTaitGhidagliaSA3D	FluxFcnDescTait.h	/^  FluxFcnTaitGhidagliaSA3D(IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitGhidagliaSA3D
FluxFcnTaitGhidagliaSA3D	FluxFcnDescTait.h	/^class FluxFcnTaitGhidagliaSA3D : public FluxFcnGhidagliaSA3D {$/;"	c
FluxFcnTaitGhidagliaSAturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitGhidagliaSAturb3D(IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitGhidagliaSAturb3D
FluxFcnTaitGhidagliaSAturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitGhidagliaSAturb3D : public FluxFcnGhidagliaSAturb3D {$/;"	c
FluxFcnTaitInflowEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitInflowEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitInflowEuler3D
FluxFcnTaitInflowEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitInflowEuler3D : public FluxFcnInflowEuler3D {$/;"	c
FluxFcnTaitInternalInflowEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitInternalInflowEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnTaitInternalInflowEuler3D
FluxFcnTaitInternalInflowEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitInternalInflowEuler3D : public FluxFcnInternalInflowEuler3D {$/;"	c
FluxFcnTaitInternalOutflowEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitInternalOutflowEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) : $/;"	f	class:FluxFcnTaitInternalOutflowEuler3D
FluxFcnTaitInternalOutflowEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitInternalOutflowEuler3D : public FluxFcnInternalOutflowEuler3D {$/;"	c
FluxFcnTaitModifiedGhidagliaEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitModifiedGhidagliaEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitModifiedGhidagliaEuler3D
FluxFcnTaitModifiedGhidagliaEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitModifiedGhidagliaEuler3D : public FluxFcnModifiedGhidagliaEuler3D {$/;"	c
FluxFcnTaitOutflowEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitOutflowEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitOutflowEuler3D
FluxFcnTaitOutflowEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitOutflowEuler3D : public FluxFcnOutflowEuler3D {$/;"	c
FluxFcnTaitRoeKEturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitRoeKEturb3D(double gg, IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitRoeKEturb3D
FluxFcnTaitRoeKEturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitRoeKEturb3D : public FluxFcnRoeKEturb3D {$/;"	c
FluxFcnTaitRoeSAturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitRoeSAturb3D(double gg, IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitRoeSAturb3D
FluxFcnTaitRoeSAturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitRoeSAturb3D : public FluxFcnRoeSAturb3D {$/;"	c
FluxFcnTaitWallEuler3D	FluxFcnDescTait.h	/^  FluxFcnTaitWallEuler3D(IoData &ioData, VarFcnTait *varFcnTait, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnTaitWallEuler3D
FluxFcnTaitWallEuler3D	FluxFcnDescTait.h	/^class FluxFcnTaitWallEuler3D : public FluxFcnWallEuler3D {$/;"	c
FluxFcnTaitWallKE3D	FluxFcnDescTait.h	/^  FluxFcnTaitWallKE3D(IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnTaitWallKE3D
FluxFcnTaitWallKE3D	FluxFcnDescTait.h	/^class FluxFcnTaitWallKE3D : public FluxFcnWallKE3D {$/;"	c
FluxFcnTaitWallKEturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitWallKEturb3D(IoData &ioData, VarFcnTaitKE *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitWallKEturb3D
FluxFcnTaitWallKEturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitWallKEturb3D : public FluxFcnWallKEturb3D {$/;"	c
FluxFcnTaitWallSA3D	FluxFcnDescTait.h	/^  FluxFcnTaitWallSA3D(IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp=CONSERVATIVE) :$/;"	f	class:FluxFcnTaitWallSA3D
FluxFcnTaitWallSA3D	FluxFcnDescTait.h	/^class FluxFcnTaitWallSA3D : public FluxFcnWallSA3D {$/;"	c
FluxFcnTaitWallSAturb3D	FluxFcnDescTait.h	/^  FluxFcnTaitWallSAturb3D(IoData &ioData, VarFcnTaitSA *varFcnTait, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnTaitWallSAturb3D
FluxFcnTaitWallSAturb3D	FluxFcnDescTait.h	/^class FluxFcnTaitWallSAturb3D : public FluxFcnWallSAturb3D {$/;"	c
FluxFcnVanLeerEuler3D	FluxFcnDesc.h	/^  FluxFcnVanLeerEuler3D(VarFcnBase *vf, Type tp) :$/;"	f	class:FluxFcnVanLeerEuler3D
FluxFcnVanLeerEuler3D	FluxFcnDesc.h	/^class FluxFcnVanLeerEuler3D : public FluxFcnBase {$/;"	c
FluxFcnWallEuler3D	FluxFcnDesc.h	/^  FluxFcnWallEuler3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnWallEuler3D
FluxFcnWallEuler3D	FluxFcnDesc.h	/^class FluxFcnWallEuler3D : public FluxFcnFD<5> {$/;"	c
FluxFcnWallKE3D	FluxFcnDesc.h	/^  FluxFcnWallKE3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnWallKE3D
FluxFcnWallKE3D	FluxFcnDesc.h	/^class FluxFcnWallKE3D : public FluxFcnFD<7> {$/;"	c
FluxFcnWallKEturb3D	FluxFcnDesc.h	/^  FluxFcnWallKEturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnWallKEturb3D
FluxFcnWallKEturb3D	FluxFcnDesc.h	/^class FluxFcnWallKEturb3D : public FluxFcnBase {$/;"	c
FluxFcnWallSA3D	FluxFcnDesc.h	/^  FluxFcnWallSA3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnWallSA3D
FluxFcnWallSA3D	FluxFcnDesc.h	/^class FluxFcnWallSA3D : public FluxFcnFD<6> {$/;"	c
FluxFcnWallSAturb3D	FluxFcnDesc.h	/^  FluxFcnWallSAturb3D(VarFcnBase *vf, Type tp = CONSERVATIVE) :$/;"	f	class:FluxFcnWallSAturb3D
FluxFcnWallSAturb3D	FluxFcnDesc.h	/^class FluxFcnWallSAturb3D : public FluxFcnBase {$/;"	c
FluxMap	Manual/Aerof3d.html	/^<a name="FluxMap"><\/a>$/;"	a
Fm	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Fm	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Fm	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:FluidGnatShapeOptimizationHandler
Fm	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:FluidMetricShapeOptimizationHandler
Fm	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:FluidRomShapeOptimizationHandler
Fm	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fm;$/;"	m	class:FluidShapeOptimizationHandler
Fn	MeshMotionHandler.h	/^  DistSVec<double,3>* Fn;$/;"	m	class:AeroMeshMotionHandler
Fnp1	MeshMotionHandler.h	/^  DistSVec<double,3>* Fnp1;$/;"	m	class:AeroMeshMotionHandler
Fold	ImplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> U0,Fold;$/;"	m	class:ImplicitLevelSetTsDesc
Force	IoData.h	/^  enum Force {LAST = 0, AVERAGED = 1, LAST_KRIS = 2} force;$/;"	g	struct:AeroelasticData
ForceAlgorithm	IoData.h	/^  enum ForceAlgorithm {RECONSTRUCTED_SURFACE = 0, CONTROL_VOLUME_BOUNDARY = 1, EMBEDDED_SURFACE = 2} forceAlg;$/;"	g	struct:EmbeddedFramework
ForceGenerator	PostOperator.h	/^class ForceGenerator {$/;"	c
ForcePoints	IoData.h	/^struct ForcePoints {$/;"	s
ForcePoints	IoDataCore.C	/^ForcePoints::ForcePoints()$/;"	f	class:ForcePoints
ForceResults	IoData.h	/^  enum ForceResults {NO = 0, YES = 1} forceResults;$/;"	g	struct:SurfaceData
Forced	Manual/Aerof3d.html	/^<a name="Forced"><\/a>$/;"	a
ForcedData	IoData.h	/^struct ForcedData {$/;"	s
ForcedData	IoDataCore.C	/^ForcedData::ForcedData()$/;"	f	class:ForcedData
Forest_Edges	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Forest_Edges(ARRAY<PAIR<ID,ID> >& pairs) const$/;"	f	class:PhysBAM::UNION_FIND
Forig	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
Forig	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
Forig	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
Form	IoData.h	/^  enum Form {DESCRIPTOR = 1, NONDESCRIPTOR = 0, HYBRID = 2} form;$/;"	g	struct:TsData
Form	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	g	struct:DESModelData
Form	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	g	struct:SAModelData
Four_Four_Sum	utils/Predicate.C	277;"	d	file:
Four_One_Product	utils/Predicate.C	310;"	d	file:
Four_One_Sum	utils/Predicate.C	269;"	d	file:
Four_Two_Sum	utils/Predicate.C	273;"	d	file:
Fp	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Fp	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Fp	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:FluidGnatShapeOptimizationHandler
Fp	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:FluidMetricShapeOptimizationHandler
Fp	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:FluidRomShapeOptimizationHandler
Fp	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Fp;$/;"	m	class:FluidShapeOptimizationHandler
Fp	ProgrammedBurnCore.C	/^	double Fp(double rho) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
Fpp	ProgrammedBurnCore.C	/^	double Fpp(double rho) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
FractionalStrategy	IoData.h	/^   enum FractionalStrategy {Distance = 1, DotProduct = 2} fractionalStrategy;$/;"	g	struct:BLMeshMotionData
Frame	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    const FRAME& Frame() const$/;"	f	class:PhysBAM::FRAME
Frame_File_Exists	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Frame_File_Exists(const std::string &filename,int frame)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Framework	IoData.h	/^  enum Framework {BODYFITTED = 0, EMBEDDED = 1, EMBEDDEDALE = 2} framework;$/;"	g	struct:ProblemData
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::MATRIX_BASE
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Frobenius_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Frobenius_Norm() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.cpp	/^Frobenius_Norm_Squared() const$/;"	f	class:MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::MATRIX_BASE
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Frobenius_Norm_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Frobenius_Norm_Squared() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
From	ImplicitCollocationTsDesc.h	/^  Vec<double> From;$/;"	m	class:ImplicitCollocationTsDesc
From	ImplicitMetricTsDesc.h	/^  Vec<double> From;$/;"	m	class:ImplicitMetricTsDesc
From	ImplicitPGTsDesc.h	/^  Vec<double> From;$/;"	m	class:ImplicitPGTsDesc
From_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Angle(const T& a)$/;"	f	class:PhysBAM::ROTATION
From_Complex	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Complex(const COMPLEX<T>& c2)$/;"	f	class:PhysBAM::ROTATION
From_Components	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Components(const T s,const T x,const T y,const T z)$/;"	f	class:PhysBAM::ROTATION
From_Components_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Components_Helper(const T2 s,const T x,const T y,const T z)$/;"	f	class:PhysBAM::ROTATION
From_Components_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Components_Helper(const int s,const int x,const int y,const int z)$/;"	f	class:PhysBAM::ROTATION
From_Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^From_Euler_Angles(const T euler_angle_x,const T euler_angle_y,const T euler_angle_z) \/\/ rotation about fixed axes x, then y, then z$/;"	f	class:ROTATION
From_Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION From_Euler_Angles(const VECTOR<T,0>&)$/;"	f	class:PhysBAM::ROTATION
From_Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Euler_Angles(const TV& euler_angles)$/;"	f	class:PhysBAM::ROTATION
From_Euler_Angles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Euler_Angles(const VECTOR<T,1>& angle)$/;"	f	class:PhysBAM::ROTATION
From_Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX From_Linear(const MATRIX<T,2>& M) \/\/ Create a homogeneous 3x3 matrix corresponding to a 2x2 transform$/;"	f	class:PhysBAM::MATRIX
From_Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX From_Linear(const MATRIX<T,3>& M) \/\/ Create a homogeneous 4x4 matrix corresponding to a 3x3 transform$/;"	f	class:PhysBAM::MATRIX
From_Quaternion	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Quaternion(const QUATERNION<T>& q)$/;"	f	class:PhysBAM::ROTATION
From_Rotated_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^From_Rotated_Vector(const TV& initial_vector,const TV& final_vector)$/;"	f	class:ROTATION
From_Rotated_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^From_Rotated_Vector(const TV& v1,const TV& v2)$/;"	f	class:ROTATION
From_Rotated_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Rotated_Vector(const TV&,const TV&)$/;"	f	class:PhysBAM::ROTATION
From_Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^From_Rotation_Vector(const TV& v)$/;"	f	class:ROTATION
From_Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Rotation_Vector(const VECTOR<T,0>)$/;"	f	class:PhysBAM::ROTATION
From_Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> From_Rotation_Vector(const VECTOR<T,1>& v)$/;"	f	class:PhysBAM::ROTATION
Fs	EmbeddedTsDesc.h	/^  double (*Fs)[3]; \/\/force distribution on the structure surfac3$/;"	m	class:EmbeddedTsDesc
Fs	MultiPhysicsTsDesc.h	/^  double (*Fs)[3]; \/\/force distribution on the structure surfac3$/;"	m	class:MultiPhysicsTsDesc
FsComputed	EmbeddedTsDesc.h	/^  bool FsComputed; \/\/whether Fs has been computed for this (fluid-)time step.$/;"	m	class:EmbeddedTsDesc
FsComputed	MultiPhysicsTsDesc.h	/^  bool FsComputed; \/\/whether Fs has been computed for this (fluid-)time step.$/;"	m	class:MultiPhysicsTsDesc
Ftmp	MatVecProd.h	/^  DistSVec<double,neq> Ftmp;$/;"	m	class:MatVecProdFD
Full-order-linearized	Manual/Aerof3d.html	/^<a name="Full-order-linearized"><\/a>$/;"	a
FullM	DenseMatrix.h	/^typedef GenFullM<double> FullM;$/;"	t
FullM	Domain.h	/^typedef GenFullM<double> FullM;$/;"	t
FullM	ParallelRom.h	/^typedef GenFullM<double> FullM;$/;"	t
Full_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Full_Box()$/;"	f	class:PhysBAM::INTERVAL
Full_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Full_Box()$/;"	f	class:PhysBAM::RANGE
Function_Is_Not_Defined	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Function_Is_Not_Defined(const char* function,const char* file,unsigned int line,const std::type_info& type)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Functor	SparseGrid.h	/^    Functor(MemberFunctionType memberfn, T &object) : $/;"	f	class:SparseGrid::Functor
Functor	SparseGrid.h	/^  class Functor{$/;"	c	class:SparseGrid
Fuzzy_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.cpp	/^template<class T> bool Fuzzy_Intersects(RAY<VECTOR<T,2> >& ray,const ORIENTED_BOX<VECTOR<T,2> >& box,const T segment_intersect_epsilon)$/;"	f	namespace:PhysBAM::INTERSECTION
Fuzzy_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^template<class T> bool Fuzzy_Intersects(RAY<VECTOR<T,2> >& ray,const SEGMENT_2D<T>& segment,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
G1	f77src/g1.f	/^      SUBROUTINE G1 /;"	s
GALERKIN	IoData.h	/^  enum Gradient {LEAST_SQUARES = 0, GALERKIN = 1, NON_NODAL = 2} gradient;$/;"	e	enum:SchemeData::Gradient
GALERKIN	IoData.h	/^  enum Projection {PETROV_GALERKIN = 0, GALERKIN = 1} projection;$/;"	e	enum:NonlinearRomOnlineData::Projection
GAS	DistBcData.h	/^  enum BoundaryFluid { GAS=0, TAIT=1, JWL=2 } boundaryFluid;$/;"	e	enum:DistBcData::BoundaryFluid
GATHER_NUMBERS_TAG	IntersectorPhysBAM/Mpi_Utilities.h	32;"	d
GATHER_SET_TAG	IntersectorPhysBAM/Mpi_Utilities.h	34;"	d
GCCBACKTRACE	DebugTools.h	6;"	d
GCR	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	e	enum:KspData::Type
GE	arpack++/include/arlsupm.h	/^    GE,        \/* general *\/$/;"	e	enum:__anon44
GEMV	arpack++/include/arlutil.h	/^    GEMV,    \/* fraction of FACT spent in xGEMV *\/$/;"	e	enum:__anon51
GENBCFLUXGAS	f77src/genbcfluxgas.f	/^      SUBROUTINE GENBCFLUXGAS(/;"	s
GENBCFLUXGAS_HH	f77src/genbcfluxgas_HH.f	/^      SUBROUTINE GENBCFLUXGAS_HH(/;"	s
GENBCFLUXGAS_INT	f77src/genbcfluxgas_INT.f	/^      SUBROUTINE GENBCFLUXGAS_INT(/;"	s
GENBCFLUXJWL	f77src/genbcfluxjwl.f	/^      SUBROUTINE GENBCFLUXJWL(/;"	s
GENBCFLUXTAIT	f77src/genbcfluxtait.f	/^      SUBROUTINE GENBCFLUXTAIT(/;"	s
GENBCFLUXTAIT_HH	f77src/genbcfluxtait_HH.f	/^      SUBROUTINE GENBCFLUXTAIT_HH(/;"	s
GENERIC_SEVERE	arpack++/include/arerror.h	/^    GENERIC_SEVERE      = -999,$/;"	e	enum:ArpackError::ErrorCode
GENERIC_WARNING	arpack++/include/arerror.h	/^    GENERIC_WARNING     =  999$/;"	e	enum:ArpackError::ErrorCode
GEOMETRY_PARTICLES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.cpp	/^GEOMETRY_PARTICLES()$/;"	f	class:PhysBAM::GEOMETRY_PARTICLES
GEOMETRY_PARTICLES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^class GEOMETRY_PARTICLES:public CLONEABLE<GEOMETRY_PARTICLES<TV>,POINT_CLOUD<TV> >$/;"	c	namespace:PhysBAM
GET	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    template<int i> struct GET:public IF<i==1,T1,T2>{};$/;"	s	class:PhysBAM::PAIR
GHIDAGLIA	IoData.h	/^              GHIDAGLIA = 3, MODIFIED_GHIDAGLIA = 4} type;$/;"	e	enum:BoundarySchemeData::Type
GHOSTFLUID_FOR_POOR	IoData.h	/^  enum Method {NONE = 0, GHOSTFLUID_FOR_POOR = 1, GHOSTFLUID_WITH_RIEMANN} method;$/;"	e	enum:MultiFluidData::Method
GHOSTFLUID_WITH_RIEMANN	IoData.h	/^  enum Method {NONE = 0, GHOSTFLUID_FOR_POOR = 1, GHOSTFLUID_WITH_RIEMANN} method;$/;"	e	enum:MultiFluidData::Method
GLOBAL	IoData.h	/^  enum TypeTimeStep {AUTO = 0, LOCAL = 1, GLOBAL = 2} typeTimeStep;$/;"	e	enum:TsData::TypeTimeStep
GMRES	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	e	enum:KspData::Type
GNAT	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	e	enum:NonlinearRomOnlineData::SystemApproximation
GRADIENT	IoData.h	/^  enum InterfaceTracking {LINEAR = 0, GRADIENT = 1, HERMITE = 2}; $/;"	e	enum:MultiFluidData::InterfaceTracking
GRAMSCHMIDT_OFF	IoData.h	/^  enum GramSchmidt {GRAMSCHMIDT_OFF = 0, GRAMSCHMIDT_ON = 1} gramSchmidt;$/;"	e	enum:NonlinearRomOnlineNonStateData::GramSchmidt
GRAMSCHMIDT_ON	IoData.h	/^  enum GramSchmidt {GRAMSCHMIDT_OFF = 0, GRAMSCHMIDT_ON = 1} gramSchmidt;$/;"	e	enum:NonlinearRomOnlineNonStateData::GramSchmidt
GREEDY_LS_LINPACK	IoData.h	/^  enum GreedyLeastSquaresSolver {GREEDY_LS_PROBABILISTIC = 0, GREEDY_LS_SCALAPACK = 1, GREEDY_LS_LINPACK = 2} greedyLeastSquaresSolver;$/;"	e	enum:GappyConstructionData::GreedyLeastSquaresSolver
GREEDY_LS_PROBABILISTIC	IoData.h	/^  enum GreedyLeastSquaresSolver {GREEDY_LS_PROBABILISTIC = 0, GREEDY_LS_SCALAPACK = 1, GREEDY_LS_LINPACK = 2} greedyLeastSquaresSolver;$/;"	e	enum:GappyConstructionData::GreedyLeastSquaresSolver
GREEDY_LS_SCALAPACK	IoData.h	/^  enum GreedyLeastSquaresSolver {GREEDY_LS_PROBABILISTIC = 0, GREEDY_LS_SCALAPACK = 1, GREEDY_LS_LINPACK = 2} greedyLeastSquaresSolver;$/;"	e	enum:GappyConstructionData::GreedyLeastSquaresSolver
GXBOUNDFLUX5	f77src/g_boundflux5.f	/^      SUBROUTINE GXBOUNDFLUX5(/;"	s
GXBOUNDFLUX5TEMP	f77src/g_boundflux5temp.f	/^      SUBROUTINE GXBOUNDFLUX5TEMP(/;"	s
GXROEFLUX5	f77src/g_roeflux5.f	/^      SUBROUTINE GXROEFLUX5(/;"	s
GXROEFLUX6	f77src/g_roeflux6.f	/^      SUBROUTINE GXROEFLUX6(/;"	s
GXROEFLUX6TEMP	f77src/g_roeflux6temp.f	/^      SUBROUTINE GXROEFLUX6TEMP(/;"	s
GappyConstructionData	IoData.h	/^struct GappyConstructionData {$/;"	s
GappyConstructionData	IoDataCore.C	/^GappyConstructionData::GappyConstructionData()$/;"	f	class:GappyConstructionData
GappyPreprocessing	GappyPreprocessing.C	/^GappyPreprocessing<dim>::GappyPreprocessing(Communicator *_com, IoData &_ioData, Domain$/;"	f	class:GappyPreprocessing
GappyPreprocessing	GappyPreprocessing.h	/^class GappyPreprocessing : public NonlinearRom<dim> {$/;"	c
GasModel	Manual/Aerof3d.html	/^<a name="GasModel"><\/a>$/;"	a
GasModelData	IoData.h	/^struct GasModelData {$/;"	s
GasModelData	IoDataCore.C	/^GasModelData::GasModelData()$/;"	f	class:GasModelData
Gauss_Seidel_Single_Iteration	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    void Gauss_Seidel_Single_Iteration(VECTOR_ND<T>& x,const VECTOR_ND<T>& b) const$/;"	f	class:PhysBAM::MATRIX_MXN
GcrSolver	KspSolver.C	/^GcrSolver(const typename VecType::InfoType &info, KspData &data,$/;"	f	class:GcrSolver
GcrSolver	KspSolver.h	/^class GcrSolver : public KspSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT> {$/;"	c
GenComplex	arpack++/include/arrsnsym.h	/^GenComplex(int dim, ARFLOAT* RealPart)$/;"	f	class:ARrcNonSymStdEig
GenComplex	arpack++/include/arrsnsym.h	/^GenComplex(int dim, ARFLOAT* RealPart, ARFLOAT* ImagPart, bool conj)$/;"	f	class:ARrcNonSymStdEig
GenComplex	arpack++/include/arrsnsym.h	/^GenComplex(vector<ARFLOAT>* RealPart, vector<ARFLOAT>* ImagPart, bool conj)$/;"	f	class:ARrcNonSymStdEig
GenElemHelper_Scalar_dim_neq	Elem.h	/^class GenElemHelper_Scalar_dim_neq {$/;"	c
GenElemHelper_dim	Elem.h	/^class GenElemHelper_dim {$/;"	c
GenElemHelper_dim_obj	Elem.h	/^class GenElemHelper_dim_obj {$/;"	c
GenElemWrapper_Scalar_dim_neq	Elem.h	/^class GenElemWrapper_Scalar_dim_neq {$/;"	c
GenElemWrapper_dim	Elem.h	/^class GenElemWrapper_dim {$/;"	c
GenElemWrapper_dim_obj	Elem.h	/^class GenElemWrapper_dim_obj {$/;"	c
GenFaceHelper_Scalar_dim_neq	Face.h	/^class GenFaceHelper_Scalar_dim_neq {$/;"	c
GenFaceHelper_dim	Face.h	/^class GenFaceHelper_dim {$/;"	c
GenFaceWrapper_Scalar_dim_neq	Face.h	/^class GenFaceWrapper_Scalar_dim_neq {$/;"	c
GenFaceWrapper_dim	Face.h	/^class GenFaceWrapper_dim {$/;"	c
GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::GenFullM() $/;"	f	class:GenFullM
GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::GenFullM(const GenFullM &m) $/;"	f	class:GenFullM
GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::GenFullM(const GenFullM &m, int nr, int sr, int nc, int sc)$/;"	f	class:GenFullM
GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::GenFullM(int nr) $/;"	f	class:GenFullM
GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::GenFullM(int nr, int nc) $/;"	f	class:GenFullM
GenFullM	DenseMatrix.h	/^class GenFullM {$/;"	c
GenMat	GenMatrix.h	/^  GenMat() {}$/;"	f	class:GenMat
GenMat	GenMatrix.h	/^class GenMat {$/;"	c
Generate_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    void Generate_Unit_Direction(VECTOR<T,1>& v,int i) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Generate_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    void Generate_Unit_Direction(VECTOR<T,2>& v,int i) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Generate_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    void Generate_Unit_Direction(VECTOR<T,3>& v,int i) const$/;"	f	class:PhysBAM::ORIENTED_BOX
GeoData	GeoData.C	/^GeoData::GeoData(IoData &ioData)$/;"	f	class:GeoData
GeoData	GeoData.C	/^GeoData::GeoData(const GeoData& d) :$/;"	f	class:GeoData
GeoData	GeoData.h	/^class GeoData {$/;"	c
GeoSource	GeoSource.C	/^GeoSource::GeoSource(IoData &ioData)$/;"	f	class:GeoSource
GeoSource	GeoSource.h	/^class GeoSource {$/;"	c
GeoState	GeoState.C	/^GeoState::GeoState(const GeoData &gd, Vec<double> &ctrlvoln, Vec<double> &ctrlvolnm1,$/;"	f	class:GeoState
GeoState	GeoState.h	/^class GeoState {$/;"	c
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Get(T_ARRAY& new_copy,const T_ARRAY& old_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    T_UNLESS_VOID& Get(const TK& v) \/\/ fails if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Get(const TK& v,T_UNLESS_VOID& value) const$/;"	f	class:PhysBAM::HASHTABLE
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    const T_UNLESS_VOID& Get(const TK& v) const \/\/ fails if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    template<int i> const typename GET<i>::TYPE& Get() const$/;"	f	class:PhysBAM::PAIR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    template<int i> typename GET<i>::TYPE& Get()$/;"	f	class:PhysBAM::PAIR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    void Get(T1& a,T2& b) const$/;"	f	class:PhysBAM::PAIR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Get(ARRAY_BASE& new_copy,const ARRAY_BASE& old_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Get(T& element1,T& element2,T& element3,T& element4) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Get(T& element1,T& element2,T& element3,T& element4,T& element5) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Get(T& element1,T& element2,T& element3,T& element4,T& element5,T& element6) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Get(T& element1,T& element2,T& element3,T& element4,T& element5,T& element6,T& element7) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Get(T& element1,T& element2,T& element3,T& element4,T& element5,T& element6,T& element7,T& element8) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    void Get(T& element1) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Get(T& element1,T& element2) const$/;"	f	class:PhysBAM::VECTOR
Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Get(T& element1,T& element2,T& element3) const$/;"	f	class:PhysBAM::VECTOR
GetAutoShift	arpack++/include/arrseig.h	/^  bool GetAutoShift() { return AutoShift; }$/;"	f	class:ARrcStdEig
GetIdo	arpack++/include/arrseig.h	/^  int GetIdo() { return ido; }$/;"	f	class:ARrcStdEig
GetIter	arpack++/include/arrseig.h	/^int ARrcStdEig<ARFLOAT, ARTYPE>::GetIter()$/;"	f	class:ARrcStdEig
GetJacobian	ImplicitCoupledTsDesc.h	/^  DistMat<double,dim>* GetJacobian() { $/;"	f	class:ImplicitCoupledTsDesc
GetJacobian	ImplicitEmbeddedCoupledTsDesc.h	/^  DistMat<double,dim>* GetJacobian() { $/;"	f	class:ImplicitEmbeddedCoupledTsDesc
GetJacobian	ImplicitEmbeddedTsDesc.h	/^  virtual DistMat<double,dim>* GetJacobian() { $/;"	f	class:ImplicitEmbeddedTsDesc
GetJacobian1	ImplicitSegTsDesc.h	/^  DistMat<double,neq1>* GetJacobian1() { $/;"	f	class:ImplicitSegTsDesc
GetJacobian2	ImplicitSegTsDesc.h	/^  DistMat<double,neq2>* GetJacobian2() { $/;"	f	class:ImplicitSegTsDesc
GetLevelsFromInterfaceAndMarchForward	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::GetLevelsFromInterfaceAndMarchForward(DistLevelSetStructure& LSS,$/;"	f	class:ReinitializeDistanceToWall
GetMaxit	arpack++/include/arrseig.h	/^  int GetMaxit() { return maxit; }$/;"	f	class:ARrcStdEig
GetMode	arpack++/include/arrseig.h	/^  int GetMode() { return mode; }$/;"	f	class:ARrcStdEig
GetN	arpack++/include/arrseig.h	/^  int GetN() { return n; }$/;"	f	class:ARrcStdEig
GetNcv	arpack++/include/arrseig.h	/^  int GetNcv() { return ncv; }$/;"	f	class:ARrcStdEig
GetNev	arpack++/include/arrseig.h	/^  int GetNev() { return nev; }$/;"	f	class:ARrcStdEig
GetNp	arpack++/include/arrseig.h	/^  int GetNp() { return iparam[8]; }$/;"	f	class:ARrcStdEig
GetProd	arpack++/include/arrseig.h	/^ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::GetProd()$/;"	f	class:ARrcStdEig
GetResidual	NewtonSolver.h	/^  typename ProblemDescriptor::SolVecType* GetResidual() { return &F; }$/;"	f	class:NewtonSolver
GetShift	arpack++/include/arrseig.h	/^  ARTYPE GetShift() { return sigmaR; }$/;"	f	class:ARrcStdEig
GetShiftImag	arpack++/include/arrgnsym.h	/^  ARFLOAT GetShiftImag() { return sigmaI; }$/;"	f	class:ARrcNonSymGenEig
GetTol	arpack++/include/arrseig.h	/^  ARFLOAT GetTol() { return tol; }$/;"	f	class:ARrcStdEig
GetVector	arpack++/include/arrseig.h	/^ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::GetVector()$/;"	f	class:ARrcStdEig
GetVectorImag	arpack++/include/arrsnsym.h	/^ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::GetVectorImag()$/;"	f	class:ARrcNonSymStdEig
GetWhich	arpack++/include/arrseig.h	/^  char* GetWhich() { return which; }$/;"	f	class:ARrcStdEig
Get_Angle_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Get_Angle_Axis(T& angle,TV& axis) const$/;"	f	class:ROTATION
Get_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> T_OTHER_ARRAY* Get_Array(const ID array_id)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Get_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> T_OTHER_ARRAY* Get_Array(const std::string array_name)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Get_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> const T_OTHER_ARRAY* Get_Array(const ID array_id) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Get_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    template<class T_OTHER_ARRAY> const T_OTHER_ARRAY* Get_Array(const std::string array_name) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Get_Array_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Get_Array_Helper(const ID array_id)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    T* Get_Array_Pointer()$/;"	f	class:PhysBAM::ARRAY
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    const T* Get_Array_Pointer() const$/;"	f	class:PhysBAM::ARRAY
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    T* Get_Array_Pointer()$/;"	f	class:PhysBAM::ARRAY_VIEW
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    const T* Get_Array_Pointer() const$/;"	f	class:PhysBAM::ARRAY_VIEW
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    const T* Get_Array_Pointer() const$/;"	f	class:PhysBAM::INDIRECT_ARRAY
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typename IF<IS_CONST<T_ARRAY>::value,const T*,T*>::TYPE Get_Array_Pointer()$/;"	f	class:PhysBAM::INDIRECT_ARRAY
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    T* Get_Array_Pointer()$/;"	f	class:PhysBAM::VECTOR_ND
Get_Array_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    const T* Get_Array_Pointer() const$/;"	f	class:PhysBAM::VECTOR_ND
Get_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Get_Axis() const$/;"	f	class:ROTATION
Get_Base_Directory_Name	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Base_Directory_Name(const std::string& path)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Basename	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Basename(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Basename_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Basename_Ignoring_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Get_Column(const int j,VECTOR_BASE<T,T_VECTOR>& a) const$/;"	f	class:PhysBAM::MATRIX_BASE
Get_Complementary_Keys	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Get_Complementary_Keys(const T_ARRAY1& keys_universe,T_ARRAY2& keys_complementary) const$/;"	f	class:PhysBAM::HASHTABLE
Get_Create	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    Get_Create() const$/;"	f	struct:PhysBAM::FACTORY
Get_Create_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    Get_Create_Helper(...) const$/;"	f	struct:PhysBAM::FACTORY
Get_Create_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    Get_Create_Helper(T_CREATE* create) const$/;"	f	struct:PhysBAM::FACTORY
Get_Current_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^double Get_Current_Time(){__int64 time;QueryPerformanceCounter((LARGE_INTEGER*)&time);return (double)time;}$/;"	f	namespace:PhysBAM
Get_Current_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^double Get_Current_Time(){timeval tv;gettimeofday(&tv,0);return tv.tv_sec+1e-6*tv.tv_usec;}$/;"	f	namespace:PhysBAM
Get_Data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Get_Data(ARRAY<T_UNLESS_VOID>& data) const$/;"	f	class:PhysBAM::HASHTABLE
Get_Default	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    T Get_Default(const TK& v,const T_UNLESS_VOID& default_value=T_UNLESS_VOID()) const \/\/ returns default_value if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Direction()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_File_Extension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_File_Extension(const std::string &filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_File_Extension_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_File_Extension_Ignoring_Compression_Suffix(const std::string &filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_File_Type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline FILE_TYPE Get_File_Type(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_File_Type_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline FILE_TYPE Get_File_Type_Ignoring_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Frame	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Frame(const TV& v0,const TV& v1)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Frame_Filename	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Frame_Filename(const std::string &filename,int frame)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Gaussian	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Gaussian()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Horizontal_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<VECTOR<T,d-1> > Get_Horizontal_Box() const$/;"	f	class:PhysBAM::RANGE
Get_Intersection_Range	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Get_Intersection_Range(const RAY<VECTOR<T,3> >& ray,const BOX<VECTOR<T,3> >& box,T& start_t,T& end_t)$/;"	f	namespace:PhysBAM::INTERSECTION
Get_Keys	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Get_Keys(ARRAY<TK>& keys) const$/;"	f	class:PhysBAM::HASHTABLE
Get_New_Item	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual LOG_ENTRY* Get_New_Item(LOG_CLASS& instance,const std::string& new_name)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Get_New_Item	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    LOG_ENTRY* Get_New_Item(LOG_CLASS& instance,const std::string& new_name)$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
Get_New_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual LOG_ENTRY* Get_New_Scope(LOG_CLASS& instance,const std::string& new_scope_identifier,const std::string& new_name)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Get_New_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    LOG_ENTRY* Get_New_Scope(LOG_CLASS& instance,const std::string& new_scope_identifier,const std::string& new_name)$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
Get_Number	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^    T Get_Number()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Opposite_Endpoint	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    int Get_Opposite_Endpoint(const int segment,const int node)$/;"	f	class:PhysBAM::SEGMENT_MESH
Get_Or_Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    T_UNLESS_VOID& Get_Or_Insert(const TK& v,const T_UNLESS_VOID& default_value=T_UNLESS_VOID()) \/\/ inserts the default if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    T* Get_Pointer(const TK& v) \/\/ returns NULL if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    const T* Get_Pointer(const TK& v) const \/\/ returns NULL if key not found$/;"	f	class:PhysBAM::HASHTABLE
Get_Pop_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual LOG_ENTRY* Get_Pop_Scope(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Get_Pop_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    LOG_ENTRY* Get_Pop_Scope(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
Get_Rotated_Frame	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Get_Rotated_Frame(TV& x_axis,TV& y_axis,TV& z_axis) const$/;"	f	class:ROTATION
Get_Rotated_Frame	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    void Get_Rotated_Frame(TV& x_axis,TV& y_axis) const$/;"	f	class:PhysBAM::ROTATION
Get_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Rotation()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Rotation_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^ROTATION<VECTOR<T,1> > Get_Rotation_Helper(const VECTOR<T,0>&)$/;"	f	namespace:PhysBAM
Get_Rotation_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^ROTATION<VECTOR<T,2> > Get_Rotation_Helper(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
Get_Rotation_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^ROTATION<VECTOR<T,3> > Get_Rotation_Helper(const VECTOR<T,4>& v)$/;"	f	namespace:PhysBAM
Get_Row	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Get_Row(const int i,VECTOR_BASE<T,T_VECTOR>& a) const$/;"	f	class:PhysBAM::MATRIX_BASE
Get_Segment_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    SEGMENT_MESH& Get_Segment_Mesh()$/;"	f	class:PhysBAM::SEGMENT_MESH
Get_Segment_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    SEGMENT_MESH& Get_Segment_Mesh()$/;"	f	class:PhysBAM::TRIANGLE_MESH
Get_Short_Name	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Short_Name(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Short_Name_Ignoring_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Get_Short_Name_Ignoring_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Get_Stop_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual LOG_ENTRY* Get_Stop_Time(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Get_Stop_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    virtual LOG_ENTRY* Get_Stop_Time(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
Get_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    void Get_Submatrix(const int istart,const int jstart,T_MATRIX& a) const$/;"	f	class:PhysBAM::MATRIX
Get_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Get_Submatrix(const int istart,const int jstart,DIAGONAL_MATRIX<T,3>& a) const$/;"	f	class:PhysBAM::MATRIX_BASE
Get_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Get_Submatrix(const int istart,const int jstart,MATRIX_BASE<T,T_MATRIX2>& a) const$/;"	f	class:PhysBAM::MATRIX_BASE
Get_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Get_Submatrix(const int istart,const int jstart,SYMMETRIC_MATRIX<T,3>& a) const$/;"	f	class:PhysBAM::MATRIX_BASE
Get_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Get_Subvector(const int istart,T_VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
Get_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Get_Subvector(const int istart,T_VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
Get_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Get_Subvector(const int istart,VECTOR_BASE<T,T_VECTOR2>& v) const$/;"	f	class:PhysBAM::VECTOR_BASE
Get_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Get_Time()$/;"	f	class:PhysBAM::TIMER
Get_Total_Time_Since_Registration	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Get_Total_Time_Since_Registration(const int id)$/;"	f	class:PhysBAM::TIMER
Get_Twist	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Twist(const T& a)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Uniform_Integer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Uniform_Integer(const int a,const int b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Uniform_Number	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Uniform_Number(const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Uniform_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Uniform_Vector(const RANGE<TV>& box)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Uniform_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Uniform_Vector(const T a,const T b)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Uniform_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Uniform_Vector(const VECTOR<T,d>& v0,const VECTOR<T,d>& v1)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Unique	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Get_Unique(ARRAY<T>& array) const$/;"	f	class:PhysBAM::ARRAY_BASE
Get_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    VECTOR<T,dimension> Get_Vector() const$/;"	f	class:PhysBAM::TWIST
Get_Vector_In_Unit_Sphere	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Get_Vector_In_Unit_Sphere()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Get_Vertical_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<VECTOR<T,d-1> > Get_Vertical_Box() const$/;"	f	class:PhysBAM::RANGE
Get_Working_Directory	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::string Get_Working_Directory()$/;"	f	namespace:PhysBAM::FILE_UTILITIES
GhostPoint	GhostPoint.h	/^GhostPoint(VarFcn *vf) : varFcn(vf) $/;"	f	class:GhostPoint
GhostPoint	GhostPoint.h	/^class GhostPoint{$/;"	c
Givens_Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Givens_Rotate(const int i,const int j,const T c,const T s)$/;"	f	class:PhysBAM::VECTOR_BASE
GmresSolver	KspSolver.C	/^GmresSolver(const typename VecType::InfoType &info, KspData &data, $/;"	f	class:GmresSolver
GmresSolver	KspSolver.h	/^class GmresSolver : public KspSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT> {$/;"	c
Golden_Minimum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Golden_Minimum(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
Golden_Parabolic_Minimum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Golden_Parabolic_Minimum(NONLINEAR_FUNCTION<T(T)>& F,T a,T b)$/;"	f	class:ITERATIVE_SOLVER
Gradient	IoData.h	/^  enum Gradient {LEAST_SQUARES = 0, GALERKIN = 1, NON_NODAL = 2} gradient;$/;"	g	struct:SchemeData
GramSchmidt	IoData.h	/^  enum GramSchmidt {GRAMSCHMIDT_OFF = 0, GRAMSCHMIDT_ON = 1} gramSchmidt;$/;"	g	struct:NonlinearRomOnlineNonStateData
GramSchmidt	IoData.h	/^  enum GramSchmidt {TRUE_GS = 1, FALSE_GS = 0} doGramSchmidt;$/;"	g	struct:LinearizedData
Gram_Schmidt_QR_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR Gram_Schmidt_QR_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
GreedyLeastSquaresSolver	IoData.h	/^  enum GreedyLeastSquaresSolver {GREEDY_LS_PROBABILISTIC = 0, GREEDY_LS_SCALAPACK = 1, GREEDY_LS_LINPACK = 2} greedyLeastSquaresSolver;$/;"	g	struct:GappyConstructionData
GroupInput	parser/Parser.y	/^GroupInput: UNDER Assignable '{'$/;"	l
H	KspSolver.h	/^  GenFullM<ScalarT> cs, H;$/;"	m	class:GmresSolver
H1	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:ImplicitData::Mvp
H1	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:SensitivityAnalysis::Mvp
H12	f77src/h12.f	/^      SUBROUTINE H12 /;"	s
H1FD	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:ImplicitData::Mvp
H1FD	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:SensitivityAnalysis::Mvp
H2	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:ImplicitData::Mvp
H2	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	e	enum:SensitivityAnalysis::Mvp
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T1& key1,const T2& key2)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T1& key1,const T2& key2,const T3& key3)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T1& key1,const T2& key2,const T3& key3,const T4& key4)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T1& key1,const T2& key2,const T3& key3,const T4& key4,const T5& key5)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T1& key1,const T2& key2,const T3& key3,const T4& key4,const T5& key5,const T6& key6)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    HASH(const T_ARRAY& array)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    explicit HASH()$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    explicit HASH(const int key)$/;"	f	class:PhysBAM::HASH
HASH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^class HASH$/;"	c	namespace:PhysBAM
HASHTABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    HASHTABLE(const int estimated_max_number_of_entries=5)$/;"	f	class:PhysBAM::HASHTABLE
HASHTABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^class HASHTABLE$/;"	c	namespace:PhysBAM
HASHTABLE_ENTRY_STATE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^enum HASHTABLE_ENTRY_STATE{ENTRY_FREE,ENTRY_ACTIVE,ENTRY_DELETED};$/;"	g	namespace:PhysBAM
HASHTABLE_ENTRY_TEMPLATE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK,class T> struct HASHTABLE_ENTRY_TEMPLATE{HASHTABLE_ENTRY_STATE state;TK key;T data;};$/;"	s	namespace:PhysBAM
HASHTABLE_ENTRY_TEMPLATE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK> struct HASHTABLE_ENTRY_TEMPLATE<TK,void>{HASHTABLE_ENTRY_STATE state;TK key;};$/;"	s	namespace:PhysBAM
HASHTABLE_ITERATOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    HASHTABLE_ITERATOR(T_HASHTABLE& hashtable)$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
HASHTABLE_ITERATOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    HASHTABLE_ITERATOR(T_HASHTABLE& hashtable,INVALID_ENUM)$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
HASHTABLE_ITERATOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^class HASHTABLE_ITERATOR$/;"	c	namespace:PhysBAM
HAS_CHEAP_COPY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^template<class TV> struct HAS_CHEAP_COPY<FRAME<TV> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
HAS_CHEAP_COPY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV> struct HAS_CHEAP_COPY<ROTATION<TV> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
HAS_CHEAP_COPY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^template<class T> struct HAS_CHEAP_COPY<SYMMETRIC_MATRIX<T,3> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
HAS_CHEAP_COPY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct HAS_CHEAP_COPY:public OR<IS_FUNDAMENTAL<T>::value,IS_ENUM<T>::value,IS_ARRAY_VIEW<T>::value>{};$/;"	s	namespace:PhysBAM
HAS_CHEAP_COPY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct HAS_CHEAP_COPY<VECTOR<T,d> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
HAS_TRIVIAL_DESTRUCTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct HAS_TRIVIAL_DESTRUCTOR {static const bool value=IS_POD<T>::value;};$/;"	s	namespace:PhysBAM
HAS_TYPED_READ	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T,class HAS> struct HAS_TYPED_READ{enum {value=false};};$/;"	s	namespace:PhysBAM
HAS_TYPED_READ	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T> struct HAS_TYPED_READ<T,typename FIRST<void,typename T::HAS_TYPED_READ_WRITE>::TYPE>{enum {value=true};};$/;"	s	namespace:PhysBAM
HAS_TYPED_WRITE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T,class HAS> struct HAS_TYPED_WRITE{enum {value=false};};$/;"	s	namespace:PhysBAM
HAS_TYPED_WRITE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T> struct HAS_TYPED_WRITE<T,typename FIRST<void,typename T::HAS_TYPED_READ_WRITE>::TYPE>{enum {value=true};};$/;"	s	namespace:PhysBAM
HB_MESHMOTION_WARNINGS	BCApplierCore.C	8;"	d	file:
HDM_RESIDUAL	IoData.h	/^  enum MeritFunction {ROM_RESIDUAL=0, HDM_RESIDUAL=1} meritFunction;$/;"	e	enum:NonlinearRomOnlineData::MeritFunction
HEAD	arpack++/include/arlspdef.h	/^typedef enum {HEAD, TAIL}              stack_end_t;$/;"	e	enum:__anon33
HEATPOWER_TAG	StructExc.C	14;"	d	file:
HEAT_ID	DomainCore.C	32;"	d	file:
HEAVING	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	e	enum:ForcedData::Type
HEL	arpack++/include/arlsupm.h	/^    HEL,       \/* Hermitian, store lower half *\/$/;"	e	enum:__anon44
HERMITE	IoData.h	/^  enum InterfaceTracking {LINEAR = 0, GRADIENT = 1, HERMITE = 2}; $/;"	e	enum:MultiFluidData::InterfaceTracking
HEU	arpack++/include/arlsupm.h	/^    HEU        \/* Hermitian, store upper half *\/$/;"	e	enum:__anon44
HEX_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
HHCoeffs	Face.h	/^struct HHCoeffs {$/;"	s
HJWENO	IoData.h	/^  enum LevelSetMethod { CONSERVATIVE = 0, HJWENO = 1, SCALAR=2, PRIMITIVE = 3,$/;"	e	enum:MultiFluidData::LevelSetMethod
HLLC	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	e	enum:SchemeData::Flux
HLLCFLUX	f77src/hllcflux.f	/^      SUBROUTINE HLLCFLUX(/;"	s
HLLCFLUX1	f77src/hllcflux1.f	/^      SUBROUTINE HLLCFLUX1(/;"	s
HLLCJAC	f77src/hllcjac.f	/^      SUBROUTINE HLLCJAC(/;"	s
HLLE	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	e	enum:SchemeData::Flux
HLLEFLUX	f77src/hlleflux.f	/^      SUBROUTINE HLLEFLUX(/;"	s
HLLEFLUX1	f77src/hlleflux1.f	/^      SUBROUTINE HLLEFLUX1(/;"	s
HLLEJAC	f77src/hllejac.f	/^      SUBROUTINE HLLEJAC(/;"	s
HOp	Modal.h	/^    MatVecProdH2<dim, double, dim> *HOp;$/;"	m	class:ModalSolver
HOp2	Modal.h	/^    MatVecProdH2<dim, double, dim> *HOp2;$/;"	m	class:ModalSolver
HOp2step1	Modal.h	/^    MatVecProdH2<dim, double, dim> *HOp2step1;$/;"	m	class:ModalSolver
HOpC	Modal.h	/^    MatVecProdH2<dim, bcomp, dim> *HOpC;$/;"	m	class:ModalSolver
HOpstep2	Modal.h	/^    MatVecProdH2<dim, double, dim> *HOpstep2;$/;"	m	class:ModalSolver
HOpstep3	Modal.h	/^    MatVecProdH2<dim, double, dim> *HOpstep3;$/;"	m	class:ModalSolver
HOtreatment	HigherOrderFSI.h	/^	bool HOtreatment;$/;"	m	class:HigherOrderFSI
HYBRID	IoData.h	/^  enum Form {DESCRIPTOR = 1, NONDESCRIPTOR = 0, HYBRID = 2} form;$/;"	e	enum:TsData::Form
HYBRID	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
HYBRID	IoData.h	/^  enum SurrogateInterface{HYBRID = 0, EXTERNAL = 1} surrogateinterface;$/;"	e	enum:EmbeddedFramework::SurrogateInterface
HYBRID	IoData.h	/^  enum Type {ITERATIVE = 0, NONITERATIVE = 1, HYBRID = 2} type;$/;"	e	enum:WallDistanceMethodData::Type
HYBRID	SpaceOperator.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:SpaceOperator::DescriptorCase
HYBRID	TimeState.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:TimeState::DescriptorCase
HYDRODYNAMICPRESSURE	PostFcn.h	/^                   SPEED = 19, HYDROSTATICPRESSURE = 20, HYDRODYNAMICPRESSURE = 21, $/;"	e	enum:PostFcn::ScalarType
HYDROSTATICPRESSURE	PostFcn.h	/^                   SPEED = 19, HYDROSTATICPRESSURE = 20, HYDRODYNAMICPRESSURE = 21, $/;"	e	enum:PostFcn::ScalarType
HYPERPLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef LINE_2D<T> HYPERPLANE;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
HYPERPLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef PLANE<T> HYPERPLANE;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
HYPERPLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef POINT_SIMPLEX_1D<T> HYPERPLANE;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
Halfspace_Intersection_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.cpp	/^template<class T> T Halfspace_Intersection_Size(const RANGE<VECTOR<T,2> >& box,const LINE_2D<T>& halfspace,VECTOR<T,2>* centroid)$/;"	f	namespace:PhysBAM::INTERSECTION
Halfspace_Intersection_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.cpp	/^template<class T> T Halfspace_Intersection_Size(const RANGE<VECTOR<T,3> >& box,const PLANE<T>& halfspace,VECTOR<T,3>* centroid)$/;"	f	namespace:PhysBAM::INTERSECTION
Halfspace_Intersection_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.cpp	/^template<class T> T Halfspace_Intersection_Size(const RANGE<VECTOR<T,1> >& box,const POINT_SIMPLEX_1D<T>& halfspace,VECTOR<T,1>* centroid)$/;"	f	namespace:PhysBAM::INTERSECTION
HasCloseTriangle	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^HasCloseTriangle(const int subD,const TV position,const TV min_corner,const TV max_corner,int* index,bool* is_occluded,ARRAY<int>* cand) $/;"	f	class:PhysBAMInterface
Hash	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash(const T& key)$/;"	f	namespace:PhysBAM
Hash_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int Hash_Index(const TK& v) const$/;"	f	class:PhysBAM::HASHTABLE
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline HASH Hash_Reduce(const char* key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline HASH Hash_Reduce(const double key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline HASH Hash_Reduce(const std::string& key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline HASH Hash_Reduce(const void* key){return Hash_Reduce_Helper<sizeof(void*)\/sizeof(int)>(key);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const bool key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const char key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const float key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const int key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const short key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const unsigned char key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const unsigned int key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^inline int Hash_Reduce(const unsigned short key){return key;}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T,class T_ARRAY,int d> inline HASH Hash_Reduce(const ARRAY_BASE<T,T_ARRAY,VECTOR<int,d> >& key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T,class T_ARRAY> inline HASH Hash_Reduce(const ARRAY_BASE<T,T_ARRAY>& key)$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T,int length> inline HASH Hash_Reduce(const ARRAY<VECTOR<T,length>,FACE_INDEX<1> >& key){return Hash_Reduce(key.Component(1));}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T,int length> inline HASH Hash_Reduce(const ARRAY<VECTOR<T,length>,FACE_INDEX<2> >& key){return HASH(key.Component(1),key.Component(2));}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T,int length> inline HASH Hash_Reduce(const ARRAY<VECTOR<T,length>,FACE_INDEX<3> >& key){return HASH(key.Component(1),key.Component(2),key.Component(3));}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T1,class T2,class T3> inline HASH Hash_Reduce(const TRIPLE<T1,T2,T3>& key){return HASH(key.x,key.y,key.z);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T1,class T2> inline HASH Hash_Reduce(const PAIR<T1,T2>& key){return HASH(key.x,key.y);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const COMPLEX<T>& key){return HASH(key.re,key.im);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const QUATERNION<T>& key){return HASH(key.s,key.v);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const ROTATION<VECTOR<T,1> >& key){return HASH();}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const ROTATION<VECTOR<T,2> >& key){return Hash_Reduce(key.Complex());}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const ROTATION<VECTOR<T,3> >& key){return Hash_Reduce(key.Quaternion());}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const VECTOR<T,0>& key){return HASH();}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const VECTOR<T,1>& key){return HASH(Hash_Reduce(key.x));}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const VECTOR<T,2>& key){return HASH(key.x,key.y);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const VECTOR<T,3>& key){return HASH(key.x,key.y,key.z);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class T> inline HASH Hash_Reduce(const VECTOR<T,4>& key){return HASH(key[1],key[2],key[3],key[4]);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class TV> inline HASH Hash_Reduce(const FRAME<TV>& key){return HASH(key.t,key.r);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class TV> inline HASH Hash_Reduce(const RANGE<TV>& key){return HASH(key.min_corner,key.max_corner);}$/;"	f	namespace:PhysBAM
Hash_Reduce	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<class TV> inline HASH Hash_Reduce(const TWIST<TV>& key){return HASH(key.linear,key.angular);}$/;"	f	namespace:PhysBAM
Hash_Reduce_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<> inline HASH Hash_Reduce_Helper<1>(const void* key){union {const void* p;int i;} raw;raw.p=key;return HASH(raw.i);}$/;"	f	namespace:PhysBAM
Hash_Reduce_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^template<> inline HASH Hash_Reduce_Helper<2>(const void* key){union {const void* p;int i[2];} raw;raw.p=key;return HASH(raw.i[0],raw.i[1]);}$/;"	f	namespace:PhysBAM
Heap	SparseGrid.h	/^  class Heap{             \/\/ customed heap class$/;"	c	class:SparseGrid
Heap	SparseGridCore.C	/^SparseGrid::Heap::Heap(){$/;"	f	class:SparseGrid::Heap
Heap	SparseGridCore.C	/^SparseGrid::Heap::Heap(const Heap &heap){$/;"	f	class:SparseGrid::Heap
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(ARRAY<T,ID>& a,ARRAY<T2,ID>& aux) \/\/ largest on top$/;"	f	class:PhysBAM::ARRAY
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(ARRAY<T,ID>& a,ARRAY<T2,ID>& aux,ID index,const ID heap_size) \/\/ largest on top, only sorts down from index (not up!)$/;"	f	class:PhysBAM::ARRAY
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(ARRAY<T,ID>& a,ARRAY<T2,ID>& aux,const ID max_index) \/\/ largest on top, only does from 1 to max_index$/;"	f	class:PhysBAM::ARRAY
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(ARRAY<T,ID>& a,const ID max_index) \/\/ largest on top, only does from 1 to max_index$/;"	f	class:PhysBAM::ARRAY
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(T_ARRAY& a) \/\/ largest on top$/;"	f	class:PhysBAM::ARRAY
Heapify	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    static void Heapify(T_ARRAY& a,ID index,const ID heap_size) \/\/ largest on top, only sorts down from index (not up!)$/;"	f	class:PhysBAM::ARRAY
HeatFluxResults	IoData.h	/^  enum HeatFluxResults {UNSPECIFIED_HF = -1, NO_HF = 0, YES_HF = 1} heatFluxResults;$/;"	g	struct:SurfaceData
HeatTransferHandler	HeatTransferHandler.h	/^class HeatTransferHandler {$/;"	c
HeatTransferHandler	HeatTransferHandlerCore.C	/^HeatTransferHandler::HeatTransferHandler(IoData& iod, MatchNodeSet** matchNodes, Domain* dom) : $/;"	f	class:HeatTransferHandler
Heaving	Manual/Aerof3d.html	/^<a name="Heaving"><\/a>$/;"	a
HeavingData	IoData.h	/^struct HeavingData {$/;"	s
HeavingData	IoDataCore.C	/^HeavingData::HeavingData()$/;"	f	class:HeavingData
HeavingMeshMotionHandler	MeshMotionHandler.h	/^class HeavingMeshMotionHandler : public MeshMotionHandler {$/;"	c
HeavingMeshMotionHandler	MeshMotionHandlerCore.C	/^HeavingMeshMotionHandler::HeavingMeshMotionHandler(IoData &iod, Domain *dom) :$/;"	f	class:HeavingMeshMotionHandler
Heaviside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Heaviside(const T phi,const T half_width=0)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
Heaviside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Heaviside(const T phi,const T value_minus,const T value_plus,const T half_width=0)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
Hessian	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename IMPLICIT_OBJECT<TV>::T_SYMMETRIC_MATRIX IMPLICIT_OBJECT<TV>::Hessian(const TV& X) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
HessianType	AutoDiff/SpaceDerivatives.h	/^    typedef Eigen::Array<Eigen::Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime>,InputsAtCompileTime,1> HessianType;$/;"	t	class:SpatialView
Higham_Iterate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Higham_Iterate(const T tolerance,const int max_iterations,const bool exit_on_max_iterations) const$/;"	f	class:MATRIX
HigherOrderFSI	HigherOrderFSI.C	/^HigherOrderFSI::HigherOrderFSI() $/;"	f	class:HigherOrderFSI
HigherOrderFSI	HigherOrderFSI.h	/^class HigherOrderFSI {$/;"	c
HigherOrderMultiFluid	HigherOrderMultiFluid.C	/^HigherOrderMultiFluid::HigherOrderMultiFluid() {$/;"	f	class:HigherOrderMultiFluid
HigherOrderMultiFluid	HigherOrderMultiFluid.h	/^class HigherOrderMultiFluid {$/;"	c
Hints_005fand_005ftips	Manual/Aerof3d.html	/^<a name="Hints_005fand_005ftips"><\/a>$/;"	a
Hints_and_tips	Manual/Aerof3d.html	/^<a name="Hints_and_tips"><\/a>$/;"	a
Homogeneous_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,2> Homogeneous_Times(const VECTOR<T,2>& v) const \/\/ assumes w=1 is the 3rd coordinate of v$/;"	f	class:PhysBAM::MATRIX
Homogeneous_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    VECTOR<T,3> Homogeneous_Times(const VECTOR<T,3>& v) const \/\/ assumes w=1 is the 4th coordinate of v$/;"	f	class:PhysBAM::MATRIX
HomotopyComputation	IoData.h	/^  enum HomotopyComputation {OFF_HOMOTOPY = 0, ON_HOMOTOPY = 1} homotopy;$/;"	g	struct:SensitivityAnalysis
Horizontal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,1> Horizontal_Vector() const$/;"	f	class:PhysBAM::VECTOR
Horizontal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR<T,2> Horizontal_Vector() const$/;"	f	class:PhysBAM::VECTOR
Householder_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^Householder_QR_Factorization(MATRIX_BASE<T,T_MATRIX2>& V,MATRIX_BASE<T,T_MATRIX3>& R)$/;"	f	class:MATRIX_BASE
Householder_QR_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR Householder_QR_Solve(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX_BASE
Householder_Transform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static VECTOR_ND<T> Householder_Transform(const VECTOR_BASE<T,T_VECTOR>& b,const MATRIX_BASE<T,T_MATRIX2>& V) \/\/ TODO: don't assume VECTOR_ND$/;"	f	class:PhysBAM::MATRIX_BASE
Householder_Transform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    VECTOR_DIFFERENCE<T_VECTOR,VECTOR_SCALE<T,T_VECTOR2> > Householder_Transform(const VECTOR_BASE<T,T_VECTOR2>& v) const$/;"	f	class:PhysBAM::VECTOR_BASE
Householder_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T_VECTOR Householder_Vector(const int k) const$/;"	f	class:PhysBAM::VECTOR_BASE
HowMny	arpack++/include/arrseig.h	/^  char    HowMny;     \/\/ Indicates if eigenvectors ('A') or Schur vectors ('P')$/;"	m	class:ARrcStdEig
Hydro	Manual/Aerof3d.html	/^<a name="Hydro"><\/a>$/;"	a
ID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename T_ARRAY::ELEMENT T;typedef typename T_INDICES_NO_REFERENCE::INDEX ID;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
IDEAL	IoData.h	/^  enum Type {IDEAL = 0, JWL = 1} type;$/;"	e	enum:JWLModelData::Type
IDEAL	IoData.h	/^  enum Type {IDEAL = 0, STIFFENED = 1} type;$/;"	e	enum:GasModelData::Type
IDENTITY	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
IDENTITY_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    explicit IDENTITY_ARRAY(const ID m)$/;"	f	class:PhysBAM::IDENTITY_ARRAY
IDENTITY_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^class IDENTITY_ARRAY:public ARRAY_BASE<ID,IDENTITY_ARRAY<ID>,ID>$/;"	c	namespace:PhysBAM
IDtag	MacroCell.h	/^  int IDtag;$/;"	m	class:MacroCell
IEnds_With	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^bool IEnds_With(const std::string& input,const std::string& test)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b,class T1,class T2> struct IF{typedef T1 TYPE;};$/;"	s	namespace:PhysBAM
IF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IF<false,T1,T2>{typedef T2 TYPE;};$/;"	s	namespace:PhysBAM
IH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	249;"	d	file:
IHm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	248;"	d	file:
IHmn	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	247;"	d	file:
ILUTR	SparseMatrix.C	/^void SparseMat<Scalar,dim>::ILUTR()$/;"	f	class:SparseMat
IMPLICIT	IoData.h	/^  enum Type {EXPLICIT = 0, IMPLICIT = 1} type;$/;"	e	enum:TsData::Type
IMPLICIT_BACKWARD_EULER_VEL	IoData.h	/^  enum Velocities {AUTO_VEL = 0, IMPLICIT_BACKWARD_EULER_VEL = 1, IMPLICIT_THREE_POINT_BDF_VEL = 2,$/;"	e	enum:DGCLData::Velocities
IMPLICIT_COLL_TS_DESC_H_	ImplicitCollocationTsDesc.h	2;"	d
IMPLICIT_CURRENT_CFG	IoData.h	/^                IMPLICIT_CURRENT_CFG = 6, IMPLICIT_LATEST_CFG = 7, EXPLICIT_RK2 = 8} normals;$/;"	e	enum:DGCLData::Normals
IMPLICIT_FIRST_ORDER	MeshMotionHandler.h	/^  enum TimeIntegrator {IMPLICIT_FIRST_ORDER, IMPLICIT_SECOND_ORDER} timeIntegrator;$/;"	e	enum:AeroMeshMotionHandler::TimeIntegrator
IMPLICIT_FIRST_ORDER_EZGCL	IoData.h	/^                IMPLICIT_FIRST_ORDER_EZGCL = 3, IMPLICIT_SECOND_ORDER_EZGCL = 4, IMPLICIT_THIRD_ORDER_EZGCL = 5,$/;"	e	enum:DGCLData::Normals
IMPLICIT_FIRST_ORDER_GCL	IoData.h	/^  enum Normals {AUTO = 0, IMPLICIT_FIRST_ORDER_GCL = 1, IMPLICIT_SECOND_ORDER_GCL = 2,$/;"	e	enum:DGCLData::Normals
IMPLICIT_GAPPY_TS_DESC_H_	ImplicitGappyTsDesc.h	2;"	d
IMPLICIT_GNAT_TS_DESC_H_	ImplicitGnatTsDesc.h	2;"	d
IMPLICIT_IMPOSED_BACKWARD_EULER_VEL	IoData.h	/^                   IMPLICIT_IMPOSED_VEL = 3, IMPLICIT_IMPOSED_BACKWARD_EULER_VEL = 4,$/;"	e	enum:DGCLData::Velocities
IMPLICIT_IMPOSED_THREE_POINT_BDF_VEL	IoData.h	/^                   IMPLICIT_IMPOSED_THREE_POINT_BDF_VEL = 5, IMPLICIT_ZERO = 6, EXPLICIT_RK2_VEL = 7} velocities;$/;"	e	enum:DGCLData::Velocities
IMPLICIT_IMPOSED_VEL	IoData.h	/^                   IMPLICIT_IMPOSED_VEL = 3, IMPLICIT_IMPOSED_BACKWARD_EULER_VEL = 4,$/;"	e	enum:DGCLData::Velocities
IMPLICIT_LATEST_CFG	IoData.h	/^                IMPLICIT_CURRENT_CFG = 6, IMPLICIT_LATEST_CFG = 7, EXPLICIT_RK2 = 8} normals;$/;"	e	enum:DGCLData::Normals
IMPLICIT_METRIC_TS_DESC_H_	ImplicitMetricTsDesc.h	2;"	d
IMPLICIT_OBJECT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^IMPLICIT_OBJECT()$/;"	f	class:IMPLICIT_OBJECT
IMPLICIT_OBJECT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^class IMPLICIT_OBJECT:public STRUCTURE<TV>$/;"	c	namespace:PhysBAM
IMPLICIT_OBJECT_ON_A_RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^    IMPLICIT_OBJECT_ON_A_RAY(const T_IMPLICIT_OBJECT& implicit_object_input,RAY<TV>& ray_input)$/;"	f	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY
IMPLICIT_OBJECT_ON_A_RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^class IMPLICIT_OBJECT_ON_A_RAY:public NONLINEAR_FUNCTION<typename T_IMPLICIT_OBJECT::VECTOR_T::SCALAR(typename T_IMPLICIT_OBJECT::VECTOR_T::SCALAR)>$/;"	c	namespace:PhysBAM
IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^    IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION(const T_IMPLICIT_OBJECT& implicit_object_input,RAY<TV>& ray_input)$/;"	f	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION
IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^class IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION:public NONLINEAR_FUNCTION<typename T_IMPLICIT_OBJECT::VECTOR_T::SCALAR(typename T_IMPLICIT_OBJECT::VECTOR_T::SCALAR)>$/;"	c	namespace:PhysBAM
IMPLICIT_SECOND_ORDER	MeshMotionHandler.h	/^  enum TimeIntegrator {IMPLICIT_FIRST_ORDER, IMPLICIT_SECOND_ORDER} timeIntegrator;$/;"	e	enum:AeroMeshMotionHandler::TimeIntegrator
IMPLICIT_SECOND_ORDER_EZGCL	IoData.h	/^                IMPLICIT_FIRST_ORDER_EZGCL = 3, IMPLICIT_SECOND_ORDER_EZGCL = 4, IMPLICIT_THIRD_ORDER_EZGCL = 5,$/;"	e	enum:DGCLData::Normals
IMPLICIT_SECOND_ORDER_GCL	IoData.h	/^  enum Normals {AUTO = 0, IMPLICIT_FIRST_ORDER_GCL = 1, IMPLICIT_SECOND_ORDER_GCL = 2,$/;"	e	enum:DGCLData::Normals
IMPLICIT_THIRD_ORDER_EZGCL	IoData.h	/^                IMPLICIT_FIRST_ORDER_EZGCL = 3, IMPLICIT_SECOND_ORDER_EZGCL = 4, IMPLICIT_THIRD_ORDER_EZGCL = 5,$/;"	e	enum:DGCLData::Normals
IMPLICIT_THREE_POINT_BDF_VEL	IoData.h	/^  enum Velocities {AUTO_VEL = 0, IMPLICIT_BACKWARD_EULER_VEL = 1, IMPLICIT_THREE_POINT_BDF_VEL = 2,$/;"	e	enum:DGCLData::Velocities
IMPLICIT_ZERO	IoData.h	/^                   IMPLICIT_IMPOSED_THREE_POINT_BDF_VEL = 5, IMPLICIT_ZERO = 6, EXPLICIT_RK2_VEL = 7} velocities;$/;"	e	enum:DGCLData::Velocities
INCLUDE_OFF	IoData.h	/^  enum Include {INCLUDE_OFF = 0, INCLUDE_ON = 1} include;$/;"	e	enum:NonlinearRomOnlineNonStateData::Include
INCLUDE_ON	IoData.h	/^  enum Include {INCLUDE_OFF = 0, INCLUDE_ON = 1} include;$/;"	e	enum:NonlinearRomOnlineNonStateData::Include
INCOMPATIBLE_SIZES	arpack++/include/arerror.h	/^    INCOMPATIBLE_SIZES  = -506,$/;"	e	enum:ArpackError::ErrorCode
INCONSISTENT_DATA	arpack++/include/arerror.h	/^    INCONSISTENT_DATA   = -508,$/;"	e	enum:ArpackError::ErrorCode
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    typedef T ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::ARRAY
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef ID INDEX;$/;"	t	class:PhysBAM::ARRAY_BASE
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef T_DIFFERENCE ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef T_PRODUCT ELEMENT;typedef typename T_ARRAY2::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    typedef typename NEGATION<T>::TYPE ELEMENT;typedef typename T_ARRAY::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_NEGATION
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef T_SUM ELEMENT;typedef typename T_ARRAY2::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef T_PRODUCT ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef T_SUM ELEMENT;typedef typename T_ARRAY1::INDEX INDEX;$/;"	t	class:PhysBAM::ARRAY_SUM
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typedef typename REMOVE_CONST<T>::TYPE ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::ARRAY_VIEW
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    typedef ID INDEX;$/;"	t	class:PhysBAM::CONSTANT_ARRAY
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    typedef ID INDEX;$/;"	t	class:PhysBAM::IDENTITY_ARRAY
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef T ELEMENT;typedef ID INDEX;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef T ELEMENT;typedef typename T_ARRAY::INDEX INDEX;$/;"	t	class:PhysBAM::PROJECTED_ARRAY
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR
INDEX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    typedef int INDEX;$/;"	t	class:PhysBAM::VECTOR_ND
INDEX_PROJECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    INDEX_PROJECTOR(const int index)$/;"	f	struct:PhysBAM::INDEX_PROJECTOR
INDEX_PROJECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^struct INDEX_PROJECTOR$/;"	s	namespace:PhysBAM
INDIRECT_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    INDIRECT_ARRAY(T_ARRAY_VIEW array,typename ADD_REFERENCE<CONST_T_INDICES>::TYPE indices)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
INDIRECT_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    INDIRECT_ARRAY(const INDIRECT_ARRAY<typename REMOVE_CONST<T_ARRAY>::TYPE,T_INDICES>& indirect)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
INDIRECT_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^class INDIRECT_ARRAY:public INDIRECT_ARRAY_BASE<T_INDICES>,$/;"	c	namespace:PhysBAM
INDIRECT_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class ID,int d> struct INDIRECT_ARRAY_BASE<VECTOR<ID,d>&>{enum {m=VECTOR<ID,d>::m};};$/;"	s	namespace:PhysBAM
INDIRECT_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_ARRAY,class T_INDICES> struct INDIRECT_ARRAY_BASE<INDIRECT_ARRAY<T_ARRAY,T_INDICES>&>:public INDIRECT_ARRAY_BASE<T_INDICES>{};$/;"	s	namespace:PhysBAM
INDIRECT_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_INDICES> struct INDIRECT_ARRAY_BASE{};$/;"	s	namespace:PhysBAM
INDIRECT_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    INDIRECT_COMPARE(const T_ARRAY& array_input)$/;"	f	struct:PhysBAM::INDIRECT_COMPARE
INDIRECT_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    INDIRECT_COMPARE(const T_ARRAY& array_input,const T_COMPARE& comparison_input)$/;"	f	struct:PhysBAM::INDIRECT_COMPARE
INDIRECT_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^struct INDIRECT_COMPARE$/;"	s	namespace:PhysBAM
INEFFICIENT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class TV> struct INEFFICIENT_VECTOR{static const bool value=IS_VECTOR<TV>::value && !EFFICIENT_VECTOR<TV>::value;};$/;"	s	namespace:PhysBAM
INEXACT	utils/Predicate.C	130;"	d	file:
INFO_TAG	StructExc.C	13;"	d	file:
INITIALIZATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    INITIALIZATION_HELPER(T* object,bool& initialized)$/;"	f	struct:PhysBAM::LOG_REAL::__anon18::INITIALIZATION_HELPER
INITIALIZATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^struct INITIALIZATION_HELPER$/;"	s	namespace:PhysBAM::LOG_REAL::__anon18	file:
INSIDE	IntersectorFRG/IntersectorFRG.C	/^const int IntersectorFRG::UNDECIDED, IntersectorFRG::INSIDE, IntersectorFRG::OUTSIDE;$/;"	m	class:IntersectorFRG	file:
INSIDE	IntersectorFRG/IntersectorFRG.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: ~~$/;"	m	class:IntersectorFRG
INSIDE	IntersectorPhysBAM/IntersectorPhysBAM.C	/^const int IntersectorPhysBAM::UNDECIDED, IntersectorPhysBAM::INSIDE, IntersectorPhysBAM::OUTSIDE;$/;"	m	class:IntersectorPhysBAM	file:
INSIDE	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: not a fluid$/;"	m	class:IntersectorPhysBAM
INSTANTIATE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.cpp	10;"	d	file:
INSTANTIATION_HELPER	GappyPreprocessingCore.C	235;"	d	file:
INSTANTIATION_HELPER	GappyPreprocessingCore.C	3;"	d	file:
INSTANTIATION_HELPER	MultiGridKernel.C	490;"	d	file:
INSTANTIATION_HELPER	MultiGridLevel.C	4627;"	d	file:
INSTANTIATION_HELPER	MultiGridPrec.C	190;"	d	file:
INSTANTIATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	72;"	d	file:
INSTANTIATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	115;"	d	file:
INSTANTIATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	195;"	d	file:
INSTANTIATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	189;"	d	file:
INSTANTIATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	250;"	d	file:
INSTANTIATION_HELPER2	MultiGridKernel.C	493;"	d	file:
INSTANTIATION_HELPER2	MultiGridLevel.C	4664;"	d	file:
INSTANTIATION_HELPER_1	ParallelRomCore.C	111;"	d	file:
INSTANTIATION_HELPER_1	ParallelRomCore.C	5;"	d	file:
INSTANTIATION_HELPER_2	ParallelRomCore.C	112;"	d	file:
INSTANTIATION_HELPER_2	ParallelRomCore.C	43;"	d	file:
INSTANTIATION_HELPER_3	ParallelRomCore.C	113;"	d	file:
INSTANTIATION_HELPER_3	ParallelRomCore.C	51;"	d	file:
INSTANTIATION_HELPER_4	ParallelRomCore.C	114;"	d	file:
INSTANTIATION_HELPER_4	ParallelRomCore.C	63;"	d	file:
INSTANTIATION_HELPER_5	ParallelRomCore.C	67;"	d	file:
INSTANTIATION_HELPER_V	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	236;"	d	file:
INSTANTIATION_HELPER_V23	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	243;"	d	file:
INST_HELPER	AgglomeratedFace.C	537;"	d	file:
INST_HELPER	BlockTridiagonalMatrix.C	107;"	d	file:
INST_HELPER	MultiGridOperator.C	661;"	d	file:
INST_HELPER	MultiGridSmoothingMatrix.C	287;"	d	file:
INST_HELPER	MultiGridSpaceOperator.C	178;"	d	file:
INST_HELPER2	AgglomeratedFace.C	574;"	d	file:
INST_HELPER2	MultiGridOperator.C	691;"	d	file:
INST_HELPER2	MultiGridSpaceOperator.C	188;"	d	file:
INSUFICIENT_MEMORY	arpack++/include/arerror.h	/^    INSUFICIENT_MEMORY  = -503,$/;"	e	enum:ArpackError::ErrorCode
INTERIOR_POINT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum LOCATION {START_POINT,INTERIOR_POINT,LOCATION_UNKNOWN};$/;"	e	enum:PhysBAM::RAY::LOCATION
INTERNAL	IoData.h	/^  enum Type {EXTERNAL = 0, INTERNAL = 1} type;$/;"	e	enum:BcsFreeStreamData::Type
INTERSECTION	IoData.h	/^  enum InterfaceAlgorithm {MID_EDGE = 0, INTERSECTION = 1} interfaceAlg;$/;"	e	enum:EmbeddedFramework::InterfaceAlgorithm
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.cpp	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM	file:
INTERSECTION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.h	/^namespace INTERSECTION{$/;"	n	namespace:PhysBAM
INTERVAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL()$/;"	f	class:PhysBAM::INTERVAL
INTERVAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL(const T min_corner,const T max_corner)$/;"	f	class:PhysBAM::INTERVAL
INTERVAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL(const T value)$/;"	f	class:PhysBAM::INTERVAL
INTERVAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    template<class T2> explicit INTERVAL(const INTERVAL<T2>& interval)$/;"	f	class:PhysBAM::INTERVAL
INTERVAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^class INTERVAL$/;"	c	namespace:PhysBAM
INTS_EQUAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<int i,int j> struct INTS_EQUAL {static const bool value=false;};$/;"	s	namespace:PhysBAM
INTS_EQUAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<int i> struct INTS_EQUAL<i,i> {static const bool value=true;};$/;"	s	namespace:PhysBAM
INT_CONVERTIBLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct INT_CONVERTIBLE {INT_CONVERTIBLE(int);};$/;"	s	namespace:PhysBAM
INT_INVERSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^struct INT_INVERSE$/;"	s	namespace:PhysBAM
INT_MINUS_ONE	DistLeastSquareSolver.C	/^const int DistLeastSquareSolver::INT_MINUS_ONE = -1;$/;"	m	class:DistLeastSquareSolver	file:
INT_MINUS_ONE	DistLeastSquareSolver.h	/^  static const int INT_MINUS_ONE;$/;"	m	class:DistLeastSquareSolver
INT_ONE	DistLeastSquareSolver.C	/^const int DistLeastSquareSolver::INT_ONE = 1;$/;"	m	class:DistLeastSquareSolver	file:
INT_ONE	DistLeastSquareSolver.h	/^  static const int INT_ONE;$/;"	m	class:DistLeastSquareSolver
INT_ZERO	DistLeastSquareSolver.C	/^const int DistLeastSquareSolver::INT_ZERO = 0;$/;"	m	class:DistLeastSquareSolver	file:
INT_ZERO	DistLeastSquareSolver.h	/^  static const int INT_ZERO;$/;"	m	class:DistLeastSquareSolver
INVALID_ENUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    enum INVALID_ENUM {INVALID_ITERATOR};$/;"	g	class:PhysBAM::HASHTABLE_ITERATOR
INVALID_ITERATOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    enum INVALID_ENUM {INVALID_ITERATOR};$/;"	e	enum:PhysBAM::HASHTABLE_ITERATOR::INVALID_ENUM
INVMODE_UNDEFINED	arpack++/include/arerror.h	/^    INVMODE_UNDEFINED   = -106,$/;"	e	enum:ArpackError::ErrorCode
ISOTHERMAL	IoData.h	/^  enum Type { ADIABATIC = 1, ISOTHERMAL = 2 } type;$/;"	e	enum:SurfaceData::Type
ISOTHERMAL	IoData.h	/^  enum Type {ISOTHERMAL = 0, ADIABATIC = 1} type;$/;"	e	enum:BcsWallData::Type
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^template<class T,class ID> struct IS_ARRAY<ARRAY<T,ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY<ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^template<class T_ARRAY> struct IS_ARRAY<ARRAY_NEGATION<T_ARRAY> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY<ARRAY_PLUS_SCALAR<T1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_SUM<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_ARRAY<ARRAY_VIEW<T,ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^template<class T,class ID> struct IS_ARRAY<CONSTANT_ARRAY<T,ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^template<class ID> struct IS_ARRAY<IDENTITY_ARRAY<ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_ARRAY,class T_INDICES> struct IS_ARRAY<INDIRECT_ARRAY<T_ARRAY,T_INDICES> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct IS_ARRAY<PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY,class ENABLER=void> struct IS_ARRAY {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY> struct IS_ARRAY<const T_ARRAY>:public IS_ARRAY<T_ARRAY>{};$/;"	s	namespace:PhysBAM
IS_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T2,class T_ARRAY2> struct IS_ARRAY_BASE<ARRAY_BASE<T2,T_ARRAY2,ID> > {static const bool value=true;};$/;"	s	class:PhysBAM::ARRAY_BASE
IS_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T_ARRAY2> struct IS_ARRAY_BASE {static const bool value=false;};$/;"	s	class:PhysBAM::ARRAY_BASE
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<ARRAY<T,ID> > {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^template<class T_ARRAY> struct IS_ARRAY_VIEW<ARRAY_NEGATION<T_ARRAY> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_PLUS_SCALAR<T1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_SUM<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<ARRAY_VIEW<T,ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<CONSTANT_ARRAY<T,ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^template<class ID> struct IS_ARRAY_VIEW<IDENTITY_ARRAY<ID> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_ARRAY,class T_INDICES> struct IS_ARRAY_VIEW<INDIRECT_ARRAY<T_ARRAY,T_INDICES> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct IS_ARRAY_VIEW<PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR> > {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY,class ENABLER=void> struct IS_ARRAY_VIEW {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY> struct IS_ARRAY_VIEW<const T_ARRAY>:public IS_ARRAY_VIEW<T_ARRAY>{};$/;"	s	namespace:PhysBAM
IS_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^template<class T> struct IS_ARRAY_VIEW<VECTOR_ND<T> > {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_BASE_OF	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class B,class D> struct IS_BASE_OF {static const bool value=IS_BASE_OF_VALUE<B,D>::value;};$/;"	s	namespace:PhysBAM
IS_BASE_OF_VALUE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_BASE_OF_VALUE$/;"	s	namespace:PhysBAM
IS_BASE_OF_VALUE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_BASE_OF_VALUE<B,B> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<BOX<TV>,RW> {static const bool value=false;}; \/\/ required since memory format differs from disk format$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<INTERVAL<TV>,RW> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<RANGE<TV>,RW> {static const bool value=false;}; \/\/ required since memory format differs from disk format$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<DIAGONAL_MATRIX<T,2>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<DIAGONAL_MATRIX<T,3>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<FRAME<TV>,RW>:public IS_BINARY_IO_SAFE<TV,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n,class RW> struct IS_BINARY_IO_SAFE<MATRIX<T,m,n>,RW> {static const bool value=AND<(m>0),(n>0),IS_BINARY_IO_SAFE<T,RW>::value>::value;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<QUATERNION<T>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<ROTATION<TV>,RW> {static const bool value=(TV::m>1) && IS_BINARY_IO_SAFE<TV,RW>::value;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<SYMMETRIC_MATRIX<T,2>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<SYMMETRIC_MATRIX<T,3>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<UPPER_TRIANGULAR_MATRIX<T,2>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<UPPER_TRIANGULAR_MATRIX<T,3>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct IS_BINARY_IO_SAFE<double,double>:public IS_PRIMITIVE_BINARY_IO_SAFE<double>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct IS_BINARY_IO_SAFE<float,float>:public IS_PRIMITIVE_BINARY_IO_SAFE<float>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class RW> struct IS_BINARY_IO_SAFE<bool,RW> {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW,class ENABLER> struct IS_BINARY_IO_SAFE {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<T,RW,typename ENABLE_IF<OR<IS_INTEGRAL<T>::value,IS_ENUM<T>::value>::value>::TYPE>:public IS_PRIMITIVE_BINARY_IO_SAFE<T>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^template<class T,class RW> struct IS_BINARY_IO_SAFE<COMPLEX<T>,RW>:public IS_BINARY_IO_SAFE<T,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<TWIST<TV>,RW>:public IS_BINARY_IO_SAFE<TV,RW>{};$/;"	s	namespace:PhysBAM
IS_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d,class RW> struct IS_BINARY_IO_SAFE<VECTOR<T,d>,RW> {static const bool value=(d>0) && IS_BINARY_IO_SAFE<T,RW>::value;};$/;"	s	namespace:PhysBAM
IS_CLASS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_CLASS$/;"	s	namespace:PhysBAM
IS_CLONEABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^template<class T> struct IS_CLONEABLE:public AND<$/;"	s	namespace:PhysBAM
IS_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_CONST<ARRAY_VIEW<const T,ID> > {static const bool value=true;}; \/\/ ARRAY_VIEW<const T,ID> is equivalent to const ARRAY_VIEW<const T,ID>$/;"	s	namespace:PhysBAM
IS_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_CONST {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_CONST<const T> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_CONVERTIBLE {static const bool value=IS_CONVERTIBLE_DISPATCH<T1,T2>::value;};$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_BASIC_IMPL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_CONVERTIBLE_BASIC_IMPL$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_DISPATCH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_CONVERTIBLE_DISPATCH:public IS_CONVERTIBLE_DISPATCH_BASE<T1,T2>::type{};$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_DISPATCH_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_CONVERTIBLE_DISPATCH_BASE$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_IMPL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_CONVERTIBLE_IMPL$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_IMPL_SELECT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_CONVERTIBLE_IMPL_SELECT$/;"	s	namespace:PhysBAM
IS_CONVERTIBLE_IMPL_SELECT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_CONVERTIBLE_IMPL_SELECT<true, true>$/;"	s	namespace:PhysBAM
IS_EMPTY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct IS_EMPTY {static const bool value=IS_EMPTY_VALUE<T>::value;};$/;"	s	namespace:PhysBAM
IS_EMPTY_VALUE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_EMPTY_VALUE$/;"	s	namespace:PhysBAM
IS_ENUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_ENUM {static const bool value=IS_ENUM_IMPL<T>::value;};$/;"	s	namespace:PhysBAM
IS_ENUM_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <> struct IS_ENUM_HELPER<false> {template <class T> struct type {static const bool value=IS_CONVERTIBLE<typename ADD_REFERENCE<T>::TYPE,INT_CONVERTIBLE>::value;};};$/;"	s	namespace:PhysBAM
IS_ENUM_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <bool is_typename_arithmetic_or_reference = true> struct IS_ENUM_HELPER {template <class T> struct type {static const bool value=false;};};$/;"	s	namespace:PhysBAM
IS_ENUM_IMPL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct IS_ENUM_IMPL$/;"	s	namespace:PhysBAM
IS_FLOATING_POINT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FLOATING_POINT {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_FLOAT_OR_DOUBLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FLOAT_OR_DOUBLE:public OR<IS_SAME<T,float>::value,IS_SAME<T,double>::value>{};$/;"	s	namespace:PhysBAM
IS_FUNCTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FUNCTION {static const bool value=NOT<IS_CONVERTIBLE<T*, const volatile void*>::value>::value;};$/;"	s	namespace:PhysBAM
IS_FUNDAMENTAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FUNDAMENTAL {static const bool value=OR<IS_SCALAR<T>::value,IS_VOID<T>::value>::value;};$/;"	s	namespace:PhysBAM
IS_INTEGRAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_INTEGRAL {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_MEMBER_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,class TF> struct IS_MEMBER_POINTER<TF T::*> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_MEMBER_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_MEMBER_POINTER {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_POD	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POD {static const bool value=IS_VOID<T>::value||IS_SCALAR_TYPE<typename REMOVE_ALL_EXTENTS<T>::type>::value;};$/;"	s	namespace:PhysBAM
IS_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POINTER {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POINTER<T*> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_PRIMITIVE_BINARY_IO_SAFE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T> struct IS_PRIMITIVE_BINARY_IO_SAFE {static const bool value=!big_endian && (sizeof(T)==PLATFORM_INDEPENDENT_SIZE<T>::value);};$/;"	s	namespace:PhysBAM
IS_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_REFERENCE {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_REFERENCE<T&> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_SAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_SAME {static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_SAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SAME<T,T> {static const bool value=true;};$/;"	s	namespace:PhysBAM
IS_SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SCALAR {static const bool value=OR<IS_INTEGRAL<T>::value,IS_FLOATING_POINT<T>::value>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^template<class TV> struct IS_SCALAR_BLOCK<BOX<TV> >:public IS_SCALAR_BLOCK<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^template<class TV> struct IS_SCALAR_BLOCK<INTERVAL<TV> >:public IS_SCALAR_BLOCK<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^template<class TV> struct IS_SCALAR_BLOCK<RANGE<TV> >:public IS_SCALAR_BLOCK<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_BLOCK<DIAGONAL_MATRIX<T,2> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_BLOCK<DIAGONAL_MATRIX<T,3> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^template<class TV> struct IS_SCALAR_BLOCK<FRAME<TV> >:public IS_SCALAR_BLOCK<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n> struct IS_SCALAR_BLOCK<MATRIX<T,m,n> > {static const bool value=IS_SCALAR_BLOCK<T>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^template<class T> struct IS_SCALAR_BLOCK<QUATERNION<T> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV> struct IS_SCALAR_BLOCK<ROTATION<TV> > {static const bool value=(TV::m>1) && IS_SCALAR_BLOCK<TV>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_BLOCK<SYMMETRIC_MATRIX<T,2> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_BLOCK<SYMMETRIC_MATRIX<T,3> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_BLOCK<UPPER_TRIANGULAR_MATRIX<T,2> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_BLOCK<UPPER_TRIANGULAR_MATRIX<T,3> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^template<class T> struct IS_SCALAR_BLOCK<COMPLEX<T> >:public IS_SCALAR_BLOCK<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct IS_SCALAR_BLOCK {static const bool value=IS_SCALAR<T>::value;}; \/\/ true if memory layout is contiguous array of scalars$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct IS_SCALAR_BLOCK<TWIST<TV> >:public IS_SCALAR_BLOCK<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_BLOCK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct IS_SCALAR_BLOCK<VECTOR<T,d> > {static const bool value=(d>0) && IS_SCALAR_BLOCK<T>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SCALAR_TYPE {static const bool value=IS_SCALAR<T>::value||IS_ENUM<T>::value||IS_POINTER<T>::value||IS_MEMBER_POINTER<T>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<DIAGONAL_MATRIX<T,2> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<DIAGONAL_MATRIX<T,3> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n> struct IS_SCALAR_VECTOR_SPACE<MATRIX<T,m,n> > {static const bool value=IS_SCALAR_VECTOR_SPACE<T>::value;};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<QUATERNION<T> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<SYMMETRIC_MATRIX<T,2> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<SYMMETRIC_MATRIX<T,3> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<UPPER_TRIANGULAR_MATRIX<T,2> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<UPPER_TRIANGULAR_MATRIX<T,3> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE<COMPLEX<T> >:public IS_SCALAR_VECTOR_SPACE<T>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE {static const bool value=IS_SCALAR<T>::value;}; \/\/ true if we can compute vector space operations on the underlying array of scalars$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct IS_SCALAR_VECTOR_SPACE<TWIST<TV> >:public IS_SCALAR_VECTOR_SPACE<TV>{};$/;"	s	namespace:PhysBAM
IS_SCALAR_VECTOR_SPACE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct IS_SCALAR_VECTOR_SPACE<VECTOR<T,d> > {static const bool value=(d>0) && IS_SCALAR_VECTOR_SPACE<T>::value;};$/;"	s	namespace:PhysBAM
IS_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class TV,class ENABLER=void> struct IS_VECTOR{static const bool value=false;};$/;"	s	namespace:PhysBAM
IS_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class TV> struct IS_VECTOR<TV,typename DISABLE_IF<IS_SAME<typename TV::ELEMENT,void>::value>::TYPE>$/;"	s	namespace:PhysBAM
IS_VOID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_VOID {static const bool value=false;};$/;"	s	namespace:PhysBAM
ITERATIVE	IoData.h	/^  enum Type {ITERATIVE = 0, NONITERATIVE = 1, HYBRID = 2} type;$/;"	e	enum:WallDistanceMethodData::Type
ITERATIVE_SOLVER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^    ITERATIVE_SOLVER()$/;"	f	class:PhysBAM::ITERATIVE_SOLVER
ITERATIVE_SOLVER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^class ITERATIVE_SOLVER $/;"	c	namespace:PhysBAM
ITERATOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef HASHTABLE_ITERATOR<TK,T> ITERATOR;$/;"	t	class:PhysBAM::HASHTABLE
IdealGasEOS	ProgrammedBurnCore.C	/^	IdealGasEOS(double _g) : gamma(_g) { }$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
IdealGasEOS	ProgrammedBurnCore.C	/^class IdealGasEOS {$/;"	c	namespace:ProgrammedBurn_CJ	file:
Identify_Connected_Components	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Identify_Connected_Components(ARRAY<int>& label)$/;"	f	class:TRIANGLE_MESH
IdentityPrec	KspPrec.h	/^  IdentityPrec(BCApplier *bcs = 0) : BCs(bcs) {}$/;"	f	class:IdentityPrec
IdentityPrec	KspPrec.h	/^class IdentityPrec : public KspPrec<dim, Scalar2> {$/;"	c
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    static DIAGONAL_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    static DIAGONAL_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static T_MATRIX Identity_Matrix(const int n)$/;"	f	class:PhysBAM::MATRIX_BASE
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    static UPPER_TRIANGULAR_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    static UPPER_TRIANGULAR_MATRIX Identity_Matrix()$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
IluPrec	KspPrec.C	/^IluPrec<Scalar,dim, Scalar2>::IluPrec(PcData &pcData, Domain *domain, int **nodeType) : $/;"	f	class:IluPrec
IluPrec	KspPrec.h	/^class IluPrec : public KspPrec<dim, Scalar2>, public DistMat<Scalar,dim> {$/;"	c
Implicit	Manual/Aerof3d.html	/^<a name="Implicit"><\/a>$/;"	a
ImplicitCollocationTsDesc	ImplicitCollocationTsDesc.C	/^ImplicitCollocationTsDesc<dim>::ImplicitCollocationTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitCollocationTsDesc
ImplicitCollocationTsDesc	ImplicitCollocationTsDesc.h	/^class ImplicitCollocationTsDesc : public ImplicitGappyTsDesc<dim> {$/;"	c
ImplicitCoupledTsDesc	ImplicitCoupledTsDesc.C	/^ImplicitCoupledTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitCoupledTsDesc
ImplicitCoupledTsDesc	ImplicitCoupledTsDesc.h	/^class ImplicitCoupledTsDesc : public ImplicitTsDesc<dim> {$/;"	c
ImplicitData	IoData.h	/^struct ImplicitData {$/;"	s
ImplicitData	IoDataCore.C	/^ImplicitData::ImplicitData()$/;"	f	class:ImplicitData
ImplicitEmbeddedCoupledTsDesc	ImplicitEmbeddedCoupledTsDesc.C	/^ImplicitEmbeddedCoupledTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ImplicitEmbeddedCoupledTsDesc
ImplicitEmbeddedCoupledTsDesc	ImplicitEmbeddedCoupledTsDesc.h	/^class ImplicitEmbeddedCoupledTsDesc : public ImplicitEmbeddedTsDesc<dim> {$/;"	c
ImplicitEmbeddedRomTsDesc	ImplicitEmbeddedRomTsDesc.cpp	/^ImplicitEmbeddedRomTsDesc<dim>::ImplicitEmbeddedRomTsDesc(IoData &_ioData,$/;"	f	class:ImplicitEmbeddedRomTsDesc
ImplicitEmbeddedRomTsDesc	ImplicitEmbeddedRomTsDesc.h	/^class ImplicitEmbeddedRomTsDesc : public ImplicitEmbeddedCoupledTsDesc<dim> {$/;"	c
ImplicitEmbeddedSegTsDesc	ImplicitEmbeddedSegTsDesc.C	/^ImplicitEmbeddedSegTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ImplicitEmbeddedSegTsDesc
ImplicitEmbeddedSegTsDesc	ImplicitEmbeddedSegTsDesc.h	/^class ImplicitEmbeddedSegTsDesc : public ImplicitEmbeddedTsDesc<dim> {$/;"	c
ImplicitEmbeddedTsDesc	ImplicitEmbeddedTsDesc.C	/^ImplicitEmbeddedTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ImplicitEmbeddedTsDesc
ImplicitEmbeddedTsDesc	ImplicitEmbeddedTsDesc.h	/^class ImplicitEmbeddedTsDesc : public EmbeddedTsDesc<dim> {$/;"	c
ImplicitGappyTsDesc	ImplicitGappyTsDesc.C	/^ImplicitGappyTsDesc<dim>::ImplicitGappyTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitGappyTsDesc
ImplicitGappyTsDesc	ImplicitGappyTsDesc.h	/^class ImplicitGappyTsDesc : public ImplicitRomTsDesc<dim> {$/;"	c
ImplicitGnatTsDesc	ImplicitGnatTsDesc.C	/^ImplicitGnatTsDesc<dim>::ImplicitGnatTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitGnatTsDesc
ImplicitGnatTsDesc	ImplicitGnatTsDesc.h	/^class ImplicitGnatTsDesc : public ImplicitGappyTsDesc<dim> {$/;"	c
ImplicitLevelSetTsDesc	ImplicitLevelSetTsDesc.C	/^ImplicitLevelSetTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ImplicitLevelSetTsDesc
ImplicitLevelSetTsDesc	ImplicitLevelSetTsDesc.h	/^class ImplicitLevelSetTsDesc : public LevelSetTsDesc<dim, dimLS> {$/;"	c
ImplicitMetricTsDesc	ImplicitMetricTsDesc.C	/^ImplicitMetricTsDesc<dim>::ImplicitMetricTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitMetricTsDesc
ImplicitMetricTsDesc	ImplicitMetricTsDesc.h	/^class ImplicitMetricTsDesc : public ImplicitGappyTsDesc<dim> {$/;"	c
ImplicitMultiPhysicsTsDesc	ImplicitMultiPhysicsTsDesc.C	/^ImplicitMultiPhysicsTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:ImplicitMultiPhysicsTsDesc
ImplicitMultiPhysicsTsDesc	ImplicitMultiPhysicsTsDesc.h	/^class ImplicitMultiPhysicsTsDesc : public MultiPhysicsTsDesc<dim,dimLS> {$/;"	c
ImplicitPGTsDesc	ImplicitPGTsDesc.C	/^ImplicitPGTsDesc<dim>::ImplicitPGTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitPGTsDesc
ImplicitPGTsDesc	ImplicitPGTsDesc.h	/^class ImplicitPGTsDesc : public ImplicitRomTsDesc<dim> {$/;"	c
ImplicitRiemann	ImplicitRiemann.h	/^class ImplicitRiemann {$/;"	c
ImplicitRomPostproTsDesc	ImplicitRomPostproTsDesc.C	/^ImplicitRomPostproTsDesc<dim>::ImplicitRomPostproTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitRomPostproTsDesc
ImplicitRomPostproTsDesc	ImplicitRomPostproTsDesc.h	/^class ImplicitRomPostproTsDesc : public ImplicitRomTsDesc<dim> {$/;"	c
ImplicitRomTsDesc	ImplicitRomTsDesc.C	/^ImplicitRomTsDesc<dim>::ImplicitRomTsDesc(IoData &_ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitRomTsDesc
ImplicitRomTsDesc	ImplicitRomTsDesc.h	/^class ImplicitRomTsDesc : public TsDesc<dim> {$/;"	c
ImplicitSegTsDesc	ImplicitSegTsDesc.C	/^ImplicitSegTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitSegTsDesc
ImplicitSegTsDesc	ImplicitSegTsDesc.h	/^class ImplicitSegTsDesc : public ImplicitTsDesc<dim> {$/;"	c
ImplicitTsDesc	ImplicitTsDesc.C	/^ImplicitTsDesc<dim>::ImplicitTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) :$/;"	f	class:ImplicitTsDesc
ImplicitTsDesc	ImplicitTsDesc.h	/^class ImplicitTsDesc : public TsDesc<dim> {$/;"	c
ImplosionSetup	IoData.h	/^struct ImplosionSetup {$/;"	s
ImplosionSetup	IoDataCore.C	/^ImplosionSetup::ImplosionSetup() {$/;"	f	class:ImplosionSetup
ImplosionSetup	Manual/Aerof3d.html	/^<a name="ImplosionSetup"><\/a>$/;"	a
ImplosionSetupType	EmbeddedTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;  $/;"	g	class:EmbeddedTsDesc
ImplosionSetupType	MultiPhysicsTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;$/;"	g	class:MultiPhysicsTsDesc
In_Place_Cholesky_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^In_Place_Cholesky_Factorization()$/;"	f	class:MATRIX_BASE
In_Place_Cholesky_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void In_Place_Cholesky_Inverse()$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_Cholesky_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void In_Place_Cholesky_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_Cholesky_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR In_Place_Cholesky_Solve(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_Gram_Schmidt_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^In_Place_Gram_Schmidt_QR_Factorization(MATRIX_BASE<T,T_MATRIX2>& R)$/;"	f	class:MATRIX_BASE
In_Place_Gram_Schmidt_QR_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR In_Place_Gram_Schmidt_QR_Solve(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_LU_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^In_Place_LU_Factorization(MATRIX_BASE<T,T_MATRIX2>& L)$/;"	f	class:MATRIX_BASE
In_Place_LU_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void In_Place_LU_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse) \/\/ don't assume VECTOR_ND$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_LU_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR In_Place_LU_Solve(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_PLU_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^In_Place_PLU_Factorization(MATRIX_BASE<T,T_MATRIX2>& L,COLUMN_PERMUTATION& p)$/;"	f	class:MATRIX_BASE
In_Place_PLU_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void In_Place_PLU_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_PLU_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR In_Place_PLU_Solve(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX_BASE
In_Place_Robust_Householder_QR_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^In_Place_Robust_Householder_QR_Solve(VECTOR_BASE<T,T_VECTOR1>& b,VECTOR_BASE<int,T_VECTOR2>& p)$/;"	f	class:MATRIX_BASE
Incenter	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV Incenter() const \/\/ intersection of angle bisectors$/;"	f	class:PhysBAM::TRIANGLE_3D
Include	IoData.h	/^  enum Include {INCLUDE_OFF = 0, INCLUDE_ON = 1} include;$/;"	g	struct:NonlinearRomOnlineNonStateData
IncludeLiftFaces	IoData.h	/^  enum IncludeLiftFaces {NONE_LIFTFACE = 0,$/;"	g	struct:GappyConstructionData
IncreasePressure	Domain.C	/^void Domain::IncreasePressure(double p, VarFcn *vf,  DistSVec<double,dim> &U){$/;"	f	class:Domain
IncreasePressure	Domain.C	/^void Domain::IncreasePressure(double p, VarFcn *vf,  DistSVec<double,dim> &U, DistVec<int> &fluidId){$/;"	f	class:Domain
IncreasePressure	EmbeddedTsDesc.C	/^bool EmbeddedTsDesc<dim>::IncreasePressure(int it, double dt, double t, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
IncreasePressure	LevelSetTsDesc.C	/^bool LevelSetTsDesc<dim,dimLS>::IncreasePressure(int it, double dt, double t, DistSVec<double,dim> &U)$/;"	f	class:LevelSetTsDesc
IncreasePressure	MultiPhysicsTsDesc.C	/^bool MultiPhysicsTsDesc<dim,dimLS>::IncreasePressure(int it, double dt, double t, DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
IncreasePressure	SubDomain.C	/^void SubDomain::IncreasePressure(double p, VarFcn *vf, SVec<double,dim> &U){$/;"	f	class:SubDomain
IncreasePressure	SubDomain.C	/^void SubDomain::IncreasePressure(double p, VarFcn *vf, SVec<double,dim> &U, Vec<int> &fluidId){$/;"	f	class:SubDomain
IncreasePressure	TsDesc.h	/^  virtual bool IncreasePressure(int it, double dt, double t, DistSVec<double,dim> &U){return true;}$/;"	f	class:TsDesc
Increase_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Increase_Size(const int size)$/;"	f	class:PhysBAM::STACK
Indefinite_Polar_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    void Indefinite_Polar_Decomposition(MATRIX& Q,SYMMETRIC_MATRIX<T,2>& S) const$/;"	f	class:PhysBAM::MATRIX
Indirect_Comparison	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline INDIRECT_COMPARE<T_ARRAY,T_COMPARISON> Indirect_Comparison(const T_ARRAY& array,const T_COMPARISON& comparison)$/;"	f	namespace:PhysBAM
Indirect_Comparison	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline INDIRECT_COMPARE<T_ARRAY> Indirect_Comparison(const T_ARRAY& array)$/;"	f	namespace:PhysBAM
InfRadius	IoData.h	/^  enum InfRadius {FALSE = 0, TRUE = 1} infRadius;$/;"	g	struct:RotationData
Infinity_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Infinity_Norm() const$/;"	f	class:PhysBAM::MATRIX_BASE
Inflate	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Inflate(const T inflation_distance){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
InfoType	DistEmbeddedVector.h	/^  typedef DistInfo InfoType;$/;"	t	class:DistEmbeddedVec
InfoType	DistVector.h	/^  typedef DistInfo InfoType;$/;"	t	class:DistSVec
InfoType	DistVector.h	/^  typedef DistInfo InfoType;$/;"	t	class:DistVec
InfoType	Vector.h	/^  typedef int InfoType;$/;"	t	class:SVec
InfoType	Vector.h	/^  typedef int InfoType;$/;"	t	class:Vec
InitialCondition	IoData.h	/^  enum InitialCondition {DISPLACEMENT = 0, VELOCITY = 1} initCond;$/;"	g	struct:LinearizedData
InitialConditions	IoData.h	/^struct InitialConditions {$/;"	s
InitialConditions	IoDataCore.C	/^InitialConditions::InitialConditions() {$/;"	f	class:InitialConditions
InitialConditionsEmbedded	Manual/Aerof3d.html	/^<a name="InitialConditionsEmbedded"><\/a>$/;"	a
InitialConditionsMultiPhase	Manual/Aerof3d.html	/^<a name="InitialConditionsMultiPhase"><\/a>$/;"	a
InitialState	Manual/Aerof3d.html	/^<a name="InitialState"><\/a>$/;"	a
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    void Initialize(const TV& endpoint_input,const TV& direction_input,const bool already_normalized=false)$/;"	f	class:PhysBAM::RAY
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Initialize(ARRAY_VIEW<const ARRAY_COLLECTION* const> elements_per_cell)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Initialize(const ARRAY_COLLECTION& elements)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    Initialize(const ARRAY<T_ARRAY_COLLECTION*>& elements_per_cell)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    Initialize(const ARRAY_BASE<T_ARRAY_COLLECTION*,T_ARRAYS,typename T_ARRAYS::INDEX>& elements_per_cell)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    Initialize(const ARRAY_VIEW<T_ARRAY_COLLECTION*>& elements_per_cell)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Initialize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Initialize(const ID entries)$/;"	f	class:PhysBAM::UNION_FIND
InitializeWallFunction	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::InitializeWallFunction(SubDomain& subD, $/;"	f	class:ReinitializeDistanceToWall
Initialize_Adjacent_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Initialize_Adjacent_Elements()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Boundary_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Boundary_Mesh()$/;"	f	class:TRIANGLE_MESH
Initialize_Boundary_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Boundary_Nodes()$/;"	f	class:TRIANGLE_MESH
Initialize_Circle_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Circle_Mesh(const int num_radial,const int num_tangential) \/\/ construct a circle$/;"	f	class:TRIANGLE_MESH
Initialize_Connected_Segments	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Initialize_Connected_Segments()$/;"	f	class:SEGMENT_MESH
Initialize_Cylinder_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Cylinder_Mesh(const int m,const int n,const bool create_caps)$/;"	f	class:TRIANGLE_MESH
Initialize_Edge_Triangles	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Edge_Triangles()$/;"	f	class:TRIANGLE_MESH
Initialize_Element_Edges	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Element_Edges()$/;"	f	class:TRIANGLE_MESH
Initialize_Equilateral_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Equilateral_Mesh(const int m,const int n)$/;"	f	class:TRIANGLE_MESH
Initialize_Herring_Bone_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Herring_Bone_Mesh(const int m,const int n) \/\/ construct a regular m-by-n herring bone rectangular mesh$/;"	f	class:TRIANGLE_MESH
Initialize_Hierarchy_Using_KD_Tree	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Initialize_Hierarchy_Using_KD_Tree()$/;"	f	class:BOX_HIERARCHY
Initialize_Hierarchy_Using_KD_Tree	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Initialize_Hierarchy_Using_KD_Tree()$/;"	f	class:TRIANGLE_HIERARCHY
Initialize_Hierarchy_Using_KD_Tree_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Initialize_Hierarchy_Using_KD_Tree_Helper(KD_TREE_NODE<T>* node)$/;"	f	class:BOX_HIERARCHY
Initialize_Incident_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Initialize_Incident_Elements()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Logging	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^void Initialize_Logging(const bool suppress_cout_input,const bool suppress_timing_input,const int verbosity_level_input,const bool cache_initial_output)$/;"	f	namespace:PhysBAM::LOG_REAL
Initialize_Logging	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^template<class A,class B,class C,class D> inline void Initialize_Logging(const A&,const B&,const C&,const D&){}$/;"	f	namespace:PhysBAM::LOG_NULL
Initialize_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    void Initialize_Mesh(const SIMPLEX_MESH& mesh) \/\/ works with the copy constructor$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    void Initialize_Mesh(const int number_nodes_input,const ARRAY<VECTOR<int,d+1> >& simplex_list) \/\/ construct a mesh given a list of simplices$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Mesh_With_Particle_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    void Initialize_Mesh_With_Particle_Offset(const SIMPLEX_MESH& mesh,const int particle_offset)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Neighbor_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Initialize_Neighbor_Elements()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_Neighbor_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Initialize_Neighbor_Nodes()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Initialize_New_Table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Initialize_New_Table(const int estimated_max_number_of_entries_input)$/;"	f	class:PhysBAM::HASHTABLE
Initialize_Node_On_Boundary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Node_On_Boundary()$/;"	f	class:TRIANGLE_MESH
Initialize_Ordered_Loop_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Initialize_Ordered_Loop_Nodes()$/;"	f	class:SEGMENT_MESH
Initialize_Segment_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Segment_Mesh()$/;"	f	class:TRIANGLE_MESH
Initialize_Square_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Square_Mesh(const int m,const int n) \/\/ construct a regular m-by-n rectangular mesh$/;"	f	class:TRIANGLE_MESH
Initialize_Straight_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Initialize_Straight_Mesh(const int number_of_points,bool loop)$/;"	f	class:SEGMENT_MESH
Initialize_Timer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^double Initialize_Timer(){__int64 frequency;QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);return 1000.\/(double)frequency;}$/;"	f	namespace:PhysBAM
Initialize_Timer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^double Initialize_Timer(){return 1e3;} \/\/ to convert seconds to milliseconds$/;"	f	namespace:PhysBAM
Initialize_Topologically_Sorted_Incident_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Topologically_Sorted_Incident_Elements()$/;"	f	class:TRIANGLE_MESH
Initialize_Topologically_Sorted_Neighbor_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Topologically_Sorted_Neighbor_Nodes()$/;"	f	class:TRIANGLE_MESH
Initialize_Torus_Mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Initialize_Torus_Mesh(const int m,const int n)$/;"	f	class:TRIANGLE_MESH
Inlet	Manual/Aerof3d.html	/^<a name="Inlet"><\/a>$/;"	a
InletNode	InletNode.h	/^class InletNode {$/;"	c
InletNode	InletNodeCore.C	/^InletNode::InletNode()$/;"	f	class:InletNode
InletNodeSet	InletNode.h	/^class InletNodeSet {$/;"	c
InletNodeSet	InletNodeCore.C	/^InletNodeSet::InletNodeSet()$/;"	f	class:InletNodeSet
InnerProd	Vector.h	/^  InnerProd(T1 aa, T2 bb, int l) : a(aa), b(bb) { len = l; }$/;"	f	class:InnerProd
InnerProd	Vector.h	/^class InnerProd {$/;"	c
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Inner_Product(const T_ARRAY1& m,const T_ARRAY2& a1,const T_ARRAY2& a2)$/;"	f	class:PhysBAM::ARRAY_BASE
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^    Inner_Product(const ARRAY_BASE<T,T_ARRAY,ID>& m,const ARRAY_BASE<T2,T_ARRAY2,ID>& a1,const ARRAY_BASE<T2,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^    Inner_Product(const ARRAY_BASE<typename T_ARRAY2::SCALAR,T_ARRAY,ID>& m,const ARRAY_BASE<T,T_ARRAY2,ID>& a1,const ARRAY_BASE<T,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Inner_Product(const VECTOR<T,2>& a,const VECTOR<T,2>& b) const \/\/ inner product with respect to this matrix$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    static T Inner_Product(const DIAGONAL_MATRIX& A,const DIAGONAL_MATRIX& B)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Inner_Product(const VECTOR<T,3>& a,const VECTOR<T,3>& b) const \/\/ inner product with respect to this matrix$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    static T Inner_Product(const DIAGONAL_MATRIX& A,const DIAGONAL_MATRIX& B)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Inner_Product(const VECTOR<T,0>& u,const VECTOR<T,0>& v) const$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Inner_Product(const VECTOR<T,0>& u,const VECTOR<T,0>& v) const$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Inner_Product(const VECTOR<T,1>& u,const VECTOR<T,1>& v) const$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static T Inner_Product(const MATRIX& A,const MATRIX& B)$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    static T Inner_Product(const MATRIX& A,const MATRIX& B) \/\/ 6 mults, 5 adds$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static T Inner_Product(const MATRIX& A,const MATRIX& B)$/;"	f	class:PhysBAM::MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static T Inner_Product(const SYMMETRIC_MATRIX& A,const SYMMETRIC_MATRIX& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static T Inner_Product(const SYMMETRIC_MATRIX& A,const SYMMETRIC_MATRIX& B)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Inner_Product_Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^Inner_Product_Conjugate(const DIAGONAL_MATRIX<T,2>& A,const MATRIX<T,2>& Q,const DIAGONAL_MATRIX<T,2> B)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product_Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^Inner_Product_Conjugate(const DIAGONAL_MATRIX<T,3>& A,const MATRIX<T,3>& Q,const DIAGONAL_MATRIX<T,3> B)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inner_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Inner_Product_Double_Precision(const T_ARRAY1& m,const T_ARRAY2& a1,const T_ARRAY2& a2)$/;"	f	class:PhysBAM::ARRAY_BASE
Inner_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^    Inner_Product_Double_Precision(const ARRAY_BASE<T,T_ARRAY,ID>& m,const ARRAY_BASE<T2,T_ARRAY2,ID>& a1,const ARRAY_BASE<T2,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Inner_Product_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^    Inner_Product_Double_Precision(const ARRAY_BASE<typename T_ARRAY2::SCALAR,T_ARRAY,ID>& m,const ARRAY_BASE<T,T_ARRAY2,ID>& a1,const ARRAY_BASE<T,T_ARRAY2,ID>& a2)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Input	Manual/Aerof3d.html	/^<a name="Input"><\/a>$/;"	a
InputData	IoData.h	/^struct InputData {$/;"	s
InputData	IoDataCore.C	/^InputData::InputData()$/;"	f	class:InputData
InputNumberOfColumns	AutoDiff/Function.h	/^           InputNumberOfColumns           = 1,$/;"	e	enum:MatrixValuedFunction::__anon3
InputNumberOfColumns	AutoDiff/Function.h	/^           InputNumberOfColumns           = 1,$/;"	e	enum:ScalarValuedFunction::__anon1
InputNumberOfColumns	AutoDiff/Function.h	/^           InputNumberOfColumns           = 1,$/;"	e	enum:VectorValuedFunction::__anon2
InputNumberOfColumns	AutoDiff/SpaceDerivatives.h	/^           InputNumberOfColumns            = FunctionTemplate<Scalar>::InputNumberOfColumns,$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
InputNumberOfColumns	AutoDiff/SpaceDerivatives.h	/^           InputNumberOfColumns     = MatrixValuedFunctionBase::InputNumberOfColumns,$/;"	e	enum:Jacobian::__anon6
InputNumberOfRows	AutoDiff/Function.h	/^    enum { InputNumberOfRows              = _NumberOfGeneralizedCoordinates,$/;"	e	enum:MatrixValuedFunction::__anon3
InputNumberOfRows	AutoDiff/Function.h	/^    enum { InputNumberOfRows              = _NumberOfGeneralizedCoordinates,$/;"	e	enum:ScalarValuedFunction::__anon1
InputNumberOfRows	AutoDiff/Function.h	/^    enum { InputNumberOfRows              = _NumberOfGeneralizedCoordinates,$/;"	e	enum:VectorValuedFunction::__anon2
InputNumberOfRows	AutoDiff/SpaceDerivatives.h	/^    enum { InputNumberOfRows               = FunctionTemplate<Scalar>::InputNumberOfRows,$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
InputNumberOfRows	AutoDiff/SpaceDerivatives.h	/^    enum { InputNumberOfRows        = MatrixValuedFunctionBase::InputNumberOfRows,$/;"	e	enum:Jacobian::__anon6
InputType	AutoDiff/SpaceDerivatives.h	/^    typedef Eigen::Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	class:SpatialView
InputsAtCompileTime	AutoDiff/SpaceDerivatives.h	/^      InputsAtCompileTime = FunctionTemplate<Scalar>::NumberOfGeneralizedCoordinates,$/;"	e	enum:SpatialView::__anon4
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Insert(const T& element,const ID index)$/;"	f	class:PhysBAM::ARRAY
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    Insert(const HASHTABLE_ENTRY_TEMPLATE<TK,T2>& entry)$/;"	f	class:PhysBAM::HASHTABLE
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    T_UNLESS_VOID& Insert(const TK& v,const T_UNLESS_VOID& value) \/\/ assumes no entry with v exists$/;"	f	class:PhysBAM::HASHTABLE
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Insert(const HASHTABLE_ENTRY_TEMPLATE<TK,void>& entry)$/;"	f	class:PhysBAM::HASHTABLE
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Insert(const TK& v) \/\/ assumes no entry with v exists$/;"	f	class:PhysBAM::HASHTABLE
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR<T,d+1> Insert(const T& element,const int index) const$/;"	f	class:PhysBAM::VECTOR
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR<T,1> Insert(const T& element,const int index) const$/;"	f	class:PhysBAM::VECTOR
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR<T,2> Insert(const T& element,const int index) const$/;"	f	class:PhysBAM::VECTOR
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,3> Insert(const T& element,const int index) const$/;"	f	class:PhysBAM::VECTOR
Insert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR<T,4> Insert(const T& element,const int index) const$/;"	f	class:PhysBAM::VECTOR
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Inside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::LINE_2D
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Inside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::PLANE
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Inside(const VECTOR<T,2>& point,const T thickness_over_two) const $/;"	f	class:SEGMENT_2D
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Inside(const TV& point,const T thickness_over_two) const$/;"	f	class:TRIANGLE_3D
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Inside(const TV& location,const T thickness_over_two) const$/;"	f	class:IMPLICIT_OBJECT
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Inside(const T& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Inside(const T& location,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Inside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Inside(const TV& location,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
Inside_Polygon	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^Inside_Polygon(const VECTOR<T,2>& X_point)$/;"	f	class:POLYGON
Installation	Manual/Aerof3d.html	/^<a name="Installation"><\/a>$/;"	a
Instance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^LOG_CLASS* Instance()$/;"	f	namespace:PhysBAM::LOG_REAL
Instance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^inline log_null_class* Instance(){return &cout;}$/;"	f	namespace:PhysBAM::LOG_NULL
IntExpr	parser/Parser.y	/^IntExpr:$/;"	l
Integration	IoData.h	/^  enum Integration {AUTO = 0, WALL_FUNCTION = 1, FULL = 2} integration;$/;"	g	struct:BcsWallData
Integration_Step	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Integration_Step(const T phi) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Interface	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static int Interface(const T phi_1,const T phi_2)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
InterfaceAlgorithm	IoData.h	/^  enum InterfaceAlgorithm {MID_EDGE = 0, INTERSECTION = 1} interfaceAlg;$/;"	g	struct:EmbeddedFramework
InterfaceExtrapolation	IoData.h	/^  enum InterfaceExtrapolation {EXTRAPOLATIONFIRSTORDER=0, EXTRAPOLATIONSECONDORDER=1, AUTO=2} interfaceExtrapolation;$/;"	g	struct:MultiFluidData
InterfaceLimiter	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	g	struct:EmbeddedFramework
InterfaceLimiter	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	g	struct:MultiFluidData
InterfaceTag	MultiPhysicsTsDesc.h	/^  DistSVec<bool,2> InterfaceTag;$/;"	m	class:MultiPhysicsTsDesc
InterfaceTracking	IoData.h	/^  enum InterfaceTracking {LINEAR = 0, GRADIENT = 1, HERMITE = 2}; $/;"	g	struct:MultiFluidData
InterfaceTreatment	IoData.h	/^  enum InterfaceTreatment {FIRSTORDER=0, SECONDORDER=1} interfaceTreatment;$/;"	g	struct:MultiFluidData
InterfaceType	IoData.h	/^  enum InterfaceType {FSF = 0, FF = 1, FSFandFF = 2} interfaceType;$/;"	g	struct:MultiFluidData
Interpolate	OneDimensionalInterpolator.h	/^    static void Interpolate(SVec<double,dim> &V, double& Vi, int id,$/;"	f	class:OneDimensionalInterpolator
Interpolation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    static FRAME Interpolation(const FRAME& f1,const FRAME& f2,const T s)$/;"	f	class:PhysBAM::FRAME
Interpolation_Fraction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Interpolation_Fraction(const VECTOR<T,3>& location) const$/;"	f	class:SEGMENT_3D
Interpolation_Fraction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Interpolation_Fraction(const VECTOR<T,3>& location,const VECTOR<T,3>& x1,const VECTOR<T,3>& x2) $/;"	f	class:SEGMENT_3D
Intersect	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Intersect(const TV& start,const TV& end,const T thickness) const$/;"	f	class:PhysBAMInterface
Intersect	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Intersect(const int subD,const ARRAY<TV>& node_positions,const ARRAY<bool>& occluded_node,ARRAY<TRIPLE<VECTOR<int,3>,IntersectionResult<T>,IntersectionResult<T> > >& edges_and_results) const$/;"	f	class:PhysBAMInterface
Intersect	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Intersect(const INTERVAL& box1,const INTERVAL& box2)$/;"	f	class:PhysBAM::INTERVAL
Intersect	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Intersect(const RANGE<TV>& box1,const RANGE<TV>& box2) \/\/ assumes nonnegative entries$/;"	f	class:PhysBAM::RANGE
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Intersection(const ORIENTED_BOX& box) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Intersection(const RANGE<TV>& box) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Intersection(RAY<TV>& ray,const T thickness) const$/;"	f	class:IMPLICIT_OBJECT
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Intersection(RAY<VECTOR<T,3> >& ray,VECTOR<T,3>& weights,const T thickness_over_two,const bool use_ray_bounding_box) const$/;"	f	class:TRIANGLE_HIERARCHY
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Intersection(RAY<VECTOR<T,3> >& ray,const T thickness_over_two,const bool use_ray_bounding_box) const$/;"	f	class:TRIANGLE_HIERARCHY
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^Intersection(const int box,RAY<VECTOR<T,3> >& ray,const T thickness,const T thickness_over_two,const bool use_ray_bounding_box) const$/;"	f	class:TRIANGLE_HIERARCHY
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Intersection(const INTERVAL& interval) const$/;"	f	class:PhysBAM::INTERVAL
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Intersection(const INTERVAL& interval,const T thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Intersection(const INTERVAL& interval,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Intersection(const RANGE<TV>& box) const$/;"	f	class:PhysBAM::RANGE
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Intersection(const RANGE<TV>& box,const T thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Intersection(const RANGE<TV>& box,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
IntersectionResult	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^struct IntersectionResult {$/;"	s	namespace:PhysBAM
Intersection_Area	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    T Intersection_Area(const RANGE<TV>& box) const$/;"	f	class:PhysBAM::RANGE
Intersection_Helper	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Intersection_Helper(const ARRAY<TRIANGLE_3D<T> >& triangle_list,const ARRAY<int>& scope,const ARRAY<int>& candidates,$/;"	f	namespace:__anon13
Intersection_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^template<class T,class T_BOX> static bool Intersection_Helper(const ORIENTED_BOX<VECTOR<T,1> >& self,const T_BOX& box,const VECTOR<T,1>& u,const VECTOR<T,1>& v){PHYSBAM_NOT_IMPLEMENTED();}$/;"	f	namespace:PhysBAM
Intersection_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^template<class T,class T_BOX> static bool Intersection_Helper(const ORIENTED_BOX<VECTOR<T,2> >& self,const T_BOX& box,const VECTOR<T,2>& u,const VECTOR<T,2>& v){return false;}$/;"	f	namespace:PhysBAM
Intersection_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^template<class T,class T_BOX> static bool Intersection_Helper(const ORIENTED_BOX<VECTOR<T,3> >& self,const T_BOX& box,const VECTOR<T,3>& u,const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Intersection_List(const int box,const IMPLICIT_OBJECT<TV>& implicit_object,const MATRIX<T,TV::dimension>& rotation,const TV& translation,ARRAY<int>& intersection_list,const T contour_value) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Intersection_List(const int box,const ORIENTED_BOX<TV>& test_box,ARRAY<int>& intersection_list) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Intersection_List(const int box,const RANGE<TV>& test_box,ARRAY<int>& intersection_list,const T_THICKNESS thickness_over_two) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Intersection_List(const int box,const TV& point,ARRAY<int>& intersection_list,const T_THICKNESS thickness_over_two) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Intersection_List(const int box,const T_HYPERPLANE& test_plane,ARRAY<int>& intersection_list,const T thickness_over_two) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    virtual void Intersection_List(const IMPLICIT_OBJECT<TV>& implicit_object,const MATRIX<T,TV::dimension>& rotation,const TV& translation,ARRAY<int>& intersection_list,const T contour_value=0) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    virtual void Intersection_List(const ORIENTED_BOX<TV>& test_box,ARRAY<int>& intersection_list) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    virtual void Intersection_List(const RANGE<TV>& test_box,ARRAY<int>& intersection_list,const T thickness_over_two=0) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    virtual void Intersection_List(const TV& point,ARRAY<int>& intersection_list,const T thickness_over_two=0) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    virtual void Intersection_List(const T_HYPERPLANE& test_plane,ARRAY<int>& intersection_list,const T thickness_over_two=0) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY_DEFINITION.h	/^Intersection_List(T_VISITOR& visitor) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY_DEFINITION.h	/^Intersection_List(const BOX_HIERARCHY<TV>& other_hierarchy,T_VISITOR& visitor,const T_THICKNESS extra_thickness) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY_DEFINITION.h	/^Intersection_List(const BOX_HIERARCHY<TV>& other_hierarchy,T_VISITOR& visitor,const int self_box,const int other_box,const T_THICKNESS extra_thickness) const$/;"	f	class:BOX_HIERARCHY
Intersection_List	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Intersection_List(const IMPLICIT_OBJECT<VECTOR<T,3> >& implicit_surface,const MATRIX<T,3>& rotation,const VECTOR<T,3>& translation,ARRAY<int>& intersection_list,$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Intersection_X_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^template<class T> bool Intersection_X_Segment(RAY<VECTOR<T,2> >& ray,const T x1,const T x2,const T y,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersection_Y_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^template<class T> bool Intersection_Y_Segment(RAY<VECTOR<T,2> >& ray,const T x,const T y1,const T y2,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
IntersectorFRG	IntersectorFRG/IntersectorFRG.C	/^IntersectorFRG::IntersectorFRG(SubDomain &sub, SVec<double,3> &X,$/;"	f	class:IntersectorFRG
IntersectorFRG	IntersectorFRG/IntersectorFRG.h	/^class IntersectorFRG : public LevelSetStructure {$/;"	c
IntersectorName	IoData.h	/^  enum IntersectorName {PHYSBAM = 0, FRG = 1} intersectorName;$/;"	g	struct:EmbeddedFramework
IntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.C	/^IntersectorPhysBAM::IntersectorPhysBAM(SubDomain &sub,SVec<double,3> &X, $/;"	f	class:IntersectorPhysBAM
IntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.h	/^class IntersectorPhysBAM : public LevelSetStructure {$/;"	c
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.cpp	/^template<class T> bool Intersects(const RANGE<VECTOR<T,2> >& box,const LINE_2D<T>& line,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.cpp	/^template<class T> bool Intersects(const RANGE<VECTOR<T,3> >& box,const PLANE<T>& plane,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.cpp	/^template<class T> bool Intersects(const RANGE<VECTOR<T,1> >& box,const POINT_SIMPLEX_1D<T>& point,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,1> >& ray,const RANGE<VECTOR<T,1> >& box,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,2> >& ray,const RANGE<VECTOR<T,2> >& box,const T thickness_over_two,const T segment_intersect_epsilon)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,3> >& ray,const RANGE<VECTOR<T,3> >& box,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,3> >& ray,const PLANE<T>& plane, const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,3> >& ray,const PLANE<T>& plane, const T thickness_over_two,const T distance,const T rate_of_approach)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,2> >& ray,const SEGMENT_2D<T>& segment,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.cpp	/^template<class T> bool Intersects(RAY<VECTOR<T,3> >& ray,const TRIANGLE_3D<T>& triangle, const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Introduction	Manual/Aerof3d.html	/^<a name="Introduction"><\/a>$/;"	a
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^Inverse(const T_MATRIX& x)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^Inverse(const double x)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^Inverse(const float x)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^Inverse(const int x)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^    ONE Inverse() const$/;"	f	struct:PhysBAM::ONE
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Inverse() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Inverse() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME Inverse() const$/;"	f	class:PhysBAM::FRAME
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Inverse() const$/;"	f	class:PhysBAM::MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Inverse() const$/;"	f	class:PhysBAM::MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Inverse() const$/;"	f	class:PhysBAM::MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Inverse() const$/;"	f	class:PhysBAM::MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Inverse() const$/;"	f	class:MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.cpp	/^Inverse() const$/;"	f	class:MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION Inverse() const$/;"	f	class:PhysBAM::QUATERNION
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION<TV> Inverse() const$/;"	f	class:PhysBAM::ROTATION
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX Inverse() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Inverse() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX Inverse() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX Inverse() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Inverse() const$/;"	f	class:PhysBAM::COMPLEX
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Inverse(const VECTOR<T,d>& v)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^Inverse(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^Inverse(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^Inverse(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
Inverse_Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Inverse_Inner_Product(const VECTOR<T,2>& a,const VECTOR<T,2>& b) const \/\/ inner product with respect to the inverse of this matrix$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inverse_Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Inverse_Inner_Product(const VECTOR<T,3>& a,const VECTOR<T,3>& b) const \/\/ inner product with respect to the inverse of this matrix$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Inverse_Inner_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Inverse_Inner_Product(const VECTOR<T,1>& u,const VECTOR<T,1>& v) const$/;"	f	class:PhysBAM::MATRIX
Inverse_Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Inverse_Rotate(const TV& v) const \/\/ 20 mult and 13 add\/sub$/;"	f	class:PhysBAM::ROTATION
Inverse_Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Inverse_Rotate(const TV& v) const$/;"	f	class:PhysBAM::ROTATION
Inverse_Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const TV& Inverse_Rotate(const TV& x) const$/;"	f	class:PhysBAM::ROTATION
Inverse_Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^Inverse_Rotate(const VECTOR<int,3>& v) const \/\/ homogenous of degree 2 in q, since we can't usefully assume normalization for integer case$/;"	f	class:PhysBAM::ROTATION
Inverse_Rotation_And_Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX Inverse_Rotation_And_Translation()$/;"	f	class:PhysBAM::MATRIX
Inverse_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME Inverse_Times(const FRAME& f) const$/;"	f	class:PhysBAM::FRAME
Inverse_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    TV Inverse_Times(const TV& v) const$/;"	f	class:PhysBAM::FRAME
Inverse_Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Inverse_Transposed() const$/;"	f	class:PhysBAM::MATRIX
Inverse_Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Inverse_Transposed() const$/;"	f	class:PhysBAM::MATRIX
Invert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    void Invert()$/;"	f	class:PhysBAM::FRAME
Invert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    void Invert()$/;"	f	class:PhysBAM::MATRIX
Invert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    void Invert()$/;"	f	class:PhysBAM::MATRIX
Invert	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    void Invert()$/;"	f	class:PhysBAM::MATRIX
InvertAutoShift	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::InvertAutoShift()$/;"	f	class:ARrcStdEig
InvertMode	arpack++/include/arrgsym.h	/^  char    InvertMode;$/;"	m	class:ARrcSymGenEig
Invert_Rotation_And_Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    void Invert_Rotation_And_Translation()$/;"	f	class:PhysBAM::MATRIX
IoData	IoData.h	/^class IoData {$/;"	c
IoData	IoDataCore.C	/^IoData::IoData(Communicator *communicator)$/;"	f	class:IoData
IsComplex	arpack++/include/arhbmat.h	/^  bool IsComplex() { return (type[0]=='C'); }$/;"	f	class:ARhbMatrix
IsDefined	arpack++/include/ardfmat.h	/^  bool IsDefined() const { return (m!=0); }$/;"	f	class:ARdfMatrix
IsDefined	arpack++/include/arhbmat.h	/^  bool IsDefined() { return (m!=0); }$/;"	f	class:ARhbMatrix
IsDefined	arpack++/include/armat.h	/^  bool IsDefined() { return defined; }$/;"	f	class:ARMatrix
IsFactored	arpack++/include/arbnsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARbdNonSymMatrix
IsFactored	arpack++/include/arbnspen.h	/^  bool IsFactored() { return (AsB.IsFactored()||AsBc.IsFactored()); }$/;"	f	class:ARbdNonSymPencil
IsFactored	arpack++/include/arbnspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARbdNonSymPencil
IsFactored	arpack++/include/arbsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARbdSymMatrix
IsFactored	arpack++/include/arbspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARbdSymPencil
IsFactored	arpack++/include/ardnsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARdsNonSymMatrix
IsFactored	arpack++/include/ardnspen.h	/^  bool IsFactored() { return (AsB.IsFactored()||AsBc.IsFactored()); }$/;"	f	class:ARdsNonSymPencil
IsFactored	arpack++/include/ardnspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARdsNonSymPencil
IsFactored	arpack++/include/ardsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARdsSymMatrix
IsFactored	arpack++/include/ardspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARdsSymPencil
IsFactored	arpack++/include/arlnsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARluNonSymMatrix
IsFactored	arpack++/include/arlnspen.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARluNonSymPencil
IsFactored	arpack++/include/arlsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARluSymMatrix
IsFactored	arpack++/include/arlspen.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARluSymPencil
IsFactored	arpack++/include/arunsmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARumNonSymMatrix
IsFactored	arpack++/include/arunspen.h	/^  bool IsFactored() { return (AsB.IsFactored()||AsBc.IsFactored()); }$/;"	f	class:ARumNonSymPencil
IsFactored	arpack++/include/arunspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARumNonSymPencil
IsFactored	arpack++/include/arusmat.h	/^  bool IsFactored() { return factored; }$/;"	f	class:ARumSymMatrix
IsFactored	arpack++/include/aruspen.h	/^  bool IsFactored() { return AsB.IsFactored(); }$/;"	f	class:ARumSymPencil
IsHermitian	arpack++/include/arhbmat.h	/^  bool IsHermitian() { return (type[1]=='H'); }$/;"	f	class:ARhbMatrix
IsOutOfCore	arpack++/include/ardfmat.h	/^  bool IsOutOfCore() const { $/;"	f	class:ARdfMatrix
IsReal	arpack++/include/arhbmat.h	/^  bool IsReal() { return (type[0]=='R'); }$/;"	f	class:ARhbMatrix
IsRowOrdered	arpack++/include/ardfmat.h	/^  bool IsRowOrdered() const { return roword; }$/;"	f	class:ARdfMatrix
IsSkewSymmetric	arpack++/include/arhbmat.h	/^  bool IsSkewSymmetric() { return (type[1]=='Z'); }$/;"	f	class:ARhbMatrix
IsSymmetric	arpack++/include/arhbmat.h	/^  bool IsSymmetric() { return (type[1]=='S'); }$/;"	f	class:ARhbMatrix
IsSymmetric	arpack++/include/arunsmat.h	/^  bool IsSymmetric() { return bool(icntl[5]); }$/;"	f	class:ARumNonSymMatrix
IsSymmetric	arpack++/include/arunspen.h	/^  bool IsSymmetric() { return AsB.IsSymmetric(); }$/;"	f	class:ARumNonSymPencil
IsUnsymmetric	arpack++/include/arhbmat.h	/^  bool IsUnsymmetric() { return (type[1]=='U'); }$/;"	f	class:ARhbMatrix
Is_Animated	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Animated(const std::string &filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Box_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Box_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Curve2D_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Curve2D_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Curve_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Curve_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Hex_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Hex_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    bool Is_Normalized(const T tolerance=(T)1e-3) const$/;"	f	class:PhysBAM::QUATERNION
Is_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    bool Is_Normalized() const$/;"	f	class:PhysBAM::ROTATION
Is_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    bool Is_Normalized(const T tolerance=(T)1e-3) const$/;"	f	class:PhysBAM::ROTATION
Is_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    bool Is_Normalized(const T tolerance=(T)1e-4) const$/;"	f	class:PhysBAM::ROTATION
Is_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    bool Is_Normalized(const T tolerance=(T)1e-3) const$/;"	f	class:PhysBAM::COMPLEX
Is_Number	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^bool Is_Number(const std::string& str) \/\/ integer or floating point$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Is_Oct_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Oct_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Phi2D_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Phi2D_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Phi_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Phi_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Phoneme_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Phoneme_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Ply2D_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Ply2D_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Ply_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Ply_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Rgb_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Rgb_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Rgd2D_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Rgd2D_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Rgd_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Rgd_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    bool Is_Root(const ID i) const$/;"	f	class:PhysBAM::UNION_FIND
Is_Tet_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Tet_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Is_Tri_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline bool Is_Tri_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Iterate	arpack++/include/arseig.h	/^  virtual void Iterate() {$/;"	f	class:ARStdEig
Iterative_Solver_Tolerance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<> inline double Iterative_Solver_Tolerance(){return .001;}$/;"	f	namespace:__anon14
Iterative_Solver_Tolerance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<> inline float Iterative_Solver_Tolerance(){return (float).01;}$/;"	f	namespace:__anon14
Iterative_Solver_Tolerance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class T> inline T Iterative_Solver_Tolerance(){STATIC_ASSERT((T)false);}$/;"	f	namespace:__anon14
JACOBI	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
JACOBIAN_ROB_GREEDY	IoData.h	/^                   JACOBIAN_ROB_GREEDY = 2, RESIDUAL_AND_JACOBIAN_ROBS_GREEDY = 3, SPECIFIED_SNAPS_GREEDY = 4} greedyData;$/;"	e	enum:GappyConstructionData::greedyData
JACSUPERSONIC	f77src/hllcjac.f	/^      SUBROUTINE JACSUPERSONIC(/;"	s
JWL	DistBcData.h	/^  enum BoundaryFluid { GAS=0, TAIT=1, JWL=2 } boundaryFluid;$/;"	e	enum:DistBcData::BoundaryFluid
JWL	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	e	enum:FluidModelData::Fluid
JWL	IoData.h	/^  enum Type {IDEAL = 0, JWL = 1} type;$/;"	e	enum:JWLModelData::Type
JWL	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	e	enum:VarFcnBase::Type
JWLEOS	ProgrammedBurnCore.C	/^	JWLEOS(double _A1,double _A2, double _R1, double _R2, double _omega) : A1(_A1), A2(_A2),$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
JWLEOS	ProgrammedBurnCore.C	/^class JWLEOS {$/;"	c	namespace:ProgrammedBurn_CJ	file:
JWLModel	Manual/Aerof3d.html	/^<a name="JWLModel"><\/a>$/;"	a
JWLModelData	IoData.h	/^struct JWLModelData {$/;"	s
JWLModelData	IoDataCore.C	/^JWLModelData::JWLModelData()$/;"	f	class:JWLModelData
JacSkip	IoData.h	/^  int JacSkip;$/;"	m	struct:NewtonData
JacobiPrec	KspPrec.C	/^JacobiPrec<Scalar,dim, Scalar2>::JacobiPrec(typename DiagMat<Scalar,dim>::Type type, $/;"	f	class:JacobiPrec
JacobiPrec	KspPrec.h	/^class JacobiPrec : public KspPrec<dim, Scalar2>, public DistMat<Scalar,dim> {$/;"	c
Jacobi_Singular_Value_Decomposition	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.cpp	/^Jacobi_Singular_Value_Decomposition(ARRAY<VECTOR<int,2> >& left_givens_pairs,ARRAY<VECTOR<T,2> >& left_givens_coefficients,$/;"	f	class:MATRIX_MXN
Jacobi_Transform	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.cpp	/^Jacobi_Transform(const int sweep,const T threshold,T& app,T& apq,T& aqq,T& arp,T& arq,T& v1p,T& v1q,T& v2p,T& v2q,T& v3p,T& v3q)$/;"	f	class:SYMMETRIC_MATRIX
Jacobian	AutoDiff/SpaceDerivatives.h	/^    Jacobian(const Eigen::Array<typename VectorValuedFunctionTemplate<Scalar>::ScalarConstantType,$/;"	f	class:Jacobian
Jacobian	AutoDiff/SpaceDerivatives.h	/^class Jacobian : MatrixValuedFunction<VectorValuedFunctionTemplate<_Scalar>::NumberOfGeneralizedCoordinates,$/;"	c
Jacobian	ImplicitEmbeddedRomTsDesc.h	/^    MatVecProd<dim, dim> *Jacobian;$/;"	m	class:ImplicitEmbeddedRomTsDesc
JacobianActionData	IoData.h	/^struct JacobianActionData {$/;"	s
JacobianActionData	IoDataCore.C	/^JacobianActionData::JacobianActionData()$/;"	f	class:JacobianActionData
JacobianType	AutoDiff/Function.h	/^    typedef Eigen::Array<ReturnType,1,NumberOfGeneralizedCoordinates> JacobianType;$/;"	t	class:MatrixValuedFunction
JacobianType	AutoDiff/Function.h	/^    typedef Eigen::Matrix<Scalar,1,NumberOfGeneralizedCoordinates> JacobianType;$/;"	t	class:ScalarValuedFunction
JacobianType	AutoDiff/Function.h	/^    typedef Eigen::Matrix<Scalar,NumberOfValues,NumberOfGeneralizedCoordinates> JacobianType;$/;"	t	class:VectorValuedFunction
JacobianType	AutoDiff/SpaceDerivatives.h	/^    typedef Eigen::Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	class:SpatialView
JacobianVectorProduct	AutoDiff/SpaceDerivatives.h	/^    JacobianVectorProduct(const Eigen::Array<typename Base::ScalarConstantType, Base::NumberOfScalarConstants, 1>& _sconst,$/;"	f	class:JacobianVectorProduct
JacobianVectorProduct	AutoDiff/SpaceDerivatives.h	/^class JacobianVectorProduct : public VectorValuedFunction<FunctionTemplate<Scalar>::NumberOfGeneralizedCoordinates,$/;"	c
Join	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^std::string Join(const std::string& separator,const ARRAY<std::string>& tokens)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
JwlInfo	ImplicitRiemann.C	/^  JwlInfo(double om, double ent,VarFcn* v, int f) : omega(om), vf_(v), fluidId(f),entropy(ent) {}$/;"	f	struct:JwlInfo
JwlInfo	ImplicitRiemann.C	/^struct JwlInfo {$/;"	s	file:
JwlKernel2	ImplicitRiemann.C	/^struct JwlKernel2 {$/;"	s	file:
K	Modal.h	/^    double *K;$/;"	m	class:ModalSolver
KDTree	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::KDTree(int nobj, Obj *allObjs, int depth) {$/;"	f	class:KDTree
KDTree	IntersectorFRG/Geometry/KDTree.h	/^class KDTree {$/;"	c
KDTree	KDTree.h	/^class KDTree {$/;"	c
KDTreeNode	KDTree.h	/^  struct KDTreeNode {$/;"	s	class:KDTree
KD_TREE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    KD_TREE(const bool store_values_on_internal_nodes_input=true)$/;"	f	class:PhysBAM::KD_TREE
KD_TREE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^class KD_TREE:public NONCOPYABLE$/;"	c	namespace:PhysBAM
KD_TREE_NODE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    KD_TREE_NODE()$/;"	f	class:PhysBAM::KD_TREE_NODE
KD_TREE_NODE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^class KD_TREE_NODE:public NONCOPYABLE$/;"	c	namespace:PhysBAM
KEModelData	IoData.h	/^struct KEModelData {$/;"	s
KEModelData	IoDataCore.C	/^KEModelData::KEModelData()$/;"	f	class:KEModelData
KENERGY	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
KEY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef TK KEY;$/;"	t	class:PhysBAM::HASHTABLE
KEpsilonTerm	KEpsilonTerm.h	/^KEpsilonTerm::KEpsilonTerm(IoData &iod)$/;"	f	class:KEpsilonTerm
KEpsilonTerm	KEpsilonTerm.h	/^class KEpsilonTerm {$/;"	c
K_MEANS_WITHOUT_BOUNDS	IoData.h	/^  enum ClusteringAlgorithm {K_MEANS_WITHOUT_BOUNDS = 0, K_MEANS_WITH_BOUNDS = 1} clusteringAlgorithm;$/;"	e	enum:ClusteringData::ClusteringAlgorithm
K_MEANS_WITH_BOUNDS	IoData.h	/^  enum ClusteringAlgorithm {K_MEANS_WITHOUT_BOUNDS = 0, K_MEANS_WITH_BOUNDS = 1} clusteringAlgorithm;$/;"	e	enum:ClusteringData::ClusteringAlgorithm
K_TURB	PostFcn.h	/^                   K_TURB = 10, EPS_TURB = 11, EDDY_VISCOSITY = 12, DELTA_PLUS = 13, $/;"	e	enum:PostFcn::ScalarType
Key	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    const TK& Key() const$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
KirchhoffData	IoData.h	/^struct KirchhoffData {$/;"	s
KirchhoffData	IoDataCore.C	/^KirchhoffData::KirchhoffData()$/;"	f	class:KirchhoffData
KirchhoffIntegrator	KirchhoffIntegrator.C	/^KirchhoffIntegrator::KirchhoffIntegrator$/;"	f	class:KirchhoffIntegrator
KirchhoffIntegrator	KirchhoffIntegrator.h	/^class KirchhoffIntegrator {$/;"	c
KmeansBoundType	IoData.h	/^  enum KmeansBoundType {TIGHT_BOUNDS = 0, LOOSE_BOUNDS = 1} kmeansBoundType;$/;"	g	struct:ClusteringData
KrylovData	IoData.h	/^struct KrylovData {$/;"	s
KrylovData	IoDataCore.C	/^KrylovData::KrylovData()$/;"	f	class:KrylovData
KspBinaryOutput	KspBinaryOutput.C	/^KspBinaryOutput<VecType>::KspBinaryOutput(Communicator *_com, IoData *_ioData, Domain *_domain)  : $/;"	f	class:KspBinaryOutput
KspBinaryOutput	KspBinaryOutput.h	/^class KspBinaryOutput {$/;"	c
KspConvCriterion	KspConvCriterion.C	/^KspConvCriterion::KspConvCriterion(KspData &data)$/;"	f	class:KspConvCriterion
KspConvCriterion	KspConvCriterion.h	/^class KspConvCriterion {$/;"	c
KspData	IoData.h	/^struct KspData {$/;"	s
KspData	IoDataCore.C	/^KspData::KspData()$/;"	f	class:KspData
KspFluidData	IoData.h	/^struct KspFluidData {$/;"	s
KspFluidData	IoDataCore.C	/^KspFluidData::KspFluidData()$/;"	f	class:KspFluidData
KspPrec	KspPrec.h	/^  KspPrec() {}$/;"	f	class:KspPrec
KspPrec	KspPrec.h	/^class KspPrec {$/;"	c
KspSolver	KspSolver.C	/^KspSolver(KspData &data, MatVecProdOp *mvp, PrecOp *pc, IoOp *io)$/;"	f	class:KspSolver
KspSolver	KspSolver.h	/^  KspSolver() {}$/;"	f	class:KspSolver
KspSolver	KspSolver.h	/^class KspSolver {$/;"	c
L	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
L	arpack++/include/arlnsmat.h	/^  SuperMatrix L;$/;"	m	class:ARluNonSymMatrix
L	arpack++/include/arlnspen.h	/^  SuperMatrix                        L;$/;"	m	class:ARluNonSymPencil
L	arpack++/include/arlsmat.h	/^  SuperMatrix L;$/;"	m	class:ARluSymMatrix
L	arpack++/include/arlspen.h	/^  SuperMatrix            L;$/;"	m	class:ARluSymPencil
L1_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T L1_Norm() const$/;"	f	class:PhysBAM::VECTOR
L1_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T L1_Norm() const$/;"	f	class:PhysBAM::VECTOR
L1_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T L1_Norm() const$/;"	f	class:PhysBAM::VECTOR
L1_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T L1_Norm() const$/;"	f	class:PhysBAM::VECTOR_BASE
LAPACKC_H	arpack++/include/lapackc.h	21;"	d
LAPACKF_H	arpack++/include/lapackf.h	18;"	d
LAPACK_ERROR	arpack++/include/arerror.h	/^    LAPACK_ERROR        = -201,$/;"	e	enum:ArpackError::ErrorCode
LAPACK_H	AlternatingLeastSquare/include/lapack.h	2;"	d
LARGE_VELOCITY	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
LAST	IoData.h	/^  enum Force {LAST = 0, AVERAGED = 1, LAST_KRIS = 2} force;$/;"	e	enum:AeroelasticData::Force
LAST_KRIS	IoData.h	/^  enum Force {LAST = 0, AVERAGED = 1, LAST_KRIS = 2} force;$/;"	e	enum:AeroelasticData::Force
LEAST_SQUARES	IoData.h	/^  enum Gradient {LEAST_SQUARES = 0, GALERKIN = 1, NON_NODAL = 2} gradient;$/;"	e	enum:SchemeData::Gradient
LEAST_SQUARES	IoData.h	/^  enum PhaseChangeAlgorithm {AVERAGE = 0, LEAST_SQUARES = 1, AUTO = 2} phaseChangeAlg;$/;"	e	enum:EmbeddedFramework::PhaseChangeAlgorithm
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef typename MATRIX_INFO<T_MATRIX>::RIGHT_VECTOR RIGHT_VECTOR;typedef typename MATRIX_INFO<T_MATRIX>::LEFT_VECTOR LEFT_VECTOR;$/;"	t	class:PhysBAM::MATRIX_BASE
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,class T_MATRIX> struct MATRIX_INFO<MATRIX_BASE<T,T_MATRIX> >{typedef typename MATRIX_INFO<T_MATRIX>::LEFT_VECTOR LEFT_VECTOR;$/;"	t	struct:PhysBAM::MATRIX_INFO
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<DIAGONAL_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef DIAGONAL_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<SYMMETRIC_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef SYMMETRIC_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<UPPER_TRIANGULAR_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;};$/;"	t	struct:PhysBAM::MATRIX_INFO
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct MATRIX_INFO<MATRIX<T,m,n> >{typedef VECTOR<T,m> LEFT_VECTOR;typedef VECTOR<T,n> RIGHT_VECTOR;typedef MATRIX<T,n,m> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
LEFT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T> struct MATRIX_INFO<MATRIX_MXN<T> >{typedef VECTOR_ND<T> LEFT_VECTOR;typedef VECTOR_ND<T> RIGHT_VECTOR;typedef MATRIX_MXN<T> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
LEGACYMESH	IoData.h	/^  enum RiemannNormal {REAL = 0, MESH = 1, LEGACYMESH = 2 } riemannNormal;$/;"	e	enum:MultiFluidData::RiemannNormal
LES	IoData.h	/^  enum Type {NONE = 0, EDDY_VISCOSITY = 1, LES = 2} type;$/;"	e	enum:TurbulenceClosureData::Type
LESModel	Manual/Aerof3d.html	/^<a name="LESModel"><\/a>$/;"	a
LESModelData	IoData.h	/^struct LESModelData {$/;"	s
LESModelData	IoDataCore.C	/^LESModelData::LESModelData()$/;"	f	class:LESModelData
LEVELSET_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    LEVELSET_UTILITIES() {};$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
LEVELSET_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^class LEVELSET_UTILITIES:public NONCOPYABLE$/;"	c	namespace:PhysBAM
LEVENBERG_MARQUARDT_SVD	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	e	enum:NonlinearRomOnlineData::LSSolver
LEXICOGRAPHIC_COMPARE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^struct LEXICOGRAPHIC_COMPARE$/;"	s	namespace:PhysBAM
LIMITERALEX1	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	e	enum:EmbeddedFramework::InterfaceLimiter
LIMITERALEX1	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	e	enum:MultiFluidData::InterfaceLimiter
LIMITERNONE	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	e	enum:EmbeddedFramework::InterfaceLimiter
LIMITERNONE	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	e	enum:MultiFluidData::InterfaceLimiter
LINEAR	EmbeddedTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;  $/;"	e	enum:EmbeddedTsDesc::ImplosionSetupType
LINEAR	IoData.h	/^  enum InterfaceTracking {LINEAR = 0, GRADIENT = 1, HERMITE = 2}; $/;"	e	enum:MultiFluidData::InterfaceTracking
LINEAR	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruct;$/;"	e	enum:EmbeddedFramework::Reconstruction
LINEAR	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruction;$/;"	e	enum:SchemeData::Reconstruction
LINEAR	IoData.h	/^  enum Type{LINEAR=0, SMOOTHSTEP=1} type;$/;"	e	enum:ImplosionSetup::Type
LINEAR	MultiPhysicsTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;$/;"	e	enum:MultiPhysicsTsDesc::ImplosionSetupType
LINEARIZED	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
LINEAR_EXTRAPOLATION	IoData.h	/^              LINEAR_EXTRAPOLATION = 2,$/;"	e	enum:BoundarySchemeData::Type
LINEAR_FE	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	e	enum:DefoMeshMotionData::Element
LINEAR_INTERPOLATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^class LINEAR_INTERPOLATION$/;"	c	namespace:PhysBAM
LINELEN	arpack++/include/arch.h	59;"	d
LINE_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    LINE_2D()$/;"	f	class:PhysBAM::LINE_2D
LINE_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    LINE_2D(const TV& normal_input,const TV& x1_input)$/;"	f	class:PhysBAM::LINE_2D
LINE_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^class LINE_2D$/;"	c	namespace:PhysBAM
LINE_SEARCH_BACKTRACKING	IoData.h	/^  enum LineSearch {LINE_SEARCH_FALSE = 0, LINE_SEARCH_BACKTRACKING = 1, LINE_SEARCH_WOLF = 2} lineSearch;$/;"	e	enum:NonlinearRomOnlineData::LineSearch
LINE_SEARCH_FALSE	IoData.h	/^  enum LineSearch {LINE_SEARCH_FALSE = 0, LINE_SEARCH_BACKTRACKING = 1, LINE_SEARCH_WOLF = 2} lineSearch;$/;"	e	enum:NonlinearRomOnlineData::LineSearch
LINE_SEARCH_WOLF	IoData.h	/^  enum LineSearch {LINE_SEARCH_FALSE = 0, LINE_SEARCH_BACKTRACKING = 1, LINE_SEARCH_WOLF = 2} lineSearch;$/;"	e	enum:NonlinearRomOnlineData::LineSearch
LINPACKdgedi	DenseMatrixOps.h	/^int LINPACKdgedi(Scalar *a, int *ipvt, Scalar *work)$/;"	f
LINPACKdgefa	DenseMatrixOps.h	/^int LINPACKdgefa(Scalar *a, int *ipvt)$/;"	f
LIQUID	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	e	enum:FluidModelData::Fluid
LOCAL	IoData.h	/^  enum TypeTimeStep {AUTO = 0, LOCAL = 1, GLOBAL = 2} typeTimeStep;$/;"	e	enum:TsData::TypeTimeStep
LOCALFLIGHTDISPLACEMENT	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	e	enum:PostFcn::VectorType
LOCATION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum LOCATION {START_POINT,INTERIOR_POINT,LOCATION_UNKNOWN};$/;"	g	class:PhysBAM::RAY
LOCATION_UNKNOWN	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum LOCATION {START_POINT,INTERIOR_POINT,LOCATION_UNKNOWN};$/;"	e	enum:PhysBAM::RAY::LOCATION
LOG_CERR_BUFFER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^class LOG_CERR_BUFFER:public std::stringbuf$/;"	c	namespace:PhysBAM::LOG_REAL	file:
LOG_CLASS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^LOG_CLASS::LOG_CLASS(const bool suppress_cout_input,const bool suppress_cerr_input,const bool suppress_timing_input,const int verbosity_level_input,const bool cache_initial_output)$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
LOG_CLASS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^class LOG_CLASS$/;"	c	namespace:PhysBAM::LOG_REAL
LOG_COUT_BUFFER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^class LOG_COUT_BUFFER:public std::stringbuf$/;"	c	namespace:PhysBAM::LOG_REAL	file:
LOG_ENTRY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    LOG_ENTRY(LOG_ENTRY* parent_input,const int depth_input,const int timer_id_input,const std::string& name_input,int& verbosity_level_input)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
LOG_ENTRY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^class LOG_ENTRY:public NONCOPYABLE$/;"	c	namespace:PhysBAM::LOG_REAL
LOG_NULL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^namespace LOG_NULL{$/;"	n	namespace:PhysBAM	file:
LOG_NULL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^namespace LOG_NULL{$/;"	n	namespace:PhysBAM
LOG_REAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^namespace LOG_REAL{$/;"	n	namespace:PhysBAM	file:
LOG_REAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^namespace LOG_REAL{$/;"	n	namespace:PhysBAM
LOG_REAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	18;"	d
LOG_REAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^namespace LOG_REAL{$/;"	n	namespace:PhysBAM
LOG_REAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^namespace LOG_REAL{$/;"	n	namespace:PhysBAM
LOG_SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    LOG_SCOPE(LOG_ENTRY* parent_input,int depth_input,int timer_id_input,const std::string& scope_identifier_input,const std::string& name_input,int& verbosity_level_input)$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
LOG_SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^class LOG_SCOPE:public LOG_ENTRY$/;"	c	namespace:PhysBAM::LOG_REAL
LOOSE	DistLeastSquareSolver.h	/^  enum BufferResizePolicy { TIGHT, LOOSE };$/;"	e	enum:DistLeastSquareSolver::BufferResizePolicy
LOOSE_BOUNDS	IoData.h	/^  enum KmeansBoundType {TIGHT_BOUNDS = 0, LOOSE_BOUNDS = 1} kmeansBoundType;$/;"	e	enum:ClusteringData::KmeansBoundType
LOWER_MASK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    static const unsigned int a=0x9908b0df,UPPER_MASK=0x80000000,LOWER_MASK=0x7fffffff;$/;"	m	class:PhysBAM::MT19937
LS	LevelSetTsDesc.h	/^  LevelSet<dimLS> *LS;$/;"	m	class:LevelSetTsDesc
LS	MultiPhysicsTsDesc.h	/^  LevelSet<dimLS> *LS;$/;"	m	class:MultiPhysicsTsDesc
LSS	MatVecProd.h	/^    DistLevelSetStructure* LSS;$/;"	m	struct:MatVecProd::_fsi
LSS	MatVecProd.h	/^    DistLevelSetStructure* LSS;$/;"	m	struct:MatVecProdMultiPhase::_fsi
LSSolver	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	g	struct:NonlinearRomOnlineData
LSUB	arpack++/include/arlspdef.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;$/;"	e	enum:__anon32
LUSUP	arpack++/include/arlspdef.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;$/;"	e	enum:__anon32
LU_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void LU_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse) const$/;"	f	class:PhysBAM::MATRIX_BASE
LU_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR LU_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
LU_space_t	arpack++/include/arlspdef.h	/^typedef enum {SYSTEM, USER}            LU_space_t;$/;"	t	typeref:enum:__anon34
L_FST_SUPC	arpack++/include/arlsupm.h	139;"	d
L_NZ_START	arpack++/include/arlsupm.h	138;"	d
L_SUB	arpack++/include/arlsupm.h	137;"	d
L_SUB_START	arpack++/include/arlsupm.h	136;"	d
Label_Connected_Component_With_ID	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Label_Connected_Component_With_ID(ARRAY<int>& label,const int triangle,const int id) const$/;"	f	class:TRIANGLE_MESH
Largest_Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Largest_Column() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Largest_Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Largest_Column() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Largest_Column_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Largest_Column_Normalized() const \/\/ 5 mults, 2 adds, 1 div, 1 sqrt$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Largest_Column_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Largest_Column_Normalized() const \/\/ 9 mults, 6 adds, 1 div, 1 sqrt$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Largest_Normalized_Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> Largest_Normalized_Column() const$/;"	f	class:PhysBAM::MATRIX
Last	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T& Last()$/;"	f	class:PhysBAM::ARRAY_BASE
Last	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    const T& Last() const$/;"	f	class:PhysBAM::ARRAY_BASE
Last	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Last() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Last	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Last() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Last_Eigenvector_From_Ordered_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Last_Eigenvector_From_Ordered_Eigenvalues(const DIAGONAL_MATRIX<T,2>& eigenvalues) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Last_Eigenvector_From_Ordered_Eigenvalues	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Last_Eigenvector_From_Ordered_Eigenvalues(const DIAGONAL_MATRIX<T,3>& eigenvalues,const T tolerance=1e-5) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
LatestCracking	FSI/CrackingSurface.h	/^  LatestCracking() {\/*nothing*\/}$/;"	f	struct:LatestCracking
LatestCracking	FSI/CrackingSurface.h	/^struct LatestCracking {$/;"	s
LawType	IoData.h	/^  enum LawType {VELOCITYPOINTS = 0, CONSTANTACCELERATION = 1} lawtype;$/;"	g	struct:RigidMeshMotionData
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Lazy_Inside(const TV& location) const$/;"	f	class:PhysBAM::LINE_2D
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    bool Lazy_Inside(const TV &location) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Lazy_Inside(const TV& location) const$/;"	f	class:PhysBAM::PLANE
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Inside(const TV& location,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Lazy_Inside(const T& location) const$/;"	f	class:PhysBAM::INTERVAL
Lazy_Inside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Lazy_Inside(const TV& location) const$/;"	f	class:PhysBAM::RANGE
Lazy_Inside_And_Value	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Inside_And_Value(const TV& location,T& phi_value,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Inside_Extended_Levelset	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Inside_Extended_Levelset(const TV& unclamped_X,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Inside_Extended_Levelset_And_Value	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Inside_Extended_Levelset_And_Value(const TV& unclamped_X,T& phi_value,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Inside_Half_Open	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Lazy_Inside_Half_Open(const T& location) const$/;"	f	class:PhysBAM::INTERVAL
Lazy_Inside_Half_Open	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Lazy_Inside_Half_Open(const TV& location) const$/;"	f	class:PhysBAM::RANGE
Lazy_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Lazy_Intersection(const INTERVAL& interval) const$/;"	f	class:PhysBAM::INTERVAL
Lazy_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Lazy_Intersection(const RANGE<TV>& box) const$/;"	f	class:PhysBAM::RANGE
Lazy_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Lazy_Intersects(RAY<VECTOR<T,3> >& ray,const RANGE<VECTOR<T,3> >& box,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Lazy_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^template<class T> bool Lazy_Intersects(RAY<VECTOR<T,3> >& ray,const PLANE<T>& plane)$/;"	f	namespace:PhysBAM::INTERSECTION
Lazy_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.cpp	/^template<class T> bool Lazy_Intersects(RAY<VECTOR<T,3> >& ray,const TRIANGLE_3D<T>& triangle, const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Lazy_Outside(const TV& location) const$/;"	f	class:PhysBAM::LINE_2D
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Lazy_Outside(const TV& location) const$/;"	f	class:PhysBAM::PLANE
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Outside(const TV& location,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^template<class T> bool Lazy_Outside(RAY<VECTOR<T,3> >& ray,const RANGE<VECTOR<T,3> >& box)$/;"	f	namespace:PhysBAM::INTERSECTION
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Lazy_Outside(const T& location) const$/;"	f	class:PhysBAM::INTERVAL
Lazy_Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Lazy_Outside(const TV& location) const$/;"	f	class:PhysBAM::RANGE
Lazy_Outside_Dimension_Case	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	77;"	d	file:
Lazy_Outside_Extended_Levelset	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Outside_Extended_Levelset(const TV& unclamped_X,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Outside_Extended_Levelset_And_Value	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> bool IMPLICIT_OBJECT<TV>::Lazy_Outside_Extended_Levelset_And_Value(const TV& unclamped_X,T& phi_value,const T contour_value) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Lazy_Planar_Point_Inside_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Lazy_Planar_Point_Inside_Triangle(const VECTOR<T,3>& point) const$/;"	f	class:TRIANGLE_3D
Leaf	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    bool Leaf(const int box) const$/;"	f	class:PhysBAM::BOX_HIERARCHY
Leaf_Node	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Leaf_Node(const TV& point) const$/;"	f	class:KD_TREE
Leaf_Node_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Leaf_Node_Helper(const TV& point,KD_TREE_NODE<T>* node) const$/;"	f	class:KD_TREE
LeastSquareSolver	AlternatingLeastSquare/als_io.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	g	struct:EmbeddedAlternatingLeastSquareData
LeastSquareSolver	ImplicitEmbeddedRomTsDesc.h	/^    ParallelRom<dim> *LeastSquareSolver;$/;"	m	class:ImplicitEmbeddedRomTsDesc
LeastSquareSolver	IoData.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	g	struct:EmbeddedAlternatingLeastSquareData
Left_Givens_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    void Left_Givens_Rotation(const int i,const int j,const T c,const T s)$/;"	f	class:PhysBAM::MATRIX_MXN
Left_Procrustes_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Left_Procrustes_Rotation(const MATRIX& A,const MATRIX& B)$/;"	f	class:PhysBAM::MATRIX
Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    T Length() const$/;"	f	class:PhysBAM::SEGMENT_2D
Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    T Length() const$/;"	f	class:PhysBAM::SEGMENT_3D
LevelSet	LevelSet.C	/^LevelSet<dimLS>::LevelSet(IoData &iod, Domain *dom):$/;"	f	class:LevelSet
LevelSet	LevelSet.h	/^class LevelSet {$/;"	c
LevelSet	Manual/Aerof3d.html	/^<a name="LevelSet"><\/a>$/;"	a
LevelSetMethod	IoData.h	/^  enum LevelSetMethod { CONSERVATIVE = 0, HJWENO = 1, SCALAR=2, PRIMITIVE = 3,$/;"	g	struct:MultiFluidData
LevelSetResult	LevelSet/LevelSetStructure.h	/^   LevelSetResult(double gpx, double gpy, double gpz,$/;"	f	struct:LevelSetResult
LevelSetResult	LevelSet/LevelSetStructure.h	/^  LevelSetResult() {$/;"	f	struct:LevelSetResult
LevelSetResult	LevelSet/LevelSetStructure.h	/^struct LevelSetResult {$/;"	s
LevelSetSolver	Solvers/Solvers.h	/^LevelSetSolver {$/;"	c
LevelSetSource	OneDimensionalSolver.C	/^  LevelSetSource(VarFcn* _vf,SVec<double,5>& _lu) :  vf(_vf), locU(_lu) { }$/;"	f	class:LevelSetSource
LevelSetSource	OneDimensionalSolver.C	/^class LevelSetSource {$/;"	c	file:
LevelSetStructure	LevelSet/LevelSetStructure.h	/^LevelSetStructure(Vec<int>& status,$/;"	f	class:LevelSetStructure
LevelSetStructure	LevelSet/LevelSetStructure.h	/^class LevelSetStructure {$/;"	c
LevelSetTsDesc	LevelSetTsDesc.C	/^LevelSetTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:LevelSetTsDesc
LevelSetTsDesc	LevelSetTsDesc.h	/^class LevelSetTsDesc : public TsDesc<dim> {$/;"	c
Limited_Shifted_Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Limited_Shifted_Get(ARRAY_BASE& new_copy,const ARRAY_BASE& old_copy,const VECTOR<int,1>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Limited_Shifted_Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Limited_Shifted_Get(ARRAY_BASE& new_copy,const ARRAY_BASE& old_copy,const VECTOR<int,2>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Limited_Shifted_Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Limited_Shifted_Get(ARRAY_BASE& new_copy,const ARRAY_BASE& old_copy,const VECTOR<int,3>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Limiter	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	g	struct:SchemeData
LineJacobi	MultiGridSmoothingMatrix.h	/^  enum SmoothingMode { BlockJacobi, LineJacobi, RAS };$/;"	e	enum:MultiGridSmoothingMatrix::SmoothingMode
LinePlot	IoData.h	/^struct LinePlot {$/;"	s
LinePlot	IoDataCore.C	/^LinePlot::LinePlot() {$/;"	f	class:LinePlot
LineSearch	IoData.h	/^  enum LineSearch {LINE_SEARCH_FALSE = 0, LINE_SEARCH_BACKTRACKING = 1, LINE_SEARCH_WOLF = 2} lineSearch;$/;"	g	struct:NonlinearRomOnlineData
LineSearch	Manual/Aerof3d.html	/^<a name="LineSearch"><\/a>$/;"	a
LineSearchData	IoData.h	/^struct LineSearchData {$/;"	s
LineSearchData	IoDataCore.C	/^LineSearchData::LineSearchData()$/;"	f	class:LineSearchData
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T x_left,const T x_right,const T2& u_left,const T2& u_right,const T x)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T x_left,const T2& u_left,const T2& u_slope,const T x)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T x_left,const T2& u_left,const T2& u_slope,const VECTOR<T,1> X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T2 nodes[2],const VECTOR<T,1>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T2 nodes[4],const VECTOR<T,2>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T2 nodes[8],const VECTOR<T,3>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T2& u_left,const T2& u_right,const T x)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear(const T2& u_left,const T2& u_right,const VECTOR<T,1>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
LinearSolver	Manual/Aerof3d.html	/^<a name="LinearSolver"><\/a>$/;"	a
Linear_Combination	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static T Linear_Combination(const T_ARRAY1& w,const T_ARRAY2& a)$/;"	f	class:PhysBAM::ARRAY_BASE
Linear_Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear_Normalized(const T2& u_left,const T2& u_slope,const T x)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linear_Point_Inside_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Linear_Point_Inside_Segment(const TV& X,const T thickness_over_2) const$/;"	f	class:SEGMENT_2D
Linear_Predivided	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Linear_Predivided(const T x_left,const T one_over_x_right_minus_x_left,const T2& u_left,const T2& u_right,const T x)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Linearized	Manual/Aerof3d.html	/^<a name="Linearized"><\/a>$/;"	a
LinearizedData	IoData.h	/^struct LinearizedData {$/;"	s
LinearizedData	IoDataCore.C	/^LinearizedData::LinearizedData()$/;"	f	class:LinearizedData
LiquidModel	Manual/Aerof3d.html	/^<a name="LiquidModel"><\/a>$/;"	a
LiquidModelData	IoData.h	/^struct LiquidModelData {$/;"	s
LiquidModelData	IoDataCore.C	/^LiquidModelData::LiquidModelData()$/;"	f	class:LiquidModelData
List1	parser/Parser.y	/^List1: '{' Symbol '}'$/;"	l
List2	parser/Parser.y	/^List2: '{' Symbol ',' Symbol '}'$/;"	l
List3	parser/Parser.y	/^List3: '{' Symbol ',' Symbol ',' Symbol '}'$/;"	l
List4	parser/Parser.y	/^List4: '{' Symbol ',' Symbol ',' Symbol ',' Symbol '}'$/;"	l
List5	parser/Parser.y	/^List5: '{' Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol '}'$/;"	l
List6	parser/Parser.y	/^List6: '{' Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol '}'$/;"	l
List7	parser/Parser.y	/^List7: '{'  Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol ',' Symbol '}'$/;"	l
Lm	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Lm	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Lm	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:FluidGnatShapeOptimizationHandler
Lm	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:FluidMetricShapeOptimizationHandler
Lm	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:FluidRomShapeOptimizationHandler
Lm	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lm;$/;"	m	class:FluidShapeOptimizationHandler
LocalLevelSet	PhysBAM_Interface/LOCAL_LEVELSET.h	/^class LocalLevelSet {$/;"	c
LocalRiemann	LocalRiemann.h	/^  LocalRiemann()           { vf_ = 0; fluid1 = 0; fluid2 = 1;}$/;"	f	class:LocalRiemann
LocalRiemann	LocalRiemann.h	/^  LocalRiemann(VarFcn *vf, int tag1, int tag2) { vf_ = vf; fluid1 = tag1; fluid2 = tag2;}$/;"	f	class:LocalRiemann
LocalRiemann	LocalRiemann.h	/^class LocalRiemann {$/;"	c
LocalRiemannFluidStructure	LocalRiemannDesc.h	/^  LocalRiemannFluidStructure() : LocalRiemann(), stabil_alpha(0.0), viscous_switch(0.0), prec(false) {fluid1 = fluid2 = 0;}$/;"	f	class:LocalRiemannFluidStructure
LocalRiemannFluidStructure	LocalRiemannDesc.h	/^  LocalRiemannFluidStructure(VarFcn *vf) : LocalRiemann(vf,0,0), stabil_alpha(0.0), viscous_switch(0.0), prec(false) {fluid1 = fluid2 = 0;}$/;"	f	class:LocalRiemannFluidStructure
LocalRiemannFluidStructure	LocalRiemannDesc.h	/^class LocalRiemannFluidStructure : public LocalRiemann {$/;"	c
LocalRiemannGfmp	LocalRiemann.h	/^  LocalRiemannGfmp() : LocalRiemann() {}$/;"	f	class:LocalRiemannGfmp
LocalRiemannGfmp	LocalRiemann.h	/^  LocalRiemannGfmp(VarFcn *vf, int tag1, int tag2) : LocalRiemann(vf,tag1,tag2) {}$/;"	f	class:LocalRiemannGfmp
LocalRiemannGfmp	LocalRiemann.h	/^class LocalRiemannGfmp : public LocalRiemann {$/;"	c
LocalRiemannGfmpGasGas	LocalRiemannDesc.h	/^  LocalRiemannGfmpGasGas(VarFcn *vf, int tag1, int tag2) : LocalRiemannGfmp(vf,tag1,tag2) {}$/;"	f	class:LocalRiemannGfmpGasGas
LocalRiemannGfmpGasGas	LocalRiemannDesc.h	/^class LocalRiemannGfmpGasGas : public LocalRiemannGfmp {$/;"	c
LocalRiemannGfmpGasJWL	LocalRiemannDesc.h	/^  LocalRiemannGfmpGasJWL(VarFcn *vf, int tag1, int tag2) : LocalRiemannGfmp(vf,tag1,tag2) {}$/;"	f	class:LocalRiemannGfmpGasJWL
LocalRiemannGfmpGasJWL	LocalRiemannDesc.h	/^class LocalRiemannGfmpGasJWL : public LocalRiemannGfmp {$/;"	c
LocalRiemannGfmpJWLJWL	LocalRiemannDesc.h	/^  LocalRiemannGfmpJWLJWL(VarFcn *vf, int tag1, int tag2) : LocalRiemannGfmp(vf,tag1,tag2) {}$/;"	f	class:LocalRiemannGfmpJWLJWL
LocalRiemannGfmpJWLJWL	LocalRiemannDesc.h	/^class LocalRiemannGfmpJWLJWL : public LocalRiemannGfmp {$/;"	c
LocalRiemannGfmpTaitTait	LocalRiemannDesc.h	/^  LocalRiemannGfmpTaitTait(VarFcn *vf, int tag1, int tag2) : LocalRiemannGfmp(vf,tag1,tag2) {}$/;"	f	class:LocalRiemannGfmpTaitTait
LocalRiemannGfmpTaitTait	LocalRiemannDesc.h	/^class LocalRiemannGfmpTaitTait : public LocalRiemannGfmp {$/;"	c
LocalRiemannGfmpar	LocalRiemann.h	/^    LocalRiemannGfmpar(VarFcn *vf, int tag1, int tag2, MultiFluidData::TypePhaseChange phaseChangeType,$/;"	f	class:LocalRiemannGfmpar
LocalRiemannGfmpar	LocalRiemann.h	/^  LocalRiemannGfmpar() : LocalRiemann() {}$/;"	f	class:LocalRiemannGfmpar
LocalRiemannGfmpar	LocalRiemann.h	/^class LocalRiemannGfmpar : public LocalRiemann {$/;"	c
LocalRiemannGfmparGasGas	LocalRiemannDesc.h	/^  LocalRiemannGfmparGasGas(VarFcn *vf, int tag1, int tag2, MultiFluidData::TypePhaseChange typePhaseChange,$/;"	f	class:LocalRiemannGfmparGasGas
LocalRiemannGfmparGasGas	LocalRiemannDesc.h	/^class LocalRiemannGfmparGasGas : public LocalRiemannGfmpar {$/;"	c
LocalRiemannGfmparGasJWL	LocalRiemannDesc.h	/^  LocalRiemannGfmparGasJWL(VarFcn *vf, int tag1, int tag2, SparseGridCluster *sgCluster, $/;"	f	class:LocalRiemannGfmparGasJWL
LocalRiemannGfmparGasJWL	LocalRiemannDesc.h	/^class LocalRiemannGfmparGasJWL : public LocalRiemannGfmpar {$/;"	c
LocalRiemannGfmparGasTait	LocalRiemannDesc.h	/^  LocalRiemannGfmparGasTait(VarFcn *vf, int tag1, int tag2, MultiFluidData::TypePhaseChange typePhaseChange) : LocalRiemannGfmpar(vf,tag1,tag2,typePhaseChange) {}$/;"	f	class:LocalRiemannGfmparGasTait
LocalRiemannGfmparGasTait	LocalRiemannDesc.h	/^class LocalRiemannGfmparGasTait: public LocalRiemannGfmpar {$/;"	c
LocalRiemannGfmparJWLJWL	LocalRiemannDesc.h	/^  LocalRiemannGfmparJWLJWL(VarFcn *vf, int tag1, int tag2, MultiFluidData::TypePhaseChange typePhaseChange) : LocalRiemannGfmpar(vf,tag1,tag2,typePhaseChange) {}$/;"	f	class:LocalRiemannGfmparJWLJWL
LocalRiemannGfmparJWLJWL	LocalRiemannDesc.h	/^class LocalRiemannGfmparJWLJWL : public LocalRiemannGfmpar {$/;"	c
LocalRiemannGfmparTaitJWL	LocalRiemannDesc.h	/^  LocalRiemannGfmparTaitJWL(VarFcn *vf, int tag1, int tag2, SparseGridCluster *sgCluster, $/;"	f	class:LocalRiemannGfmparTaitJWL
LocalRiemannGfmparTaitJWL	LocalRiemannDesc.h	/^class LocalRiemannGfmparTaitJWL : public LocalRiemannGfmpar {$/;"	c
LocalRiemannGfmparTaitTait	LocalRiemannDesc.h	/^  LocalRiemannGfmparTaitTait(VarFcn *vf, int tag1, int tag2, MultiFluidData::TypePhaseChange typePhaseChange,$/;"	f	class:LocalRiemannGfmparTaitTait
LocalRiemannGfmparTaitTait	LocalRiemannDesc.h	/^class LocalRiemannGfmparTaitTait: public LocalRiemannGfmpar {$/;"	c
LocalRiemannLowMach	LocalRiemann.h	/^  LocalRiemannLowMach()           { vf_ = 0; fluid1 = 0; fluid2 = 1;}$/;"	f	class:LocalRiemannLowMach
LocalRiemannLowMach	LocalRiemann.h	/^ LocalRiemannLowMach(VarFcn *vf, int tag1, int tag2, double beta, int dim) : LocalRiemann(vf, tag1, tag2), beta(beta), dim(dim)$/;"	f	class:LocalRiemannLowMach
LocalRiemannLowMach	LocalRiemann.h	/^class LocalRiemannLowMach : public LocalRiemann {$/;"	c
Locate_Nearest_Neighbors	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Locate_Nearest_Neighbors(const TV& location,const T max_distance_squared,ARRAY<int>& points_found,ARRAY<T>& distance_squared_of_points_found,$/;"	f	class:KD_TREE
Locate_Nearest_Neighbors_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Locate_Nearest_Neighbors_Helper(const KD_TREE_NODE<T>* cell,const TV& location,T& max_distance_squared,int& number_of_points_found,ARRAY<int>& points_found,$/;"	f	class:KD_TREE
LogarithmicMapping	SparseGrid.h	/^    LogarithmicMapping(double base){ base_ = base; }$/;"	f	class:SparseGrid::LogarithmicMapping
LogarithmicMapping	SparseGrid.h	/^  class LogarithmicMapping{$/;"	c	class:SparseGrid
Logical	arpack++/include/arlutil.h	/^typedef unsigned char Logical;$/;"	t
LowMachPrec	LowMachPrec.h	/^  LowMachPrec() { $/;"	f	class:LowMachPrec
LowMachPrec	LowMachPrec.h	/^  LowMachPrec(IoData &iod){$/;"	f	class:LowMachPrec
LowMachPrec	LowMachPrec.h	/^class LowMachPrec {$/;"	c
Lower_Triangular_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR Lower_Triangular_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Lp	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Lp	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Lp	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:FluidGnatShapeOptimizationHandler
Lp	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:FluidMetricShapeOptimizationHandler
Lp	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:FluidRomShapeOptimizationHandler
Lp	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Lp;$/;"	m	class:FluidShapeOptimizationHandler
Lp_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Lp_Norm(const T& p) const$/;"	f	class:PhysBAM::VECTOR
Lp_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Lp_Norm(const T& p) const$/;"	f	class:PhysBAM::VECTOR
Lp_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Lp_Norm(const T& p) const$/;"	f	class:PhysBAM::VECTOR_BASE
LsSolver	IoData.h	/^  enum LsSolver {QR=0, NORMAL_EQUATIONS=1} lsSolver;$/;"	g	struct:SensitivityAnalysis
M	AlternatingLeastSquare/als_lapack.h	/^    unsigned char *M;$/;"	m	class:AlternatingLeastSquare
M	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *M;$/;"	m	class:DistDynamicVMSTerm
M	EdgeGalerkin.h	/^  DistSVec<double,9> M;$/;"	m	class:EdgeGalerkin
MACH	IoData.h	/^  enum Tag {MACH = 0, TIME = 1, VELOCITY = 2} tag;$/;"	e	enum:RigidMeshMotionData::Tag
MACH	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	e	enum:PostFcn::ScalarType
MACHAVG	PostFcn.h	/^  enum ScalarAvgType {DENSITYAVG = 0, MACHAVG = 1, PRESSUREAVG = 2, TEMPERATUREAVG = 3,$/;"	e	enum:PostFcn::ScalarAvgType
MASSFLOW	IoData.h	/^  enum Type {DIRECTSTATE = 1, MASSFLOW = 2, POROUSWALL = 3} type;$/;"	e	enum:BoundaryData::Type
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(m),INITIAL_SIZE nn=INITIAL_SIZE(n))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    explicit MATRIX(const VECTOR<T,size>& column1)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^class MATRIX:public MATRIX_BASE<T,MATRIX<T,m_input,n_input> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(),INITIAL_SIZE nn=INITIAL_SIZE())$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    explicit MATRIX(const MATRIX<T2,0>& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^class MATRIX<T,0>:public MATRIX_BASE<T,MATRIX<T,0> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(),INITIAL_SIZE nn=INITIAL_SIZE())$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    explicit MATRIX(const MATRIX<T2,0,1>& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^class MATRIX<T,0,1>:public MATRIX_BASE<T,MATRIX<T,0,1> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(1),INITIAL_SIZE nn=INITIAL_SIZE(1))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    explicit MATRIX(const MATRIX<T2,1>& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    explicit MATRIX(const T x11)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    explicit MATRIX(const VECTOR<T,1>& v)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^class MATRIX<T,1>:public MATRIX_BASE<T,MATRIX<T,1> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(1),INITIAL_SIZE nn=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    explicit MATRIX(const MATRIX<T2,1,2>& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    explicit MATRIX(const T x11,const T x12)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    explicit MATRIX(const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^class MATRIX<T,1,2>:public MATRIX_BASE<T,MATRIX<T,1,2> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const MATRIX<T2,2>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const SYMMETRIC_MATRIX<T,2>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const T x11,const T x21,const T x12,const T x22)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const UPPER_TRIANGULAR_MATRIX<T,2>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX(const VECTOR<T,2> & column1,const VECTOR<T,2> & column2)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(2),INITIAL_SIZE nn=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^class MATRIX<T,2>:public MATRIX_BASE<T,MATRIX<T,2> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX()$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX(INITIAL_SIZE m,INITIAL_SIZE n)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX(const MATRIX<T2,2,3>& matrix)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX(const T x11,const T x21,const T x12,const T x22,const T x13,const T x23)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    MATRIX(const VECTOR<T,2>& v1,const VECTOR<T,2>& v2,const VECTOR<T,2>& v3)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^class MATRIX<T_input,2,3>:public TRANSPOSE_MATRIX<MATRIX<T_input,3,2> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX()$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX(const MATRIX<T2,3,2>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX(const T x11,const T x21,const T x31,const T x12,const T x22,const T x32)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX(const VECTOR<T,3>& column1,const VECTOR<T,3>& column2)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    explicit MATRIX(INITIAL_SIZE mm,INITIAL_SIZE nn)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^class MATRIX<T,3,2>:public MATRIX_BASE<T,MATRIX<T,3,2> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^MATRIX(const MATRIX_MXN<T>& matrix_input)$/;"	f	class:MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const DIAGONAL_MATRIX<T,3>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const MATRIX<T2,3>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const SYMMETRIC_MATRIX<T,3>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const T x11,const T x21,const T x31,const T x12,const T x22,const T x32,const T x13,const T x23,const T x33)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const UPPER_TRIANGULAR_MATRIX<T,3>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX(const VECTOR<T,3>& column1,const VECTOR<T,3>& column2,const VECTOR<T,3>& column3)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    explicit MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(3),INITIAL_SIZE nn=INITIAL_SIZE(3))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^class MATRIX<T,3>:public MATRIX_BASE<T,MATRIX<T,3> >$/;"	c	namespace:PhysBAM
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX(const MATRIX<T2,4>& matrix_input)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX(const T x11,const T x21,const T x31,const T x41,const T x12,const T x22,const T x32,const T x42,const T x13,const T x23,const T x33,const T x43,const T x14,const T x24,const T x34,$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    explicit MATRIX(INITIAL_SIZE m=INITIAL_SIZE(4),INITIAL_SIZE n=INITIAL_SIZE(4))$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    explicit MATRIX(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^class MATRIX<T,4>:public MATRIX_BASE<T,MATRIX<T,4> >$/;"	c	namespace:PhysBAM
MATRIX_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    MATRIX_BASE()$/;"	f	class:PhysBAM::MATRIX_BASE
MATRIX_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    MATRIX_BASE(const MATRIX_BASE&)$/;"	f	class:PhysBAM::MATRIX_BASE
MATRIX_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^class MATRIX_BASE$/;"	c	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,class T_MATRIX> struct MATRIX_INFO<MATRIX_BASE<T,T_MATRIX> >{typedef typename MATRIX_INFO<T_MATRIX>::LEFT_VECTOR LEFT_VECTOR;$/;"	s	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<DIAGONAL_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef DIAGONAL_MATRIX<T,d> TRANSPOSE;};$/;"	s	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<SYMMETRIC_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef SYMMETRIC_MATRIX<T,d> TRANSPOSE;};$/;"	s	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<UPPER_TRIANGULAR_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;};$/;"	s	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct MATRIX_INFO<MATRIX<T,m,n> >{typedef VECTOR<T,m> LEFT_VECTOR;typedef VECTOR<T,n> RIGHT_VECTOR;typedef MATRIX<T,n,m> TRANSPOSE;};$/;"	s	namespace:PhysBAM
MATRIX_INFO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T> struct MATRIX_INFO<MATRIX_MXN<T> >{typedef VECTOR_ND<T> LEFT_VECTOR;typedef VECTOR_ND<T> RIGHT_VECTOR;typedef MATRIX_MXN<T> TRANSPOSE;};$/;"	s	namespace:PhysBAM
MATRIX_IS_SINGULAR	arpack++/include/arerror.h	/^    MATRIX_IS_SINGULAR  = -501,$/;"	e	enum:ArpackError::ErrorCode
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN()$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN(const INITIAL_SIZE m_input,const INITIAL_SIZE n_input)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN(const MATRIX_MXN<T>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN(const int m_input,const int n_input)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const DIAGONAL_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const INITIAL_SIZE n_input)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const MATRIX_MXN<T2>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const SYMMETRIC_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const UPPER_TRIANGULAR_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    explicit MATRIX_MXN(const int n_input)$/;"	f	class:PhysBAM::MATRIX_MXN
MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^class MATRIX_MXN:public MATRIX_BASE<T,MATRIX_MXN<T> >$/;"	c	namespace:PhysBAM
MATRIX_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^struct MATRIX_POLICY<VECTOR<T,0> >$/;"	s	namespace:PhysBAM
MATRIX_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^struct MATRIX_POLICY<VECTOR<T,1> >$/;"	s	namespace:PhysBAM
MATRIX_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^struct MATRIX_POLICY<VECTOR<T,2> >$/;"	s	namespace:PhysBAM
MATRIX_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^struct MATRIX_POLICY<VECTOR<T,3> >$/;"	s	namespace:PhysBAM
MAX	arpack++/include/arlutil.h	42;"	d
MAXIT_NON_POSITIVE	arpack++/include/arerror.h	/^    MAXIT_NON_POSITIVE  =  102,$/;"	e	enum:ArpackError::ErrorCode
MAXLINE	BinFileHandler.h	15;"	d
MAXLINE	FSI/DynamicNodalTransfer.h	17;"	d
MAXLINE	IntersectorFRG/IntersectorFRG.h	17;"	d
MAXLINE	IntersectorPhysBAM/IntersectorPhysBAM.h	17;"	d
MAXLINE	tools/loader.C	10;"	d	file:
MAXNODES	IoData.h	/^  const static int MAXNODES = 3176;$/;"	m	struct:Probes
MAX_ACTIVE_PTR	MemoryPool.h	4;"	d
MAX_ALLOCA_SIZE	ConnectivityCore.C	15;"	d	file:
MAX_CODES	DomainCore.C	29;"	d	file:
MAX_ITERATIONS	arpack++/include/arerror.h	/^    MAX_ITERATIONS      =  201,$/;"	e	enum:ArpackError::ErrorCode
MBar	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *MBar;$/;"	m	class:DistDynamicVMSTerm
MDOT	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
MEMORY_OVERFLOW	arpack++/include/arerror.h	/^    MEMORY_OVERFLOW     = -902,$/;"	e	enum:ArpackError::ErrorCode
MESH	IoData.h	/^  enum RiemannNormal {REAL = 0, MESH = 1, LEGACYMESH = 2 } riemannNormal;$/;"	e	enum:MultiFluidData::RiemannNormal
MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^    typedef POINT_SIMPLEX_MESH MESH;$/;"	t	struct:PhysBAM::MESH_POLICY
MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^    typedef SEGMENT_MESH MESH;$/;"	t	struct:PhysBAM::MESH_POLICY
MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^    typedef TETRAHEDRON_MESH MESH;$/;"	t	struct:PhysBAM::MESH_POLICY
MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^    typedef TRIANGLE_MESH MESH;$/;"	t	struct:PhysBAM::MESH_POLICY
MESH_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^struct MESH_POLICY<0>$/;"	s	namespace:PhysBAM
MESH_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^struct MESH_POLICY<1>$/;"	s	namespace:PhysBAM
MESH_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^struct MESH_POLICY<2>$/;"	s	namespace:PhysBAM
MESH_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^struct MESH_POLICY<3>$/;"	s	namespace:PhysBAM
MF_RIEMANN_NORMAL_LEGACYMESH	Edge.h	/^  enum MultifluidRiemannNormal { MF_RIEMANN_NORMAL_MESH, MF_RIEMANN_NORMAL_REAL, MF_RIEMANN_NORMAL_LEGACYMESH };$/;"	e	enum:EdgeSet::MultifluidRiemannNormal
MF_RIEMANN_NORMAL_MESH	Edge.h	/^  enum MultifluidRiemannNormal { MF_RIEMANN_NORMAL_MESH, MF_RIEMANN_NORMAL_REAL, MF_RIEMANN_NORMAL_LEGACYMESH };$/;"	e	enum:EdgeSet::MultifluidRiemannNormal
MF_RIEMANN_NORMAL_REAL	Edge.h	/^  enum MultifluidRiemannNormal { MF_RIEMANN_NORMAL_MESH, MF_RIEMANN_NORMAL_REAL, MF_RIEMANN_NORMAL_LEGACYMESH };$/;"	e	enum:EdgeSet::MultifluidRiemannNormal
MG	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
MGALGEBRAIC	IoData.h	/^  enum MGType { MGALGEBRAIC = 0, MGGEOMETRIC = 1} mg_type;$/;"	e	enum:PcData::MGType
MGGEOMETRIC	IoData.h	/^  enum MGType { MGALGEBRAIC = 0, MGGEOMETRIC = 1} mg_type;$/;"	e	enum:PcData::MGType
MGGMRES	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	e	enum:MultiGridData::MGSmoother
MGJACOBI	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2 } mg_smoother;$/;"	e	enum:PcData::MGSmoother
MGJACOBI	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	e	enum:MultiGridData::MGSmoother
MGLINEJACOBI	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2 } mg_smoother;$/;"	e	enum:PcData::MGSmoother
MGLINEJACOBI	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	e	enum:MultiGridData::MGSmoother
MGRAS	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2 } mg_smoother;$/;"	e	enum:PcData::MGSmoother
MGRAS	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	e	enum:MultiGridData::MGSmoother
MGSmoother	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2 } mg_smoother;$/;"	g	struct:PcData
MGSmoother	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	g	struct:MultiGridData
MGType	IoData.h	/^  enum MGType { MGALGEBRAIC = 0, MGGEOMETRIC = 1} mg_type;$/;"	g	struct:PcData
MID_EDGE	IoData.h	/^  enum InterfaceAlgorithm {MID_EDGE = 0, INTERSECTION = 1} interfaceAlg;$/;"	e	enum:EmbeddedFramework::InterfaceAlgorithm
MIN	arpack++/include/arlutil.h	43;"	d
MM	AlternatingLeastSquare/als_lapack.h	/^    double *MM; \/\/ double version of M, for calculating error$/;"	m	class:AlternatingLeastSquare
MODIFIED	IoData.h	/^  enum Startup {REGULAR = 0, MODIFIED = 1} startup;$/;"	e	enum:ImplicitData::Startup
MODIFIED_GHIDAGLIA	IoData.h	/^              GHIDAGLIA = 3, MODIFIED_GHIDAGLIA = 4} type;$/;"	e	enum:BoundarySchemeData::Type
MOMCROSS	f77src/hllcjac.f	/^      SUBROUTINE MOMCROSS(/;"	s
MOMDERIVATIVE	f77src/hllcjac.f	/^      SUBROUTINE MOMDERIVATIVE(/;"	s
MPIType	Communicator.h	/^  static MPI_Datatype MPIType;$/;"	m	class:CommTrace
MPIType	CommunicatorMPI.C	/^MPI_Datatype CommTrace<char>::MPIType = MPI_CHAR;$/;"	m	class:CommTrace	file:
MPIType	CommunicatorMPI.C	/^MPI_Datatype CommTrace<double>::MPIType = MPI_DOUBLE;$/;"	m	class:CommTrace	file:
MPIType	CommunicatorMPI.C	/^MPI_Datatype CommTrace<float>::MPIType = MPI_FLOAT;$/;"	m	class:CommTrace	file:
MPIType	CommunicatorMPI.C	/^MPI_Datatype CommTrace<int>::MPIType = MPI_INTEGER;$/;"	m	class:CommTrace	file:
MPIType	CommunicatorMPI.C	/^MPI_Datatype CommTrace<std::complex<double> >::MPIType = MPI_DOUBLE;$/;"	m	class:CommTrace	file:
MPI_INTEGER	CommunicatorMPI.C	10;"	d	file:
MPI_INTEGER	tools/loader.C	21;"	d	file:
MT19937	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^MT19937()$/;"	f	class:PhysBAM::MT19937
MT19937	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^MT19937(const unsigned int value)$/;"	f	class:PhysBAM::MT19937
MT19937	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^class MT19937$/;"	c	namespace:PhysBAM
MULTIFLUID	IoData.h	/^  enum ProblemMode { MULTIFLUID=0, FSI=1} problemMode;$/;"	e	enum:OneDimensionalInfo::ProblemMode
MULTIGRID	IoData.h	/^  enum SolutionMethod { TIMESTEPPING = 0, MULTIGRID = 1} solutionMethod;$/;"	e	enum:ProblemData::SolutionMethod
MULTI_SOLUTIONS_GAPPY_FALSE	IoData.h	/^  enum UseMultiSolutionsGappy {MULTI_SOLUTIONS_GAPPY_FALSE=0, MULTI_SOLUTIONS_GAPPY_TRUE=1} useMultiSolutionsGappy;$/;"	e	enum:InputData::UseMultiSolutionsGappy
MULTI_SOLUTIONS_GAPPY_TRUE	IoData.h	/^  enum UseMultiSolutionsGappy {MULTI_SOLUTIONS_GAPPY_FALSE=0, MULTI_SOLUTIONS_GAPPY_TRUE=1} useMultiSolutionsGappy;$/;"	e	enum:InputData::UseMultiSolutionsGappy
MUT_OVER_MU	PostFcn.h	/^                   PSENSOR = 14, MUT_OVER_MU = 15, PHILEVEL = 16,PHILEVEL2 = 17, DIFFPRESSURE = 18, $/;"	e	enum:PostFcn::ScalarType
MacroCell	MacroCell.h	/^class MacroCell {$/;"	c
MacroCell	MacroCellCore.C	/^MacroCell::MacroCell(int val, int macroCellID, double gam)$/;"	f	class:MacroCell
MacroCellSet	MacroCell.h	/^class MacroCellSet {$/;"	c
MacroCellSet	MacroCellCore.C	/^MacroCellSet::MacroCellSet(int nCells, Connectivity *cellToNode, int nNodes, double gam)$/;"	f	class:MacroCellSet
MacroCellSet	MacroCellCore.C	/^MacroCellSet::MacroCellSet(int numCells,$/;"	f	class:MacroCellSet
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    SCALAR Magnitude() const$/;"	f	class:PhysBAM::ARRAY_BASE
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::QUATERNION
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::COMPLEX
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::VECTOR
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::VECTOR
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::VECTOR
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::VECTOR
Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Magnitude() const$/;"	f	class:PhysBAM::VECTOR_BASE
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    SCALAR Magnitude_Squared() const$/;"	f	class:PhysBAM::ARRAY_BASE
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    inline double Magnitude_Squared(const double a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    inline float Magnitude_Squared(const float a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    inline typename TV::SCALAR Magnitude_Squared(const TV& v)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    typename T_ARRAY::SCALAR Magnitude_Squared(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::QUATERNION
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::COMPLEX
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::VECTOR
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::VECTOR
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::VECTOR
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::VECTOR
Magnitude_Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Magnitude_Squared() const$/;"	f	class:PhysBAM::VECTOR_BASE
Make_First_Nonexistent_Directory_In_Sequence	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::string Make_First_Nonexistent_Directory_In_Sequence(std::string directory_pattern,const int id_start,int* id_final)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Make_Orientations_Consistent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Make_Orientations_Consistent()$/;"	f	class:TRIANGLE_MESH
Map	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    static VECTOR Map(const T_FUNCTION& f,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Map	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    static VECTOR Map(const T_FUNCTION& f,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Map	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static VECTOR Map(const T_FUNCTION& f,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Map	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static VECTOR Map(const T_FUNCTION& f,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
MapFaces	MapFace.h	/^typedef std::map<MaxFace, int> MapFaces;$/;"	t
MapPair	Edge.h	/^  typedef map<Pair, int, less<Pair> > MapPair;$/;"	t	class:EdgeSet
MapPair	Edge.h	/^  typedef map<Pair, int> MapPair;$/;"	t	class:EdgeSet
Mapped_Merge	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Mapped_Merge(const UNION_FIND<ID2>& union_find,const T_ARRAY& map)$/;"	f	class:PhysBAM::UNION_FIND
Mark_Edge_Connected_Component_Incident_On_A_Node	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Mark_Edge_Connected_Component_Incident_On_A_Node(const int node,const int triangle_index_in_incident_elements,ARRAY<bool>& marked) const$/;"	f	class:TRIANGLE_MESH
Mark_Edge_Connected_Component_Incident_On_A_Node	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Mark_Edge_Connected_Component_Incident_On_A_Node(const int node,ARRAY<bool>& marked) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
Mark_Nodes_Referenced	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Mark_Nodes_Referenced(ARRAY<T>& marks,const T& mark) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Mark_Nodes_Referenced	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    virtual void Mark_Nodes_Referenced(ARRAY<int>& marks,const int mark) const {}$/;"	f	class:PhysBAM::STRUCTURE
MatScalar	EmbeddedTsDesc.C	23;"	d	file:
MatScalar	ExplicitEmbeddedTsDesc.C	10;"	d	file:
MatScalar	ExplicitEmbeddedTsDesc.C	8;"	d	file:
MatScalar	ExplicitLevelSetTsDesc.C	11;"	d	file:
MatScalar	ExplicitLevelSetTsDesc.C	13;"	d	file:
MatScalar	ExplicitMultiPhysicsTsDesc.C	10;"	d	file:
MatScalar	ExplicitMultiPhysicsTsDesc.C	12;"	d	file:
MatScalar	ImplicitCoupledTsDesc.C	12;"	d	file:
MatScalar	ImplicitCoupledTsDesc.C	14;"	d	file:
MatScalar	ImplicitRomTsDesc.C	11;"	d	file:
MatScalar	ImplicitRomTsDesc.C	13;"	d	file:
MatScalar	ImplicitSegTsDesc.C	16;"	d	file:
MatScalar	ImplicitSegTsDesc.C	18;"	d	file:
MatScalar	LevelSetTsDesc.C	22;"	d	file:
MatVecProd	MatVecProd.h	/^  MatVecProd() : isFSI(false) {}$/;"	f	class:MatVecProd
MatVecProd	MatVecProd.h	/^class MatVecProd {$/;"	c
MatVecProdFD	MatVecProd.C	/^MatVecProdFD<dim, neq>::MatVecProdFD$/;"	f	class:MatVecProdFD
MatVecProdFD	MatVecProd.h	/^class MatVecProdFD : public MatVecProd<dim,neq> {$/;"	c
MatVecProdFDMultiPhase	MatVecProd.C	/^MatVecProdFDMultiPhase<dim,dimLS>::MatVecProdFDMultiPhase($/;"	f	class:MatVecProdFDMultiPhase
MatVecProdFDMultiPhase	MatVecProd.h	/^class MatVecProdFDMultiPhase : public MatVecProdMultiPhase<dim,dimLS> {$/;"	c
MatVecProdH1	MatVecProd.C	/^MatVecProdH1<dim,Scalar,neq>::MatVecProdH1(DistTimeState<dim> *ts, SpaceOperator<dim> *spo,$/;"	f	class:MatVecProdH1
MatVecProdH1	MatVecProd.h	/^class MatVecProdH1 : public MatVecProd<dim,neq>, public DistMat<Scalar,neq> {$/;"	c
MatVecProdH1MultiPhase	MatVecProd.C	/^MatVecProdH1MultiPhase<dim,dimLS>::MatVecProdH1MultiPhase(DistTimeState<dim> *ts,$/;"	f	class:MatVecProdH1MultiPhase
MatVecProdH1MultiPhase	MatVecProd.h	/^class MatVecProdH1MultiPhase : public MatVecProdMultiPhase<dim,dimLS>,$/;"	c
MatVecProdH2	MatVecProd.C	/^MatVecProdH2<dim,Scalar,neq>::MatVecProdH2$/;"	f	class:MatVecProdH2
MatVecProdH2	MatVecProd.h	/^class MatVecProdH2 : public MatVecProd<dim,neq>, public DistMat<Scalar,dim> {$/;"	c
MatVecProdLS	MatVecProd.C	/^MatVecProdLS<dim,dimLS>::MatVecProdLS(DistTimeState<dim> *ts, DistGeoState *gs,$/;"	f	class:MatVecProdLS
MatVecProdLS	MatVecProd.h	/^class MatVecProdLS : public DistMat<double,dimLS> {$/;"	c
MatVecProdMultiPhase	MatVecProd.h	/^  MatVecProdMultiPhase(DistTimeState<dim> *ts, MultiPhaseSpaceOperator<dim,dimLS> *spo,$/;"	f	class:MatVecProdMultiPhase
MatVecProdMultiPhase	MatVecProd.h	/^class MatVecProdMultiPhase {$/;"	c
MatVecProd_dRdX	MatVecProd.C	/^MatVecProd_dRdX<dim,Scalar,neq>::MatVecProd_dRdX$/;"	f	class:MatVecProd_dRdX
MatVecProd_dRdX	MatVecProd.h	/^class MatVecProd_dRdX : public MatVecProd<dim,neq> {$/;"	c
MatchNode	MatchNode.C	/^struct MatchNode {$/;"	s	file:
MatchNodeSet	MatchNode.h	/^  MatchNodeSet() { numNodes = 0; totalSize = 0; index = 0; gap = 0; xi = 0; normgap = 0; }$/;"	f	class:MatchNodeSet
MatchNodeSet	MatchNode.h	/^class MatchNodeSet {$/;"	c
MatchNodeSet	MatchNodeCore.C	/^MatchNodeSet::MatchNodeSet(const char *name) {$/;"	f	class:MatchNodeSet
MatchNodeSet	MatchNodeCore.C	/^MatchNodeSet::MatchNodeSet(int value)$/;"	f	class:MatchNodeSet
MaterialFluxData	IoData.h	/^  struct MaterialFluxData {$/;"	s	struct:SchemeData
Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    MATRIX<T,d+1> Matrix() const$/;"	f	class:PhysBAM::FRAME
MatrixValuedFunction	AutoDiff/Function.h	/^class MatrixValuedFunction {$/;"	c
MatrixValuedFunctionBase	AutoDiff/SpaceDerivatives.h	/^                                 typename VectorValuedFunctionTemplate<_Scalar>::ScalarConstantType> MatrixValuedFunctionBase;$/;"	t	class:Jacobian
MatrixXd	Modal.C	/^typedef Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> MatrixXd;$/;"	t	file:
Mavripilis	MultiGridLevel.h	/^    enum SeedNodeChoice { Random, Mavripilis };$/;"	e	enum:MultiGridLevel::SeedNodeChoice
Max	Communicator.h	/^    static const int Add=0, Min=1, Max=2;$/;"	m	class:Communication::Window
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Max() const$/;"	f	class:PhysBAM::ARRAY_BASE
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Max(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Max() const$/;"	f	class:PhysBAM::ARRAY_BASE
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Max() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Max() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Max() const$/;"	f	class:PhysBAM::MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Max() const$/;"	f	class:PhysBAM::MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Max() const$/;"	f	class:PhysBAM::MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    T Max() const$/;"	f	class:PhysBAM::MATRIX
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Max() const$/;"	f	class:PhysBAM::VECTOR
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Max() const$/;"	f	class:PhysBAM::VECTOR
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Max() const$/;"	f	class:PhysBAM::VECTOR
Max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Max() const$/;"	f	class:PhysBAM::VECTOR_BASE
MaxFace	MapFace.h	/^    MaxFace(int n, int *d) { $/;"	f	struct:MaxFace
MaxFace	MapFace.h	/^struct MaxFace {$/;"	s
MaxNumEd	Elem.h	/^  static const int MaxNumEd = 12;$/;"	m	class:Elem
MaxNumFc	Elem.h	/^  static const int MaxNumFc = 6;$/;"	m	class:Elem
MaxNumNd	Elem.h	/^  static const int MaxNumNd = 8;$/;"	m	class:Elem
MaxNumNd	Face.h	/^  static const int MaxNumNd = 4;$/;"	m	class:Face
MaxNumNd	MapFace.h	/^    static const int MaxNumNd = 4;$/;"	m	struct:MaxFace
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::MATRIX_BASE
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::QUATERNION
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::VECTOR
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::VECTOR
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::VECTOR
Max_Abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Max_Abs() const$/;"	f	class:PhysBAM::VECTOR_BASE
Max_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ID Max_Size() const$/;"	f	class:PhysBAM::ARRAY
Max_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int Max_Size() const$/;"	f	class:PhysBAM::HASHTABLE
Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Maxabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Maxabs(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Maxabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Maximum_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Maximum_Angle() const$/;"	f	class:TRIANGLE_3D
Maximum_Corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Maximum_Corner() const$/;"	f	class:PhysBAM::RANGE
Maximum_Edge_Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Maximum_Edge_Length() const$/;"	f	class:TRIANGLE_3D
Maximum_Edge_Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Maximum_Edge_Length(const TV& x1,const TV& x2,const TV& x3)$/;"	f	class:PhysBAM::TRIANGLE_3D
Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    SCALAR Maximum_Magnitude() const$/;"	f	class:PhysBAM::ARRAY_BASE
Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^    Maximum_Magnitude(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static typename SCALAR_POLICY<TV>::TYPE Maximum_Magnitude(const ARRAY_BASE<TV,TV_INT>& a)$/;"	f	class:PhysBAM::ARRAY_BASE
Maximum_Magnitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Maximum_Magnitude() const$/;"	f	class:PhysBAM::VECTOR_BASE
Maximum_Valence	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Maximum_Valence(int* index)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Maxmag() const$/;"	f	class:PhysBAM::ARRAY_BASE
Maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Maxmag(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Maxmag() const$/;"	f	class:PhysBAM::ARRAY_BASE
Median_Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Median_Split(const int partition_index,const int first_index,const int last_index,ARRAY_VIEW<const TV> points,ARRAY_VIEW<int> permutation_array,const int axis)$/;"	f	class:KD_TREE
MemModel	arpack++/include/arlspdef.h	/^    LU_space_t MemModel; \/* 0 - system malloc'd; 1 - user provided *\/$/;"	m	struct:__anon35
MemModel	arpack++/include/arlspdef.h	/^    LU_space_t MemModel; \/* 0 - system malloc'd; 1 - user provided *\/$/;"	m	struct:__anon36
MemModel	arpack++/include/arlspdef.h	/^    LU_space_t MemModel; \/* 0 - system malloc'd; 1 - user provided *\/$/;"	m	struct:__anon37
MemModel	arpack++/include/arlspdef.h	/^    LU_space_t MemModel; \/* 0 - system malloc'd; 1 - user provided *\/$/;"	m	struct:__anon38
MemType	arpack++/include/arlspdef.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;$/;"	t	typeref:enum:__anon32
MemberFunctionType	SparseGrid.h	/^    typedef void (T::*MemberFunctionType)(double *, double *, double *);$/;"	t	class:SparseGrid::Functor
MemoryOverflow	ArpackUtil.h	/^void MemoryOverflow() { throw ArpackError(ArpackError::MEMORY_OVERFLOW); }$/;"	f
MemoryPool	MemoryPool.C	/^MemoryPool::MemoryPool() : status(false), size(0), ptr(0)$/;"	f	class:MemoryPool
MemoryPool	MemoryPool.h	/^class MemoryPool {$/;"	c
Memory_Usage	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^unsigned int Memory_Usage()$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Merge	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Merge(const UNION_FIND<ID>& union_find)$/;"	f	class:PhysBAM::UNION_FIND
Merge_Forest_Edges	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Merge_Forest_Edges(const ARRAY<PAIR<ID,ID> >& pairs)$/;"	f	class:PhysBAM::UNION_FIND
MeritFunction	IoData.h	/^  enum MeritFunction {ROM_RESIDUAL=0, HDM_RESIDUAL=1} meritFunction;$/;"	g	struct:NonlinearRomOnlineData
MeshMotion	Manual/Aerof3d.html	/^<a name="MeshMotion"><\/a>$/;"	a
MeshMotionHandler	MeshMotionHandler.h	/^class MeshMotionHandler {$/;"	c
MeshMotionHandler	MeshMotionHandlerCore.C	/^MeshMotionHandler::MeshMotionHandler(IoData &iod, Domain *dom) : $/;"	f	class:MeshMotionHandler
MeshMotionSolver	MeshMotionSolver.h	/^  MeshMotionSolver() {};$/;"	f	class:MeshMotionSolver
MeshMotionSolver	MeshMotionSolver.h	/^class MeshMotionSolver {$/;"	c
Method	IoData.h	/^  enum Method {DIRECT = 0, ADJOINT = 1} method;$/;"	g	struct:SensitivityAnalysis
Method	IoData.h	/^  enum Method {NONE = 0, GHOSTFLUID_FOR_POOR = 1, GHOSTFLUID_WITH_RIEMANN} method;$/;"	g	struct:MultiFluidData
Method	RKIntegrator.h	/^  enum Method { FE, RK2, RK4 };$/;"	g	class:RKIntegrator
Min	Communicator.h	/^    static const int Add=0, Min=1, Max=2;$/;"	m	class:Communication::Window
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Min() const$/;"	f	class:PhysBAM::ARRAY_BASE
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Min(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Min() const$/;"	f	class:PhysBAM::ARRAY_BASE
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Min() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Min() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Min() const$/;"	f	class:PhysBAM::MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Min() const$/;"	f	class:PhysBAM::MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Min() const$/;"	f	class:PhysBAM::MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    T Min() const$/;"	f	class:PhysBAM::MATRIX
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Min() const$/;"	f	class:PhysBAM::VECTOR
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Min() const$/;"	f	class:PhysBAM::VECTOR
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Min() const$/;"	f	class:PhysBAM::VECTOR
Min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Min() const$/;"	f	class:PhysBAM::VECTOR_BASE
Min_Phi	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Min_Phi() const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Minimum_Altitude	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Minimum_Altitude(const TV& x1,const TV& x2,const TV& x3)$/;"	f	class:PhysBAM::TRIANGLE_3D
Minimum_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Minimum_Angle() const$/;"	f	class:TRIANGLE_3D
Minimum_Cell_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Minimum_Cell_Size() const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();} $/;"	f	class:IMPLICIT_OBJECT
Minimum_Cell_Size_Within_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Minimum_Cell_Size_Within_Box(const RANGE<TV>& box) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Minimum_Corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Minimum_Corner() const$/;"	f	class:PhysBAM::RANGE
Minimum_Edge_Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Minimum_Edge_Length() const$/;"	f	class:TRIANGLE_3D
Minimum_Edge_Length	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Minimum_Edge_Length(const TV& x1,const TV& x2,const TV& x3)$/;"	f	class:PhysBAM::TRIANGLE_3D
Minimum_Valence	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Minimum_Valence(int* index)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Minmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Minmag() const$/;"	f	class:PhysBAM::ARRAY_BASE
Minmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^    T Minmag(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Minmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Minmag() const$/;"	f	class:PhysBAM::ARRAY_BASE
Minus_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Minus_Equals(ARRAY_BASE<T,T_ARRAY,ID>&a,const ARRAY_BASE<T,T_ARRAY1,ID>& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Minus_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Minus_Equals(ARRAY_BASE<T,T_ARRAY,ID>&a,const T& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
ModalSolver	Modal.C	/^ModalSolver<dim>::ModalSolver(Communicator *_com, IoData &_ioData, Domain &dom) : $/;"	f	class:ModalSolver
ModalSolver	Modal.h	/^class ModalSolver {$/;"	c
Mode	Communicator.h	/^  enum Mode { Share, CopyOnSend };$/;"	g	class:CommPattern
Mode	IoData.h	/^  enum Mode { NORMAL=0, CONVTEST1 = 1, CONVTEST2=2 } mode;$/;"	g	struct:OneDimensionalInfo
Mode	IoData.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	g	struct:ProblemData
Mode	IoData.h	/^  enum Mode {Recursive = 1, NonRecursive = 2} mode;$/;"	g	struct:DefoMeshMotionData
Mode	RefVal.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	g	class:RefVal
ModePhi	OneDimensionalSolver.h	/^  enum ReadMode { ModeU, ModePhi };$/;"	e	enum:OneDimensional::ReadMode
ModeU	OneDimensionalSolver.h	/^  enum ReadMode { ModeU, ModePhi };$/;"	e	enum:OneDimensional::ReadMode
Mom_Test	DistDynamicLESTerm.h	/^  DistSVec<double,16> *Mom_Test;$/;"	m	class:DistDynamicLESTerm
Move_Contents_By_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Move_Contents_By_Offset(const VECTOR<int,1>& offset)$/;"	f	class:PhysBAM::ARRAY_BASE
Move_Contents_By_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Move_Contents_By_Offset(const VECTOR<int,2>& offset)$/;"	f	class:PhysBAM::ARRAY_BASE
Move_Contents_By_Offset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    void Move_Contents_By_Offset(const VECTOR<int,3>& offset)$/;"	f	class:PhysBAM::ARRAY_BASE
Mtype	arpack++/include/arlsupm.h	/^	Mtype_t Mtype; \/* Matrix type: describes the mathematical property of $/;"	m	struct:__anon45
Mtype_t	arpack++/include/arlsupm.h	/^} Mtype_t;$/;"	t	typeref:enum:__anon44
Mult0MMt0v	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
Mult0MMt0v	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
Mult0MMt0v	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
Mult0MMt0v	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultAv	arpack++/include/arbnspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARbdNonSymPencil
MultAv	arpack++/include/arbspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARbdSymPencil
MultAv	arpack++/include/ardnspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARdsNonSymPencil
MultAv	arpack++/include/ardspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARdsSymPencil
MultAv	arpack++/include/arlnspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARluNonSymPencil
MultAv	arpack++/include/arlspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARluSymPencil
MultAv	arpack++/include/arunspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARumNonSymPencil
MultAv	arpack++/include/aruspen.h	/^  void MultAv(ARTYPE* v, ARTYPE* w) { A->MultMv(v,w); }$/;"	f	class:ARumSymPencil
MultAx	arpack++/include/argnsym.h	/^  TypeBx  MultAx;     \/\/ Function that evaluates the product A*x.$/;"	m	class:ARNonSymGenEig
MultAx	arpack++/include/argsym.h	/^  TypeBx  MultAx;     \/\/ Function that evaluates the product A*x.$/;"	m	class:ARSymGenEig
MultBv	arpack++/include/arbnspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARbdNonSymPencil
MultBv	arpack++/include/arbspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARbdSymPencil
MultBv	arpack++/include/ardnspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARdsNonSymPencil
MultBv	arpack++/include/ardspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARdsSymPencil
MultBv	arpack++/include/arlnspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARluNonSymPencil
MultBv	arpack++/include/arlspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARluSymPencil
MultBv	arpack++/include/arunspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARumNonSymPencil
MultBv	arpack++/include/aruspen.h	/^  void MultBv(ARTYPE* v, ARTYPE* w) { B->MultMv(v,w); }$/;"	f	class:ARumSymPencil
MultBx	arpack++/include/argeig.h	/^  TypeBx  MultBx;     \/\/ Function that evaluates the product B*x.$/;"	m	class:ARGenEig
MultInvAsBv	arpack++/include/arbnspen.h	/^MultInvAsBv(arcomplex<ARFLOAT>* v, arcomplex<ARFLOAT>* w)$/;"	f	class:ARbdNonSymPencil
MultInvAsBv	arpack++/include/arbnspen.h	/^void ARbdNonSymPencil<ARTYPE, ARFLOAT>::MultInvAsBv(ARFLOAT* v, ARFLOAT* w)$/;"	f	class:ARbdNonSymPencil
MultInvAsBv	arpack++/include/arbspen.h	/^  void MultInvAsBv(ARTYPE* v, ARTYPE* w) {  AsB.MultInvv(v,w); }$/;"	f	class:ARbdSymPencil
MultInvAsBv	arpack++/include/ardnspen.h	/^MultInvAsBv(arcomplex<ARFLOAT>* v, arcomplex<ARFLOAT>* w)$/;"	f	class:ARdsNonSymPencil
MultInvAsBv	arpack++/include/ardnspen.h	/^void ARdsNonSymPencil<ARTYPE, ARFLOAT>::MultInvAsBv(ARFLOAT* v, ARFLOAT* w)$/;"	f	class:ARdsNonSymPencil
MultInvAsBv	arpack++/include/ardspen.h	/^  void MultInvAsBv(ARTYPE* v, ARTYPE* w) {  AsB.MultInvv(v,w); }$/;"	f	class:ARdsSymPencil
MultInvAsBv	arpack++/include/arlnspen.h	/^MultInvAsBv(arcomplex<ARFLOAT>* v, arcomplex<ARFLOAT>* w)$/;"	f	class:ARluNonSymPencil
MultInvAsBv	arpack++/include/arlnspen.h	/^void ARluNonSymPencil<ARTYPE, ARFLOAT>::MultInvAsBv(ARFLOAT* v, ARFLOAT* w)$/;"	f	class:ARluNonSymPencil
MultInvAsBv	arpack++/include/arlspen.h	/^void ARluSymPencil<ARTYPE>::MultInvAsBv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluSymPencil
MultInvAsBv	arpack++/include/arunspen.h	/^MultInvAsBv(arcomplex<ARFLOAT>* v, arcomplex<ARFLOAT>* w)$/;"	f	class:ARumNonSymPencil
MultInvAsBv	arpack++/include/arunspen.h	/^void ARumNonSymPencil<ARTYPE, ARFLOAT>::MultInvAsBv(ARFLOAT* v, ARFLOAT* w)$/;"	f	class:ARumNonSymPencil
MultInvAsBv	arpack++/include/aruspen.h	/^  void MultInvAsBv(ARTYPE* v, ARTYPE* w) { AsB.MultInvv(v,w); }$/;"	f	class:ARumSymPencil
MultInvBAv	arpack++/include/arbnspen.h	/^void ARbdNonSymPencil<ARTYPE, ARFLOAT>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymPencil
MultInvBAv	arpack++/include/arbspen.h	/^void ARbdSymPencil<ARTYPE>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdSymPencil
MultInvBAv	arpack++/include/ardnspen.h	/^void ARdsNonSymPencil<ARTYPE, ARFLOAT>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymPencil
MultInvBAv	arpack++/include/ardspen.h	/^void ARdsSymPencil<ARTYPE>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsSymPencil
MultInvBAv	arpack++/include/arlnspen.h	/^void ARluNonSymPencil<ARTYPE, ARFLOAT>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymPencil
MultInvBAv	arpack++/include/arlspen.h	/^void ARluSymPencil<ARTYPE>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluSymPencil
MultInvBAv	arpack++/include/arunspen.h	/^void ARumNonSymPencil<ARTYPE, ARFLOAT>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymPencil
MultInvBAv	arpack++/include/aruspen.h	/^void ARumSymPencil<ARTYPE>::MultInvBAv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumSymPencil
MultInvv	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
MultInvv	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdSymMatrix
MultInvv	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
MultInvv	arpack++/include/ardsmat.h	/^void ARdsSymMatrix<ARTYPE>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsSymMatrix
MultInvv	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
MultInvv	arpack++/include/arlsmat.h	/^void ARluSymMatrix<ARTYPE>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluSymMatrix
MultInvv	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultInvv	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::MultInvv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumSymMatrix
MultMMtv	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
MultMMtv	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
MultMMtv	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
MultMMtv	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultMtMv	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
MultMtMv	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
MultMtMv	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
MultMtMv	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultMtv	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
MultMtv	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::MultMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
MultMtv	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
MultMtv	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultMv	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdNonSymMatrix
MultMv	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARbdSymMatrix
MultMv	arpack++/include/ardnsmat.h	/^void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsNonSymMatrix
MultMv	arpack++/include/ardsmat.h	/^void ARdsSymMatrix<ARTYPE>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARdsSymMatrix
MultMv	arpack++/include/arlnsmat.h	/^void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluNonSymMatrix
MultMv	arpack++/include/arlsmat.h	/^void ARluSymMatrix<ARTYPE>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARluSymMatrix
MultMv	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumNonSymMatrix
MultMv	arpack++/include/arusmat.h	/^void ARumSymMatrix<ARTYPE>::MultMv(ARTYPE* v, ARTYPE* w)$/;"	f	class:ARumSymMatrix
MultOPx	arpack++/include/arseig.h	/^  TypeOPx MultOPx;    \/\/ Function that evaluates the product OP*x.$/;"	m	class:ARStdEig
MultiFluid	OneDimensionalSolver.h	/^  enum ProblemMode { MultiFluid, FSI};$/;"	e	enum:OneDimensional::ProblemMode
MultiFluidData	IoData.h	/^struct MultiFluidData {$/;"	s
MultiFluidData	IoDataCore.C	/^MultiFluidData::MultiFluidData()$/;"	f	class:MultiFluidData
MultiGridAlgebraic	MultigridCommon.h	/^enum MultiGridMethod { MultiGridAlgebraic, MultiGridGeometric };$/;"	e	enum:MultiGridMethod
MultiGridCoupledTsDesc	MultiGridCoupledTsDesc.C	/^MultiGridCoupledTsDesc(IoData & iod, GeoSource & gs,  Domain * dom) :$/;"	f	class:MultiGridCoupledTsDesc
MultiGridCoupledTsDesc	MultiGridCoupledTsDesc.h	/^class MultiGridCoupledTsDesc : public ImplicitCoupledTsDesc<dim> {$/;"	c
MultiGridData	IoData.h	/^struct MultiGridData {$/;"	s
MultiGridData	IoDataCore.C	/^MultiGridData::MultiGridData()$/;"	f	class:MultiGridData
MultiGridDistSVec	MultiGridDistSVec.C	/^MultiGridDistSVec() {$/;"	f	class:MultiGridDistSVec
MultiGridDistSVec	MultiGridDistSVec.h	/^class MultiGridDistSVec {$/;"	c
MultiGridEmbeddedTsDesc	MultiGridEmbeddedTsDesc.C	/^MultiGridEmbeddedTsDesc(IoData & iod, GeoSource & gs,  Domain * dom) :$/;"	f	class:MultiGridEmbeddedTsDesc
MultiGridEmbeddedTsDesc	MultiGridEmbeddedTsDesc.h	/^class MultiGridEmbeddedTsDesc : public ImplicitEmbeddedCoupledTsDesc<dim> {$/;"	c
MultiGridGeometric	MultigridCommon.h	/^enum MultiGridMethod { MultiGridAlgebraic, MultiGridGeometric };$/;"	e	enum:MultiGridMethod
MultiGridJacobiPrec	MultiGridKspSolver.h	/^  MultiGridJacobiPrec(MultiGridSmoothingMatrix<Scalar,neq>** smoothingMatrices,                   $/;"	f	class:MultiGridJacobiPrec
MultiGridJacobiPrec	MultiGridKspSolver.h	/^class MultiGridJacobiPrec {$/;"	c
MultiGridKernel	MultiGridKernel.C	/^MultiGridKernel<Scalar>::MultiGridKernel(Domain *dom, DistGeoState& distGeoState, IoData& ioData,int num_levels)$/;"	f	class:MultiGridKernel
MultiGridKernel	MultiGridKernel.h	/^class MultiGridKernel {$/;"	c
MultiGridKspSolver	MultiGridKspSolver.C	/^MultiGridKspSolver(Domain* domain,KspData& coarseSolverData,$/;"	f	class:MultiGridKspSolver
MultiGridKspSolver	MultiGridKspSolver.h	/^class MultiGridKspSolver {$/;"	c
MultiGridLevel	MultiGridLevel.C	/^MultiGridLevel<Scalar>::MultiGridLevel(MultiGridLevel* mg,int level_num,$/;"	f	class:MultiGridLevel
MultiGridLevel	MultiGridLevel.C	/^MultiGridLevel<Scalar>::MultiGridLevel(MultiGridMethod mgm,MultiGridLevel* mg, Domain& domain, DistInfo& refinedNodeDistInfo, DistInfo& refinedEdgeDistInfo)$/;"	f	class:MultiGridLevel
MultiGridLevel	MultiGridLevel.h	/^class MultiGridLevel {$/;"	c
MultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.C	/^MultiGridLevelSetStructure(DistMultiGridLevelSetStructure& lss,$/;"	f	class:MultiGridLevelSetStructure
MultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.h	/^class MultiGridLevelSetStructure : public LevelSetStructure {$/;"	c
MultiGridMatVecProd	MultiGridKspSolver.h	/^  MultiGridMatVecProd(DistMat<Scalar,neq>* macroA, MultiGridLevel<Scalar>* multiGridLevel) :      $/;"	f	class:MultiGridMatVecProd
MultiGridMatVecProd	MultiGridKspSolver.h	/^class MultiGridMatVecProd {$/;"	c
MultiGridMethod	MultigridCommon.h	/^enum MultiGridMethod { MultiGridAlgebraic, MultiGridGeometric };$/;"	g
MultiGridMvpMatrix	MultiGridMvpMatrix.C	/^MultiGridMvpMatrix(Domain* domain,$/;"	f	class:MultiGridMvpMatrix
MultiGridMvpMatrix	MultiGridMvpMatrix.h	/^class MultiGridMvpMatrix {$/;"	c
MultiGridOperator	MultiGridOperator.C	/^MultiGridOperator<Scalar,dim>::MultiGridOperator(MultiGridLevel<Scalar>* mg_lvl,$/;"	f	class:MultiGridOperator
MultiGridOperator	MultiGridOperator.h	/^class MultiGridOperator {$/;"	c
MultiGridPrec	MultiGridPrec.C	/^MultiGridPrec<Scalar,dim,Scalar2>::MultiGridPrec(Domain *dom, DistGeoState& distGeoState, IoData& ioData) : domain(dom), DistMat<Scalar2,dim>(dom)$/;"	f	class:MultiGridPrec
MultiGridPrec	MultiGridPrec.h	/^class MultiGridPrec : public KspPrec<dim, Scalar2>, public DistMat<Scalar2,dim> {$/;"	c
MultiGridRASPrec	MultiGridKspSolver.h	/^  MultiGridRASPrec(MultiGridSmoothingMatrix<Scalar,neq>** smoothingMatrices,$/;"	f	class:MultiGridRASPrec
MultiGridRASPrec	MultiGridKspSolver.h	/^class MultiGridRASPrec {$/;"	c
MultiGridSegTsDesc	MultiGridSegTsDesc.C	/^MultiGridSegTsDesc(IoData & iod, GeoSource & gs,  Domain * dom) :$/;"	f	class:MultiGridSegTsDesc
MultiGridSegTsDesc	MultiGridSegTsDesc.h	/^class MultiGridSegTsDesc : public ImplicitSegTsDesc<dim,neq1,neq2> {$/;"	c
MultiGridSmoothingMatrices	MultiGridSmoothingMatrices.C	/^MultiGridSmoothingMatrices(MultiGridKernel<Scalar>* pKernel,$/;"	f	class:MultiGridSmoothingMatrices
MultiGridSmoothingMatrices	MultiGridSmoothingMatrices.h	/^class MultiGridSmoothingMatrices {$/;"	c
MultiGridSmoothingMatrix	MultiGridSmoothingMatrix.C	/^MultiGridSmoothingMatrix(SmoothingMode m, int isub,$/;"	f	class:MultiGridSmoothingMatrix
MultiGridSmoothingMatrix	MultiGridSmoothingMatrix.h	/^class MultiGridSmoothingMatrix : public GenMat<Scalar,dim> {$/;"	c
MultiGridSolver	MultiGridSolver.h	/^MultiGridSolver<ProblemDescriptor>::MultiGridSolver(ProblemDescriptor *prbd)$/;"	f	class:MultiGridSolver
MultiGridSolver	MultiGridSolver.h	/^class MultiGridSolver {$/;"	c
MultiGridSpaceOperator	MultiGridSpaceOperator.C	/^MultiGridSpaceOperator(IoData& ioData,Domain* domain, $/;"	f	class:MultiGridSpaceOperator
MultiGridSpaceOperator	MultiGridSpaceOperator.h	/^class MultiGridSpaceOperator {$/;"	c
MultiInitialConditionsData	IoData.h	/^struct MultiInitialConditionsData {$/;"	s
MultiPhase	Manual/Aerof3d.html	/^<a name="MultiPhase"><\/a>$/;"	a
MultiPhaseSpaceOperator	SpaceOperator.C	/^MultiPhaseSpaceOperator<dim,dimLS>::MultiPhaseSpaceOperator(IoData &ioData, VarFcn *vf, DistBcData<dim> *bc,$/;"	f	class:MultiPhaseSpaceOperator
MultiPhaseSpaceOperator	SpaceOperator.C	/^MultiPhaseSpaceOperator<dim,dimLS>::MultiPhaseSpaceOperator(const MultiPhaseSpaceOperator<dim,dimLS> &spo, bool typeAlloc)$/;"	f	class:MultiPhaseSpaceOperator
MultiPhaseSpaceOperator	SpaceOperator.h	/^class MultiPhaseSpaceOperator : public SpaceOperator<dim> {$/;"	c
MultiPhysicsTsDesc	MultiPhysicsTsDesc.C	/^MultiPhysicsTsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom):$/;"	f	class:MultiPhysicsTsDesc
MultiPhysicsTsDesc	MultiPhysicsTsDesc.h	/^class MultiPhysicsTsDesc : public TsDesc<dim> , ForceGenerator<dim> {$/;"	c
MultifluidRiemannNormal	Edge.h	/^  enum MultifluidRiemannNormal { MF_RIEMANN_NORMAL_MESH, MF_RIEMANN_NORMAL_REAL, MF_RIEMANN_NORMAL_LEGACYMESH };$/;"	g	class:EdgeSet
Multigrid	Multigrid.h	/^class Multigrid {$/;"	c
MultigridSubdomain	MultiGridLevel.h	/^struct MultigridSubdomain {$/;"	s
MultiphaseRiemannCopy	DistTimeState.C	/^  MultiphaseRiemannCopy(int _dim) : dim(_dim) { }$/;"	f	struct:MultiphaseRiemannCopy
MultiphaseRiemannCopy	DistTimeState.C	/^struct MultiphaseRiemannCopy {$/;"	s	file:
Multiplier	MatVecProd.h	/^  struct Multiplier<dd,dd,Scalar1,Scalar2>$/;"	s	class:MatVecProdH2
Multiplier	MatVecProd.h	/^  struct Multiplier<dd,dd,Scalar1,Scalar2>$/;"	s	class:MatVecProd_dRdX
Multiplier	MatVecProd.h	/^  template<int dd, int nn, class Scalar1, class Scalar2> struct Multiplier$/;"	s	class:MatVecProdH2
Multiplier	MatVecProd.h	/^  template<int dd, int nn, class Scalar1, class Scalar2> struct Multiplier$/;"	s	class:MatVecProd_dRdX
Multiply_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Multiply_With_Symmetric_Result(const MATRIX<T,3>& A,const MATRIX<T,3>& B) \/\/ A*B and assume symmetric result, 18 mults, 12 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Mvp	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	g	struct:ImplicitData
Mvp	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	g	struct:SensitivityAnalysis
MvpAuxilliaryIterator	MvpMatrix.h	/^  struct MvpAuxilliaryIterator : public GenMat<Scalar,dim>::AuxilliaryIterator {$/;"	s	class:MvpMat
MvpMat	MvpMatrix.h	/^ MvpMat(int nn, int ne, int nBC = 0) : a(nn + 2*(ne+nBC)),uh(0), hu(0), hh(0) { n = nn; numEdges = ne;}$/;"	f	class:MvpMat
MvpMat	MvpMatrix.h	/^class MvpMat : public GenMat<Scalar,dim> {$/;"	c
MyLU	OneDimensionalSourceTerm.h	/^  struct MyLU {$/;"	s	class:OneDimensionalSourceTerm
MyTriangle	IntersectorFRG/IntersectorFRG.C	/^  MyTriangle() {}$/;"	f	class:MyTriangle
MyTriangle	IntersectorFRG/IntersectorFRG.C	/^  MyTriangle(int i, Vec<Vec3D> &coord, int *nd) {$/;"	f	class:MyTriangle
MyTriangle	IntersectorFRG/IntersectorFRG.C	/^class MyTriangle {$/;"	c	file:
N	BlockTridiagonalMatrix.h	/^  int N;$/;"	m	class:BlockTridiagonalMatrix
N	ODEIntegrator.h	/^  int N;$/;"	m	class:ODEIntegrator
NARROWRAND	utils/Predicate.C	136;"	d	file:
NATURAL	IoData.h	/^  enum Renumbering {NATURAL = 0, RCM = 1} renumbering;$/;"	e	enum:PcData::Renumbering
NAUPP_H	arpack++/include/naupp.h	18;"	d
NAVIER_STOKES	EmbeddedTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	e	enum:EmbeddedTsDesc::Type
NAVIER_STOKES	IoData.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} type;$/;"	e	enum:EquationsData::Type
NAVIER_STOKES	MultiPhysicsTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	e	enum:MultiPhysicsTsDesc::Type
NBlocks	arpack++/include/ardfmat.h	/^  int NBlocks() const { return nblocks; }$/;"	f	class:ARdfMatrix
NC	arpack++/include/arlsupm.h	/^    NC,        \/* column-wise, no supernode *\/$/;"	e	enum:__anon42
NCP	arpack++/include/arlsupm.h	/^    NCP,       \/* column-wise, column-permuted, no supernode $/;"	e	enum:__anon42
NCPformat	arpack++/include/arlsupm.h	/^} NCPformat;$/;"	t	typeref:struct:__anon49
NCV_OUT_OF_BOUNDS	arpack++/include/arerror.h	/^    NCV_OUT_OF_BOUNDS   =  101,$/;"	e	enum:ArpackError::ErrorCode
NCformat	arpack++/include/arlsupm.h	/^} NCformat;$/;"	t	typeref:struct:__anon46
NCols	arpack++/include/ardfmat.h	/^  int NCols() const { return n; }$/;"	f	class:ARdfMatrix
NCols	arpack++/include/arhbmat.h	/^  int NCols() { return n; }$/;"	f	class:ARhbMatrix
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^template<class T_ARRAY> struct NEGATION<T_ARRAY,typename ENABLE_IF<IS_ARRAY<T_ARRAY>::value>::TYPE>$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<int>{typedef int TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct NEGATION<TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct NEGATION<VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct NEGATION<VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct NEGATION<VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct NEGATION<VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T_VECTOR> struct NEGATION<T_VECTOR,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR>::value>::TYPE>$/;"	s	namespace:PhysBAM
NEGO_BUF_TAG	StructExc.C	22;"	d	file:
NEGO_NUM_TAG	StructExc.C	21;"	d	file:
NEUPP_H	arpack++/include/neupp.h	18;"	d
NEV_OUT_OF_BOUNDS	arpack++/include/arerror.h	/^    NEV_OUT_OF_BOUNDS   = -103,$/;"	e	enum:ArpackError::ErrorCode
NLROMOFFLINE	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
NLROMONLINE	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
NL_BALL_VERTEX	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	e	enum:DefoMeshMotionData::Element
NO	IoData.h	/^  enum CheckFinalRes {NO = 0, YES = 1} checkFinalRes;$/;"	e	enum:KspData::CheckFinalRes
NO	IoData.h	/^  enum FailSafe {NO = 0, YES = 1, ALWAYS = 2} failsafe;$/;"	e	enum:NewtonData::FailSafe
NO	IoData.h	/^  enum ForceResults {NO = 0, YES = 1} forceResults;$/;"	e	enum:SurfaceData::ForceResults
NO	IoData.h	/^  enum YesNo {YES = 0, NO = 1 };$/;"	e	enum:LiquidModelData::YesNo
NO	arpack++/include/arlutil.h	49;"	d
NOCHANGE	arpack++/include/arlnames.h	30;"	d
NODAL_STATE	IoData.h	/^  enum EOSChange {NODAL_STATE = 0, RIEMANN_SOLUTION = 1} eosChange;$/;"	e	enum:EmbeddedFramework::EOSChange
NODE_BASED	IoData.h	/^  enum StructureNormal {ELEMENT_BASED = 0, NODE_BASED = 1} structNormal;$/;"	e	enum:EmbeddedFramework::StructureNormal
NONCOPYABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/NONCOPYABLE.h	/^    NONCOPYABLE(){}$/;"	f	class:PhysBAM::NONCOPYABLE
NONCOPYABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/NONCOPYABLE.h	/^class NONCOPYABLE$/;"	c	namespace:PhysBAM
NONDESCRIPTOR	IoData.h	/^  enum Form {DESCRIPTOR = 1, NONDESCRIPTOR = 0, HYBRID = 2} form;$/;"	e	enum:TsData::Form
NONDESCRIPTOR	SpaceOperator.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:SpaceOperator::DescriptorCase
NONDESCRIPTOR	TimeState.h	/^    DESCRIPTOR, HYBRID, NONDESCRIPTOR$/;"	e	enum:TimeState::DescriptorCase
NONE	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:CorotSolver::SymmetryAxis
NONE	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	e	enum:EmbeddedCorotSolver::SymmetryAxis
NONE	EmbeddedTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;  $/;"	e	enum:EmbeddedTsDesc::ImplosionSetupType
NONE	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	e	enum:TsData::Clipping
NONE	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	e	enum:SchemeData::Limiter
NONE	IoData.h	/^  enum Method {NONE = 0, GHOSTFLUID_FOR_POOR = 1, GHOSTFLUID_WITH_RIEMANN} method;$/;"	e	enum:MultiFluidData::Method
NONE	IoData.h	/^  enum OptimalPressureDimensionality {NON_DIMENSIONAL=0, DIMENSIONAL=1,NONE=2} optPressureDim;$/;"	e	enum:InputData::OptimalPressureDimensionality
NONE	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	e	enum:SchemeFixData::Symmetry
NONE	IoData.h	/^  enum Type {NONE = 0, BACKTRACKING = 1} type;$/;"	e	enum:LineSearchData::Type
NONE	IoData.h	/^  enum Type {NONE = 0, EDDY_VISCOSITY = 1, LES = 2} type;$/;"	e	enum:TurbulenceClosureData::Type
NONE	MultiPhysicsTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;$/;"	e	enum:MultiPhysicsTsDesc::ImplosionSetupType
NONEFIX	IoData.h	/^  enum FixSolution {NONEFIX = 0, PREVIOUSVALEUSFIX = 1} fixsol;$/;"	e	enum:SensitivityAnalysis::FixSolution
NONE_LIFTFACE	IoData.h	/^  enum IncludeLiftFaces {NONE_LIFTFACE = 0,$/;"	e	enum:GappyConstructionData::IncludeLiftFaces
NONITERATIVE	IoData.h	/^  enum Type {ITERATIVE = 0, NONITERATIVE = 1, HYBRID = 2} type;$/;"	e	enum:WallDistanceMethodData::Type
NONLINEAR_FUNCTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^class NONLINEAR_FUNCTION<R(T1)>$/;"	c	namespace:PhysBAM
NONLINEAR_FUNCTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^class NONLINEAR_FUNCTION<R(T1,T2)>$/;"	c	namespace:PhysBAM
NON_DIMENSIONAL	IoData.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	e	enum:ProblemData::Mode
NON_DIMENSIONAL	IoData.h	/^  enum OptimalPressureDimensionality {NON_DIMENSIONAL=0, DIMENSIONAL=1,NONE=2} optPressureDim;$/;"	e	enum:InputData::OptimalPressureDimensionality
NON_DIMENSIONAL	RefVal.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	e	enum:RefVal::Mode
NON_LINEAR_FE	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	e	enum:DefoMeshMotionData::Element
NON_NODAL	IoData.h	/^  enum Gradient {LEAST_SQUARES = 0, GALERKIN = 1, NON_NODAL = 2} gradient;$/;"	e	enum:SchemeData::Gradient
NON_PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 2} prec;$/;"	e	enum:MultiFluidData::Prec
NON_PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 3 } prec;$/;"	e	enum:EmbeddedFramework::Prec
NON_PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1} prec;$/;"	e	enum:ProblemData::Prec
NORMAL	IoData.h	/^  enum Mode { NORMAL=0, CONVTEST1 = 1, CONVTEST2=2 } mode;$/;"	e	enum:OneDimensionalInfo::Mode
NORMALIZE_FALSE	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	e	enum:SnapshotsData::NormalizeSnaps
NORMALIZE_FALSE	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	e	enum:StateSnapshotsData::NormalizeSnaps
NORMALIZE_TRUE	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	e	enum:SnapshotsData::NormalizeSnaps
NORMALIZE_TRUE	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	e	enum:StateSnapshotsData::NormalizeSnaps
NORMAL_EQUATIONS	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	e	enum:NonlinearRomOnlineData::LSSolver
NORMAL_EQUATIONS	IoData.h	/^  enum LsSolver {QR=0, NORMAL_EQUATIONS=1} lsSolver;$/;"	e	enum:SensitivityAnalysis::LsSolver
NOT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<> struct NOT<false> {static const bool value=true;};$/;"	s	namespace:PhysBAM
NOT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b> struct NOT {static const bool value=false;};$/;"	s	namespace:PhysBAM
NOT_ACCURATE_EIG	arpack++/include/arerror.h	/^    NOT_ACCURATE_EIG    = -203,$/;"	e	enum:ArpackError::ErrorCode
NOT_CORRECTED	Face.h	72;"	d
NOT_FACTORED_MATRIX	arpack++/include/arerror.h	/^    NOT_FACTORED_MATRIX = -505,$/;"	e	enum:ArpackError::ErrorCode
NOT_IMPLEMENTED	arpack++/include/arerror.h	/^    NOT_IMPLEMENTED     = -901,$/;"	e	enum:ArpackError::ErrorCode
NOT_SQUARE_MATRIX	arpack++/include/arerror.h	/^    NOT_SQUARE_MATRIX   = -504,$/;"	e	enum:ArpackError::ErrorCode
NO_ERRORS	arpack++/include/arerror.h	/^    NO_ERRORS           =    0,$/;"	e	enum:ArpackError::ErrorCode
NO_GAPPYRES	IoData.h	/^  enum ComputeGappyRes {NO_GAPPYRES = 0, YES_GAPPYRES  = 1} computeGappyRes;$/;"	e	enum:GappyConstructionData::ComputeGappyRes
NO_HF	IoData.h	/^  enum HeatFluxResults {UNSPECIFIED_HF = -1, NO_HF = 0, YES_HF = 1} heatFluxResults;$/;"	e	enum:SurfaceData::HeatFluxResults
NO_MARKER	arpack++/include/arlspdef.h	29;"	d
NO_PREC	IoData.h	/^  enum Prec {NO_PREC = 0, PREC = 1} prec;$/;"	e	enum:TsData::Prec
NO_SHIFTS_APPLIED	arpack++/include/arerror.h	/^    NO_SHIFTS_APPLIED   =  202,$/;"	e	enum:ArpackError::ErrorCode
NO_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct NO_TYPE {char padding[8];};$/;"	s	namespace:PhysBAM
NO_UPDATES_FALSE	IoData.h	/^  enum PreprocessForNoUpdates {NO_UPDATES_FALSE = 0, NO_UPDATES_TRUE = 1} preprocessForNoUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForNoUpdates
NO_UPDATES_TRUE	IoData.h	/^  enum PreprocessForNoUpdates {NO_UPDATES_FALSE = 0, NO_UPDATES_TRUE = 1} preprocessForNoUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForNoUpdates
NPHASES	arpack++/include/arlutil.h	/^    NPHASES  \/* total number of phases *\/$/;"	e	enum:__anon51
NR	arpack++/include/arlsupm.h	/^    NR,        \/* row-wize, no supernode *\/$/;"	e	enum:__anon42
NRformat	arpack++/include/arlsupm.h	/^} NRformat;$/;"	t	typeref:struct:__anon47
NRows	arpack++/include/ardfmat.h	/^  int NRows() const { return m; }$/;"	f	class:ARdfMatrix
NRows	arpack++/include/arhbmat.h	/^  int NRows() { return m; }$/;"	f	class:ARhbMatrix
NULL	tools/alloca.cougar.c	61;"	d	file:
NUMTIMINGS	Timer.h	/^                gappyOffline, romOffline, icInterp, NUMTIMINGS$/;"	e	enum:Timer::TimerIndex
NUM_TEMPV	arpack++/include/arlspdef.h	30;"	d
NUTILDE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
NUT_TURB	PostFcn.h	/^		   VORTICITY = 5, CSDLES = 6, CSDVMS = 7, SKIN_FRICTION = 8, NUT_TURB = 9, $/;"	e	enum:PostFcn::ScalarType
N_SMALLER_THAN_2	arpack++/include/arerror.h	/^    N_SMALLER_THAN_2    = -102,$/;"	e	enum:ArpackError::ErrorCode
Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	/^Name()$/;"	f	class:BOX
Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    static std::string Name()$/;"	f	class:PhysBAM::LINE_2D
Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Name()$/;"	f	class:PhysBAM::ORIENTED_BOX
Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    static std::string Name()$/;"	f	class:PhysBAM::PLANE
Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    virtual std::string Name() const {PHYSBAM_WARN_IF_NOT_OVERRIDDEN();return Static_Name();}$/;"	f	class:PhysBAM::STRUCTURE
Name	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    std::string Name() const {return Static_Name();}$/;"	f	class:PhysBAM::FRAME
Name	arpack++/include/arhbmat.h	/^  char* Name() { return name; }$/;"	f	class:ARhbMatrix
Name_To_Factory	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    static FACTORY_BASE<T_BASE_OBJECT>* Name_To_Factory(const T_NAME& name)$/;"	f	class:PhysBAM::REGISTRY
NavierStokes	Manual/Aerof3d.html	/^<a name="NavierStokes"><\/a>$/;"	a
NavierStokesCoupledSolver	Solvers/Solvers.h	/^NavierStokesCoupledSolver {$/;"	c
NavierStokesCoupledSolver	Solvers/Solvers.h	/^NavierStokesCoupledSolver<5> {$/;"	c
NavierStokesCoupledSolver	Solvers/Solvers.h	/^NavierStokesCoupledSolver<6> {$/;"	c
NavierStokesCoupledSolver	Solvers/Solvers.h	/^NavierStokesCoupledSolver<7> {$/;"	c
NavierStokesEmbedded	Solvers/Solvers.h	/^NavierStokesEmbedded {$/;"	c
NavierStokesEmbeddedCoupledSolver	Solvers/Solvers.h	/^NavierStokesEmbeddedCoupledSolver {$/;"	c
NavierStokesEmbeddedSegSolver	Solvers/Solvers.h	/^NavierStokesEmbeddedSegSolver {$/;"	c
NavierStokesMultiPhysicsEmbedded	Solvers/Solvers.h	/^NavierStokesMultiPhysicsEmbedded {$/;"	c
NavierStokesSegSolver	Solvers/Solvers.h	/^NavierStokesSegSolver {$/;"	c
NavierStokesTerm	NavierStokesTerm.h	/^NavierStokesTerm::NavierStokesTerm(IoData &iod, VarFcn *vf) : varFcn(vf)$/;"	f	class:NavierStokesTerm
NavierStokesTerm	NavierStokesTerm.h	/^class NavierStokesTerm {$/;"	c
Negative_Cell_Fraction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.cpp	/^Negative_Cell_Fraction(const T phi_lower_left,const T phi_lower_right,const T phi_upper_left,const T phi_upper_right,const T aspect_ratio)$/;"	f	class:LEVELSET_UTILITIES
NeighborDomain	MultiGridLevel.h	/^struct NeighborDomain {$/;"	s
New	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    T* New() \/\/ memory will be freed by Delete_All (do not use delete!)$/;"	f	class:PhysBAM::POINTER_POOL
Newton	Manual/Aerof3d.html	/^<a name="Newton"><\/a>$/;"	a
NewtonData	IoData.C	/^NewtonData<GenericKrylov>::NewtonData()$/;"	f	class:NewtonData
NewtonData	IoData.h	/^struct NewtonData {$/;"	s
NewtonSolver	NewtonSolver.h	/^NewtonSolver<ProblemDescriptor>::NewtonSolver(ProblemDescriptor *prbd) : $/;"	f	class:NewtonSolver
NewtonSolver	NewtonSolver.h	/^class NewtonSolver {$/;"	c
Newton_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Newton_Root(NONLINEAR_FUNCTION<T(T)>& F,T x0)$/;"	f	class:ITERATIVE_SOLVER
Next	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    void Next()$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
Next_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int Next_Index(const int h) const \/\/ linear probing$/;"	f	class:PhysBAM::HASHTABLE
Next_Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int Next_Resize() const$/;"	f	class:PhysBAM::HASHTABLE
Ni	DistDynamicLESTerm.h	/^  DistVec<int> *Ni;$/;"	m	class:DistDynamicLESTerm
Ni	LevelSet/LevelSetStructure.h	/^	   double Ni() const { return *xip; }$/;"	f	class:LevelSetResult::iterator
NoShift	arpack++/include/arrgeig.h	/^inline void ARrcGenEig<ARFLOAT, ARTYPE>::NoShift()$/;"	f	class:ARrcGenEig
NoShift	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::NoShift()$/;"	f	class:ARrcStdEig
NoTrace	arpack++/include/arrseig.h	/^  void NoTrace() { TraceOff(); }$/;"	f	class:ARrcStdEig
NodalGrad	NodalGrad.h	/^  NodalGrad(SVec<Scalar,dim> &dx, SVec<Scalar,dim> &dy, SVec<Scalar,dim> &dz, $/;"	f	class:NodalGrad
NodalGrad	NodalGrad.h	/^  NodalGrad(SVec<Scalar,dim> &dx, SVec<Scalar,dim> &dy, SVec<Scalar,dim> &dz,$/;"	f	class:NodalGrad
NodalGrad	NodalGrad.h	/^class NodalGrad {$/;"	c
Node	IoData.h	/^    Node() { id = -1; locationX = locationY = locationZ = -1.0e20; subId = localNodeId = -1;$/;"	f	struct:Probes::Node
Node	IoData.h	/^  struct Node { $/;"	s	struct:Probes
Node	RTree.h	/^	struct Node $/;"	s	class:RTree
NodeSet	Node.h	/^  NodeSet(int n) : SVec<double,3>(n) {}$/;"	f	class:NodeSet
NodeSet	Node.h	/^class NodeSet : public SVec<double,3> {$/;"	c
NodeToElem	SubDomain.h	/^  Connectivity *NodeToElem;$/;"	m	class:SubDomain
NodeToNode	SubDomain.h	/^  Connectivity *NodeToNode;$/;"	m	class:SubDomain
NodeToSubD	SubDomain.h	/^  Connectivity *NodeToSubD;$/;"	m	class:SubDomain
Node_In_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    bool Node_In_Segment(const int node,const int segment) const$/;"	f	class:PhysBAM::SEGMENT_MESH
Node_In_Simplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    bool Node_In_Simplex(const int node,const int simplex) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Node_In_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    bool Node_In_Triangle(const int node,const int triangle_index) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
Node_Weights	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    template<class T> static VECTOR<T,d> Node_Weights(const VECTOR<int,d+1>& simplex_nodes,const int node)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Nodes_In_Simplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    bool Nodes_In_Simplex(const VECTOR<int,d2>& nodes,const int simplex) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
NonRecursive	IoData.h	/^  enum Mode {Recursive = 1, NonRecursive = 2} mode;$/;"	e	enum:DefoMeshMotionData::Mode
NonSym	Communicator.h	/^  enum Symmetry { Sym, NonSym };$/;"	e	enum:CommPattern::Symmetry
NonZeros	arpack++/include/arhbmat.h	/^  int NonZeros() { return nnz; }$/;"	f	class:ARhbMatrix
Non_Manifold_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Non_Manifold_Nodes(ARRAY<int>& node_list)$/;"	f	class:TRIANGLE_MESH
NonlinearRom	NonlinearRom.C	/^NonlinearRom<dim>::NonlinearRom(Communicator *_com, IoData &_ioData, Domain &_domain)  : $/;"	f	class:NonlinearRom
NonlinearRom	NonlinearRom.h	/^class NonlinearRom {$/;"	c
NonlinearRomDatabaseConstruction	NonlinearRomDatabaseConstruction.C	/^NonlinearRomDatabaseConstruction<dim>::NonlinearRomDatabaseConstruction(Communicator* _com, IoData& _ioData, Domain& _domain, GeoSource& _geoSource)  : $/;"	f	class:NonlinearRomDatabaseConstruction
NonlinearRomDatabaseConstruction	NonlinearRomDatabaseConstruction.h	/^class NonlinearRomDatabaseConstruction : public NonlinearRomOnlineII<dim> {$/;"	c
NonlinearRomDirectoriesData	IoData.h	/^struct NonlinearRomDirectoriesData {$/;"	s
NonlinearRomDirectoriesData	IoDataCore.C	/^NonlinearRomDirectoriesData::NonlinearRomDirectoriesData()$/;"	f	class:NonlinearRomDirectoriesData
NonlinearRomFileSystemData	IoData.h	/^struct NonlinearRomFileSystemData {$/;"	s
NonlinearRomFileSystemData	IoDataCore.C	/^NonlinearRomFileSystemData::NonlinearRomFileSystemData()$/;"	f	class:NonlinearRomFileSystemData
NonlinearRomFilesData	IoData.h	/^struct NonlinearRomFilesData {$/;"	s
NonlinearRomFilesData	IoDataCore.C	/^NonlinearRomFilesData::NonlinearRomFilesData()$/;"	f	class:NonlinearRomFilesData
NonlinearRomOfflineData	IoData.h	/^struct NonlinearRomOfflineData {$/;"	s
NonlinearRomOfflineData	IoDataCore.C	/^NonlinearRomOfflineData::NonlinearRomOfflineData()$/;"	f	class:NonlinearRomOfflineData
NonlinearRomOfflineSolver	NonlinearRomOffline.C	/^NonlinearRomOfflineSolver<dim>::NonlinearRomOfflineSolver(Communicator *_com, IoData &_ioData, Domain &dom, GeoSource &_geoSource) :$/;"	f	class:NonlinearRomOfflineSolver
NonlinearRomOfflineSolver	NonlinearRomOffline.h	/^class NonlinearRomOfflineSolver {$/;"	c
NonlinearRomOnlineData	IoData.h	/^struct NonlinearRomOnlineData {$/;"	s
NonlinearRomOnlineData	IoDataCore.C	/^NonlinearRomOnlineData::NonlinearRomOnlineData()$/;"	f	class:NonlinearRomOnlineData
NonlinearRomOnlineII	NonlinearRomOnlineII.C	/^NonlinearRomOnlineII<dim>::NonlinearRomOnlineII(Communicator* _com, IoData& _ioData, Domain& _domain, std::vector<double>* _weights)  : $/;"	f	class:NonlinearRomOnlineII
NonlinearRomOnlineII	NonlinearRomOnlineII.h	/^class NonlinearRomOnlineII : public NonlinearRom<dim> {$/;"	c
NonlinearRomOnlineIII	NonlinearRomOnlineIII.C	/^NonlinearRomOnlineIII<dim>::NonlinearRomOnlineIII(Communicator* _com, IoData& _ioData, Domain& _domain, std::vector<double>* _weights)  : $/;"	f	class:NonlinearRomOnlineIII
NonlinearRomOnlineIII	NonlinearRomOnlineIII.h	/^class NonlinearRomOnlineIII : public NonlinearRom<dim> {$/;"	c
NonlinearRomOnlineNonStateData	IoData.h	/^struct NonlinearRomOnlineNonStateData {$/;"	s
NonlinearRomOnlineNonStateData	IoDataCore.C	/^NonlinearRomOnlineNonStateData::NonlinearRomOnlineNonStateData()$/;"	f	class:NonlinearRomOnlineNonStateData
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	/^Normal(const TV& X) const$/;"	f	class:BOX
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	/^Normal(const int aggregate) const$/;"	f	class:BOX
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    TV Normal(const TV&) const$/;"	f	class:PhysBAM::LINE_2D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Normal(const TV& X) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    TV Normal() const$/;"	f	class:PhysBAM::PLANE
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    TV Normal(const TV& X) const$/;"	f	class:PhysBAM::PLANE
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    static TV Normal(const TV& x1,const TV& x2,const TV& x3)$/;"	f	class:PhysBAM::PLANE
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    static TV Normal(const T_ARRAY& X)$/;"	f	class:PhysBAM::PLANE
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    TV Normal() const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    static TV Normal(const TV& x1,const int direction)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV Normal() const$/;"	f	class:PhysBAM::SEGMENT_2D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Normal(const TV& x1,const TV& x2) $/;"	f	class:PhysBAM::SEGMENT_2D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Normal(const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    static VECTOR<T,3> Normal(const VECTOR<T,3>& x1,const VECTOR<T,3>& x2,const VECTOR<T,3>& x3) $/;"	f	class:PhysBAM::SEGMENT_3D
Normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> TV IMPLICIT_OBJECT<TV>::Normal(const TV& location,const int aggregate) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Normal_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    static TV Normal_Direction(const TV& x1,const TV& x2,const TV& x3)$/;"	f	class:PhysBAM::PLANE
Normal_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    static TV Normal_Direction(const T_ARRAY& X)$/;"	f	class:PhysBAM::PLANE
Normal_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    static VECTOR<T,3> Normal_Direction(const VECTOR<T,3>& x1,const VECTOR<T,3>& x2,const VECTOR<T,3>& x3) $/;"	f	class:PhysBAM::SEGMENT_3D
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,n> Normal_Equations_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Normal_Equations_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Normal_Equations_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Normal_Equations_Matrix() const \/\/ 1 mult$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX<T,2> Normal_Equations_Matrix() const$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    SYMMETRIC_MATRIX<T,2> Normal_Equations_Matrix() const \/\/ 6 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    SYMMETRIC_MATRIX<T,2> Normal_Equations_Matrix() const \/\/ 9 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Normal_Equations_Matrix() const \/\/ 18 mults, 12 adds$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Normal_Equations_Matrix() const$/;"	f	class:PhysBAM::MATRIX_MXN
Normal_Equations_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    VECTOR<T,n> Normal_Equations_Solve(const VECTOR<T,m>& b) const$/;"	f	class:PhysBAM::MATRIX
Normal_Equations_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    VECTOR_ND<T> Normal_Equations_Solve(const VECTOR_ND<T>& b) const$/;"	f	class:PhysBAM::MATRIX_MXN
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    T Normalize()$/;"	f	class:PhysBAM::QUATERNION
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    T Normalize()$/;"	f	class:PhysBAM::ROTATION
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    T Normalize()$/;"	f	class:PhysBAM::COMPLEX
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    T Normalize()$/;"	f	class:PhysBAM::VECTOR
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Normalize()$/;"	f	class:PhysBAM::VECTOR
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Normalize()$/;"	f	class:PhysBAM::VECTOR
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Normalize()$/;"	f	class:PhysBAM::VECTOR
Normalize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Normalize()$/;"	f	class:PhysBAM::VECTOR_BASE
NormalizeSnaps	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	g	struct:SnapshotsData
NormalizeSnaps	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	g	struct:StateSnapshotsData
Normalize_Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    void Normalize_Columns()$/;"	f	class:PhysBAM::MATRIX
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION Normalized() const$/;"	f	class:PhysBAM::QUATERNION
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION<TV> Normalized() const$/;"	f	class:PhysBAM::ROTATION
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Normalized() const$/;"	f	class:PhysBAM::COMPLEX
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR Normalized() const$/;"	f	class:PhysBAM::VECTOR
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR Normalized() const$/;"	f	class:PhysBAM::VECTOR
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Normalized() const$/;"	f	class:PhysBAM::VECTOR
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Normalized() const \/\/ 6 mults, 2 adds, 1 div, 1 sqrt$/;"	f	class:PhysBAM::VECTOR
Normalized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T_VECTOR Normalized() const$/;"	f	class:PhysBAM::VECTOR_BASE
Normals	IoData.h	/^  enum Normals {AUTO = 0, IMPLICIT_FIRST_ORDER_GCL = 1, IMPLICIT_SECOND_ORDER_GCL = 2,$/;"	g	struct:DGCLData
Not_Implemented	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Not_Implemented(const char* function,const char* file,unsigned int line)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Not_Implemented	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Not_Implemented(const char* function,const char* file,unsigned int line,const char* message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Not_Implemented	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Not_Implemented(const char* function,const char* file,unsigned int line,const std::string& message)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Nriemann	MatVecProd.h	/^    int Nriemann;$/;"	m	struct:MatVecProd::_fsi
Nriemann	MatVecProd.h	/^    int Nriemann;$/;"	m	struct:MatVecProdMultiPhase::_fsi
NumElems	TriangulatedInterface.C	/^int TriangulatedInterface::NumElems() {$/;"	f	class:TriangulatedInterface
NumLines	MultiGridLevel.h	/^    int NumLines(int iSub) const { return numLines[iSub]; }$/;"	f	class:MultiGridLevel
NumNodes	TriangulatedInterface.C	/^int TriangulatedInterface::NumNodes() {$/;"	f	class:TriangulatedInterface
NumberOfGeneralizedCoordinates	AutoDiff/Function.h	/^           NumberOfGeneralizedCoordinates = _NumberOfGeneralizedCoordinates,$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfGeneralizedCoordinates	AutoDiff/Function.h	/^           NumberOfGeneralizedCoordinates = _NumberOfGeneralizedCoordinates,$/;"	e	enum:ScalarValuedFunction::__anon1
NumberOfGeneralizedCoordinates	AutoDiff/Function.h	/^           NumberOfGeneralizedCoordinates = _NumberOfGeneralizedCoordinates,$/;"	e	enum:VectorValuedFunction::__anon2
NumberOfGeneralizedCoordinates	AutoDiff/SpaceDerivatives.h	/^           NumberOfGeneralizedCoordinates  = InputNumberOfRows*InputNumberOfColumns,$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
NumberOfGeneralizedCoordinates	AutoDiff/SpaceDerivatives.h	/^           NumberOfGeneralizedCoordinates = MatrixValuedFunctionBase::NumberOfGeneralizedCoordinates,$/;"	e	enum:Jacobian::__anon6
NumberOfIntegerConstants	AutoDiff/Function.h	/^           NumberOfIntegerConstants       = _NumberOfIntegerConstants$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfIntegerConstants	AutoDiff/Function.h	/^           NumberOfIntegerConstants       = _NumberOfIntegerConstants$/;"	e	enum:ScalarValuedFunction::__anon1
NumberOfIntegerConstants	AutoDiff/Function.h	/^           NumberOfIntegerConstants       = _NumberOfIntegerConstants$/;"	e	enum:VectorValuedFunction::__anon2
NumberOfIntegerConstants	AutoDiff/SpaceDerivatives.h	/^           NumberOfIntegerConstants        = FunctionTemplate<Scalar>::NumberOfIntegerConstants,$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
NumberOfIntegerConstants	AutoDiff/SpaceDerivatives.h	/^           NumberOfIntegerConstants = MatrixValuedFunctionBase::NumberOfIntegerConstants,$/;"	e	enum:Jacobian::__anon6
NumberOfScalarConstants	AutoDiff/Function.h	/^           NumberOfScalarConstants        = _NumberOfScalarConstants,$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfScalarConstants	AutoDiff/Function.h	/^           NumberOfScalarConstants        = _NumberOfScalarConstants,$/;"	e	enum:ScalarValuedFunction::__anon1
NumberOfScalarConstants	AutoDiff/Function.h	/^           NumberOfScalarConstants        = _NumberOfScalarConstants,$/;"	e	enum:VectorValuedFunction::__anon2
NumberOfScalarConstants	AutoDiff/SpaceDerivatives.h	/^           NumberOfScalarConstants         = FunctionTemplate<Scalar>::NumberOfScalarConstants,$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
NumberOfScalarConstants	AutoDiff/SpaceDerivatives.h	/^           NumberOfScalarConstants  = MatrixValuedFunctionBase::NumberOfScalarConstants,$/;"	e	enum:Jacobian::__anon6
NumberOfValues	AutoDiff/Function.h	/^           NumberOfValues                 = 1,$/;"	e	enum:ScalarValuedFunction::__anon1
NumberOfValues	AutoDiff/Function.h	/^           NumberOfValues                 = _NumberOfValues,$/;"	e	enum:VectorValuedFunction::__anon2
NumberOfValues	AutoDiff/Function.h	/^           NumberOfValues                 = _NumberOfValuesPerColumn*_NumberOfValuesPerRow,$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfValues	AutoDiff/SpaceDerivatives.h	/^           NumberOfValues                  = FunctionTemplate<Scalar>::NumberOfValues*NumberOfGeneralizedCoordinates$/;"	e	enum:FirstPartialSpaceDerivatives::__anon5
NumberOfValues	AutoDiff/SpaceDerivatives.h	/^           NumberOfValues           = NumberOfValuesPerRow*NumberOfValuesPerColumn$/;"	e	enum:Jacobian::__anon6
NumberOfValuesPerColumn	AutoDiff/Function.h	/^           NumberOfValuesPerColumn        = _NumberOfValuesPerColumn,$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfValuesPerColumn	AutoDiff/SpaceDerivatives.h	/^           NumberOfValuesPerColumn  = MatrixValuedFunctionBase::NumberOfValuesPerColumn,$/;"	e	enum:Jacobian::__anon6
NumberOfValuesPerRow	AutoDiff/Function.h	/^           NumberOfValuesPerRow           = _NumberOfValuesPerRow,$/;"	e	enum:MatrixValuedFunction::__anon3
NumberOfValuesPerRow	AutoDiff/SpaceDerivatives.h	/^           NumberOfValuesPerRow     = MatrixValuedFunctionBase::NumberOfValuesPerRow,$/;"	e	enum:Jacobian::__anon6
Number_False	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    int Number_False() const$/;"	f	class:PhysBAM::ARRAY_BASE
Number_Of_Arrays	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    ID Number_Of_Arrays() const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Number_Of_Nodes_With_Minimum_Valence	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Number_Of_Nodes_With_Minimum_Valence()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Number_Of_Nonzero_Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.cpp	/^Number_Of_Nonzero_Rows(const T threshold) const$/;"	f	class:MATRIX_BASE
Number_To_String	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Number_To_String(const int i)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    int Number_True() const$/;"	f	class:PhysBAM::ARRAY_BASE
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    int Number_True() const$/;"	f	class:PhysBAM::ARRAY_BASE
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    int Number_True() const$/;"	f	class:PhysBAM::VECTOR
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Number_True() const$/;"	f	class:PhysBAM::VECTOR
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Number_True() const$/;"	f	class:PhysBAM::VECTOR
Number_True	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Number_True() const$/;"	f	class:PhysBAM::VECTOR
NumberingMap	RestrictionMapping.h	/^  typedef std::map<int, int> NumberingMap;$/;"	t	class:RestrictionMapping
OCT_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
ODEIntegrator	ODEIntegrator.h	/^  ODEIntegrator(double _t0, double _tfinal, int _n) {$/;"	f	class:ODEIntegrator
ODEIntegrator	ODEIntegrator.h	/^class ODEIntegrator {$/;"	c
OFF	IoData.h	/^  enum CrackingWithLevelSet {OFF = 0, ON = 1} crackingWithLevelset;$/;"	e	enum:EmbeddedFramework::CrackingWithLevelSet
OFF	IoData.h	/^  enum DualTimeStepping {OFF = 0, ON = 1} dualtimestepping;$/;"	e	enum:TsData::DualTimeStepping
OFF	IoData.h	/^  enum SolveFluid {OFF = 0, ON = 1} solvefluid;$/;"	e	enum:ProblemData::SolveFluid
OFF	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:BFixData::__anon10
OFF	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:CFixData::__anon8
OFF	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:SFixData::__anon9
OFF_ADAPTIVEEPSFSI	IoData.h	/^  enum AdaptiveEpsFSI {OFF_ADAPTIVEEPSFSI = 0, ON_ADAPTIVEEPSFSI = 1} adaptiveEpsFSI;$/;"	e	enum:SensitivityAnalysis::AdaptiveEpsFSI
OFF_ANGLERAD	IoData.h	/^  enum AngleRadians {OFF_ANGLERAD = 0, ON_ANGLERAD = 1} angleRad;$/;"	e	enum:SensitivityAnalysis::AngleRadians
OFF_COMPATIBLE3D	IoData.h	/^  enum Compatible3D {OFF_COMPATIBLE3D = 0, ON_COMPATIBLE3D = 1} comp3d;$/;"	e	enum:SensitivityAnalysis::Compatible3D
OFF_EXACTSOLUTION	IoData.h	/^  enum ExactSolution {OFF_EXACTSOLUTION = 0, ON_EXACTSOLUTION = 1} excsol;$/;"	e	enum:SensitivityAnalysis::ExactSolution
OFF_HOMOTOPY	IoData.h	/^  enum HomotopyComputation {OFF_HOMOTOPY = 0, ON_HOMOTOPY = 1} homotopy;$/;"	e	enum:SensitivityAnalysis::HomotopyComputation
OFF_SENSITIVITYALPHA	IoData.h	/^  enum SensitivityAOA {OFF_SENSITIVITYALPHA = 0, ON_SENSITIVITYALPHA = 1} sensAlpha;$/;"	e	enum:SensitivityAnalysis::SensitivityAOA
OFF_SENSITIVITYBETA	IoData.h	/^  enum SensitivityYAW {OFF_SENSITIVITYBETA = 0, ON_SENSITIVITYBETA = 1} sensBeta;$/;"	e	enum:SensitivityAnalysis::SensitivityYAW
OFF_SENSITIVITYFSI	IoData.h	/^  enum SensitivityFSI  {OFF_SENSITIVITYFSI  = 0, ON_SENSITIVITYFSI  = 1} sensFSI;$/;"	e	enum:SensitivityAnalysis::SensitivityFSI
OFF_SENSITIVITYLIFTX	IoData.h	/^  enum SensitivityLiftx {OFF_SENSITIVITYLIFTX = 0, ON_SENSITIVITYLIFTX = 1} sensLiftx;$/;"	e	enum:SensitivityAnalysis::SensitivityLiftx
OFF_SENSITIVITYLIFTY	IoData.h	/^  enum SensitivityLifty {OFF_SENSITIVITYLIFTY = 0, ON_SENSITIVITYLIFTY = 1} sensLifty;$/;"	e	enum:SensitivityAnalysis::SensitivityLifty
OFF_SENSITIVITYLIFTZ	IoData.h	/^  enum SensitivityLiftz {OFF_SENSITIVITYLIFTZ = 0, ON_SENSITIVITYLIFTZ = 1} sensLiftz;$/;"	e	enum:SensitivityAnalysis::SensitivityLiftz
OFF_SENSITIVITYMACH	IoData.h	/^  enum SensitivityMach {OFF_SENSITIVITYMACH = 0, ON_SENSITIVITYMACH = 1} sensMach;$/;"	e	enum:SensitivityAnalysis::SensitivityMach
OFF_SENSITIVITYMESH	IoData.h	/^  enum SensitivityMesh {OFF_SENSITIVITYMESH = 0, ON_SENSITIVITYMESH = 1} sensMesh;$/;"	e	enum:SensitivityAnalysis::SensitivityMesh
OIBEI	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	e	enum:LinearizedData::ErrorIndicator
OLD	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
ON	IoData.h	/^  enum CrackingWithLevelSet {OFF = 0, ON = 1} crackingWithLevelset;$/;"	e	enum:EmbeddedFramework::CrackingWithLevelSet
ON	IoData.h	/^  enum DualTimeStepping {OFF = 0, ON = 1} dualtimestepping;$/;"	e	enum:TsData::DualTimeStepping
ON	IoData.h	/^  enum SolveFluid {OFF = 0, ON = 1} solvefluid;$/;"	e	enum:ProblemData::SolveFluid
ON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:BFixData::__anon10
ON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:CFixData::__anon8
ON	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	e	enum:SFixData::__anon9
ONE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^struct ONE$/;"	s	namespace:PhysBAM
ONE_BLOCK_RK2	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	e	enum:ExplicitData::Type
ONE_BLOCK_RK2bis	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	e	enum:ExplicitData::Type
ONE_EQUATION_DES	IoData.h	/^  enum Type {ONE_EQUATION_SPALART_ALLMARAS = 0, ONE_EQUATION_DES = 1, TWO_EQUATION_KE = 2} type;$/;"	e	enum:TurbulenceModelData::Type
ONE_EQUATION_SPALART_ALLMARAS	IoData.h	/^  enum Type {ONE_EQUATION_SPALART_ALLMARAS = 0, ONE_EQUATION_DES = 1, TWO_EQUATION_KE = 2} type;$/;"	e	enum:TurbulenceModelData::Type
ON_ADAPTIVEEPSFSI	IoData.h	/^  enum AdaptiveEpsFSI {OFF_ADAPTIVEEPSFSI = 0, ON_ADAPTIVEEPSFSI = 1} adaptiveEpsFSI;$/;"	e	enum:SensitivityAnalysis::AdaptiveEpsFSI
ON_ANGLERAD	IoData.h	/^  enum AngleRadians {OFF_ANGLERAD = 0, ON_ANGLERAD = 1} angleRad;$/;"	e	enum:SensitivityAnalysis::AngleRadians
ON_COMPATIBLE3D	IoData.h	/^  enum Compatible3D {OFF_COMPATIBLE3D = 0, ON_COMPATIBLE3D = 1} comp3d;$/;"	e	enum:SensitivityAnalysis::Compatible3D
ON_EXACTSOLUTION	IoData.h	/^  enum ExactSolution {OFF_EXACTSOLUTION = 0, ON_EXACTSOLUTION = 1} excsol;$/;"	e	enum:SensitivityAnalysis::ExactSolution
ON_HOMOTOPY	IoData.h	/^  enum HomotopyComputation {OFF_HOMOTOPY = 0, ON_HOMOTOPY = 1} homotopy;$/;"	e	enum:SensitivityAnalysis::HomotopyComputation
ON_SENSITIVITYALPHA	IoData.h	/^  enum SensitivityAOA {OFF_SENSITIVITYALPHA = 0, ON_SENSITIVITYALPHA = 1} sensAlpha;$/;"	e	enum:SensitivityAnalysis::SensitivityAOA
ON_SENSITIVITYBETA	IoData.h	/^  enum SensitivityYAW {OFF_SENSITIVITYBETA = 0, ON_SENSITIVITYBETA = 1} sensBeta;$/;"	e	enum:SensitivityAnalysis::SensitivityYAW
ON_SENSITIVITYFSI	IoData.h	/^  enum SensitivityFSI  {OFF_SENSITIVITYFSI  = 0, ON_SENSITIVITYFSI  = 1} sensFSI;$/;"	e	enum:SensitivityAnalysis::SensitivityFSI
ON_SENSITIVITYLIFTX	IoData.h	/^  enum SensitivityLiftx {OFF_SENSITIVITYLIFTX = 0, ON_SENSITIVITYLIFTX = 1} sensLiftx;$/;"	e	enum:SensitivityAnalysis::SensitivityLiftx
ON_SENSITIVITYLIFTY	IoData.h	/^  enum SensitivityLifty {OFF_SENSITIVITYLIFTY = 0, ON_SENSITIVITYLIFTY = 1} sensLifty;$/;"	e	enum:SensitivityAnalysis::SensitivityLifty
ON_SENSITIVITYLIFTZ	IoData.h	/^  enum SensitivityLiftz {OFF_SENSITIVITYLIFTZ = 0, ON_SENSITIVITYLIFTZ = 1} sensLiftz;$/;"	e	enum:SensitivityAnalysis::SensitivityLiftz
ON_SENSITIVITYMACH	IoData.h	/^  enum SensitivityMach {OFF_SENSITIVITYMACH = 0, ON_SENSITIVITYMACH = 1} sensMach;$/;"	e	enum:SensitivityAnalysis::SensitivityMach
ON_SENSITIVITYMESH	IoData.h	/^  enum SensitivityMesh {OFF_SENSITIVITYMESH = 0, ON_SENSITIVITYMESH = 1} sensMesh;$/;"	e	enum:SensitivityAnalysis::SensitivityMesh
OR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b1,bool b2,bool b3=false,bool b4=false> struct OR {static const bool value=b1 || b2 || b3 || b4;};$/;"	s	namespace:PhysBAM
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef BOX<VECTOR<T,1> > ORIENTED_BOX;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef PhysBAM::ORIENTED_BOX<VECTOR<T,2> > ORIENTED_BOX;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef PhysBAM::ORIENTED_BOX<VECTOR<T,3> > ORIENTED_BOX;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX()$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const RANGE<TV>& box,const FRAME<TV>& frame)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const RANGE<TV>& box,const MATRIX<T,d+1>& transform)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const RANGE<TV>& box,const ROTATION<TV>& rotation)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const RANGE<TV>& box,const ROTATION<TV>& rotation,const TV& corner_input)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const TV& corner_input,const MATRIX<T,d>& edges_input)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const TV& corner_input,const TV& edge1_input,const TV& edge2_input)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX(const TV& corner_input,const TV& edge1_input,const TV& edge2_input,const TV& edge3_input)$/;"	f	class:PhysBAM::ORIENTED_BOX
ORIENTED_BOX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^class ORIENTED_BOX$/;"	c	namespace:PhysBAM
ORIGINAL	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	e	enum:DESModelData::Form
ORIGINAL	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	e	enum:SAModelData::Form
OUTPUT_ONLY_SPATIAL_RES_OFF	IoData.h	/^  enum OutputOnlySpatialResidual {OUTPUT_ONLY_SPATIAL_RES_OFF = 0, OUTPUT_ONLY_SPATIAL_RES_ON = 1} outputOnlySpatialResidual;$/;"	e	enum:ROMOutputData::OutputOnlySpatialResidual
OUTPUT_ONLY_SPATIAL_RES_ON	IoData.h	/^  enum OutputOnlySpatialResidual {OUTPUT_ONLY_SPATIAL_RES_OFF = 0, OUTPUT_ONLY_SPATIAL_RES_ON = 1} outputOnlySpatialResidual;$/;"	e	enum:ROMOutputData::OutputOnlySpatialResidual
OUTPUT_REDUCED_BASES_FALSE	IoData.h	/^  enum OutputReducedBases {OUTPUT_REDUCED_BASES_FALSE = 0, OUTPUT_REDUCED_BASES_TRUE = 1} outputReducedBases;$/;"	e	enum:GappyConstructionData::OutputReducedBases
OUTPUT_REDUCED_BASES_TRUE	IoData.h	/^  enum OutputReducedBases {OUTPUT_REDUCED_BASES_FALSE = 0, OUTPUT_REDUCED_BASES_TRUE = 1} outputReducedBases;$/;"	e	enum:GappyConstructionData::OutputReducedBases
OUTSIDE	IntersectorFRG/IntersectorFRG.C	/^const int IntersectorFRG::UNDECIDED, IntersectorFRG::INSIDE, IntersectorFRG::OUTSIDE;$/;"	m	class:IntersectorFRG	file:
OUTSIDE	IntersectorFRG/IntersectorFRG.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: ~~$/;"	m	class:IntersectorFRG
OUTSIDE	IntersectorPhysBAM/IntersectorPhysBAM.C	/^const int IntersectorPhysBAM::UNDECIDED, IntersectorPhysBAM::INSIDE, IntersectorPhysBAM::OUTSIDE;$/;"	m	class:IntersectorPhysBAM	file:
OUTSIDE	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: not a fluid$/;"	m	class:IntersectorPhysBAM
OUTSIDECOLOR	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::OUTSIDECOLOR;$/;"	m	class:IntersectorFRG	file:
OUTSIDECOLOR	IntersectorFRG/IntersectorFRG.h	/^    static int OUTSIDECOLOR;$/;"	m	class:IntersectorFRG
OUTSIDECOLOR	IntersectorPhysBAM/IntersectorPhysBAM.C	/^int IntersectorPhysBAM::OUTSIDECOLOR;$/;"	m	class:IntersectorPhysBAM	file:
OUTSIDECOLOR	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    static int OUTSIDECOLOR;$/;"	m	class:IntersectorPhysBAM
OVERWRITE_OFF	IoData.h	/^  enum OverwriteNonlinearSnaps {OVERWRITE_OFF = 0, OVERWRITE_ON = 1} overwriteNonlinearSnaps;$/;"	e	enum:ROMOutputData::OverwriteNonlinearSnaps
OVERWRITE_ON	IoData.h	/^  enum OverwriteNonlinearSnaps {OVERWRITE_OFF = 0, OVERWRITE_ON = 1} overwriteNonlinearSnaps;$/;"	e	enum:ROMOutputData::OverwriteNonlinearSnaps
Object-oriented-input	Manual/Aerof3d.html	/^<a name="Object-oriented-input"><\/a>$/;"	a
ObjectMap	IoData.h	/^class ObjectMap {$/;"	c
Objects	Manual/Aerof3d.html	/^<a name="Objects"><\/a>$/;"	a
OffType	BinFileHandler.h	/^  typedef long long OffType; $/;"	t	class:BinFileHandler
Offset_If_Contiguous	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    static ID Offset_If_Contiguous(const ARRAY_PLUS_SCALAR<int,T_INDICES_2>& indices)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
Offset_If_Contiguous	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    static ID Offset_If_Contiguous(const IDENTITY_ARRAY<ID>& indices) \/\/ for contiguous indices, we can extract an offset$/;"	f	class:PhysBAM::INDIRECT_ARRAY
One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^    static ONE One()$/;"	f	struct:PhysBAM::ONE
One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    static QUATERNION One()$/;"	f	class:PhysBAM::QUATERNION
One	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    static COMPLEX<T> One()$/;"	f	class:PhysBAM::COMPLEX
OneDimensional	OneDimensionalSolver.C	/^OneDimensional::OneDimensional(int np,double* mesh,IoData &ioData, Domain *domain) : $/;"	f	class:OneDimensional
OneDimensional	OneDimensionalSolver.h	/^class OneDimensional {$/;"	c
OneDimensionalInfo	IoData.h	/^struct OneDimensionalInfo {$/;"	s
OneDimensionalInfo	IoDataCore.C	/^OneDimensionalInfo::OneDimensionalInfo(){$/;"	f	class:OneDimensionalInfo
OneDimensionalInputData	IoData.h	/^struct OneDimensionalInputData {$/;"	s
OneDimensionalInputData	IoDataCore.C	/^OneDimensionalInputData::OneDimensionalInputData() {$/;"	f	class:OneDimensionalInputData
OneDimensionalInterpolator	OneDimensionalInterpolator.h	/^class OneDimensionalInterpolator {$/;"	c
OneDimensionalSourceTerm	OneDimensionalSourceTerm.h	/^  OneDimensionalSourceTerm() { logr1r0 = 0; pow_ry_k = pow_ri_k = 0; }$/;"	f	class:OneDimensionalSourceTerm
OneDimensionalSourceTerm	OneDimensionalSourceTerm.h	/^class OneDimensionalSourceTerm {$/;"	c
Op	DistVectorOp.h	/^  static void Op(DistSVec<Scalar1,dim1>& v1,DistSVec<Scalar2,dim2>& v2,$/;"	f	class:DistVectorOp
OptimalPressureDimensionality	IoData.h	/^  enum OptimalPressureDimensionality {NON_DIMENSIONAL=0, DIMENSIONAL=1,NONE=2} optPressureDim;$/;"	g	struct:InputData
Orientations_Consistent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Orientations_Consistent()$/;"	f	class:TRIANGLE_MESH
Oriented_Angle_Between	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    static T Oriented_Angle_Between(const VECTOR& u,const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Orthogonal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Orthogonal_Vector() const$/;"	f	class:PhysBAM::VECTOR
Orthogonal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Orthogonal_Vector() const$/;"	f	class:PhysBAM::VECTOR
Other_Node	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    static int Other_Node(const VECTOR<int,d+1>& simplex_nodes,const VECTOR<int,d>& subsimplex_nodes)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Other_Node	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    int Other_Node(const int node1,const int node2,const int triangle) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
Other_Two_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Other_Two_Nodes(const int node,const int triangle,int& other_node1,int& other_node2) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
OuterProd	Vector.h	/^  OuterProd(Scalar yy, T aa, int l) : y(yy), a(aa) { len = l; }$/;"	f	class:OuterProd
OuterProd	Vector.h	/^class OuterProd {$/;"	c
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    static MATRIX Outer_Product(const VECTOR<T,m>& u,const VECTOR<T,n>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    static MATRIX Outer_Product(const VECTOR<T,0>& u,const VECTOR<T,0>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    static MATRIX Outer_Product(const VECTOR<T,0>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    static MATRIX Outer_Product(const VECTOR<T,0>& u,const VECTOR<T,0>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    static MATRIX Outer_Product(const VECTOR<T,0>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    static MATRIX Outer_Product(const VECTOR<T,1>& u)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    static MATRIX Outer_Product(const VECTOR<T,1>& u,const VECTOR<T,1>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    static MATRIX Outer_Product(const VECTOR<T,1>& u,const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Outer_Product(const VECTOR<T,2>& u,const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    static MATRIX Outer_Product(const VECTOR<T,3>& u,const VECTOR<T,2>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Outer_Product(const VECTOR<T,3>& u,const VECTOR<T,3>& v)$/;"	f	class:PhysBAM::MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    static MATRIX_MXN<T> Outer_Product(const VECTOR_ND<T> u,const VECTOR_ND<T> v)$/;"	f	class:PhysBAM::MATRIX_MXN
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Outer_Product(const VECTOR<T,2>& u)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Outer_Product(const VECTOR<T,3>& u) \/\/ 6 mults$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Outer_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    static DERIVED Outer_Product(const VECTOR<T,m>& u,const VECTOR<T,n>& v)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Outer_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    SYMMETRIC_MATRIX<T,2> Outer_Product_Matrix() const \/\/ 6 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
Outer_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Outer_Product_Matrix() const \/\/ 18 mults, 12 adds$/;"	f	class:PhysBAM::MATRIX
Outer_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX<T,2> Outer_Product_Matrix() const \/\/ 4 mults, 1 add$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Outlet	Manual/Aerof3d.html	/^<a name="Outlet"><\/a>$/;"	a
Output	Manual/Aerof3d.html	/^<a name="Output"><\/a>$/;"	a
OutputData	IoData.h	/^struct OutputData {$/;"	s
OutputData	IoDataCore.C	/^OutputData::OutputData()$/;"	f	class:OutputData
OutputOnlySpatialResidual	IoData.h	/^  enum OutputOnlySpatialResidual {OUTPUT_ONLY_SPATIAL_RES_OFF = 0, OUTPUT_ONLY_SPATIAL_RES_ON = 1} outputOnlySpatialResidual;$/;"	g	struct:ROMOutputData
OutputReducedBases	IoData.h	/^  enum OutputReducedBases {OUTPUT_REDUCED_BASES_FALSE = 0, OUTPUT_REDUCED_BASES_TRUE = 1} outputReducedBases;$/;"	g	struct:GappyConstructionData
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Outside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::LINE_2D
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Outside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::PLANE
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Outside(const TV& location,const T thickness_over_two) const$/;"	f	class:IMPLICIT_OBJECT
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Outside(const T& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool Outside(const T& location,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Outside(const TV& location,const T thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
Outside	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool Outside(const TV& location,const ZERO thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
OverV	arpack++/include/arrseig.h	/^  bool OverV() { return (EigVec == &V[1]); }$/;"	f	class:ARrcStdEig
Overview	Manual/Aerof3d.html	/^<a name="Overview"><\/a>$/;"	a
OverwriteNonlinearSnaps	IoData.h	/^  enum OverwriteNonlinearSnaps {OVERWRITE_OFF = 0, OVERWRITE_ON = 1} overwriteNonlinearSnaps;$/;"	g	struct:ROMOutputData
Owns_Data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    bool Owns_Data() const$/;"	f	class:PhysBAM::VECTOR_ND
P	HeatTransferHandler.h	/^  DistVec<double> P;$/;"	m	class:HeatTransferHandler
PAIR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    PAIR() $/;"	f	class:PhysBAM::PAIR
PAIR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    PAIR(const T1& x_input,const T2& y_input) $/;"	f	class:PhysBAM::PAIR
PAIR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^class PAIR$/;"	c	namespace:PhysBAM
PARAMETER_ERROR	arpack++/include/arerror.h	/^    PARAMETER_ERROR     = -101,$/;"	e	enum:ArpackError::ErrorCode
PARAMETRIC_LINE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    PARAMETRIC_LINE(const NONLINEAR_FUNCTION<R(T1,T2)>& f,const T1 x,const T2 y,const T1 a,const T2 b)$/;"	f	class:PhysBAM::PARAMETRIC_LINE
PARAMETRIC_LINE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^class PARAMETRIC_LINE<T,R(T1,T2)>:public NONLINEAR_FUNCTION<R(T)>$/;"	c	namespace:PhysBAM
PARSETREE_H_	parser/ParseTree.h	9;"	d
PART_UNDEFINED	arpack++/include/arerror.h	/^    PART_UNDEFINED      = -105,$/;"	e	enum:ArpackError::ErrorCode
PERFECTGAS	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	e	enum:VarFcnBase::Type
PERFECT_GAS	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	e	enum:FluidModelData::Fluid
PETROV_GALERKIN	IoData.h	/^  enum Projection {PETROV_GALERKIN = 0, GALERKIN = 1} projection;$/;"	e	enum:NonlinearRomOnlineData::Projection
PHI2D_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
PHILEVEL	PostFcn.h	/^                   PSENSOR = 14, MUT_OVER_MU = 15, PHILEVEL = 16,PHILEVEL2 = 17, DIFFPRESSURE = 18, $/;"	e	enum:PostFcn::ScalarType
PHILEVEL2	PostFcn.h	/^                   PSENSOR = 14, MUT_OVER_MU = 15, PHILEVEL = 16,PHILEVEL2 = 17, DIFFPRESSURE = 18, $/;"	e	enum:PostFcn::ScalarType
PHI_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
PHONEME_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
PHYSBAM	IoData.h	/^  enum IntersectorName {PHYSBAM = 0, FRG = 1} intersectorName;$/;"	e	enum:EmbeddedFramework::IntersectorName
PHYSBAM_ALWAYS_INLINE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	13;"	d
PHYSBAM_ALWAYS_INLINE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	21;"	d
PHYSBAM_ALWAYS_INLINE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	24;"	d
PHYSBAM_ASSERT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	31;"	d
PHYSBAM_CAT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	22;"	d
PHYSBAM_COMMA	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	27;"	d
PHYSBAM_DEBUG_FUNCTION_NAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	14;"	d
PHYSBAM_DEBUG_ONLY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	35;"	d
PHYSBAM_DEBUG_ONLY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	37;"	d
PHYSBAM_DEBUG_PRINT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	14;"	d
PHYSBAM_DEBUG_PRINT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	55;"	d
PHYSBAM_DEBUG_PRINT_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	53;"	d
PHYSBAM_DECLARE_ELEMENT_ID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	103;"	d
PHYSBAM_FATAL_ERROR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	28;"	d
PHYSBAM_FLATTEN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	14;"	d
PHYSBAM_FLATTEN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	22;"	d
PHYSBAM_FLATTEN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	25;"	d
PHYSBAM_FUNCTION_IS_NOT_DEFINED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	22;"	d
PHYSBAM_MAP	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	49;"	d
PHYSBAM_MAP_1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	34;"	d
PHYSBAM_MAP_10	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	43;"	d
PHYSBAM_MAP_11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	44;"	d
PHYSBAM_MAP_12	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	45;"	d
PHYSBAM_MAP_13	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	46;"	d
PHYSBAM_MAP_14	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	47;"	d
PHYSBAM_MAP_15	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	48;"	d
PHYSBAM_MAP_2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	35;"	d
PHYSBAM_MAP_3	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	36;"	d
PHYSBAM_MAP_4	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	37;"	d
PHYSBAM_MAP_5	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	38;"	d
PHYSBAM_MAP_6	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	39;"	d
PHYSBAM_MAP_7	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	40;"	d
PHYSBAM_MAP_8	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	41;"	d
PHYSBAM_MAP_9	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	42;"	d
PHYSBAM_MPI_UTILITIES	IntersectorPhysBAM/Mpi_Utilities.C	/^namespace PHYSBAM_MPI_UTILITIES{$/;"	n	file:
PHYSBAM_MPI_UTILITIES	IntersectorPhysBAM/Mpi_Utilities.h	/^namespace PHYSBAM_MPI_UTILITIES{$/;"	n
PHYSBAM_NORETURN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	12;"	d
PHYSBAM_NORETURN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	19;"	d
PHYSBAM_NOT_IMPLEMENTED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	25;"	d
PHYSBAM_OVERLOAD	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	32;"	d
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    void Rescale(const T scaling_factor) PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Calculate_Bounding_Box_Radii(const ARRAY<RANGE<TV> >& bounding_boxes,ARRAY<T>& radius) PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Initialize_Hierarchy_Using_KD_Tree() PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    bool Assert_Consistent() const PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::SEGMENT_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    void Delete_Auxiliary_Structures() PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::SEGMENT_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    void Refresh_Auxiliary_Structures() PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::SEGMENT_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    bool Assert_Consistent() const PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Delete_Auxiliary_Structures() PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Refresh_Auxiliary_Structures() PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Set_Number_Nodes(const int number_nodes_input) PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::TRIANGLE_MESH
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T Prime(const T x) const PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::CUBIC
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T operator()(const T x) const PHYSBAM_OVERRIDE;$/;"	m	class:PhysBAM::CUBIC
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	16;"	d
PHYSBAM_OVERRIDE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	9;"	d
PHYSBAM_PRIMITIVE_CAT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	23;"	d
PHYSBAM_REM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	28;"	d
PHYSBAM_SEALED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	10;"	d
PHYSBAM_SEALED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	17;"	d
PHYSBAM_SIMPLE_EXCEPTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.h	15;"	d
PHYSBAM_SIMPLE_EXCEPTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.h	38;"	d
PHYSBAM_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	29;"	d
PHYSBAM_SIZE_A	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	30;"	d
PHYSBAM_SIZE_B	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	31;"	d
PHYSBAM_SPLIT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	24;"	d
PHYSBAM_SPLIT_0	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	25;"	d
PHYSBAM_SPLIT_1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	26;"	d
PHYSBAM_TYPE_TRAIT_DECLARE_CV_QUALIFIERS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	13;"	d
PHYSBAM_TYPE_TRAIT_DECLARE_CV_QUALIFIERS2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	231;"	d
PHYSBAM_TYPE_TRAIT_DECLARE_CV_QUALIFIERS2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	237;"	d
PHYSBAM_TYPE_TRAIT_DECLARE_CV_QUALIFIERS2_PART1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	226;"	d
PHYSBAM_TYPE_TRAIT_DECLARE_CV_QUALIFIERS2_PART1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	238;"	d
PHYSBAM_UNUSED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    static std::ostream& cerr PHYSBAM_UNUSED =::PhysBAM::LOG_REAL::cerr_Helper();$/;"	m	namespace:PhysBAM::LOG_REAL::__anon20
PHYSBAM_UNUSED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    static std::ostream& cout PHYSBAM_UNUSED =::PhysBAM::LOG_REAL::cout_Helper();$/;"	m	namespace:PhysBAM::LOG_REAL::__anon20
PHYSBAM_UNUSED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	11;"	d
PHYSBAM_UNUSED	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	18;"	d
PHYSBAM_WARNING	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	19;"	d
PHYSBAM_WARN_IF_NOT_OVERRIDDEN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	16;"	d
PI	TsParameters.C	19;"	d	file:
PITCHING	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	e	enum:ForcedData::Type
PLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    PLANE()$/;"	f	class:PhysBAM::PLANE
PLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    PLANE(const TV& normal_input,const TV& x1_input)$/;"	f	class:PhysBAM::PLANE
PLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    PLANE(const TV& x1_input,const TV& x2_input,const TV& x3_input)$/;"	f	class:PhysBAM::PLANE
PLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^class PLANE$/;"	c	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<bool>{static const int value=1;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<char>{static const int value=1;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<double>{static const int value=8;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<float>{static const int value=4;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<int>{static const int value=4;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<short>{static const int value=2;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned char>{static const int value=1;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned int>{static const int value=4;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned short>{static const int value=2;};$/;"	s	namespace:PhysBAM
PLATFORM_INDEPENDENT_SIZE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T> struct PLATFORM_INDEPENDENT_SIZE<T,typename ENABLE_IF<IS_ENUM<T>::value>::TYPE>{static const int value=4;};$/;"	s	namespace:PhysBAM
PLU_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void PLU_Inverse(MATRIX_BASE<T,T_MATRIX2>& inverse) const$/;"	f	class:PhysBAM::MATRIX_BASE
PLU_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR PLU_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
PLY2D_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
PLY_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
POD	IoData.h	/^  enum Type {POD = 0, BALANCED_POD = 1} type;$/;"	e	enum:DataCompressionData::Type
POD-basis	Manual/Aerof3d.html	/^<a name="POD-basis"><\/a>$/;"	a
PODMethod	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	g	struct:DataCompressionData
POINT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef POINT_2D<T> POINT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
POINT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef VECTOR<T,1> POINT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
POINT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef VECTOR<T,3> POINT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
POINTER_POOL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    POINTER_POOL()$/;"	f	class:PhysBAM::POINTER_POOL
POINTER_POOL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^class POINTER_POOL:public NONCOPYABLE$/;"	c	namespace:PhysBAM
POINT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    POINT_2D()$/;"	f	class:PhysBAM::POINT_2D
POINT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    POINT_2D(const TV& x_input)$/;"	f	class:PhysBAM::POINT_2D
POINT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^class POINT_2D:public VECTOR<T,2>$/;"	c	namespace:PhysBAM
POINT_CLOUD	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    POINT_CLOUD()$/;"	f	class:PhysBAM::POINT_CLOUD
POINT_CLOUD	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^class POINT_CLOUD:public CLONEABLE<POINT_CLOUD<TV> >$/;"	c	namespace:PhysBAM
POINT_CLOUDS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/CENTER.h	/^namespace POINT_CLOUDS_COMPUTATIONS$/;"	n	namespace:PhysBAM
POINT_CLOUDS_COMPUTATIONS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^namespace POINT_CLOUDS_COMPUTATIONS$/;"	n	namespace:PhysBAM
POINT_SIMPLEX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef POINT_SIMPLEX_1D<T> POINT_SIMPLEX;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
POINT_SIMPLEX_1D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    POINT_SIMPLEX_1D()$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
POINT_SIMPLEX_1D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    POINT_SIMPLEX_1D(const TV& x1,const bool direction)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
POINT_SIMPLEX_1D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    explicit POINT_SIMPLEX_1D(const T_ARRAY& X_input)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
POINT_SIMPLEX_1D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^class POINT_SIMPLEX_1D$/;"	c	namespace:PhysBAM
POINT_SIMPLEX_COLLISION_ENDS_INSIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^enum POINT_SIMPLEX_COLLISION_TYPE {POINT_SIMPLEX_NO_COLLISION,POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE,POINT_SIMPLEX_COLLISION_ENDS_INSIDE,POINT_SIMPLEX_UNKNOWN_COLLISION};$/;"	e	enum:PhysBAM::POINT_SIMPLEX_COLLISION_TYPE
POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^enum POINT_SIMPLEX_COLLISION_TYPE {POINT_SIMPLEX_NO_COLLISION,POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE,POINT_SIMPLEX_COLLISION_ENDS_INSIDE,POINT_SIMPLEX_UNKNOWN_COLLISION};$/;"	e	enum:PhysBAM::POINT_SIMPLEX_COLLISION_TYPE
POINT_SIMPLEX_COLLISION_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^enum POINT_SIMPLEX_COLLISION_TYPE {POINT_SIMPLEX_NO_COLLISION,POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE,POINT_SIMPLEX_COLLISION_ENDS_INSIDE,POINT_SIMPLEX_UNKNOWN_COLLISION};$/;"	g	namespace:PhysBAM
POINT_SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/POINT_SIMPLEX_MESH.h	/^class POINT_SIMPLEX_MESH:public SIMPLEX_MESH<0>$/;"	c	namespace:PhysBAM
POINT_SIMPLEX_NO_COLLISION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^enum POINT_SIMPLEX_COLLISION_TYPE {POINT_SIMPLEX_NO_COLLISION,POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE,POINT_SIMPLEX_COLLISION_ENDS_INSIDE,POINT_SIMPLEX_UNKNOWN_COLLISION};$/;"	e	enum:PhysBAM::POINT_SIMPLEX_COLLISION_TYPE
POINT_SIMPLEX_UNKNOWN_COLLISION	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^enum POINT_SIMPLEX_COLLISION_TYPE {POINT_SIMPLEX_NO_COLLISION,POINT_SIMPLEX_COLLISION_ENDS_OUTSIDE,POINT_SIMPLEX_COLLISION_ENDS_INSIDE,POINT_SIMPLEX_UNKNOWN_COLLISION};$/;"	e	enum:PhysBAM::POINT_SIMPLEX_COLLISION_TYPE
POLYGON	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^POLYGON() $/;"	f	class:POLYGON
POLYGON	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.cpp	/^POLYGON(const int number_of_vertices) $/;"	f	class:POLYGON
POLYGON	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^class POLYGON $/;"	c	namespace:PhysBAM
POROUS	IoData.h	/^  enum Type {FLUID = 0, POROUS = 1} type;$/;"	e	enum:VolumeData::Type
POROUSWALL	IoData.h	/^  enum Type {DIRECTSTATE = 1, MASSFLOW = 2, POROUSWALL = 3} type;$/;"	e	enum:BoundaryData::Type
POST_PRO_OFF	IoData.h	/^  enum PostProProjectedStates {POST_PRO_OFF = 0, POST_PRO_ON = 1} postProProjectedStates;$/;"	e	enum:RelativeProjectionErrorData::PostProProjectedStates
POST_PRO_ON	IoData.h	/^  enum PostProProjectedStates {POST_PRO_OFF = 0, POST_PRO_ON = 1} postProProjectedStates;$/;"	e	enum:RelativeProjectionErrorData::PostProProjectedStates
PRANDTL	IoData.h	/^  enum Type {CONSTANT = 0, SUTHERLAND = 1, PRANDTL = 2} type;$/;"	e	enum:ViscosityModelData::Type
PREC	IoData.h	/^  enum Prec {NO_PREC = 0, PREC = 1} prec;$/;"	e	enum:TsData::Prec
PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 2} prec;$/;"	e	enum:MultiFluidData::Prec
PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 3 } prec;$/;"	e	enum:EmbeddedFramework::Prec
PRECONDITIONED	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1} prec;$/;"	e	enum:ProblemData::Prec
PREFIX	tools/Makefile	/^PREFIX     = loader$/;"	m
PREPARE_NOT_OK	arpack++/include/arerror.h	/^    PREPARE_NOT_OK      = -404,$/;"	e	enum:ArpackError::ErrorCode
PRESSURE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
PRESSURE	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	e	enum:PostFcn::ScalarType
PRESSUREAVG	PostFcn.h	/^  enum ScalarAvgType {DENSITYAVG = 0, MACHAVG = 1, PRESSUREAVG = 2, TEMPERATUREAVG = 3,$/;"	e	enum:PostFcn::ScalarAvgType
PRESSURECOEFFICIENT	PostFcn.h	/^                   SURFACE_HEAT_FLUX = 26, PRESSURECOEFFICIENT = 27, CONTROL_VOLUME = 28, FLUIDID = 29,$/;"	e	enum:PostFcn::ScalarType
PRESSURE_CLIPPING	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
PREVIOUSVALEUSFIX	IoData.h	/^  enum FixSolution {NONEFIX = 0, PREVIOUSVALEUSFIX = 1} fixsol;$/;"	e	enum:SensitivityAnalysis::FixSolution
PRIMITIVE	FluxFcnBase.h	/^  enum Type {CONSERVATIVE = 0, PRIMITIVE = 1} typeJac;$/;"	e	enum:FluxFcnBase::Type
PRIMITIVE	IoData.h	/^  enum LevelSetMethod { CONSERVATIVE = 0, HJWENO = 1, SCALAR=2, PRIMITIVE = 3,$/;"	e	enum:MultiFluidData::LevelSetMethod
PROBABILISTIC_SVD	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	e	enum:NonlinearRomOnlineData::LSSolver
PROBABILISTIC_SVD	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	e	enum:DataCompressionData::PODMethod
PROCESS_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^namespace PROCESS_UTILITIES{$/;"	n	namespace:PhysBAM	file:
PROCESS_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.h	/^namespace PROCESS_UTILITIES{$/;"	n	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct PRODUCT<T1,T_ARRAY2,typename IF<IS_SCALAR<T1>::value && IS_ARRAY<T_ARRAY2>::value,void,typename PRODUCT<T1,typename T_ARRAY2::ELEMENT>::TYPE>::TYPE>$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct PRODUCT<T_ARRAY2,T1,typename IF<IS_SCALAR<T1>::value && IS_ARRAY<T_ARRAY2>::value,void,typename PRODUCT<T1,typename T_ARRAY2::ELEMENT>::TYPE>::TYPE>$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^template<class T_ARRAY1,class T_ARRAY2> struct PRODUCT<T_ARRAY1,T_ARRAY2,typename ENABLE_IF<IS_ARRAY<T_ARRAY1>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef DIAGONAL_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,DIAGONAL_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,VECTOR<T,d> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n,int k> struct PRODUCT<MATRIX<T,m,k>,MATRIX<T,k,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<DIAGONAL_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,DIAGONAL_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,SYMMETRIC_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,UPPER_TRIANGULAR_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,VECTOR<T,n> >{typedef VECTOR<T,m> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX_MXN<T>,MATRIX<T,m,n> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<SYMMETRIC_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct PRODUCT<MATRIX_MXN<T>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct PRODUCT<MATRIX_MXN<T>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class TV> struct PRODUCT<FRAME<TV>,TV>{typedef TV TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,float>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,int>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,int>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,int>{typedef int TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct PRODUCT<TWIST<TV>,typename TV::SCALAR> {typedef TWIST<TV> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct PRODUCT<typename TV::SCALAR,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T1,class T_VECTOR2> struct PRODUCT<T1,T_VECTOR2,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR2>::value && IS_SCALAR<T1>::value>::TYPE>$/;"	s	namespace:PhysBAM
PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T1,class T_VECTOR2> struct PRODUCT<T_VECTOR2,T1,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR2>::value && IS_SCALAR<T1>::value>::TYPE>$/;"	s	namespace:PhysBAM
PRODUCT_TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T1,class T2> struct PRODUCT_TRANSPOSE{typedef typename PRODUCT<T1,typename TRANSPOSE<T2>::TYPE>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
PROJECTED_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    PROJECTED_ARRAY(T_ARRAY& array)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
PROJECTED_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    PROJECTED_ARRAY(T_ARRAY& array,const T_PROJECTOR& projector)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
PROJECTED_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    PROJECTED_ARRAY(const PROJECTED_ARRAY<typename REMOVE_CONST<T_ARRAY>::TYPE,T_PROJECTOR>& projected_array)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
PROJECTED_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^class PROJECTED_ARRAY:public PROJECTED_ARRAY_BASE<T_ARRAY>,public ARRAY_BASE<typename PROJECTED_ARRAY_ELEMENT<T_ARRAY,T_PROJECTOR>::TYPE,PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR> >,$/;"	c	namespace:PhysBAM
PROJECTED_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct PROJECTED_ARRAY_BASE<PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR>&>:public PROJECTED_ARRAY_BASE<T_ARRAY>{};$/;"	s	namespace:PhysBAM
PROJECTED_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY> struct PROJECTED_ARRAY_BASE{};$/;"	s	namespace:PhysBAM
PROJECTED_ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<int d> struct PROJECTED_ARRAY_BASE<VECTOR<int,d>&>{enum {m=VECTOR<int,d>::m};};$/;"	s	namespace:PhysBAM
PROJECTED_ARRAY_ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct PROJECTED_ARRAY_ELEMENT$/;"	s	namespace:PhysBAM
PROJECTIONS_FALSE	IoData.h	/^  enum PreprocessForProjections {PROJECTIONS_FALSE = 0, PROJECTIONS_TRUE = 1} preprocessForProjections;$/;"	e	enum:BasisUpdatesData::PreprocessForProjections
PROJECTIONS_TRUE	IoData.h	/^  enum PreprocessForProjections {PROJECTIONS_FALSE = 0, PROJECTIONS_TRUE = 1} preprocessForProjections;$/;"	e	enum:BasisUpdatesData::PreprocessForProjections
PROJECT_ALS_IO_H	AlternatingLeastSquare/als_io.h	7;"	d
PROJECT_IMPLICITEMBEDDEDROMTSDESC_H	ImplicitEmbeddedRomTsDesc.h	6;"	d
PROJECT_INCREMENTAL_SNAPS_FALSE	IoData.h	/^  enum ProjectIncrementalSnapshots {PROJECT_INCREMENTAL_SNAPS_FALSE = 0, PROJECT_INCREMENTAL_SNAPS_TRUE = 1} projectIncrementalSnaps;$/;"	e	enum:RelativeProjectionErrorData::ProjectIncrementalSnapshots
PROJECT_INCREMENTAL_SNAPS_TRUE	IoData.h	/^  enum ProjectIncrementalSnapshots {PROJECT_INCREMENTAL_SNAPS_FALSE = 0, PROJECT_INCREMENTAL_SNAPS_TRUE = 1} projectIncrementalSnaps;$/;"	e	enum:RelativeProjectionErrorData::ProjectIncrementalSnapshots
PROJECT_OFF	IoData.h	/^  enum ProjectSwitchStateOntoAffineSubspace {PROJECT_OFF = 0, PROJECT_ON = 1} projectSwitchStateOntoAffineSubspace;$/;"	e	enum:NonlinearRomOnlineData::ProjectSwitchStateOntoAffineSubspace
PROJECT_ON	IoData.h	/^  enum ProjectSwitchStateOntoAffineSubspace {PROJECT_OFF = 0, PROJECT_ON = 1} projectSwitchStateOntoAffineSubspace;$/;"	e	enum:NonlinearRomOnlineData::ProjectSwitchStateOntoAffineSubspace
PROJECT_PARALLELROMEXTENSION_H	ParallelRomExtension.h	6;"	d
PROJECT_SNAPS_MINUS_REF_SOL_FALSE	IoData.h	/^  enum ProjectSnapshotsMinusRefSol {PROJECT_SNAPS_MINUS_REF_SOL_FALSE = 0, PROJECT_SNAPS_MINUS_REF_SOL_TRUE = 1} subtractRefSol;$/;"	e	enum:RelativeProjectionErrorData::ProjectSnapshotsMinusRefSol
PROJECT_SNAPS_MINUS_REF_SOL_TRUE	IoData.h	/^  enum ProjectSnapshotsMinusRefSol {PROJECT_SNAPS_MINUS_REF_SOL_FALSE = 0, PROJECT_SNAPS_MINUS_REF_SOL_TRUE = 1} subtractRefSol;$/;"	e	enum:RelativeProjectionErrorData::ProjectSnapshotsMinusRefSol
PSENSOR	PostFcn.h	/^                   PSENSOR = 14, MUT_OVER_MU = 15, PHILEVEL = 16,PHILEVEL2 = 17, DIFFPRESSURE = 18, $/;"	e	enum:PostFcn::ScalarType
PSEUDOSTRUCTURAL	IoData.h	/^   enum Type {PSEUDOSTRUCTURAL = 0, ALGEBRAIC = 1 } type;$/;"	e	enum:BLMeshMotionData::Type
PSEUDO_INVERSE_LINPACK	IoData.h	/^  enum PseudoInverseSolver {PSEUDO_INVERSE_SCALAPACK = 0, PSEUDO_INVERSE_LINPACK = 1} pseudoInverseSolver;$/;"	e	enum:GappyConstructionData::PseudoInverseSolver
PSEUDO_INVERSE_SCALAPACK	IoData.h	/^  enum PseudoInverseSolver {PSEUDO_INVERSE_SCALAPACK = 0, PSEUDO_INVERSE_LINPACK = 1} pseudoInverseSolver;$/;"	e	enum:GappyConstructionData::PseudoInverseSolver
P_SENSOR	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	e	enum:SchemeData::Limiter
Pack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Pack(T_ARRAY1& buffer,typename T_ARRAY1::INDEX& position,const ID p)$/;"	f	class:PhysBAM::ARRAY_BASE
Pack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Pack(ARRAY_VIEW<char> buffer,int& position,const int p) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Pack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Pack(ARRAY_VIEW<char> buffer,int& position,const int p) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Pack_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    int Pack_Size() const$/;"	f	class:PhysBAM::ARRAY_BASE
Pack_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Pack_Size() const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Pack_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    int Pack_Size() const$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Pade	Manual/Aerof3d.html	/^<a name="Pade"><\/a>$/;"	a
PadeData	IoData.h	/^struct PadeData {$/;"	s
PadeData	IoDataCore.C	/^PadeData::PadeData()$/;"	f	class:PadeData
PadeFreq	IoData.h	/^struct PadeFreq  {$/;"	s
PadeReconstruction	IoData.h	/^  enum PadeReconstruction {TRUE = 1, FALSE = 0} padeReconst;$/;"	g	struct:LinearizedData
Pair	Edge.h	/^  typedef pair<int, int> Pair;$/;"	t	class:EdgeSet
Parabolic_Minimum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Parabolic_Minimum(NONLINEAR_FUNCTION<T(T)>& F,T x0,T x1,T x2)$/;"	f	class:ITERATIVE_SOLVER
ParallelRom	ParallelRom.C	/^ParallelRom<dim>::ParallelRom(Domain & _domain, Communicator *_com, const DistInfo &dI) : $/;"	f	class:ParallelRom
ParallelRom	ParallelRom.h	/^class ParallelRom {$/;"	c
ParallelRomExtension	ParallelRomExtension.cpp	/^ParallelRomExtension<dim>::ParallelRomExtension(Domain &domain, Communicator *comm, const DistInfo &distInfo) :$/;"	f	class:ParallelRomExtension
ParallelRomExtension	ParallelRomExtension.h	/^class ParallelRomExtension : public ParallelRom<dim> {$/;"	c
Parallelepiped_Measure	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    T Parallelepiped_Measure() const$/;"	f	class:PhysBAM::MATRIX
Parallelepiped_Measure	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Parallelepiped_Measure() const$/;"	f	class:PhysBAM::MATRIX
Parallelepiped_Measure	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    T Parallelepiped_Measure() const$/;"	f	class:PhysBAM::MATRIX
Parallelepiped_Measure	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T Parallelepiped_Measure() const$/;"	f	class:PhysBAM::MATRIX
Parameter	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    T Parameter(const TV& point) const \/\/ finds the parameter t, given a point that lies on the ray$/;"	f	class:PhysBAM::RAY
ParametersDefined	arpack++/include/arrseig.h	/^  bool ParametersDefined() { return PrepareOK; }$/;"	f	class:ARrcStdEig
ParseNode	parser/ParseTree.cpp	/^ParseNode::ParseNode(ParseTree &t, int tk) :$/;"	f	class:ParseNode
ParseNode	parser/ParseTree.h	/^class ParseNode : public Assigner {$/;"	c
ParseTree	parser/ParseTree.cpp	/^ParseTree::ParseTree(const char *name) : Assigner(name) {$/;"	f	class:ParseTree
ParseTree	parser/ParseTree.h	/^class ParseTree : public Assigner {$/;"	c
Parse_Integer_List	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^bool Parse_Integer_List(const std::string& str,ARRAY<int>& integer_list)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Parse_Integer_Range	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^bool Parse_Integer_Range(const std::string& str,ARRAY<int>& integer_list)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Partial_X	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual R Partial_X(const T1 x,const T2 y) const{PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
Partial_Y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual R Partial_Y(const T1 x,const T2 y) const{PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
Partition_Helper_Less	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        Partition_Helper_Less(ARRAY_VIEW<const TV>* p,int a,T s){points=p;axis=a;split_value=s;}$/;"	f	class:PhysBAM::KD_TREE::Partition_Helper_Less
Partition_Helper_Less	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    class Partition_Helper_Less{$/;"	c	class:PhysBAM::KD_TREE
Partition_Helper_Less_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        Partition_Helper_Less_Equal(ARRAY_VIEW<const TV>* p,int a,T s){points=p;axis=a;split_value=s;}$/;"	f	class:PhysBAM::KD_TREE::Partition_Helper_Less_Equal
Partition_Helper_Less_Equal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    class Partition_Helper_Less_Equal{$/;"	c	class:PhysBAM::KD_TREE
Path_Compress	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    void Path_Compress(const ID i,const ID root) const$/;"	f	class:PhysBAM::UNION_FIND
PcData	IoData.h	/^struct PcData {$/;"	s
PcData	IoDataCore.C	/^PcData::PcData()$/;"	f	class:PcData
Peek	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    const T& Peek() const$/;"	f	class:PhysBAM::STACK
Peek_And_Reset_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Peek_And_Reset_Time(const int id)$/;"	f	class:PhysBAM::TIMER
Peek_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Peek_Time(const int id)$/;"	f	class:PhysBAM::TIMER
Pencil	arpack++/include/arbgcomp.h	/^  ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > Pencil;$/;"	m	class:ARluCompGenEig
Pencil	arpack++/include/arbgnsym.h	/^  ARbdNonSymPencil<ARFLOAT, ARFLOAT> Pencil;$/;"	m	class:ARluNonSymGenEig
Pencil	arpack++/include/arbgsym.h	/^  ARbdSymPencil<ARFLOAT> Pencil;$/;"	m	class:ARluSymGenEig
Pencil	arpack++/include/ardgcomp.h	/^  ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > Pencil;$/;"	m	class:ARluCompGenEig
Pencil	arpack++/include/ardgnsym.h	/^  ARdsNonSymPencil<ARFLOAT, ARFLOAT> Pencil;$/;"	m	class:ARluNonSymGenEig
Pencil	arpack++/include/ardgsym.h	/^  ARdsSymPencil<ARFLOAT> Pencil;$/;"	m	class:ARluSymGenEig
Pencil	arpack++/include/arlgcomp.h	/^  ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > Pencil;$/;"	m	class:ARluCompGenEig
Pencil	arpack++/include/arlgnsym.h	/^  ARluNonSymPencil<ARFLOAT, ARFLOAT> Pencil;$/;"	m	class:ARluNonSymGenEig
Pencil	arpack++/include/arlgsym.h	/^  ARluSymPencil<ARFLOAT> Pencil;$/;"	m	class:ARluSymGenEig
Pencil	arpack++/include/arugcomp.h	/^  ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT > Pencil;$/;"	m	class:ARluCompGenEig
Pencil	arpack++/include/arugnsym.h	/^  ARumNonSymPencil<ARFLOAT, ARFLOAT> Pencil;$/;"	m	class:ARluNonSymGenEig
Pencil	arpack++/include/arugsym.h	/^  ARumSymPencil<ARFLOAT> Pencil;$/;"	m	class:ARluSymGenEig
Perform	DistTimeState.C	/^  void Perform(double* uold, double* unew, int& status,int id = 0) const {$/;"	f	struct:SetFirstOrderNodes
Perform	DistTimeState.C	/^  void Perform(double* vin, double* vout,int id1,int id2,int swept) const  {$/;"	f	struct:MultiphaseRiemannCopy
Permute	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Permute(const T_ARRAY1& source,T_ARRAY1& destination,const T_ARRAY_INT& permutation)$/;"	f	class:PhysBAM::ARRAY_BASE
Permute	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T_VECTOR Permute(const VECTOR_BASE<int,T_VECTOR2>& p) const$/;"	f	class:PhysBAM::VECTOR_BASE
Permute_Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Permute_Columns(const VECTOR<int,n>& p) const$/;"	f	class:PhysBAM::MATRIX
Permute_Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Permute_Columns(const VECTOR_ND<int>& p) const$/;"	f	class:PhysBAM::MATRIX_MXN
Perpendicular	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Perpendicular() const$/;"	f	class:PhysBAM::VECTOR
Pfinal	EmbeddedTsDesc.h	/^  double Pfinal;$/;"	m	class:EmbeddedTsDesc
Pfinal	MultiPhysicsTsDesc.h	/^  double Pfinal;$/;"	m	class:MultiPhysicsTsDesc
PhantomElement	FSI/CrackingSurface.cpp	/^PhantomElement::PhantomElement(int a, int b, int c, int d,$/;"	f	class:PhantomElement
PhantomElement	FSI/CrackingSurface.cpp	/^PhantomElement::PhantomElement(int n, int* nod, double* ph): nNodes(n) {$/;"	f	class:PhantomElement
PhantomElement	FSI/CrackingSurface.h	/^  PhantomElement(): nNodes(-1), phi(0), nodes(0) {}$/;"	f	struct:PhantomElement
PhantomElement	FSI/CrackingSurface.h	/^struct PhantomElement {$/;"	s
PhaseChangeAlgorithm	IoData.h	/^  enum PhaseChangeAlgorithm {AVERAGE = 0, LEAST_SQUARES = 1, AUTO = 2} phaseChangeAlg;$/;"	g	struct:EmbeddedFramework
PhaseType	arpack++/include/arlutil.h	/^} PhaseType;$/;"	t	typeref:enum:__anon51
Phi	LevelSetTsDesc.h	/^  DistSVec<double,dimLS> Phi;           \/\/conservative variables$/;"	m	class:LevelSetTsDesc
Phi	MatVecProd.h	/^  DistSVec<double,dimLS> *Phi;$/;"	m	class:MatVecProdFDMultiPhase
Phi	MultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> Phi;           \/\/conservative variables$/;"	m	class:MultiPhysicsTsDesc
Phi	OneDimensionalSolver.h	/^  SVec<double,1> Phi;$/;"	m	class:OneDimensional
Phi0	ExplicitEmbeddedTsDesc.h	/^  DistVec<double> Phi0;$/;"	m	class:ExplicitEmbeddedTsDesc
Phi0	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> Phi0;$/;"	m	class:ExplicitLevelSetTsDesc
Phi0	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> Phi0;$/;"	m	class:ExplicitMultiPhysicsTsDesc
Phi0	LevelSet.h	/^  DistSVec<double,dimLS> Phi0;$/;"	m	class:LevelSet
PhiF	NewtonSolver.h	/^  typename ProblemDescriptor::PhiVecType PhiF; \/\/ $/;"	m	class:NewtonSolver
PhiF	OneDimensionalSolver.C	/^void OneDimensional::PhiF(double t, SVec<double,1>& y,SVec<double,1>& k) {$/;"	f	class:OneDimensional
PhiV	LevelSetTsDesc.h	/^  DistSVec<double,dimLS> PhiV;          \/\/primitive variables$/;"	m	class:LevelSetTsDesc
PhiV	MultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> PhiV;          \/\/primitive variables$/;"	m	class:MultiPhysicsTsDesc
PhiVecType	ImplicitLevelSetTsDesc.h	/^  typedef DistSVec<double,dimLS> PhiVecType;$/;"	t	class:ImplicitLevelSetTsDesc
PhiVecType	ImplicitMultiPhysicsTsDesc.h	/^  typedef DistSVec<double,dimLS> PhiVecType;$/;"	t	class:ImplicitMultiPhysicsTsDesc
PhiVecType	MeshMotionSolver.h	/^  typedef DistSVec<double,1> PhiVecType;$/;"	t	class:TetMeshMotionSolver
PhiVecType	TsDesc.h	/^  typedef DistSVec<double,1> PhiVecType;$/;"	t	class:TsDesc
PhiWeights	MultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> PhiWeights;    \/\/<! stores Phi*Weights for each ndoe. Used in updating phase change$/;"	m	class:MultiPhysicsTsDesc
Phi_Secondary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::Phi_Secondary(const TV& location) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Phiintegrator	OneDimensionalSolver.h	/^  RKIntegrator< SVec<double, 1> >* Phiintegrator;$/;"	m	class:OneDimensional
Phin	LevelSet.h	/^  DistSVec<double,dimLS> Phin;$/;"	m	class:LevelSet
Phin	OneDimensionalSolver.h	/^  SVec<double,1> Phin;$/;"	m	class:OneDimensional
Phinm1	LevelSet.h	/^  DistSVec<double,dimLS> Phinm1;$/;"	m	class:LevelSet
Phinm2	LevelSet.h	/^  DistSVec<double,dimLS> Phinm2;$/;"	m	class:LevelSet
Phislope	OneDimensionalSolver.h	/^  SVec<double,1> Phislope;$/;"	m	class:OneDimensional
PhysBAM	IntersectorPhysBAM/Mpi_Utilities.C	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	IntersectorPhysBAM/Mpi_Utilities.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^namespace PhysBAM {$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/EDGE_EDGE_COLLISION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/STRUCTURE_REGISTRY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/POINT_SIMPLEX_MESH.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_EXPRESSION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_COPY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/DOT_PRODUCT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/DATA_STRUCTURES_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmax.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmin.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cube.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange_sort.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minmag.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/rint.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sign.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sqr.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/CENTER.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY_VIEW.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/NONCOPYABLE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^namespace PhysBAM{$/;"	n	file:
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^namespace PhysBAM{$/;"	n
PhysBAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^namespace PhysBAM{$/;"	n
PhysBAMInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^PhysBAMInterface(TRIANGLE_MESH& triangle_mesh_input,GEOMETRY_PARTICLES<TV>& particles_input, LocalLevelSet* cs)$/;"	f	class:PhysBAMInterface
PhysBAMInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^class PhysBAMInterface {$/;"	c	namespace:PhysBAM
Pin	EmbeddedFluidShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Pin	FluidCollocationShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Pin	FluidGnatShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:FluidGnatShapeOptimizationHandler
Pin	FluidMetricShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:FluidMetricShapeOptimizationHandler
Pin	FluidRomShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:FluidRomShapeOptimizationHandler
Pin	FluidShapeOptimizationHandler.h	/^  DistVec<double> Pin;$/;"	m	class:FluidShapeOptimizationHandler
Pin	MeshMotionHandler.h	/^  DistVec<double> Pin;$/;"	m	class:MeshMotionHandler
Pinit	EmbeddedTsDesc.h	/^  double Pinit;$/;"	m	class:EmbeddedTsDesc
Pinit	IoData.h	/^  double Prate, Pinit, tmax;$/;"	m	struct:ImplosionSetup
Pinit	LevelSetTsDesc.h	/^  double Pinit;$/;"	m	class:LevelSetTsDesc
Pinit	MultiPhysicsTsDesc.h	/^  double Pinit;$/;"	m	class:MultiPhysicsTsDesc
Pitching	Manual/Aerof3d.html	/^<a name="Pitching"><\/a>$/;"	a
PitchingData	IoData.h	/^struct PitchingData {$/;"	s
PitchingData	IoDataCore.C	/^PitchingData::PitchingData()$/;"	f	class:PitchingData
PitchingMeshMotionHandler	MeshMotionHandler.h	/^class PitchingMeshMotionHandler : public MeshMotionHandler {$/;"	c
PitchingMeshMotionHandler	MeshMotionHandlerCore.C	/^PitchingMeshMotionHandler::PitchingMeshMotionHandler(IoData &iod, Domain *dom) :$/;"	f	class:PitchingMeshMotionHandler
Placement_Clone	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    virtual CLONEABLE_BASE* Placement_Clone(void* memory) const$/;"	f	class:PhysBAM::CLONEABLE
Planar_Point_Inside_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Planar_Point_Inside_Triangle(const VECTOR<T,3>& point,const T thickness_over_2) const$/;"	f	class:TRIANGLE_3D
Plane	Manual/Aerof3d.html	/^<a name="Plane"><\/a>$/;"	a
PlaneData	IoData.h	/^struct PlaneData {$/;"	s
PlaneData	IoDataCore.C	/^PlaneData::PlaneData()$/;"	f	class:PlaneData
Plus_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Plus_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const ARRAY_BASE<T,T_ARRAY1,ID>& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Plus_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Plus_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const T& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Point	Manual/Aerof3d.html	/^<a name="Point"><\/a>$/;"	a
Point	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV Point(const T t) const \/\/ finds the point on the ray, given by the parameter t$/;"	f	class:PhysBAM::RAY
PointData	IoData.h	/^struct PointData {$/;"	s
PointData	IoDataCore.C	/^PointData::PointData()$/;"	f	class:PointData
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Point_Face_Collision(const TV& x,const TV& v,const TV& v1,const TV& v2,const T dt,const T collision_thickness,T& collision_time,TV& normal,VECTOR<T,2>& weights,T& relative_speed,$/;"	f	class:SEGMENT_2D
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    bool Point_Face_Collision(const TV& x,const TV& v,const INDIRECT_ARRAY<ARRAY_VIEW<TV>,VECTOR<int,2>&> V_face,const T dt,const T collision_thickness,T& collision_time,TV& normal,$/;"	f	class:PhysBAM::SEGMENT_2D
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Point_Face_Collision(const TV& x,const TV& v,const TV& v1,const TV& v2,const TV& v3,const T dt,const T collision_thickness,$/;"	f	class:TRIANGLE_3D
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    bool Point_Face_Collision(const TV& x,const TV& v,const INDIRECT_ARRAY<ARRAY_VIEW<TV>,VECTOR<int,3>&> V_face,const T dt,const T collision_thickness,T& collision_time,TV& normal,$/;"	f	class:PhysBAM::TRIANGLE_3D
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Point_Face_Collision(const SEGMENT_2D<T>& seg_fault,const VECTOR<T,2>& x,const VECTOR<T,2>& v,const VECTOR<T,2>& v1,const VECTOR<T,2>& v2,const T dt,const T collision_thickness,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Point_Face_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Point_Face_Collision(const TRIANGLE_3D<T>& tri,const VECTOR<T,3>& x,const VECTOR<T,3>& v,const VECTOR<T,3>& v1,const VECTOR<T,3>& v2,const VECTOR<T,3>& v3,const T dt,const T collision_thickness,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Point_Face_Interaction(const VECTOR<T,2>& x,const T interaction_distance,const bool allow_negative_weights,T& distance) const$/;"	f	class:SEGMENT_2D
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Point_Face_Interaction(const VECTOR<T,2>& x,const VECTOR<T,2>& v,const TV& v1,const TV& v2,const T interaction_distance,T& distance,$/;"	f	class:SEGMENT_2D
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    bool Point_Face_Interaction(const TV& x,const TV& v,const INDIRECT_ARRAY<ARRAY_VIEW<TV>,VECTOR<int,2>&> V_face,const T interaction_distance,T& distance,$/;"	f	class:PhysBAM::SEGMENT_2D
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Point_Face_Interaction(const TV& x,const TV& v,const TV& v1,const TV& v2,const TV& v3,const T interaction_distance,T& distance,$/;"	f	class:TRIANGLE_3D
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Point_Face_Interaction(const VECTOR<T,3>& x,const T interaction_distance,const bool allow_negative_weights,T& distance) const                       $/;"	f	class:TRIANGLE_3D
Point_Face_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    bool Point_Face_Interaction(const TV& x,const TV& v,const INDIRECT_ARRAY<ARRAY_VIEW<TV>,VECTOR<int,3>&> V_face,const T interaction_distance,T& distance,$/;"	f	class:PhysBAM::TRIANGLE_3D
Point_Face_Interaction_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Point_Face_Interaction_Data(const VECTOR<T,2>& x,T& distance,VECTOR<T,2>& interaction_normal,VECTOR<T,2>& weights,const bool perform_attractions) const$/;"	f	class:SEGMENT_2D
Point_Face_Interaction_Data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Point_Face_Interaction_Data(const VECTOR<T,3>& x,T& distance,VECTOR<T,3>& interaction_normal,VECTOR<T,3>& weights,const bool perform_attractions) const                       $/;"	f	class:TRIANGLE_3D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    Point_From_Barycentric_Coordinates(const ONE,const T_ARRAY& X)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    TV Point_From_Barycentric_Coordinates(const ONE) const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    static TV Point_From_Barycentric_Coordinates(const ONE,const TV& x1)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV Point_From_Barycentric_Coordinates(const T alpha) const $/;"	f	class:PhysBAM::SEGMENT_2D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Point_From_Barycentric_Coordinates(const T alpha,const TV& x1,const TV& x2)$/;"	f	class:PhysBAM::SEGMENT_2D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Point_From_Barycentric_Coordinates(const T alpha,const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static TV Point_From_Barycentric_Coordinates(const TV& weights,const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV Point_From_Barycentric_Coordinates(const TV& weights) const$/;"	f	class:PhysBAM::TRIANGLE_3D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Point_From_Barycentric_Coordinates(const TV& weights,const TV& x1,const TV& x2,const TV& x3) \/\/ clockwise vertices$/;"	f	class:PhysBAM::TRIANGLE_3D
Point_From_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static TV Point_From_Barycentric_Coordinates(const TV& weights,const T_ARRAY& X) \/\/ clockwise vertices$/;"	f	class:PhysBAM::TRIANGLE_3D
Point_From_Normalized_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV Point_From_Normalized_Coordinates(const TV& weights) const$/;"	f	class:PhysBAM::RANGE
Point_Inside_Triangle	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Point_Inside_Triangle(const ARRAY<int> &scope, const ARRAY<TRIANGLE_3D<T> >& triangle_list,const VECTOR<T,3>& point,$/;"	f	namespace:__anon13
Point_Inside_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Point_Inside_Triangle(const VECTOR<T,3>& point,const T thickness_over_2) const$/;"	f	class:TRIANGLE_3D
Point_Point_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Point_Point_Collision(const POINT_SIMPLEX_1D<T>& initial_simplex,const VECTOR<T,1>& x,const VECTOR<T,1>& v,const VECTOR<T,1>& v1,const T dt,const T collision_thickness,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Polar	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    static COMPLEX<T> Polar(const T r,const T theta)   \/\/ r*e^(i*theta) = r(cos(theta)+i*sin(theta))$/;"	f	class:PhysBAM::COMPLEX
PolygonReconstructionData	PolygonReconstructionData.h	/^    PolygonReconstructionData() : numberOfEdges(0) {}$/;"	f	struct:PolygonReconstructionData
PolygonReconstructionData	PolygonReconstructionData.h	/^struct PolygonReconstructionData { \/\/for force computation under the embedded framework$/;"	s
Pop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    T Pop()$/;"	f	class:PhysBAM::ARRAY
Pop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    T Pop()$/;"	f	class:PhysBAM::STACK
Pop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    void Pop()$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
Pop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    void Pop(){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
Pop_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ARRAY_VIEW<const T> Pop_Elements(const int count) \/\/ return value should be copied immediately, not kept around$/;"	f	class:PhysBAM::ARRAY
Pop_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Pop_Scope()$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
PorousMedia	IoData.h	/^struct PorousMedia  {$/;"	s
PorousMedia	IoDataCore.C	/^PorousMedia::PorousMedia()  {$/;"	f	class:PorousMedia
PorousMedium	Manual/Aerof3d.html	/^<a name="PorousMedium"><\/a>$/;"	a
PosVecType	TsDesc.h	/^  typedef DistSVec<double,3> PosVecType;$/;"	t	class:TsDesc
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Positive_Definite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    bool Positive_Definite() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Positive_Definite_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Positive_Definite_Part() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    bool Positive_Semidefinite() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    bool Positive_Semidefinite() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    bool Positive_Semidefinite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    bool Positive_Semidefinite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    bool Positive_Semidefinite() const$/;"	f	class:PhysBAM::MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    bool Positive_Semidefinite(const T tolerance=(T)1e-7) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Positive_Semidefinite	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    bool Positive_Semidefinite(const T tolerance=(T)1e-7) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
PostFcn	PostFcn.C	/^PostFcn::PostFcn(VarFcn *vf)$/;"	f	class:PostFcn
PostFcn	PostFcn.h	/^class PostFcn {$/;"	c
PostFcnDES	PostFcn.C	/^PostFcnDES::PostFcnDES(IoData &iod, VarFcn *vf) : PostFcnNS(iod, vf), DESTerm(iod)$/;"	f	class:PostFcnDES
PostFcnDES	PostFcn.h	/^class PostFcnDES : public PostFcnNS, public DESTerm {$/;"	c
PostFcnEuler	PostFcn.C	/^PostFcnEuler::PostFcnEuler(IoData &iod, VarFcn *vf) : PostFcn(vf)$/;"	f	class:PostFcnEuler
PostFcnEuler	PostFcn.h	/^class PostFcnEuler : public PostFcn {$/;"	c
PostFcnKE	PostFcn.C	/^PostFcnKE::PostFcnKE(IoData &iod, VarFcn *vf) : PostFcnNS(iod, vf), KEpsilonTerm(iod)$/;"	f	class:PostFcnKE
PostFcnKE	PostFcn.h	/^class PostFcnKE : public PostFcnNS, public KEpsilonTerm {$/;"	c
PostFcnNS	PostFcn.C	/^PostFcnNS::PostFcnNS(IoData &iod, VarFcn *vf) $/;"	f	class:PostFcnNS
PostFcnNS	PostFcn.h	/^class PostFcnNS : public PostFcnEuler, public NavierStokesTerm {$/;"	c
PostFcnSA	PostFcn.C	/^PostFcnSA::PostFcnSA(IoData &iod, VarFcn *vf) : PostFcnNS(iod, vf), SATerm(iod)$/;"	f	class:PostFcnSA
PostFcnSA	PostFcn.h	/^class PostFcnSA : public PostFcnNS, public SATerm {$/;"	c
PostOperator	PostOperator.C	/^PostOperator<dim>::PostOperator(IoData &iod, VarFcn *vf, DistBcData<dim> *bc, $/;"	f	class:PostOperator
PostOperator	PostOperator.h	/^class PostOperator {$/;"	c
PostProProjectedStates	IoData.h	/^  enum PostProProjectedStates {POST_PRO_OFF = 0, POST_PRO_ON = 1} postProProjectedStates;$/;"	g	struct:RelativeProjectionErrorData
Postpro	Manual/Aerof3d.html	/^<a name="Postpro"><\/a>$/;"	a
PrT	Domain.h	/^  DistVec<double> *PrT;$/;"	m	class:Domain
PrT	DynamicVMSTerm.h	/^  double PrT;$/;"	m	class:DynamicVMSTerm
PrT	SmagorinskyLESTerm.h	/^  double PrT;$/;"	m	class:SmagorinskyLESTerm
PrT	VMSLESTerm.h	/^  double PrT;$/;"	m	class:VMSLESTerm
PrT	WaleLESTerm.h	/^  double PrT;$/;"	m	class:WaleLESTerm
Prandtl	DynamicLESTerm.h	/^  double Prandtl;$/;"	m	class:DynamicLESTerm
Prandtl	DynamicVMSTerm.h	/^  double Prandtl;$/;"	m	class:DynamicVMSTerm
PrandtlViscoFcn	ViscoFcn.h	/^  PrandtlViscoFcn(IoData &iod) : ViscoFcn(iod)$/;"	f	class:PrandtlViscoFcn
PrandtlViscoFcn	ViscoFcn.h	/^class PrandtlViscoFcn : public ViscoFcn {$/;"	c
Prate	EmbeddedTsDesc.h	/^  double Prate;$/;"	m	class:EmbeddedTsDesc
Prate	IoData.h	/^  double Prate, Pinit, tmax;$/;"	m	struct:ImplosionSetup
Prate	LevelSetTsDesc.h	/^  double Prate;$/;"	m	class:LevelSetTsDesc
Prate	MultiPhysicsTsDesc.h	/^  double Prate;$/;"	m	class:MultiPhysicsTsDesc
PreScalar	Modal.h	5;"	d
PreScalar	Modal.h	7;"	d
Preallocate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Preallocate(const ID max_size)$/;"	f	class:PhysBAM::ARRAY
Preallocate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Preallocate(const int max_size)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Preallocate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Preallocate(const int max_size)$/;"	f	class:PhysBAM::STACK
Prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 2} prec;$/;"	g	struct:MultiFluidData
Prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 3 } prec;$/;"	g	struct:EmbeddedFramework
Prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1} prec;$/;"	g	struct:ProblemData
Prec	IoData.h	/^  enum Prec {NO_PREC = 0, PREC = 1} prec;$/;"	g	struct:TsData
PrecScalar	EmbeddedTsDesc.C	29;"	d	file:
PrecScalar	ExplicitEmbeddedTsDesc.C	14;"	d	file:
PrecScalar	ExplicitEmbeddedTsDesc.C	16;"	d	file:
PrecScalar	ExplicitLevelSetTsDesc.C	17;"	d	file:
PrecScalar	ExplicitLevelSetTsDesc.C	19;"	d	file:
PrecScalar	ExplicitMultiPhysicsTsDesc.C	16;"	d	file:
PrecScalar	ExplicitMultiPhysicsTsDesc.C	18;"	d	file:
PrecScalar	ImplicitCoupledTsDesc.C	18;"	d	file:
PrecScalar	ImplicitCoupledTsDesc.C	20;"	d	file:
PrecScalar	ImplicitEmbeddedCoupledTsDesc.C	14;"	d	file:
PrecScalar	ImplicitEmbeddedCoupledTsDesc.C	16;"	d	file:
PrecScalar	ImplicitEmbeddedCoupledTsDesc.h	18;"	d
PrecScalar	ImplicitEmbeddedCoupledTsDesc.h	20;"	d
PrecScalar	ImplicitEmbeddedSegTsDesc.C	14;"	d	file:
PrecScalar	ImplicitEmbeddedSegTsDesc.C	16;"	d	file:
PrecScalar	ImplicitEmbeddedSegTsDesc.h	18;"	d
PrecScalar	ImplicitEmbeddedSegTsDesc.h	20;"	d
PrecScalar	ImplicitEmbeddedTsDesc.C	14;"	d	file:
PrecScalar	ImplicitEmbeddedTsDesc.C	16;"	d	file:
PrecScalar	ImplicitEmbeddedTsDesc.h	18;"	d
PrecScalar	ImplicitEmbeddedTsDesc.h	20;"	d
PrecScalar	ImplicitLevelSetTsDesc.C	16;"	d	file:
PrecScalar	ImplicitLevelSetTsDesc.C	18;"	d	file:
PrecScalar	ImplicitMultiPhysicsTsDesc.C	14;"	d	file:
PrecScalar	ImplicitMultiPhysicsTsDesc.C	16;"	d	file:
PrecScalar	ImplicitSegTsDesc.C	22;"	d	file:
PrecScalar	ImplicitSegTsDesc.C	24;"	d	file:
PrecScalar	LevelSetTsDesc.C	28;"	d	file:
PrecScalar	MeshMotionSolver.C	17;"	d	file:
PrecScalar	MeshMotionSolver.C	19;"	d	file:
PreconditionData	IoData.h	/^struct PreconditionData {$/;"	s
PreconditionData	IoDataCore.C	/^PreconditionData::PreconditionData()$/;"	f	class:PreconditionData
Preconditioner	Manual/Aerof3d.html	/^<a name="Preconditioner"><\/a>$/;"	a
Pref	IoData.h	/^  double Pref;$/;"	m	struct:LiquidModelData
Prefix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    INDIRECT_ARRAY<T_ARRAY,IDENTITY_ARRAY<> > Prefix(const ID prefix_size)$/;"	f	class:PhysBAM::ARRAY_BASE
Prefix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    INDIRECT_ARRAY<const T_ARRAY,IDENTITY_ARRAY<> > Prefix(const ID prefix_size) const$/;"	f	class:PhysBAM::ARRAY_BASE
Prefwater	IoData.h	/^  double Prefwater;$/;"	m	struct:LiquidModelData
Prepare	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::Prepare()$/;"	f	class:ARrcStdEig
PrepareOK	arpack++/include/arrseig.h	/^  bool    PrepareOK;  \/\/ Indicates if internal variables were correctly set.$/;"	m	class:ARrcStdEig
PreprocessForApproxUpdates	IoData.h	/^  enum PreprocessForApproxUpdates {APPROX_UPDATES_FALSE = 0, APPROX_UPDATES_TRUE = 1} preprocessForApproxUpdates;$/;"	g	struct:BasisUpdatesData
PreprocessForExactUpdates	IoData.h	/^  enum PreprocessForExactUpdates {EXACT_UPDATES_FALSE = 0, EXACT_UPDATES_TRUE = 1} preprocessForExactUpdates;$/;"	g	struct:BasisUpdatesData
PreprocessForNoUpdates	IoData.h	/^  enum PreprocessForNoUpdates {NO_UPDATES_FALSE = 0, NO_UPDATES_TRUE = 1} preprocessForNoUpdates;$/;"	g	struct:BasisUpdatesData
PreprocessForProjections	IoData.h	/^  enum PreprocessForProjections {PROJECTIONS_FALSE = 0, PROJECTIONS_TRUE = 1} preprocessForProjections;$/;"	g	struct:BasisUpdatesData
PreprocessForSimpleUpdates	IoData.h	/^  enum PreprocessForSimpleUpdates {SIMPLE_UPDATES_FALSE = 0, SIMPLE_UPDATES_TRUE = 1} preprocessForSimpleUpdates;$/;"	g	struct:BasisUpdatesData
PrescribedAverage	IoData.h	/^  enum SlidingSurfaceTreatment {Default = 0, PrescribedAverage = 1} slidingSurfaceTreatment;$/;"	e	enum:DefoMeshMotionData::SlidingSurfaceTreatment
PrescribedValues	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::PrescribedValues(DistLevelSetStructure& LSS,DistSVec<double,3>& X,DistGeoState& distGeoState)$/;"	f	class:ReinitializeDistanceToWall
Prime	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual R Prime(const T1 x) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
Prime_Prime	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual R Prime_Prime(const T1 x) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
Principal_Curvatures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    VECTOR<T,TV::dimension-1> Principal_Curvatures(const TV& X) const$/;"	f	class:PhysBAM::BOX
Principal_Curvatures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    VECTOR<T,1> Principal_Curvatures(const TV& X) const$/;"	f	class:PhysBAM::LINE_2D
Principal_Curvatures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    VECTOR<T,TV::dimension-1> Principal_Curvatures(const TV& X) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Principal_Curvatures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    VECTOR<T,2> Principal_Curvatures(const TV& X) const$/;"	f	class:PhysBAM::PLANE
Principal_Curvatures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename IMPLICIT_OBJECT<TV>::T_CURVATURES IMPLICIT_OBJECT<TV>::Principal_Curvatures(const TV& X) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Print	arpack++/include/arerror.h	/^inline void ArpackError::Print(const char* where, const char* message)$/;"	f	class:ArpackError
PrintBacktrace	DebugTools.h	/^  static void PrintBacktrace() {$/;"	f	class:DebugTools
PrintElement	DebugTools.h	/^  static void PrintElement(const char* tag, DistSVec<Scalar,dim>& V,int rank,int iSub, int i) {$/;"	f	class:DebugTools
PrintFluidId	DebugTools.h	/^  static void PrintFluidId(const char* tag, DistVec<int>& fluidId, DistSVec<Scalar,3>& X, Vec3D pos, int rank) {$/;"	f	class:DebugTools
PrintPriorityNodes	MultiGridLevel.C	/^void PrintPriorityNodes(const PriorityNodes& P) {$/;"	f
Print_Stats	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Print_Stats(const int id,const char* str)$/;"	f	class:PhysBAM::TIMER
Print_Table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Print_Table(std::ostream& output) const$/;"	f	class:PhysBAM::HASHTABLE
PriorityNodes	MultiGridLevel.h	/^typedef Aerof_unordered_set<int>::type PriorityNodes;$/;"	t
PrismData	IoData.h	/^struct PrismData {$/;"	s
PrismData	IoDataCore.C	/^PrismData::PrismData()$/;"	f	class:PrismData
Probes	IoData.h	/^struct Probes {$/;"	s
Probes	IoDataCore.C	/^Probes::Probes() {$/;"	f	class:Probes
Probes	Manual/Aerof3d.html	/^<a name="Probes"><\/a>$/;"	a
ProbingNode	Manual/Aerof3d.html	/^<a name="ProbingNode"><\/a>$/;"	a
Problem	Manual/Aerof3d.html	/^<a name="Problem"><\/a>$/;"	a
ProblemData	IoData.h	/^struct ProblemData {$/;"	s
ProblemData	IoDataCore.C	/^ProblemData::ProblemData()$/;"	f	class:ProblemData
ProblemMode	IoData.h	/^  enum ProblemMode { MULTIFLUID=0, FSI=1} problemMode;$/;"	g	struct:OneDimensionalInfo
ProblemMode	OneDimensionalSolver.h	/^  enum ProblemMode { MultiFluid, FSI};$/;"	g	class:OneDimensional
ProdRes	Vector.h	/^class ProdRes {$/;"	c
ProdRes	Vector.h	/^class ProdRes<complex<double>, double> {$/;"	c
Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Product() const$/;"	f	class:PhysBAM::VECTOR
Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Product() const$/;"	f	class:PhysBAM::VECTOR
Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Product() const$/;"	f	class:PhysBAM::VECTOR
Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Product() const$/;"	f	class:PhysBAM::VECTOR_BASE
ProgrammedBurn	Manual/Aerof3d.html	/^<a name="ProgrammedBurn"><\/a>$/;"	a
ProgrammedBurn	ProgrammedBurn.h	/^class ProgrammedBurn {$/;"	c
ProgrammedBurn	ProgrammedBurnCore.C	/^ProgrammedBurn::ProgrammedBurn(IoData& ioData, DistSVec<double,3>* _nodeSet) : distInfo(&_nodeSet->info()) , nodeSet0(NULL) {$/;"	f	class:ProgrammedBurn
ProgrammedBurn	ProgrammedBurnCore.C	/^ProgrammedBurn::ProgrammedBurn(IoData& ioData, SVec<double,1>* _nodeSet) {$/;"	f	class:ProgrammedBurn
ProgrammedBurnData	IoData.h	/^struct ProgrammedBurnData {$/;"	s
ProgrammedBurnData	IoDataCore.C	/^ProgrammedBurnData::ProgrammedBurnData() {$/;"	f	class:ProgrammedBurnData
ProgrammedBurn_CJ	ProgrammedBurnCore.C	/^namespace ProgrammedBurn_CJ {$/;"	n	file:
ProjData	BCApplier.h	/^  ProjData(int nd, double nrm[3]) {$/;"	f	struct:ProjData
ProjData	BCApplier.h	/^struct ProjData {$/;"	s
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    PROJECTED_ARRAY<T_ARRAY,FIELD_PROJECTOR<T_IF_CLASS,T_FIELD,field> > Project()$/;"	f	class:PhysBAM::ARRAY_BASE
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    PROJECTED_ARRAY<T_ARRAY,INDEX_PROJECTOR> Project(const ID index)$/;"	f	class:PhysBAM::ARRAY_BASE
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    PROJECTED_ARRAY<const T_ARRAY,FIELD_PROJECTOR<T_IF_CLASS,T_FIELD,field> > Project() const$/;"	f	class:PhysBAM::ARRAY_BASE
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    PROJECTED_ARRAY<const T_ARRAY,INDEX_PROJECTOR> Project(const ID index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Project(const VECTOR& direction) \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    void Project(const VECTOR& direction) \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Project(const VECTOR& direction) \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Project	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Project(const VECTOR& direction) \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
ProjectIncrementalSnapshots	IoData.h	/^  enum ProjectIncrementalSnapshots {PROJECT_INCREMENTAL_SNAPS_FALSE = 0, PROJECT_INCREMENTAL_SNAPS_TRUE = 1} projectIncrementalSnaps;$/;"	g	struct:RelativeProjectionErrorData
ProjectResidual	MultiGridLevel.C	/^ProjectResidual(DistSVec<Scalar2,dim>& r) const {$/;"	f	class:MultiGridLevel
ProjectSnapshotsMinusRefSol	IoData.h	/^  enum ProjectSnapshotsMinusRefSol {PROJECT_SNAPS_MINUS_REF_SOL_FALSE = 0, PROJECT_SNAPS_MINUS_REF_SOL_TRUE = 1} subtractRefSol;$/;"	g	struct:RelativeProjectionErrorData
ProjectSwitchStateOntoAffineSubspace	IoData.h	/^  enum ProjectSwitchStateOntoAffineSubspace {PROJECT_OFF = 0, PROJECT_ON = 1} projectSwitchStateOntoAffineSubspace;$/;"	g	struct:NonlinearRomOnlineData
Project_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Project_On_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    void Project_On_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Project_On_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Project_On_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Project_Orthogonal_To_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Project_Orthogonal_To_Unit_Direction(const VECTOR& direction)$/;"	f	class:PhysBAM::VECTOR
Project_Points_Onto_Line	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Project_Points_Onto_Line(const TV& direction,T& line_min,T& line_max) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Project_Points_Onto_Line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Project_Points_Onto_Line(const TV& direction,T& line_min,T& line_max) const$/;"	f	class:PhysBAM::RANGE
Projected	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR Projected(const VECTOR& direction) const \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Projected	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR Projected(const VECTOR& direction) const \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Projected	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Projected(const VECTOR& direction) const \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Projected	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Projected(const VECTOR& direction) const \/\/ un-normalized direction$/;"	f	class:PhysBAM::VECTOR
Projected_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR Projected_On_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR Projected_On_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Projected_On_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_On_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Projected_On_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR Projected_Orthogonal_To_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR Projected_Orthogonal_To_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Projected_Orthogonal_To_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projected_Orthogonal_To_Unit_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Projected_Orthogonal_To_Unit_Direction(const VECTOR& direction) const$/;"	f	class:PhysBAM::VECTOR
Projection	IoData.h	/^  enum Projection {PETROV_GALERKIN = 0, GALERKIN = 1} projection;$/;"	g	struct:NonlinearRomOnlineData
Projector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    const T_PROJECTOR& Projector() const$/;"	f	class:PhysBAM::PROJECTED_ARRAY
Prolong	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::Prolong(int coarseLvl,$/;"	f	class:MultiGridKernel
Prolong	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::Prolong(MultiGridLevel<Scalar>& fineGrid, const DistSVec<Scalar2,dim>& coarseInitialData,$/;"	f	class:MultiGridLevel
Prsgs	DynamicLESTerm.h	/^  double Prsgs;$/;"	m	class:DynamicLESTerm
Prune_Duplicates	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Prune_Duplicates()$/;"	f	class:PhysBAM::ARRAY_BASE
Pscale	EmbeddedTsDesc.h	/^  double Pscale;$/;"	m	class:EmbeddedTsDesc
Pscale	MultiPhysicsTsDesc.h	/^  double Pscale;$/;"	m	class:MultiPhysicsTsDesc
PseudoFastMarchingMethod	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::PseudoFastMarchingMethod($/;"	f	class:ReinitializeDistanceToWall
PseudoInverseSolver	IoData.h	/^  enum PseudoInverseSolver {PSEUDO_INVERSE_SCALAPACK = 0, PSEUDO_INVERSE_LINPACK = 1} pseudoInverseSolver;$/;"	g	struct:GappyConstructionData
Pseudo_Divide	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T1 Pseudo_Divide(const T1& a,const T2& b)$/;"	f	namespace:PhysBAM
Pseudo_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T Pseudo_Inverse(const T a)$/;"	f	namespace:PhysBAM
Psi	LevelSet.h	/^  DistSVec<double,1> Psi;		\/\/ the steady state solution of Psi will reinitialize the level set$/;"	m	class:LevelSet
PsiRes	LevelSet.h	/^  DistSVec<double,dimLS> PsiRes;        \/\/ residual of the reinitialization equation$/;"	m	class:LevelSet
Pstiff	VarFcnSGEuler.h	/^  double Pstiff;$/;"	m	class:VarFcnSGEuler
Pstiff	VarFcnSGKE.h	/^  double Pstiff;$/;"	m	class:VarFcnSGKE
Pstiff	VarFcnSGSA.h	/^  double Pstiff;$/;"	m	class:VarFcnSGSA
Push	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    void Push(const std::string& scope_identifier,const std::string& format,const T1& d1)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
Push	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    void Push(const std::string& scope_identifier,const std::string& scope_name)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
Push_Scope	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Push_Scope(const std::string& scope_identifier,const std::string& scope_name)$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Put(const T2 constant,const T_ARRAY& old_copy,T_ARRAY& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Put(const T_ARRAY& old_copy,T_ARRAY& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const RANGE<TV_INT>& box)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const int m_start,const int m_end,const int n_start,const int n_end,const int mn_start,const int mn_end)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const RANGE<VECTOR<int,1> >& box)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const RANGE<VECTOR<int,2> >& box)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const RANGE<VECTOR<int,3> >& box)$/;"	f	class:PhysBAM::ARRAY_BASE
Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Put(const T2 constant,const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const int m_start,const int m_end,const int n_start,const int n_end,const int mn_start,const int mn_end)$/;"	f	class:PhysBAM::ARRAY_BASE
PutVector	arpack++/include/arrseig.h	/^ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::PutVector()$/;"	f	class:ARrcStdEig
PutVector	arpack++/include/arrssym.h	/^ARFLOAT* ARrcSymStdEig<ARFLOAT>::PutVector()$/;"	f	class:ARrcSymStdEig
Q	MatVecProd.h	/^  DistSVec<double,dim> *Q;$/;"	m	class:MatVecProdH2
Q	MatVecProd.h	/^  DistSVec<double,dim> *Q;$/;"	m	class:MatVecProd_dRdX
Q	MatVecProd.h	/^  DistSVec<double,dim> Q;$/;"	m	class:MatVecProdFDMultiPhase
Q	MatVecProd.h	/^  DistSVec<double,dimLS> *Q;$/;"	m	class:MatVecProdLS
Q	MatVecProd.h	/^  DistSVec<double,neq> Q;$/;"	m	class:MatVecProdFD
QBar	DistTimeState.h	/^  DistSVec<double,dim> *QBar;$/;"	m	class:DistTimeState
QR	AlternatingLeastSquare/als_io.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	e	enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
QR	IoData.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	e	enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
QR	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	e	enum:NonlinearRomOnlineData::LSSolver
QR	IoData.h	/^  enum LsSolver {QR=0, NORMAL_EQUATIONS=1} lsSolver;$/;"	e	enum:SensitivityAnalysis::LsSolver
QUADRATIC	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    QUADRATIC()$/;"	f	class:PhysBAM::QUADRATIC
QUADRATIC	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    QUADRATIC(const T a_input,const T b_input,const T c_input)$/;"	f	class:PhysBAM::QUADRATIC
QUADRATIC	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^class QUADRATIC:public NONLINEAR_FUNCTION<T(T)>$/;"	c	namespace:PhysBAM
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION()$/;"	f	class:PhysBAM::QUATERNION
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION(const T s,const T x,const T y,const T z)$/;"	f	class:PhysBAM::QUATERNION
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION(const T s,const TV& v)$/;"	f	class:PhysBAM::QUATERNION
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    explicit QUATERNION(const VECTOR<T,4>& q)$/;"	f	class:PhysBAM::QUATERNION
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    template<class T2> explicit QUATERNION(const QUATERNION<T2>& q)$/;"	f	class:PhysBAM::QUATERNION
QUATERNION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^class QUATERNION$/;"	c	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct QUOTIENT<T_ARRAY2,T1,typename IF<IS_FLOAT_OR_DOUBLE<T1>::value && IS_ARRAY<T_ARRAY2>::value,void,typename PRODUCT<T1,typename T_ARRAY2::ELEMENT>::TYPE>::TYPE>$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,float>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,int>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,int>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,int>{typedef int TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
QUOTIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T1,class T_VECTOR2> struct QUOTIENT<T_VECTOR2,T1,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR2>::value && IS_SCALAR<T1>::value>::TYPE>$/;"	s	namespace:PhysBAM
Q_From_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Q_From_QR_Factorization() const \/\/ Gram Schmidt$/;"	f	class:MATRIX
Qeps	MatVecProd.h	/^  DistSVec<double,dim> Qeps;$/;"	m	class:MatVecProdFD
Qeps	MatVecProd.h	/^  DistSVec<double,dim> Qeps;$/;"	m	class:MatVecProdFDMultiPhase
Qeps	MatVecProd.h	/^  DistSVec<double,dimLS> Qeps;$/;"	m	class:MatVecProdLS
Qepstmp	MatVecProd.h	/^  DistSVec<double,neq> Qepstmp;$/;"	m	class:MatVecProdFD
Qs	TsOutput.h	/^  DistVec<double>    *Qs;$/;"	m	class:TsOutput
Qs_match	TsOutput.h	/^  DistVec<double>    *Qs_match;$/;"	m	class:TsOutput
Qs_match_opt	TsOutput.h	/^  DistSVec<double,1> *Qs_match_opt;$/;"	m	class:TsOutput
Quadrature	Quadrature.h	/^    Quadrature () {$/;"	f	class:Quadrature
Quadrature	Quadrature.h	/^    Quadrature (int qOrder) {$/;"	f	class:Quadrature
Quadrature	Quadrature.h	/^class Quadrature$/;"	c
Quaternion	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const QUATERNION<T>& Quaternion() const$/;"	f	class:PhysBAM::ROTATION
Qv	TsOutput.h	/^  DistSVec<double,3> *Qv;$/;"	m	class:TsOutput
R	CorotSolver.h	/^  double R[3][3];$/;"	m	class:CorotSolver
R	DistNodalGrad.h	/^  DistSVec<double,6> *R;$/;"	m	class:DistNodalGrad
R	DynamicLESTerm.h	/^  double R;$/;"	m	class:DynamicLESTerm
R	EmbeddedCorotSolver.h	/^  double R[3][3];$/;"	m	class:EmbeddedCorotSolver
R	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
R	MatVecProd.h	/^  MatVecProdH1<dim, Scalar, neq> *R;$/;"	m	class:MatVecProdH2
R	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
R	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
R	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
R	OneDimensionalSolver.h	/^  SVec<double,5> R;$/;"	m	class:OneDimensional
R	TsDesc.h	/^  DistSVec<double,dim> *R;$/;"	m	class:TsDesc
R1	IoData.h	/^  double A1,R1,rhoref,A2,R2;$/;"	m	struct:JWLModelData
R1	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,neq1> R1,dx1;$/;"	m	class:MultiGridSegTsDesc
R1	ProgrammedBurnCore.C	/^	double A1,A2,R1,R2,omega;$/;"	m	class:ProgrammedBurn_CJ::JWLEOS	file:
R1	VarFcnJwl.h	/^  double A1, A2, R1, R2, rhoref;$/;"	m	class:VarFcnJwl
R1r	VarFcnJwl.h	/^  double R1r, R2r;$/;"	m	class:VarFcnJwl
R2	IoData.h	/^  double A1,R1,rhoref,A2,R2;$/;"	m	struct:JWLModelData
R2	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,neq2> R2,dx2;$/;"	m	class:MultiGridSegTsDesc
R2	ProgrammedBurnCore.C	/^	double A1,A2,R1,R2,omega;$/;"	m	class:ProgrammedBurn_CJ::JWLEOS	file:
R2	VarFcnJwl.h	/^  double A1, A2, R1, R2, rhoref;$/;"	m	class:VarFcnJwl
R2r	VarFcnJwl.h	/^  double R1r, R2r;$/;"	m	class:VarFcnJwl
RANDOM_NUMBERS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^RANDOM_NUMBERS(const unsigned int seed)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
RANDOM_NUMBERS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^class RANDOM_NUMBERS:public NONCOPYABLE$/;"	c	namespace:PhysBAM
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE()$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE(const T xmin,const T xmax)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE(const T xmin,const T xmax,const T ymin,const T ymax)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE(const T xmin,const T xmax,const T ymin,const T ymax,const T zmin,const T zmax)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE(const TV& minimum_corner,const TV& maximum_corner)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE(const TV& point)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    template<class T2> explicit RANGE(const RANGE<T2>& box)$/;"	f	class:PhysBAM::RANGE
RANGE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^class RANGE$/;"	c	namespace:PhysBAM
RANGE_ERROR	arpack++/include/arerror.h	/^    RANGE_ERROR         = -107,$/;"	e	enum:ArpackError::ErrorCode
RAPIDLY_CHANGING_DENSITY	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
RAPIDLY_CHANGING_PRESSURE	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
RAS	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	e	enum:PcData::Type
RAS	MultiGridSmoothingMatrix.h	/^  enum SmoothingMode { BlockJacobi, LineJacobi, RAS };$/;"	e	enum:MultiGridSmoothingMatrix::SmoothingMode
RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    RAY()$/;"	f	class:PhysBAM::RAY
RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    RAY(const SEGMENT_2D<T>& segment)$/;"	f	class:PhysBAM::RAY
RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    RAY(const SEGMENT_3D<T>& segment)$/;"	f	class:PhysBAM::RAY
RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    RAY(const TV& endpoint_input,const TV& direction_input,const bool already_normalized=false)$/;"	f	class:PhysBAM::RAY
RAY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^class RAY$/;"	c	namespace:PhysBAM
RBEI1	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	e	enum:LinearizedData::ErrorIndicator
RBEI2	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	e	enum:LinearizedData::ErrorIndicator
RBEI3	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	e	enum:LinearizedData::ErrorIndicator
RBEI4	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	e	enum:LinearizedData::ErrorIndicator
RBM	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
RBar	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *RBar;$/;"	m	class:DistDynamicVMSTerm
RCM	IoData.h	/^  enum Renumbering {NATURAL = 0, RCM = 1} renumbering;$/;"	e	enum:PcData::Renumbering
RCOND	arpack++/include/arlutil.h	/^    RCOND,   \/* estimate reciprocal condition number *\/$/;"	e	enum:__anon51
RCROSS	f77src/hllcjac.f	/^      SUBROUTINE RCROSS(/;"	s
RDERIVATIVE	f77src/hllcjac.f	/^      SUBROUTINE RDERIVATIVE(/;"	s
REAL	IoData.h	/^  enum RiemannNormal {REAL = 0, MESH = 1, LEGACYMESH = 2 } riemannNormal;$/;"	e	enum:MultiFluidData::RiemannNormal
REAL	utils/Predicate.C	133;"	d	file:
REALPRINT	utils/Predicate.C	134;"	d	file:
REALRAND	utils/Predicate.C	135;"	d	file:
REAL_VOLUME	IoData.h	/^  enum VolumeType { CONSTANT_VOLUME = 0, REAL_VOLUME = 1} volumeType;$/;"	e	enum:OneDimensionalInfo::VolumeType
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    template<class T2> struct REBIND{typedef BOX<T2> TYPE;};$/;"	s	class:PhysBAM::BOX
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    template<class T2> struct REBIND{typedef ARRAY<T2,ID> TYPE;};$/;"	s	class:PhysBAM::ARRAY
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T,class T_NEW,class T_ARRAY,class ID> struct REBIND<ARRAY_BASE<T,T_ARRAY,ID>,T_NEW>{typedef ARRAY_BASE<T_NEW,typename T_ARRAY::template REBIND<T_NEW>::TYPE,ID> TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T,class T_NEW> struct REBIND<ARRAY<T>,T_NEW>{typedef ARRAY<T_NEW> TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T2> struct REBIND{typedef ARRAY_BASE<T2,typename T_ARRAY::template REBIND<T2>::TYPE,ID> TYPE;};$/;"	s	class:PhysBAM::ARRAY_BASE
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID,class T_NEW> struct REBIND<ARRAY_VIEW<T,ID>,T_NEW>{typedef ARRAY_VIEW<typename IF<IS_CONST<T>::value,const T_NEW,T_NEW>::TYPE,ID> TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    template<class T2> struct REBIND{typedef ARRAY_BASE<T2,ARRAYS_ND_BASE,TV_INT> TYPE;};$/;"	s	class:PhysBAM::ARRAY_BASE
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY<T,FACE_INDEX<d> >,T_NEW>{typedef ARRAY<T_NEW,FACE_INDEX<d> > TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY<T,VECTOR<int,d> >,T_NEW>{typedef ARRAY<T_NEW,VECTOR<int,d> > TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY_BASE<T,ARRAYS_ND_BASE,VECTOR<int,d> >,T_NEW>{typedef ARRAY_BASE<T_NEW,ARRAYS_ND_BASE,VECTOR<int,d> > TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    template<class T2> struct REBIND{typedef INTERVAL<T2> TYPE;};$/;"	s	class:PhysBAM::INTERVAL
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    template<class T2> struct REBIND{typedef RANGE<T2> TYPE;};$/;"	s	class:PhysBAM::RANGE
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,d> TYPE;};$/;"	s	class:PhysBAM::VECTOR
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,0> TYPE;};$/;"	s	class:PhysBAM::VECTOR
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,1> TYPE;};$/;"	s	class:PhysBAM::VECTOR
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,2> TYPE;};$/;"	s	class:PhysBAM::VECTOR
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,3> TYPE;};$/;"	s	class:PhysBAM::VECTOR
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d,class T_NEW> struct REBIND<VECTOR<T,d>,T_NEW>{typedef VECTOR<T_NEW,d> TYPE;};$/;"	s	namespace:PhysBAM
REBIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    template<class T2> struct REBIND{typedef VECTOR_ND<T2> TYPE;};$/;"	s	class:PhysBAM::VECTOR_ND
REBIND_LENGTH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    template<int length> struct REBIND_LENGTH:public PhysBAM::REBIND_LENGTH<ARRAY,length>{};$/;"	s	class:PhysBAM::ARRAY
REBIND_LENGTH	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,int m,int d,int length_new> struct REBIND_LENGTH<ARRAY<VECTOR<T,d>,VECTOR<int,m> >,length_new>{typedef ARRAY<VECTOR<T,length_new>,VECTOR<int,m> > TYPE;};$/;"	s	namespace:PhysBAM
RECONSTRUCTED_SURFACE	IoData.h	/^  enum ForceAlgorithm {RECONSTRUCTED_SURFACE = 0, CONTROL_VOLUME_BOUNDARY = 1, EMBEDDED_SURFACE = 2} forceAlg;$/;"	e	enum:EmbeddedFramework::ForceAlgorithm
REDO_TIMESTEP	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
REDUCE_TIMESTEP	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
REDUCE_TIMESTEP_TIME	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
REFINE	arpack++/include/arlutil.h	/^    REFINE,  \/* perform iterative refinement *\/$/;"	e	enum:__anon51
REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    REGISTRY()$/;"	f	class:PhysBAM::REGISTRY
REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^class REGISTRY$/;"	c	namespace:PhysBAM
REGULAR	IoData.h	/^  enum Startup {REGULAR = 0, MODIFIED = 1} startup;$/;"	e	enum:ImplicitData::Startup
REGULAR	IoData.h	/^  enum Test {REGULAR = 0} test;$/;"	e	enum:ProblemData::Test
RELAX	arpack++/include/arlutil.h	/^    RELAX,   \/* find artificial supernodes *\/$/;"	e	enum:__anon51
REL_PROJ_ERROR_JACACTION	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	e	enum:RelativeProjectionErrorData::RelativeProjectionError
REL_PROJ_ERROR_OFF	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	e	enum:RelativeProjectionErrorData::RelativeProjectionError
REL_PROJ_ERROR_RESIDUAL	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	e	enum:RelativeProjectionErrorData::RelativeProjectionError
REL_PROJ_ERROR_STATE	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	e	enum:RelativeProjectionErrorData::RelativeProjectionError
REMOVE_ALL_EXTENTS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,int size> struct REMOVE_ALL_EXTENTS<T[size]> {typedef typename REMOVE_ALL_EXTENTS<T>::type type;};$/;"	s	namespace:PhysBAM
REMOVE_ALL_EXTENTS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_ALL_EXTENTS {typedef T type;};$/;"	s	namespace:PhysBAM
REMOVE_ALL_EXTENTS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_ALL_EXTENTS<T[]> {typedef typename REMOVE_ALL_EXTENTS<T>::type type;};$/;"	s	namespace:PhysBAM
REMOVE_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_CONST<const T>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_CONST{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T const volatile[N]>{typedef T TYPE[N];};$/;"	s	namespace:PhysBAM
REMOVE_CV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T const[N]>{typedef T TYPE[N];};$/;"	s	namespace:PhysBAM
REMOVE_CV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T volatile[N]>{typedef T TYPE[N];};$/;"	s	namespace:PhysBAM
REMOVE_CV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV<T&>{typedef T& TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV{typedef typename REMOVE_CV_POINTER<T*>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<T*>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<const T*>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<const volatile T*>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<volatile T*>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_CV_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER{};$/;"	s	namespace:PhysBAM
REMOVE_POINTER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_POINTER<T*>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_REFERENCE<T&>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REMOVE_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_REFERENCE{typedef T TYPE;};$/;"	s	namespace:PhysBAM
REORDERING_ERROR	arpack++/include/arerror.h	/^    REORDERING_ERROR    = -204,$/;"	e	enum:ArpackError::ErrorCode
RESIDUAL	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	e	enum:CFLData::Strategy
RESIDUAL_AND_JACOBIAN_ROBS_GREEDY	IoData.h	/^                   JACOBIAN_ROB_GREEDY = 2, RESIDUAL_AND_JACOBIAN_ROBS_GREEDY = 3, SPECIFIED_SNAPS_GREEDY = 4} greedyData;$/;"	e	enum:GappyConstructionData::greedyData
RESIDUAL_ROB_GREEDY	IoData.h	/^  enum greedyData {UNSPECIFIED_GREEDY = -1, STATE_ROB_GREEDY = 0, RESIDUAL_ROB_GREEDY = 1,$/;"	e	enum:GappyConstructionData::greedyData
RESID_NOT_OK	arpack++/include/arerror.h	/^    RESID_NOT_OK        = -409,$/;"	e	enum:ArpackError::ErrorCode
RESTRICTION_MAPPING_H_	RestrictionMapping.h	2;"	d
RESULT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    template<class T_ARRAY> struct RESULT:public IF<IS_CONST<T_ARRAY>::value,const typename T_ARRAY::ELEMENT&,typename T_ARRAY::ELEMENT&>{};$/;"	s	struct:PhysBAM::INDEX_PROJECTOR
RESULT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    template<class U> struct RESULT:public IF<IS_CONST<U>::value,const T_FIELD&,T_FIELD&>{};$/;"	s	struct:PhysBAM::FIELD_PROJECTOR
RESULT_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef typename T_PROJECTOR::template RESULT<const typename T_ARRAY::ELEMENT>::TYPE RESULT_CONST;$/;"	t	class:PhysBAM::PROJECTED_ARRAY
RESULT_NONCONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef typename T_PROJECTOR::template RESULT<typename T_ARRAY::ELEMENT>::TYPE RESULT_NONCONST;$/;"	t	class:PhysBAM::PROJECTED_ARRAY
RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef T& RESULT_TYPE;$/;"	t	class:PhysBAM::ARRAY_BASE
RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_EXPRESSION.h	/^    typedef const T RESULT_TYPE;$/;"	t	class:PhysBAM::ARRAY_EXPRESSION
RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typedef T& RESULT_TYPE;$/;"	t	class:PhysBAM::ARRAY_VIEW
RESULT_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename ARRAY_RESULT_TYPE<T_ARRAY>::TYPE RESULT_TYPE;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
RFD	MatVecProd.h	/^  MatVecProdFD<dim, neq> *RFD;$/;"	m	class:MatVecProdH2
RGB_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
RGD2D_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
RGD_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
RHOrefwater	IoData.h	/^  double RHOrefwater;$/;"	m	struct:LiquidModelData
RHS_IGNORED	arpack++/include/arerror.h	/^    RHS_IGNORED         = -554,$/;"	e	enum:ArpackError::ErrorCode
RICHARDSON	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	e	enum:KspData::Type
RIEMANN_SOLUTION	IoData.h	/^  enum EOSChange {NODAL_STATE = 0, RIEMANN_SOLUTION = 1} eosChange;$/;"	e	enum:EmbeddedFramework::EOSChange
RIEMANN_SOLUTION	IoData.h	/^  enum TypePhaseChange {ASIS = 0, RIEMANN_SOLUTION = 1, EXTRAPOLATION = 2} typePhaseChange;$/;"	e	enum:MultiFluidData::TypePhaseChange
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef typename MATRIX_INFO<T_MATRIX>::RIGHT_VECTOR RIGHT_VECTOR;typedef typename MATRIX_INFO<T_MATRIX>::LEFT_VECTOR LEFT_VECTOR;$/;"	t	class:PhysBAM::MATRIX_BASE
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef typename MATRIX_INFO<T_MATRIX>::RIGHT_VECTOR RIGHT_VECTOR;typedef typename MATRIX_INFO<T_MATRIX>::TRANSPOSE TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<DIAGONAL_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef DIAGONAL_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<SYMMETRIC_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef SYMMETRIC_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<UPPER_TRIANGULAR_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct MATRIX_INFO<MATRIX<T,m,n> >{typedef VECTOR<T,m> LEFT_VECTOR;typedef VECTOR<T,n> RIGHT_VECTOR;typedef MATRIX<T,n,m> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RIGHT_VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T> struct MATRIX_INFO<MATRIX_MXN<T> >{typedef VECTOR_ND<T> LEFT_VECTOR;typedef VECTOR_ND<T> RIGHT_VECTOR;typedef MATRIX_MXN<T> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
RK2	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	e	enum:MultiFluidData::RiemannComputation
RK2	RKIntegrator.h	/^  enum Method { FE, RK2, RK4 };$/;"	e	enum:RKIntegrator::Method
RK4	ExplicitEmbeddedTsDesc.h	/^  bool RK4;$/;"	m	class:ExplicitEmbeddedTsDesc
RK4	ExplicitTsDesc.h	/^  bool RK4;$/;"	m	class:ExplicitTsDesc
RK4	RKIntegrator.h	/^  enum Method { FE, RK2, RK4 };$/;"	e	enum:RKIntegrator::Method
RKIntegrator	RKIntegrator.h	/^  RKIntegrator( Method method, int N) : myMethod(method), k1(NULL),k2(NULL),$/;"	f	class:RKIntegrator
RKIntegrator	RKIntegrator.h	/^class RKIntegrator {$/;"	c
ROBConstructionData	IoData.h	/^struct ROBConstructionData {$/;"	s
ROBConstructionData	IoDataCore.C	/^ROBConstructionData::ROBConstructionData()$/;"	f	class:ROBConstructionData
ROBInnerProductSchedule	Modal.C	/^void ModalSolver<dim>::ROBInnerProductSchedule(int** cache, int n, int Nmax, int nSteps )$/;"	f	class:ModalSolver
ROBInnerProductSteps	Modal.C	/^int ModalSolver<dim>::ROBInnerProductSteps(int n, int Nmax)$/;"	f	class:ModalSolver
ROBInnerProducts	Modal.C	/^void ModalSolver<dim>::ROBInnerProducts()$/;"	f	class:ModalSolver
ROE	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	e	enum:SchemeData::Flux
ROEFLUX1	f77src/roejac2.f	/^      SUBROUTINE ROEFLUX1(/;"	s
ROEFLUX1WATER	f77src/roejac2water.f	/^      SUBROUTINE ROEFLUX1WATER(/;"	s
ROEFLUX5	f77src/roeflux5.f	/^      SUBROUTINE ROEFLUX5(/;"	s
ROEFLUX5JWL	f77src/roeflux5jwl.f	/^      SUBROUTINE ROEFLUX5JWL(/;"	s
ROEFLUX5PRIM	f77src/roeflux5prim.f	/^      SUBROUTINE ROEFLUX5PRIM(/;"	s
ROEFLUX5WATERBURN	f77src/roeflux5waterdissprec_burnable.f	/^       SUBROUTINE ROEFLUX5WATERBURN(/;"	s
ROEFLUX5WATERDISSPREC	f77src/roeflux5waterdissprec.f	/^       SUBROUTINE ROEFLUX5WATERDISSPREC(/;"	s
ROEFLUX6	f77src/roeflux6.f	/^      SUBROUTINE ROEFLUX6(/;"	s
ROEFLUX7	f77src/roeflux7.f	/^      SUBROUTINE ROEFLUX7(/;"	s
ROEJAC2	f77src/roejac2.f	/^      SUBROUTINE ROEJAC2(/;"	s
ROEJAC2WATER	f77src/roejac2water.f	/^      SUBROUTINE ROEJAC2WATER(/;"	s
ROEJAC5	f77src/roejac5.f	/^      SUBROUTINE ROEJAC5(/;"	s
ROEJAC5WATERDISSPREC	f77src/roejac5waterdissprec.f	/^       SUBROUTINE ROEJAC5WATERDISSPREC(/;"	s
ROEJAC6	f77src/roejac6.f	/^      SUBROUTINE ROEJAC6(/;"	s
ROEJAC6JWL	f77src/roejac6jwl.f	/^      SUBROUTINE ROEJAC6JWL(/;"	s
ROEJACWATERDISSPRIM	f77src/roejacwaterdissprim.f	/^      SUBROUTINE ROEJACWATERDISSPRIM(/;"	s
ROLL	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
ROM	IoData.h	/^  enum Type {DEFAULT = 0, ROM = 1, FORCED = 2} type;$/;"	e	enum:LinearizedData::Type
ROM	Manual/Aerof3d.html	/^<a name="ROM"><\/a>$/;"	a
ROM-simulation	Manual/Aerof3d.html	/^<a name="ROM-simulation"><\/a>$/;"	a
ROMOutputData	IoData.h	/^struct ROMOutputData {$/;"	s
ROMOutputData	IoDataCore.C	/^ROMOutputData::ROMOutputData()$/;"	f	class:ROMOutputData
ROM_RESIDUAL	IoData.h	/^  enum MeritFunction {ROM_RESIDUAL=0, HDM_RESIDUAL=1} meritFunction;$/;"	e	enum:NonlinearRomOnlineData::MeritFunction
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^ROTATION(const MATRIX<T,3>& A) \/\/ matches A with a quaternion$/;"	f	class:ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^ROTATION(const T angle,const TV& direction)$/;"	f	class:ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION()$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION(const COMPLEX<T>& c2)$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION(const QUATERNION<T>& q2)$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION(const T s,const T x,const T y,const T z)$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    explicit ROTATION(const MATRIX<T,2>& A)$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    template<class T2> explicit ROTATION(const ROTATION<T2>& r)$/;"	f	class:PhysBAM::ROTATION
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^class ROTATION<VECTOR<T,1> >$/;"	c	namespace:PhysBAM
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^class ROTATION<VECTOR<T,2> >$/;"	c	namespace:PhysBAM
ROTATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^class ROTATION<VECTOR<T,3> >$/;"	c	namespace:PhysBAM
RTree	RTree.h	/^  RTree() { root = NULL; }$/;"	f	class:RTree
RTree	RTree.h	/^class RTree $/;"	c
RUNGE_KUTTA_2	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	e	enum:ExplicitData::Type
RUNGE_KUTTA_4	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	e	enum:ExplicitData::Type
R_From_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX<T,2> R_From_QR_Factorization() const$/;"	f	class:PhysBAM::MATRIX
R_From_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    UPPER_TRIANGULAR_MATRIX<T,2> R_From_QR_Factorization() const \/\/ Gram Schmidt$/;"	f	class:PhysBAM::MATRIX
R_From_QR_Factorization	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^R_From_QR_Factorization() const \/\/ Gram Schmidt$/;"	f	class:MATRIX
R_SVD	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	e	enum:DataCompressionData::PODMethod
Random	MultiGridLevel.h	/^    enum SeedNodeChoice { Random, Mavripilis };$/;"	e	enum:MultiGridLevel::SeedNodeChoice
Range	IoData.h	/^  typedef double Range[2];$/;"	t	struct:SparseGridData
Range	SparseGrid.h	/^  typedef double Range[2];$/;"	t	class:SparseGrid
RawArnoldiBasisVector	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawArnoldiBasisVector(int i)$/;"	f	class:ARrcStdEig
RawArnoldiBasisVectors	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawArnoldiBasisVectors()$/;"	f	class:ARrcStdEig
RawEigenvalues	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawEigenvalues()$/;"	f	class:ARrcStdEig
RawEigenvaluesImag	arpack++/include/arrsnsym.h	/^inline ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::RawEigenvaluesImag()$/;"	f	class:ARrcNonSymStdEig
RawEigenvector	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawEigenvector(int i)$/;"	f	class:ARrcStdEig
RawEigenvectors	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawEigenvectors()$/;"	f	class:ARrcStdEig
RawResidualVector	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawResidualVector()$/;"	f	class:ARrcStdEig
RawSchurVector	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawSchurVector(int i)$/;"	f	class:ARrcStdEig
RawSchurVectors	arpack++/include/arrseig.h	/^inline ARTYPE* ARrcStdEig<ARFLOAT, ARTYPE>::RawSchurVectors()$/;"	f	class:ARrcStdEig
Ray_Intersection	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Ray_Intersection(const ARRAY<int> &scope, const ARRAY<TRIANGLE_3D<T> >& triangle_list,const ARRAY<int>& candidates,$/;"	f	namespace:__anon13
RbmExtractor	MeshMotionHandler.h	/^class RbmExtractor : public MeshMotionHandler {$/;"	c
RbmExtractor	MeshMotionHandlerCore.C	/^RbmExtractor::RbmExtractor(IoData &iod, Domain *dom) $/;"	f	class:RbmExtractor
RcnExtrap	HigherOrderFSI.C	/^void HigherOrderFSI::RcnExtrap(int l, int vertex, int i, $/;"	f	class:HigherOrderFSI
RcvData	SubDomain.C	/^void SubDomain::RcvData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
ReSolve	DenseMatrix.C	/^GenFullM<Scalar>::ReSolve(double *b)$/;"	f	class:GenFullM
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	/^    static void Read(std::istream& input,ARRAY<T,ID>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY_VIEW.h	/^    static void Read(std::istream& input,ARRAY_VIEW<T,ID>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^    static void Read(typename IF<IS_SAME<T,void>::value,UNUSABLE,std::istream&>::TYPE input,HASHTABLE<TK,T>& object) \/\/ non-void version$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^    static void Read(typename IF<IS_SAME<T,void>::value,std::istream&,UNUSABLE>::TYPE input,HASHTABLE<TK,T>& object) \/\/ void version$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^    static void Read(std::istream& input,TWIST<TV>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Read(std::istream& input,T& d)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Read(std::istream& input,T*& d)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Read(std::istream& input,std::string& d)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    template<class T> void Read(T& d)$/;"	f	class:PhysBAM::TYPED_ISTREAM
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	/^    static void Read(std::istream& input,VECTOR<T,d>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	/^    static void Read(std::istream& input,VECTOR<T,0>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	/^    static void Read(std::istream& input,VECTOR<T,1>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	/^    static void Read(std::istream& input,VECTOR<T,2>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	/^    static void Read(std::istream& input,VECTOR<T,3>& object)$/;"	f	class:PhysBAM::Read_Write
Read	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	/^    static void Read(std::istream& input,VECTOR_ND<T>& object)$/;"	f	class:PhysBAM::Read_Write
ReadBlock	arpack++/include/ardfmat.h	/^void ARdfMatrix<ARTYPE>::ReadBlock()$/;"	f	class:ARdfMatrix
ReadEntry	arpack++/include/ardfmat.h	/^ReadEntry(ifstream& file, arcomplex<double>& val)$/;"	f	class:ARdfMatrix
ReadEntry	arpack++/include/ardfmat.h	/^ReadEntry(ifstream& file, arcomplex<float>& val)$/;"	f	class:ARdfMatrix
ReadEntry	arpack++/include/ardfmat.h	/^inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, double& val)$/;"	f	class:ARdfMatrix
ReadEntry	arpack++/include/ardfmat.h	/^inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, float& val)$/;"	f	class:ARdfMatrix
ReadEntry	arpack++/include/arhbmat.h	/^ReadEntry(ifstream& file, int nval, int fval, int& j, double& val)$/;"	f	class:ARhbMatrix
ReadEntry	arpack++/include/arhbmat.h	/^ReadEntry(ifstream& file, int nval, int fval, int& j, float& val)$/;"	f	class:ARhbMatrix
ReadEntry	arpack++/include/arhbmat.h	/^ReadEntry(ifstream& file, int nval, int fval,$/;"	f	class:ARhbMatrix
ReadFormat	arpack++/include/arhbmat.h	/^void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(ifstream& file, int& n, int& fmt)$/;"	f	class:ARhbMatrix
ReadMode	OneDimensionalSolver.h	/^  enum ReadMode { ModeU, ModePhi };$/;"	g	class:OneDimensional
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Read_Binary(TYPED_ISTREAM& input,T& d)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Read_Binary(std::istream& input,T& d)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(TYPED_ISTREAM& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8,T9& d9)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8)$/;"	f	namespace:PhysBAM
Read_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Read_Binary(std::istream& input,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8,T9& d9)$/;"	f	namespace:PhysBAM
Read_Binary_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Read_Binary_Array(std::istream& input,T* array,const int number_of_elements)$/;"	f	namespace:PhysBAM
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const STREAM_TYPE stream_type,const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_File(const std::string& filename,T1& d1,T2& d2,T3& d3,T4& d4,T5& d5,T6& d6,T7& d7,T8& d8)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_From_Text_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Read_From_Text_File(const std::string& filename,T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Read_Primitive	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^Read_Primitive(std::istream& input,T& d)$/;"	f	namespace:PhysBAM
Read_Primitive	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^inline void Read_Primitive<bool>(std::istream& input,bool& d)$/;"	f	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	/^class Read_Write<ARRAY<T,ID>,RW>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY_VIEW.h	/^class Read_Write<ARRAY_VIEW<T,ID>,RW>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^class Read_Write<HASHTABLE<TK,T>,RW>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^class Read_Write<TWIST<TV>,RW,typename DISABLE_IF<IS_BINARY_IO_SAFE<TWIST<TV>,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^class Read_Write$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^class Read_Write<T*,RW>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^class Read_Write<std::string,RW>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW> class Read_Write<T,RW,typename ENABLE_IF<(IS_INTEGRAL<T>::value || IS_ENUM<T>::value) && !IS_BINARY_IO_SAFE<T,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW> class Read_Write<T,RW,typename ENABLE_IF<(IS_SAME<T,float>::value || IS_SAME<T,double>::value) && !IS_BINARY_IO_SAFE<T,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW> class Read_Write<T,RW,typename ENABLE_IF<IS_BINARY_IO_SAFE<T,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	/^class Read_Write<VECTOR<T,d>,RW,typename DISABLE_IF<OR<IS_BINARY_IO_SAFE<VECTOR<T,d>,RW>::value,$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	/^class Read_Write<VECTOR<T,0>,RW,typename DISABLE_IF<IS_BINARY_IO_SAFE<VECTOR<T,0>,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	/^class Read_Write<VECTOR<T,1>,RW,typename DISABLE_IF<IS_BINARY_IO_SAFE<VECTOR<T,1>,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	/^class Read_Write<VECTOR<T,2>,RW,typename DISABLE_IF<IS_BINARY_IO_SAFE<VECTOR<T,2>,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	/^class Read_Write<VECTOR<T,3>,RW,typename DISABLE_IF<IS_BINARY_IO_SAFE<VECTOR<T,3>,RW>::value>::TYPE>$/;"	c	namespace:PhysBAM
Read_Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	/^class Read_Write<VECTOR_ND<T>,RW>$/;"	c	namespace:PhysBAM
Real_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Real_File(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Real_Path	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::string Real_Path(const std::string& path)\/\/TODO: Implement this for windows$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Reallocate_Buffer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Reallocate_Buffer()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
RecFcn	RecFcn.h	/^  RecFcn(double b, double e) $/;"	f	class:RecFcn
RecFcn	RecFcn.h	/^class RecFcn : virtual public RecFcnBase {$/;"	c
RecFcnBarth	RecFcnDesc.h	/^  RecFcnBarth(double b, double e) : RecFcnLtdMultiDim<dim>(b, e) {}$/;"	f	class:RecFcnBarth
RecFcnBarth	RecFcnDesc.h	/^class RecFcnBarth : public RecFcnLtdMultiDim<dim> {$/;"	c
RecFcnBase	RecFcn.h	/^struct RecFcnBase {$/;"	s
RecFcnConstant	RecFcnDesc.h	/^  RecFcnConstant() : RecFcn(0.0, 0.0) {}$/;"	f	class:RecFcnConstant
RecFcnConstant	RecFcnDesc.h	/^class RecFcnConstant : public RecFcn {$/;"	c
RecFcnExtendedVanAlbada	RecFcnDesc.h	/^  RecFcnExtendedVanAlbada(double b, double e, double pc, double rhoc,$/;"	f	class:RecFcnExtendedVanAlbada
RecFcnExtendedVanAlbada	RecFcnDesc.h	/^class RecFcnExtendedVanAlbada : public RecFcnVanAlbada<dim> {$/;"	c
RecFcnLinear	RecFcnDesc.h	/^  RecFcnLinear(double b, double e) : RecFcn(b, e) {}$/;"	f	class:RecFcnLinear
RecFcnLinear	RecFcnDesc.h	/^class RecFcnLinear : public RecFcn {$/;"	c
RecFcnLinearConstant	RecFcnDesc.h	/^  RecFcnLinearConstant(double b, double e) : RecFcn(b, e) {}$/;"	f	class:RecFcnLinearConstant
RecFcnLinearConstant	RecFcnDesc.h	/^class RecFcnLinearConstant : public RecFcn {$/;"	c
RecFcnLinearVanAlbada	RecFcnDesc.h	/^  RecFcnLinearVanAlbada(double b, double e) : RecFcn(b, e) {}$/;"	f	class:RecFcnLinearVanAlbada
RecFcnLinearVanAlbada	RecFcnDesc.h	/^class RecFcnLinearVanAlbada : public RecFcn {$/;"	c
RecFcnLtdLinear	RecFcnDesc.h	/^  RecFcnLtdLinear(double b, double e) : RecFcnLinear<dim>(b, e), RecFcnLtdSensor(e) {}$/;"	f	class:RecFcnLtdLinear
RecFcnLtdLinear	RecFcnDesc.h	/^class RecFcnLtdLinear : public RecFcnLinear<dim>, public RecFcnLtdSensor {$/;"	c
RecFcnLtdLinearConstant	RecFcnDesc.h	/^  RecFcnLtdLinearConstant(double b, double e) : RecFcnLinearConstant<dim>(b, e), RecFcnLtdSensor(e) {}$/;"	f	class:RecFcnLtdLinearConstant
RecFcnLtdLinearConstant	RecFcnDesc.h	/^class RecFcnLtdLinearConstant : public RecFcnLinearConstant<dim>, public RecFcnLtdSensor {$/;"	c
RecFcnLtdMultiDim	RecFcnDesc.h	/^  RecFcnLtdMultiDim(double b, double e) : RecFcnLinear<dim>(b, e) {}$/;"	f	class:RecFcnLtdMultiDim
RecFcnLtdMultiDim	RecFcnDesc.h	/^class RecFcnLtdMultiDim : public RecFcnLinear<dim>, public RecLimiter {$/;"	c
RecFcnLtdSensor	RecFcnDesc.h	/^  RecFcnLtdSensor(double eps) { threshold = eps; }$/;"	f	class:RecFcnLtdSensor
RecFcnLtdSensor	RecFcnDesc.h	/^class RecFcnLtdSensor {$/;"	c
RecFcnVanAlbada	RecFcnDesc.h	/^  RecFcnVanAlbada(double b, double e) : RecFcn(b, e) {}$/;"	f	class:RecFcnVanAlbada
RecFcnVanAlbada	RecFcnDesc.h	/^class RecFcnVanAlbada : public RecFcn {$/;"	c
RecFcnVanAlbadaConstant	RecFcnDesc.h	/^  RecFcnVanAlbadaConstant(double b, double e) : RecFcn(b, e) {}$/;"	f	class:RecFcnVanAlbadaConstant
RecFcnVanAlbadaConstant	RecFcnDesc.h	/^class RecFcnVanAlbadaConstant : public RecFcn {$/;"	c
RecFcnVenkat	RecFcnDesc.h	/^  RecFcnVenkat(double b, double e) : RecFcnLtdMultiDim<dim>(b, e) {}$/;"	f	class:RecFcnVenkat
RecFcnVenkat	RecFcnDesc.h	/^class RecFcnVenkat : public RecFcnLtdMultiDim<dim> {$/;"	c
RecInfo	Communicator.h	/^struct RecInfo {$/;"	s
RecLimiter	RecFcn.h	/^class RecLimiter : virtual public RecFcnBase {$/;"	c
Reconstruction	IoData.h	/^  enum Reconstruction {CONSTANT = 0, EXACT_RIEMANN = 1} reconstruction;$/;"	g	struct:BcsWallData
Reconstruction	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruct;$/;"	g	struct:EmbeddedFramework
Reconstruction	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruction;$/;"	g	struct:SchemeData
RecoverEigenvalues	arpack++/include/argnsym.h	/^void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::RecoverEigenvalues()$/;"	f	class:ARNonSymGenEig
Rectangle_Intersects	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.cpp	/^template<class T> bool Rectangle_Intersects(RAY<VECTOR<T,3> >& ray,const PLANE<T>& plane,const PLANE<T>& bounding_plane1,const PLANE<T>& bounding_plane2,const PLANE<T>& bounding_plane3,const PLANE<T>& bounding_plane4,const T thickness_over_two)$/;"	f	namespace:PhysBAM::INTERSECTION
RectangularDenseMatrixOp	DenseMatrixOps.h	/^class RectangularDenseMatrixOp {$/;"	c
RectangularSparseMat	RectangularSparseMatrix.h	/^  RectangularSparseMat(int _n, int _nnz, int *_ia, int *_ja, Scalar (*_a)[dim*dim2],$/;"	f	class:RectangularSparseMat
RectangularSparseMat	RectangularSparseMatrix.h	/^class RectangularSparseMat {$/;"	c
Recursive	IoData.h	/^  enum Mode {Recursive = 1, NonRecursive = 2} mode;$/;"	e	enum:DefoMeshMotionData::Mode
ReducedMeshShapeChanger	ReducedMeshShapeChanger.C	/^ReducedMeshShapeChanger<dim>::ReducedMeshShapeChanger(Communicator *_com, IoData &_ioData, Domain &dom, DistGeoState *_geoState) : $/;"	f	class:ReducedMeshShapeChanger
ReducedMeshShapeChanger	ReducedMeshShapeChanger.h	/^class ReducedMeshShapeChanger : public GappyPreprocessing<dim> {$/;"	c
ReducedOrderBasisConstruction	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::ReducedOrderBasisConstruction() {$/;"	f	class:EmbeddedAlternatingLeastSquare
ReducedOrderBasisConstruction	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::ReducedOrderBasisConstruction(int _dim) {$/;"	f	class:EmbeddedAlternatingLeastSquare
ReducedOrderBasisConstructionTesting	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::ReducedOrderBasisConstructionTesting(int k) {$/;"	f	class:EmbeddedAlternatingLeastSquare
RefVal	RefVal.C	/^RefVal::RefVal()$/;"	f	class:RefVal
RefVal	RefVal.h	/^class RefVal {$/;"	c
RefVec	RefVector.h	/^RefVec<VecType>::RefVec(VecType &vec) : refVec(vec)$/;"	f	class:RefVec
RefVec	RefVector.h	/^class RefVec {$/;"	c
RefVec5	ParallelRomCore.C	/^typedef RefVec<DistSVec<double, 5> > RefVec5;$/;"	t	file:
RefVec6	ParallelRomCore.C	/^typedef RefVec<DistSVec<double, 6> > RefVec6;$/;"	t	file:
RefVec7	ParallelRomCore.C	/^typedef RefVec<DistSVec<double, 7> > RefVec7;$/;"	t	file:
ReferenceState	Manual/Aerof3d.html	/^<a name="ReferenceState"><\/a>$/;"	a
ReferenceStateData	IoData.h	/^struct ReferenceStateData {$/;"	s
ReferenceStateData	IoDataCore.C	/^ReferenceStateData::ReferenceStateData()$/;"	f	class:ReferenceStateData
Reflected_Direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV Reflected_Direction(const TV& normal) const$/;"	f	class:PhysBAM::RAY
Refresh_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^Refresh_Auxiliary_Structures()$/;"	f	class:SEGMENT_MESH
Refresh_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Refresh_Auxiliary_Structures()$/;"	f	class:PhysBAM::SIMPLEX_MESH
Refresh_Auxiliary_Structures	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Refresh_Auxiliary_Structures()$/;"	f	class:TRIANGLE_MESH
Region	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Region(const VECTOR<T,3>& location,int& region_id,const T distance) const$/;"	f	class:TRIANGLE_3D
Register	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    template<class T_OBJECT> static void Register()$/;"	f	class:PhysBAM::REGISTRY
Register_Timer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Register_Timer()$/;"	f	class:PhysBAM::TIMER
ReinitializeDistanceToWall	ReinitializeDistanceToWall.C	/^ReinitializeDistanceToWall<dimLS>::ReinitializeDistanceToWall(IoData &ioData, Domain& domain)$/;"	f	class:ReinitializeDistanceToWall
ReinitializeDistanceToWall	ReinitializeDistanceToWall.h	/^class ReinitializeDistanceToWall$/;"	c
RelativeProjectionError	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	g	struct:RelativeProjectionErrorData
RelativeProjectionErrorData	IoData.h	/^struct RelativeProjectionErrorData {$/;"	s
RelativeProjectionErrorData	IoDataCore.C	/^RelativeProjectionErrorData::RelativeProjectionErrorData()$/;"	f	class:RelativeProjectionErrorData
Release_Timer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Release_Timer(const int id)$/;"	f	class:PhysBAM::TIMER
Remove_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Remove_All() \/\/ if elements are non-primitive this may waste memory$/;"	f	class:PhysBAM::ARRAY
Remove_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    void Remove_All()$/;"	f	class:PhysBAM::STACK
Remove_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^Remove_Array(const ID array_id)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Remove_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Remove_Array(const std::string array_name)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Remove_Dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<VECTOR<T,d-1> > Remove_Dimension(int dimension) const$/;"	f	class:PhysBAM::RANGE
Remove_End	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Remove_End()$/;"	f	class:PhysBAM::ARRAY
Remove_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Remove_Index(const ID index) \/\/ preserves ordering of remaining elements$/;"	f	class:PhysBAM::ARRAY
Remove_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR<T,d-1> Remove_Index(const int index) const$/;"	f	class:PhysBAM::VECTOR
Remove_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR<T,0> Remove_Index(const int index) const$/;"	f	class:PhysBAM::VECTOR
Remove_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,1> Remove_Index(const int index) const$/;"	f	class:PhysBAM::VECTOR
Remove_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR<T,2> Remove_Index(const int index) const$/;"	f	class:PhysBAM::VECTOR
Remove_Index_Lazy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Remove_Index_Lazy(const ID index)$/;"	f	class:PhysBAM::ARRAY
Remove_Sorted_Indices	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Remove_Sorted_Indices(const T_ARRAY1& index)$/;"	f	class:PhysBAM::ARRAY_BASE
Remove_Sorted_Indices_Lazy	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Remove_Sorted_Indices_Lazy(const T_ARRAY1& index)$/;"	f	class:PhysBAM::ARRAY_BASE
Renumbering	IoData.h	/^  enum Renumbering {NATURAL = 0, RCM = 1} renumbering;$/;"	g	struct:PcData
Replace_Node_In_Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    void Replace_Node_In_Segment(const int segment,const int old_node,const int new_node)$/;"	f	class:PhysBAM::SEGMENT_MESH
Replace_Node_In_Simplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    void Replace_Node_In_Simplex(const int simplex,const int old_node,const int new_node)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Replace_Node_In_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    void Replace_Node_In_Triangle(const int triangle,const int old_node,const int new_node)$/;"	f	class:PhysBAM::TRIANGLE_MESH
ResRestrict	ImplicitGappyTsDesc.h	/^  std::unique_ptr< DistSVec<double, dim> > ResRestrict;$/;"	m	class:ImplicitGappyTsDesc
ResType	Vector.h	/^    typedef B ResType;$/;"	t	class:ProdRes
ResType	Vector.h	/^    typedef complex<double> ResType;$/;"	t	class:ProdRes
Rescale	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Rescale(const T scaling_factor) {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Rescale	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^Rescale(const T scaling_factor)$/;"	f	class:STRUCTURE
Reset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    void Reset()$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
Reset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Reset()$/;"	f	namespace:PhysBAM::LOG_REAL
Reset_Bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Reset_Bounds(const TV& point)$/;"	f	class:PhysBAM::RANGE
Reset_List_Arrays_Stored_In_Table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Reset_List_Arrays_Stored_In_Table() \/\/ of course, only works if pointers to ARRAY are stored in table$/;"	f	class:PhysBAM::HASHTABLE
Reset_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Reset_Time(const int id)$/;"	f	class:PhysBAM::TIMER
ResidualData	IoData.h	/^struct ResidualData {$/;"	s
ResidualData	IoDataCore.C	/^ResidualData::ResidualData()$/;"	f	class:ResidualData
ResidualScaling	IoData.h	/^  enum ResidualScaling {SCALING_OFF=0, SCALING_BALANCED=1, SCALING_ENERGY=2} residualScaling;$/;"	g	struct:NonlinearRomOnlineData
ResidualVector	arpack++/include/arrseig.h	/^inline ARTYPE ARrcStdEig<ARFLOAT, ARTYPE>::ResidualVector(int i)$/;"	f	class:ARrcStdEig
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Resize(const ID m_new,const ID new_buffer_size,const bool initialize_new_elements=true)$/;"	f	class:PhysBAM::ARRAY
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Resize(const ID m_new,const bool initialize_new_elements,const bool copy_existing_elements,const T& initialization_value)$/;"	f	class:PhysBAM::ARRAY
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Resize(const ID m_new,const bool initialize_new_elements=true,const bool copy_existing_elements=true)$/;"	f	class:PhysBAM::ARRAY
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Resize(const int new_size)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Resize(const int new_size)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Resize(const int new_size,const int new_buffer_size)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    void Resize(const int m_new,const int n_new)$/;"	f	class:PhysBAM::MATRIX_MXN
Resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    void Resize(const int n_new)$/;"	f	class:PhysBAM::VECTOR_ND
ResizeArray	ResizeArray.h	/^ResizeArray<Type>::ResizeArray(Type iv, int is) {$/;"	f	class:ResizeArray
ResizeArray	ResizeArray.h	/^class ResizeArray {$/;"	c
Resize_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Resize_Helper(const ID buffer_new,const bool initialize_new_elements,const bool copy_existing_elements,const T& initialization_value)$/;"	f	class:PhysBAM::ARRAY
Resize_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    void Resize_Helper(const ID buffer_new,const bool initialize_new_elements=true,const bool copy_existing_elements=true)$/;"	f	class:PhysBAM::ARRAY
Resize_Table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Resize_Table(const int estimated_max_number_of_entries_input=0)$/;"	f	class:PhysBAM::HASHTABLE
Resize_Within_Buffer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Resize_Within_Buffer()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Restart	Manual/Aerof3d.html	/^<a name="Restart"><\/a>$/;"	a
Restart	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::Restart()$/;"	f	class:ARrcStdEig
RestartData	IoData.h	/^struct RestartData {$/;"	s
RestartData	IoDataCore.C	/^RestartData::RestartData()$/;"	f	class:RestartData
RestartParametersData	IoData.h	/^struct RestartParametersData {$/;"	s
RestartParametersData	IoDataCore.C	/^RestartParametersData::RestartParametersData()$/;"	f	class:RestartParametersData
Restarting-AERO-F	Manual/Aerof3d.html	/^<a name="Restarting-AERO-F"><\/a>$/;"	a
Restarting-AERO_002dF	Manual/Aerof3d.html	/^<a name="Restarting-AERO_002dF"><\/a>$/;"	a
Restarting-Aero-FL	Manual/Aerof3d.html	/^<a name="Restarting-Aero-FL"><\/a>$/;"	a
Restarting-Aero_002dFL	Manual/Aerof3d.html	/^<a name="Restarting-Aero_002dFL"><\/a>$/;"	a
Restore_Intersection_Information	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    void Restore_Intersection_Information(const RAY<TV>& storage_ray)$/;"	f	class:PhysBAM::RAY
Restrict	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::Restrict(int coarseLvl, DistSVec<Scalar2,dim>& fine,$/;"	f	class:MultiGridKernel
Restrict	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::Restrict(const MultiGridLevel<Scalar>& fineGrid, const DistSVec<Scalar2, dim>& fineData, DistSVec<Scalar2, dim>& coarseData,bool average,$/;"	f	class:MultiGridLevel
Restrict	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::Restrict(const MultiGridLevel<Scalar>& fineGrid, const DistVec<Scalar2>& fineData, DistVec<Scalar2>& coarseData) const$/;"	f	class:MultiGridLevel
RestrictFaceVector	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::RestrictFaceVector(const MultiGridLevel<Scalar>& fineGrid, const DistSVec<Scalar2, dim>& fineData, DistSVec<Scalar2, dim>& coarseData) const$/;"	f	class:MultiGridLevel
RestrictMethod	IoData.h	/^  enum RestrictMethod { VOLUME_WEIGHTED = 0, AVERAGE = 1 } restrictMethod;$/;"	g	struct:MultiGridData
RestrictOperator	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::RestrictOperator(const MultiGridLevel<Scalar>& fineGrid,$/;"	f	class:MultiGridLevel
RestrictionMapping	RestrictionMapping.C	/^RestrictionMapping<dim>::RestrictionMapping(Domain * domain, InputIterator globalIndexBegin, InputIterator globalIndexEnd) :$/;"	f	class:RestrictionMapping
RestrictionMapping	RestrictionMapping.h	/^class RestrictionMapping {$/;"	c
ReturnType	AutoDiff/Function.h	/^    typedef Eigen::Matrix<Scalar,NumberOfValues,1> ReturnType;$/;"	t	class:VectorValuedFunction
ReturnType	AutoDiff/Function.h	/^    typedef Eigen::Matrix<Scalar,NumberOfValuesPerColumn,NumberOfValuesPerRow> ReturnType;$/;"	t	class:MatrixValuedFunction
ReturnType	AutoDiff/Function.h	/^    typedef Scalar ReturnType;$/;"	t	class:ScalarValuedFunction
ReturnType	AutoDiff/SpaceDerivatives.h	/^    typedef Eigen::Array<typename FunctionTemplate<Scalar>::ReturnType,InputNumberOfColumns,InputNumberOfRows> ReturnType;$/;"	t	class:FirstPartialSpaceDerivatives
ReturnType	AutoDiff/SpaceDerivatives.h	/^    typedef typename Eigen::Matrix<Scalar,NumberOfValuesPerColumn,NumberOfValuesPerRow> ReturnType;$/;"	t	class:Jacobian
ReverseCrossingEdgeRes	IntersectorFRG/IntersectorFRG.h	/^    map<int,IntersectionResult<double> > ReverseCrossingEdgeRes;$/;"	m	class:IntersectorFRG
ReverseCrossingEdgeRes	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    std::map<int,IntersectionResult<double> > ReverseCrossingEdgeRes;$/;"	m	class:IntersectorPhysBAM
Reverse_In_Place	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Reverse_In_Place(T_ARRAY1& input)$/;"	f	class:PhysBAM::ARRAY_BASE
Reversed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR Reversed() const$/;"	f	class:PhysBAM::VECTOR
Reversed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR Reversed() const$/;"	f	class:PhysBAM::VECTOR
Reversed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Reversed() const$/;"	f	class:PhysBAM::VECTOR
Reversed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Reversed() const$/;"	f	class:PhysBAM::VECTOR
Rewind	arpack++/include/ardfmat.h	/^void ARdfMatrix<ARTYPE>::Rewind() $/;"	f	class:ARdfMatrix
RichardsonSolver	KspSolver.C	/^RichardsonSolver(const typename VecType::InfoType &info, KspData &data, $/;"	f	class:RichardsonSolver
RichardsonSolver	KspSolver.h	/^class RichardsonSolver : public KspSolver<VecType,MatVecProdOp,PrecOp,IoOp> {$/;"	c
Rideal	DistDynamicLESTerm.h	/^  double            gam, Rideal;$/;"	m	class:DistDynamicLESTerm
RiemannComputation	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	g	struct:MultiFluidData
RiemannInvParams	LocalRiemann.h	/^    RiemannInvParams(int fluidId,double ent, VarFcn* v) : myFluidId(fluidId), entropy(ent), vf_(v) { }$/;"	f	struct:LocalRiemannGfmpar::RiemannInvParams
RiemannInvParams	LocalRiemann.h	/^  struct RiemannInvParams {$/;"	s	class:LocalRiemannGfmpar
RiemannNormal	IoData.h	/^  enum RiemannNormal {REAL = 0, MESH = 1, LEGACYMESH = 2 } riemannNormal;$/;"	g	struct:MultiFluidData
RiemannNormal	IoData.h	/^  enum RiemannNormal {STRUCTURE = 0, FLUID = 1} riemannNormal;$/;"	g	struct:EmbeddedFramework
Right_Givens_Rotation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    void Right_Givens_Rotation(const int i,const int j,const T c,const T s)$/;"	f	class:PhysBAM::MATRIX_MXN
Right_Multiply_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX<T,3> Right_Multiply_With_Symmetric_Result(const MATRIX& A,const DIAGONAL_MATRIX<T,3>& B)$/;"	f	class:PhysBAM::MATRIX
RigidMeshMotionData	IoData.h	/^struct RigidMeshMotionData {$/;"	s
RigidMeshMotionData	IoDataCore.C	/^RigidMeshMotionData::RigidMeshMotionData()$/;"	f	class:RigidMeshMotionData
RigidMeshMotionHandler	MeshMotionHandler.h	/^class RigidMeshMotionHandler {$/;"	c
RigidMeshMotionHandler	MeshMotionHandlerCore.C	/^RigidMeshMotionHandler::RigidMeshMotionHandler(IoData &ioData, VarFcn *vf, $/;"	f	class:RigidMeshMotionHandler
RigidRollMeshMotionHandler	MeshMotionHandler.h	/^class RigidRollMeshMotionHandler : public MeshMotionHandler {$/;"	c
RigidRollMeshMotionHandler	MeshMotionHandlerCore.C	/^RigidRollMeshMotionHandler(IoData &ioData, double *angles, Domain *dom) : $/;"	f	class:RigidRollMeshMotionHandler
Rinlet	TsDesc.h	/^  DistSVec<double,dim> *Rinlet;$/;"	m	class:TsDesc
Rn	DistTimeState.h	/^  DistSVec<double,dim> *Rn;$/;"	m	class:DistTimeState
Rn	MatVecProd.h	/^  DistSVec<double,dim> *Rn;$/;"	m	class:MatVecProdFD
Rn	TimeState.h	/^  SVec<double,dim> &Rn;$/;"	m	class:TimeState
Robust_Divide	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T Robust_Divide(const T a,const T b)$/;"	f	namespace:PhysBAM
Robust_Harmonic_Mean	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T Robust_Harmonic_Mean(T a,T b)$/;"	f	namespace:PhysBAM
Robust_Inverse	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T Robust_Inverse(const T a)$/;"	f	namespace:PhysBAM
Robust_Multiply	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	/^inline T Robust_Multiply(const T a,const T b)$/;"	f	namespace:PhysBAM
Robust_Point_Point_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Robust_Point_Point_Collision(const POINT_SIMPLEX_1D<T>& initial_simplex,const POINT_SIMPLEX_1D<T>& final_simplex,const VECTOR<T,1>& x,const VECTOR<T,1>& final_x,const T dt,const T collision_thickness,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Robust_Point_Segment_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Robust_Point_Segment_Collision(const SEGMENT_2D<T>& initial_segment,const SEGMENT_2D<T>& final_segment,const VECTOR<T,2> &x,const VECTOR<T,2> &final_x,const T dt, const T collision_thickness,$/;"	f	class:SEGMENT_2D
Robust_Point_Segment_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Robust_Point_Segment_Collision(const SEGMENT_2D<T>& initial_segment,const SEGMENT_2D<T>& final_segment,const VECTOR<T,2> &x,const VECTOR<T,2> &final_x,const T dt, const T collision_thickness,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Robust_Point_Triangle_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Robust_Point_Triangle_Collision(const TRIANGLE_3D<T>& initial_triangle,const TRIANGLE_3D<T>& final_triangle,const VECTOR<T,3>& x,const VECTOR<T,3>& final_x,const T dt,$/;"	f	class:TRIANGLE_3D
Robust_Point_Triangle_Collision	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.cpp	/^Robust_Point_Triangle_Collision(const TRIANGLE_3D<T>& initial_triangle,const TRIANGLE_3D<T>& final_triangle,const VECTOR<T,3>& x,const VECTOR<T,3>& final_x,const T dt,$/;"	f	class:PhysBAM::CONTINUOUS_COLLISION_DETECTION_COMPUTATIONS
Robust_Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    T Robust_Size() const$/;"	f	class:PhysBAM::RANGE
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    VECTOR<T,2> Robust_Solve_Linear_System(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    VECTOR<T,3> Robust_Solve_Linear_System(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    VECTOR<T,0> Robust_Solve_Linear_System(const VECTOR<T,0>& b) const$/;"	f	class:PhysBAM::MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> Robust_Solve_Linear_System(const VECTOR<T,1>& b) const$/;"	f	class:PhysBAM::MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> Robust_Solve_Linear_System(const VECTOR<T,2>& b) const$/;"	f	class:PhysBAM::MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Robust_Solve_Linear_System(const VECTOR<T,3>& b) const \/\/ 34 mults, 17 adds, 1 div$/;"	f	class:MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Robust_Solve_Linear_System(const VECTOR<T,2>& b) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Robust_Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Robust_Solve_Linear_System(const VECTOR<T,3>& b) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
RoeTurkelFlux5Function	AutoDiff/roeturkeljac5.h	/^    RoeTurkelFlux5Function(const Eigen::Array<double,18,1>& _sconst, const Eigen::Array<int,1,1>& _iconst)$/;"	f	class:RoeTurkelFlux5Function
RoeTurkelFlux5Function	AutoDiff/roeturkeljac5.h	/^class RoeTurkelFlux5Function : public VectorValuedFunction<5,5,Scalar,18,1,double>$/;"	c
RootClassAssigner	parser/Assigner.h	/^    RootClassAssigner() : ClassAssigner("", 0)  {};$/;"	f	class:RootClassAssigner
RootClassAssigner	parser/Assigner.h	/^class RootClassAssigner: public ClassAssigner  {$/;"	c
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotate(const TV& v) const \/\/ 20 mult and 13 add\/sub$/;"	f	class:PhysBAM::ROTATION
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotate(const TV& v) const$/;"	f	class:PhysBAM::ROTATION
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TWIST<TV> Rotate(const TWIST<TV>& twist) const$/;"	f	class:PhysBAM::ROTATION
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const TV& Rotate(const TV& x) const$/;"	f	class:PhysBAM::ROTATION
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const TWIST<TV>& Rotate(const TWIST<TV>& twist) const$/;"	f	class:PhysBAM::ROTATION
Rotate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^Rotate(const VECTOR<int,3>& v) const \/\/ homogenous of degree 2 in q, since we can't usefully assume normalization for integer case$/;"	f	class:PhysBAM::ROTATION
Rotate_Clockwise_90	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Rotate_Clockwise_90() const$/;"	f	class:PhysBAM::VECTOR
Rotate_Counterclockwise_90	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Rotate_Counterclockwise_90() const$/;"	f	class:PhysBAM::VECTOR
Rotate_Counterclockwise_Multiple_90	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Rotate_Counterclockwise_Multiple_90(const int n) const$/;"	f	class:PhysBAM::VECTOR
Rotate_Spin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    T_SPIN Rotate_Spin(const T_SPIN& spin) const$/;"	f	class:PhysBAM::ROTATION
Rotate_Spin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    const T_SPIN& Rotate_Spin(const T_SPIN& spin) const$/;"	f	class:PhysBAM::ROTATION
Rotated_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotated_Axis(const int axis) const$/;"	f	class:PhysBAM::ROTATION
Rotated_Clockwise_90	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Rotated_Clockwise_90() const$/;"	f	class:PhysBAM::COMPLEX
Rotated_Counter_Clockwise_90	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Rotated_Counter_Clockwise_90() const$/;"	f	class:PhysBAM::COMPLEX
Rotated_X_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Rotated_X_Axis() const \/\/ Q*(1,0,0)$/;"	f	class:ROTATION
Rotated_X_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotated_X_Axis() const \/\/ Q*(1)$/;"	f	class:PhysBAM::ROTATION
Rotated_X_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotated_X_Axis() const \/\/ Q*(1,0)$/;"	f	class:PhysBAM::ROTATION
Rotated_Y_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Rotated_Y_Axis() const \/\/ Q*(0,1,0)$/;"	f	class:ROTATION
Rotated_Y_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    TV Rotated_Y_Axis() const \/\/ Q*(0,1)$/;"	f	class:PhysBAM::ROTATION
Rotated_Z_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Rotated_Z_Axis() const \/\/ Q*(0,0,1)$/;"	f	class:ROTATION
RotationAxis	Manual/Aerof3d.html	/^<a name="RotationAxis"><\/a>$/;"	a
RotationData	IoData.h	/^struct RotationData  {$/;"	s
RotationData	IoDataCore.C	/^RotationData::RotationData()  {$/;"	f	class:RotationData
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Rotation_Matrix(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& axis,const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& initial_vector,const VECTOR<T,3>& final_vector)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& rotation)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& x_final,const VECTOR<T,3>& y_final,const VECTOR<T,3>& z_final)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& axis,const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Rotation_Matrix(const VECTOR<T,3>& x_final,const VECTOR<T,3>& y_final,const VECTOR<T,3>& z_final)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Rotation_Matrix() const \/\/ 18 mult and 12 add\/sub$/;"	f	class:ROTATION
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    MATRIX<T,1> Rotation_Matrix() const$/;"	f	class:PhysBAM::ROTATION
Rotation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    MATRIX<T,2> Rotation_Matrix() const$/;"	f	class:PhysBAM::ROTATION
Rotation_Matrix_X_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix_X_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix_X_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Rotation_Matrix_X_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix_Y_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix_Y_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix_Y_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Rotation_Matrix_Y_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix_Z_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Rotation_Matrix_Z_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Matrix_Z_Axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Rotation_Matrix_Z_Axis(const T radians)$/;"	f	class:PhysBAM::MATRIX
Rotation_Only	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Rotation_Only() const$/;"	f	class:PhysBAM::MATRIX
Rotation_Only	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX Rotation_Only() const$/;"	f	class:PhysBAM::MATRIX
Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Rotation_Vector() const$/;"	f	class:ROTATION
Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    VECTOR<T,0> Rotation_Vector() const$/;"	f	class:PhysBAM::ROTATION
Rotation_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    VECTOR<T,1> Rotation_Vector() const$/;"	f	class:PhysBAM::ROTATION
RowInd	arpack++/include/arhbmat.h	/^  ARINT* RowInd() { return irow; }$/;"	f	class:ARhbMatrix
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    int Rows() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX_BASE
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    int Rows() const$/;"	f	class:PhysBAM::MATRIX_MXN
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    int Rows() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    int Rows() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    int Rows() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Rows	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    int Rows() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
RowsInMemory	arpack++/include/ardfmat.h	/^  int RowsInMemory() const { return strows; }$/;"	f	class:ARdfMatrix
Rphi	OneDimensionalSolver.h	/^  SVec<double,1> Rphi;$/;"	m	class:OneDimensional
Rreal	TsDesc.h	/^  DistSVec<double,dim> *Rreal;$/;"	m	class:TsDesc
Running-AERO-FL	Manual/Aerof3d.html	/^<a name="Running-AERO-FL"><\/a>$/;"	a
Running-AERO_002dFL	Manual/Aerof3d.html	/^<a name="Running-AERO_002dFL"><\/a>$/;"	a
Running-Aero-F	Manual/Aerof3d.html	/^<a name="Running-Aero-F"><\/a>$/;"	a
Running-Aero_002dF	Manual/Aerof3d.html	/^<a name="Running-Aero_002dF"><\/a>$/;"	a
S	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *S;$/;"	m	class:DistDynamicVMSTerm
SAFE_BOOL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    typedef void (UNUSABLE::*SAFE_BOOL)();$/;"	t	class:PhysBAM::ELEMENT_ID
SAFE_DELETE	FluidSelectorCore.C	106;"	d	file:
SAME_ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class TA1,class TA2> struct SAME_ARRAY:public SAME_ARRAY_CANONICAL<typename CANONICALIZE_CONST_ARRAY<TA1>::TYPE,typename CANONICALIZE_CONST_ARRAY<TA2>::TYPE>{};$/;"	s	namespace:PhysBAM
SAME_ARRAY_CANONICAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct SAME_ARRAY_CANONICAL{static bool Same_Array(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	s	namespace:PhysBAM
SAME_ARRAY_CANONICAL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY> struct SAME_ARRAY_CANONICAL<T_ARRAY,T_ARRAY>{static bool Same_Array(const T_ARRAY& array1,const T_ARRAY& array2)$/;"	s	namespace:PhysBAM
SAME_AS_PROBLEM	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 2} prec;$/;"	e	enum:MultiFluidData::Prec
SAME_AS_PROBLEM	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 3 } prec;$/;"	e	enum:EmbeddedFramework::Prec
SAMPLED_MESH_NOT_USED	IoData.h	/^  enum SampledMeshUsed {SAMPLED_MESH_NOT_USED = 0, SAMPLED_MESH_USED = 1} sampledMeshUsed;$/;"	e	enum:GappyConstructionData::SampledMeshUsed
SAMPLED_MESH_USED	IoData.h	/^  enum SampledMeshUsed {SAMPLED_MESH_NOT_USED = 0, SAMPLED_MESH_USED = 1} sampledMeshUsed;$/;"	e	enum:GappyConstructionData::SampledMeshUsed
SAModelData	IoData.h	/^struct SAModelData {$/;"	s
SAModelData	IoDataCore.C	/^SAModelData::SAModelData()$/;"	f	class:SAModelData
SATURATED_LS	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
SATerm	SpalartAllmarasTerm.h	/^SATerm::SATerm(IoData &iod)$/;"	f	class:SATerm
SATerm	SpalartAllmarasTerm.h	/^class SATerm {$/;"	c
SAUPP_H	arpack++/include/saupp.h	18;"	d
SC	arpack++/include/arlsupm.h	/^    SC,        \/* column-wise, supernode *\/$/;"	e	enum:__anon42
SCALAPACK_SVD	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	e	enum:DataCompressionData::PODMethod
SCALAR	IoData.h	/^  enum LevelSetMethod { CONSERVATIVE = 0, HJWENO = 1, SCALAR=2, PRIMITIVE = 3,$/;"	e	enum:MultiFluidData::LevelSetMethod
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::BOX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::STRUCTURE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef typename SCALAR_POLICY<T>::TYPE SCALAR;$/;"	t	class:PhysBAM::ARRAY_BASE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    typedef typename SCALAR_POLICY<T>::TYPE SCALAR;$/;"	t	class:PhysBAM::ARRAY_BASE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::INTERVAL
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::RANGE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::DIAGONAL_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::DIAGONAL_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::FRAME
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,m_input,n_input> > BASE;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    typedef T_input T;typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,3,2> > BASE;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,3> > BASE;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    typedef T SCALAR;typedef MATRIX_BASE<T,MATRIX<T,4> > BASE;$/;"	t	class:PhysBAM::MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX_BASE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX_MXN
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::QUATERNION
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::ROTATION
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::SYMMETRIC_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::SYMMETRIC_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::TRANSPOSE_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::POINT_CLOUD
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::COMPLEX
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    typedef T SCALAR;$/;"	t	class:PhysBAM::TWIST
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef typename IF<IS_SCALAR<T>::value,T,UNUSABLE>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    typedef typename IF<IS_SCALAR<T>::value,T,UNUSABLE>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef typename IF<IS_SCALAR<T>::value,T,UNUSABLE>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef typename IF<IS_SCALAR<T>::value,T,UNUSABLE>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef typename IF<IS_SCALAR<T>::value,T,UNUSABLE>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename DIFFERENCE<T1,T2>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR_DIFFERENCE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename NEGATION<typename T_VECTOR::SCALAR>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR_NEGATION
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename PRODUCT<T1,T2>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR_SCALE
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename SUM<T1,T2>::TYPE SCALAR;$/;"	t	class:PhysBAM::VECTOR_SUM
SCALAR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    typedef T SCALAR;typedef VECTOR_BASE<T,VECTOR_ND<T> > BASE;$/;"	t	class:PhysBAM::VECTOR_ND
SCALAR_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T,class ENABLER=void> struct SCALAR_POLICY{typedef struct UNUSABLE{} TYPE;};$/;"	s	namespace:PhysBAM
SCALAR_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct SCALAR_POLICY<T,typename ENABLE_IF<IS_SCALAR<T>::value>::TYPE>{typedef T TYPE;};$/;"	s	namespace:PhysBAM
SCALAR_POLICY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct SCALAR_POLICY<T,typename IF<true,void,typename T::SCALAR>::TYPE> {typedef typename T::SCALAR TYPE;};$/;"	s	namespace:PhysBAM
SCALING_BALANCED	IoData.h	/^  enum ResidualScaling {SCALING_OFF=0, SCALING_BALANCED=1, SCALING_ENERGY=2} residualScaling;$/;"	e	enum:NonlinearRomOnlineData::ResidualScaling
SCALING_ENERGY	IoData.h	/^  enum ResidualScaling {SCALING_OFF=0, SCALING_BALANCED=1, SCALING_ENERGY=2} residualScaling;$/;"	e	enum:NonlinearRomOnlineData::ResidualScaling
SCALING_OFF	IoData.h	/^  enum ResidualScaling {SCALING_OFF=0, SCALING_BALANCED=1, SCALING_ENERGY=2} residualScaling;$/;"	e	enum:NonlinearRomOnlineData::ResidualScaling
SCHUR_NOT_OK	arpack++/include/arerror.h	/^    SCHUR_NOT_OK        = -408,$/;"	e	enum:ArpackError::ErrorCode
SCHUR_UNDEFINED	arpack++/include/arerror.h	/^    SCHUR_UNDEFINED     = -306,$/;"	e	enum:ArpackError::ErrorCode
SCOMPLEX_INCLUDE	arpack++/include/arlcomp.h	86;"	d
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE()$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& format,const T1& d1)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& format,const T1& d1,const T2& d2)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& format,const T1& d1,const T2& d2,const T3& d3)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& format,const T1& d1,const T2& d2,const T3& d3,const T4& d4)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& format,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    SCOPE(const std::string& scope_identifier,const std::string& scope_name)$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A,class B,class C,class D,class E> SCOPE(const A&,const B&,const C&,const D&,const E&){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A,class B,class C,class D> SCOPE(const A&,const B&,const C&,const D&){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A,class B,class C> SCOPE(const A&,const B&,const C&){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A,class B> SCOPE(const A&,const B&){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class A> SCOPE(const A&){}$/;"	f	struct:PhysBAM::LOG_NULL::SCOPE
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^class SCOPE:private NONCOPYABLE$/;"	c	namespace:PhysBAM::LOG_REAL
SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^struct SCOPE$/;"	s	namespace:PhysBAM::LOG_NULL
SCformat	arpack++/include/arlsupm.h	/^} SCformat;$/;"	t	typeref:struct:__anon48
SECOND	IoData.h	/^  enum ViscousInterfaceOrder {FIRST = 0, SECOND = 1} viscousinterfaceorder;$/;"	e	enum:EmbeddedFramework::ViscousInterfaceOrder
SECONDORDER	IoData.h	/^  enum InterfaceTreatment {FIRSTORDER=0, SECONDORDER=1} interfaceTreatment;$/;"	e	enum:MultiFluidData::InterfaceTreatment
SECOND_ORDER	IoData.h	/^  enum Dissipation {SECOND_ORDER = 0, SIXTH_ORDER = 1} dissipation;$/;"	e	enum:SchemeData::Dissipation
SECOND_ORDER	IoData.h	/^  enum FiniteDifferenceOrder {FIRST_ORDER = 1, SECOND_ORDER = 2} fdOrder; $/;"	e	enum:ImplicitData::FiniteDifferenceOrder
SEGMENT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef SEGMENT_1D<T> SEGMENT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
SEGMENT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef SEGMENT_2D<T> SEGMENT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
SEGMENT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef SEGMENT_3D<T> SEGMENT;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
SEGMENT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    SEGMENT_2D()$/;"	f	class:PhysBAM::SEGMENT_2D
SEGMENT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    SEGMENT_2D(const TV& x1_input,const TV& x2_input)$/;"	f	class:PhysBAM::SEGMENT_2D
SEGMENT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    explicit SEGMENT_2D(const T_ARRAY& X_input)$/;"	f	class:PhysBAM::SEGMENT_2D
SEGMENT_2D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^class SEGMENT_2D$/;"	c	namespace:PhysBAM
SEGMENT_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    SEGMENT_3D()$/;"	f	class:PhysBAM::SEGMENT_3D
SEGMENT_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    SEGMENT_3D(const T_ARRAY& X_input)$/;"	f	class:PhysBAM::SEGMENT_3D
SEGMENT_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    SEGMENT_3D(const VECTOR<T,3>& x1_input,const VECTOR<T,3>& x2_input)$/;"	f	class:PhysBAM::SEGMENT_3D
SEGMENT_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^class SEGMENT_3D$/;"	c	namespace:PhysBAM
SEGMENT_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^SEGMENT_MESH()$/;"	f	class:SEGMENT_MESH
SEGMENT_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^SEGMENT_MESH(const SEGMENT_MESH& segment_mesh)$/;"	f	class:SEGMENT_MESH
SEGMENT_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^SEGMENT_MESH(const int number_nodes_input,const ARRAY<VECTOR<int,2> >& segment_list)$/;"	f	class:SEGMENT_MESH
SEGMENT_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^class SEGMENT_MESH:public SIMPLEX_MESH<1>$/;"	c	namespace:PhysBAM
SELECT_SAMPLED_NODES_FALSE	IoData.h	/^  enum SelectSampledNodes {SELECT_SAMPLED_NODES_FALSE = 0, SELECT_SAMPLED_NODES_TRUE = 1} selectSampledNodes;$/;"	e	enum:GappyConstructionData::SelectSampledNodes
SELECT_SAMPLED_NODES_TRUE	IoData.h	/^  enum SelectSampledNodes {SELECT_SAMPLED_NODES_FALSE = 0, SELECT_SAMPLED_NODES_TRUE = 1} selectSampledNodes;$/;"	e	enum:GappyConstructionData::SelectSampledNodes
SEMIANALYTICAL	IoData.h	/^  enum SensitivityComputation {ANALYTICAL = 0, SEMIANALYTICAL = 1,  FINITEDIFFERENCE = 2} scFlag;$/;"	e	enum:SensitivityAnalysis::SensitivityComputation
SEUPP_H	arpack++/include/seupp.h	18;"	d
SFixData	IoData.h	/^struct SFixData {$/;"	s
SFixData	IoDataCore.C	/^SFixData::SFixData()$/;"	f	class:SFixData
SFullM	DenseMatrix.h	/^typedef SymFullM<double> SFullM;$/;"	t
SGI_DEC	arpack++/include/arch.h	74;"	d
SIDE	IoData.h	/^  enum Delta {VOLUME = 0, SIDE = 1} delta;$/;"	e	enum:LESModelData::Delta
SIData	HigherOrderFSI.h	/^   V6NodeData (*SIData);$/;"	m	class:HigherOrderFSI
SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^SIMPLEX_MESH()$/;"	f	class:PhysBAM::SIMPLEX_MESH
SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^SIMPLEX_MESH(const SIMPLEX_MESH& mesh)$/;"	f	class:PhysBAM::SIMPLEX_MESH
SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^SIMPLEX_MESH(const int number_nodes_input,const ARRAY<VECTOR<int,d+1> >& simplex_list)$/;"	f	class:PhysBAM::SIMPLEX_MESH
SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^class SIMPLEX_MESH$/;"	c	namespace:PhysBAM
SIMPLE_BUFFER_H	SimpleBuffer.h	2;"	d
SIMPLE_UPDATES_FALSE	IoData.h	/^  enum PreprocessForSimpleUpdates {SIMPLE_UPDATES_FALSE = 0, SIMPLE_UPDATES_TRUE = 1} preprocessForSimpleUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForSimpleUpdates
SIMPLE_UPDATES_TRUE	IoData.h	/^  enum PreprocessForSimpleUpdates {SIMPLE_UPDATES_FALSE = 0, SIMPLE_UPDATES_TRUE = 1} preprocessForSimpleUpdates;$/;"	e	enum:BasisUpdatesData::PreprocessForSimpleUpdates
SINGLE	IoData.h	/^  enum Type {SINGLE = 0, DOUBLE = 1} type;$/;"	e	enum:RestartData::Type
SIXTH_ORDER	IoData.h	/^  enum Dissipation {SECOND_ORDER = 0, SIXTH_ORDER = 1} dissipation;$/;"	e	enum:SchemeData::Dissipation
SIZE	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
SIZE	IoData.h	/^             ROLL = 5, RBM = 6, LINEARIZED = 7, NLROMOFFLINE = 8, NLROMONLINE = 9, SIZE = 10};$/;"	e	enum:ProblemData::Type
SIZE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
SKIN_FRICTION	PostFcn.h	/^		   VORTICITY = 5, CSDLES = 6, CSDVMS = 7, SKIN_FRICTION = 8, NUT_TURB = 9, $/;"	e	enum:PostFcn::ScalarType
SKIN_FRICTIONAVG	PostFcn.h	/^                      SKIN_FRICTIONAVG =8, AVSSIZE = 9};$/;"	e	enum:PostFcn::ScalarAvgType
SMAGORINSKY	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	e	enum:LESModelData::Type
SMDERIVATIVE	f77src/hllcjac.f	/^      SUBROUTINE SMDERIVATIVE(/;"	s
SMOOTHSTEP	EmbeddedTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;  $/;"	e	enum:EmbeddedTsDesc::ImplosionSetupType
SMOOTHSTEP	IoData.h	/^  enum Type{LINEAR=0, SMOOTHSTEP=1} type;$/;"	e	enum:ImplosionSetup::Type
SMOOTHSTEP	MultiPhysicsTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;$/;"	e	enum:MultiPhysicsTsDesc::ImplosionSetupType
SOLVE	arpack++/include/arlutil.h	/^    SOLVE,   \/* forward and back solves *\/$/;"	e	enum:__anon51
SOLVER	ErrorHandler.h	/^  enum Type {ALL = 0, SOLVER = 1};$/;"	e	enum:ErrorHandler::Type
SOWER_INPUTS_FALSE	IoData.h	/^  enum SowerInputs {SOWER_INPUTS_FALSE = 0, SOWER_INPUTS_TRUE = 1} sowerInputs;$/;"	e	enum:GappyConstructionData::SowerInputs
SOWER_INPUTS_TRUE	IoData.h	/^  enum SowerInputs {SOWER_INPUTS_FALSE = 0, SOWER_INPUTS_TRUE = 1} sowerInputs;$/;"	e	enum:GappyConstructionData::SowerInputs
SPARSEGRIDCLUSTER_H_	SparseGridCluster.h	2;"	d
SPARSEGRID_HPP_	SparseGrid.h	2;"	d
SPATIAL_ONLY	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	e	enum:ImplicitData::Type
SPATIAL_RES	PostFcn.h	/^                   D2WALL = 30, SPATIAL_RES = 31, SSIZE = 32};$/;"	e	enum:PostFcn::ScalarType
SPECIFIED_LIFTFACE	IoData.h	/^		SPECIFIED_LIFTFACE  = 1, ALL_LIFTFACE = 2} includeLiftFaces;$/;"	e	enum:GappyConstructionData::IncludeLiftFaces
SPECIFIED_SNAPS_GREEDY	IoData.h	/^                   JACOBIAN_ROB_GREEDY = 2, RESIDUAL_AND_JACOBIAN_ROBS_GREEDY = 3, SPECIFIED_SNAPS_GREEDY = 4} greedyData;$/;"	e	enum:GappyConstructionData::greedyData
SPEED	PostFcn.h	/^                   SPEED = 19, HYDROSTATICPRESSURE = 20, HYDRODYNAMICPRESSURE = 21, $/;"	e	enum:PostFcn::ScalarType
SPHERE	KirchhoffIntegrator.h	/^  enum TypeGamma {SPHERE = 0, CYLINDER = 1} d_SurfType;$/;"	e	enum:KirchhoffIntegrator::TypeGamma
SPHERICAL	IoData.h	/^  enum CoordinateType {CARTESIAN = 0, CYLINDRICAL = 1, SPHERICAL = 2} coordType;$/;"	e	enum:OneDimensionalInfo::CoordinateType
SPHERICAL	IoData.h	/^  enum Type {CYLINDRICAL = 0, SPHERICAL = 1} d_surfaceType;$/;"	e	enum:KirchhoffData::Type
SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef UNUSABLE SPIN;$/;"	t	class:PhysBAM::VECTOR
SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    typedef UNUSABLE SPIN;$/;"	t	class:PhysBAM::VECTOR
SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef VECTOR<T,0> SPIN;$/;"	t	class:PhysBAM::VECTOR
SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef VECTOR<T,1> SPIN;$/;"	t	class:PhysBAM::VECTOR
SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef VECTOR<T,3> SPIN;$/;"	t	class:PhysBAM::VECTOR
SPIRALING	IoData.h	/^             ACOUSTICBEAM=5, SPIRALING = 6, ACOUSTICVISCOUSBEAM=7} type;$/;"	e	enum:ForcedData::Type
SPNNLS	f77src/spnnls.f	/^      SUBROUTINE SPNNLS /;"	s
SR	arpack++/include/arlsupm.h	/^    SR,        \/* row-wise, supernode *\/$/;"	e	enum:__anon42
SSIZE	PostFcn.h	/^                   D2WALL = 30, SPATIAL_RES = 31, SSIZE = 32};$/;"	e	enum:PostFcn::ScalarType
STACK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    STACK()$/;"	f	class:PhysBAM::STACK
STACK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^class STACK$/;"	c	namespace:PhysBAM
STACK_DIR	tools/alloca.cougar.c	77;"	d	file:
STACK_DIR	tools/alloca.cougar.c	82;"	d	file:
STACK_DIRECTION	tools/alloca.cougar.c	72;"	d	file:
START_POINT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum LOCATION {START_POINT,INTERIOR_POINT,LOCATION_UNKNOWN};$/;"	e	enum:PhysBAM::RAY::LOCATION
START_RESID_ZERO	arpack++/include/arerror.h	/^    START_RESID_ZERO    = -202,$/;"	e	enum:ArpackError::ErrorCode
STATE_ROB_GREEDY	IoData.h	/^  enum greedyData {UNSPECIFIED_GREEDY = -1, STATE_ROB_GREEDY = 0, RESIDUAL_ROB_GREEDY = 1,$/;"	e	enum:GappyConstructionData::greedyData
STATIC_ASSERT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/STATIC_ASSERT.h	12;"	d
STATIC_ASSERT_SAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	45;"	d
STATIC_ASSERT_SAME	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	50;"	d
STATIC_CONST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,T v> struct STATIC_CONST {static const T value=v;};$/;"	s	namespace:PhysBAM
STEGER_WARMING	IoData.h	/^  enum Type { STEGER_WARMING = 0,$/;"	e	enum:BoundarySchemeData::Type
STIFFENED	IoData.h	/^  enum Type {IDEAL = 0, STIFFENED = 1} type;$/;"	e	enum:GasModelData::Type
STIFFENEDGAS	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	e	enum:VarFcnBase::Type
STIFFENED_GAS	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	e	enum:FluidModelData::Fluid
STL_VECTOR_H	arpack++/include/arch.h	39;"	d
STORE_ALL_CLUSTERS_FALSE	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	e	enum:NonlinearRomOnlineData::StoreAllClusters
STORE_ALL_CLUSTERS_FALSE	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	e	enum:ROBConstructionData::StoreAllClusters
STORE_ALL_CLUSTERS_TRUE	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	e	enum:NonlinearRomOnlineData::StoreAllClusters
STORE_ALL_CLUSTERS_TRUE	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	e	enum:ROBConstructionData::StoreAllClusters
STREAM_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    explicit STREAM_TYPE(const double)$/;"	f	class:PhysBAM::STREAM_TYPE
STREAM_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    explicit STREAM_TYPE(const float)$/;"	f	class:PhysBAM::STREAM_TYPE
STREAM_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^class STREAM_TYPE$/;"	c	namespace:PhysBAM
STRING_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^namespace STRING_UTILITIES{$/;"	n	namespace:PhysBAM	file:
STRING_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^namespace STRING_UTILITIES{$/;"	n	namespace:PhysBAM
STRONG	IoData.h	/^  enum TurbulenceModelCoupling {WEAK = 0, STRONG = 1} tmcoupling;$/;"	e	enum:ImplicitData::TurbulenceModelCoupling
STRONG	IoData.h	/^  enum ViscousBoundaryCondition {WEAK = 0, STRONG = 1} viscousboundarycondition;$/;"	e	enum:EmbeddedFramework::ViscousBoundaryCondition
STRUCTURE	IoData.h	/^  enum RiemannNormal {STRUCTURE = 0, FLUID = 1} riemannNormal;$/;"	e	enum:EmbeddedFramework::RiemannNormal
STRUCTURE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^STRUCTURE()$/;"	f	class:STRUCTURE
STRUCTURE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^class STRUCTURE:public NONCOPYABLE$/;"	c	namespace:PhysBAM
STRUCTURE_REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/STRUCTURE_REGISTRY.cpp	/^STRUCTURE_REGISTRY()$/;"	f	class:STRUCTURE_REGISTRY
STRUCTURE_REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/STRUCTURE_REGISTRY.h	/^template<class TV> class STRUCTURE_REGISTRY:public REGISTRY<STRUCTURE<TV>,std::string,STRUCTURE_REGISTRY<TV> > {$/;"	c	namespace:PhysBAM
STRUC_CMD_TAG	StructExc.C	19;"	d	file:
STRUC_ID	DomainCore.C	31;"	d	file:
STRUC_NUMPA_TAG	StructExc.C	16;"	d	file:
STRUC_RELRES_TAG	StructExc.C	18;"	d	file:
SUBCYCLING_TAG	StructExc.C	28;"	d	file:
SUBTRACT_CENTERS_FALSE	IoData.h	/^  enum SubtractClusterCenters {SUBTRACT_CENTERS_FALSE = 0, SUBTRACT_CENTERS_TRUE = 1} subtractCenters;$/;"	e	enum:StateSnapshotsData::SubtractClusterCenters
SUBTRACT_CENTERS_TRUE	IoData.h	/^  enum SubtractClusterCenters {SUBTRACT_CENTERS_FALSE = 0, SUBTRACT_CENTERS_TRUE = 1} subtractCenters;$/;"	e	enum:StateSnapshotsData::SubtractClusterCenters
SUBTRACT_NEAREST_FALSE	IoData.h	/^  enum SubtractNearestSnapshotToCenter {SUBTRACT_NEAREST_FALSE = 0, SUBTRACT_NEAREST_TRUE = 1} subtractNearestSnapsToCenters;$/;"	e	enum:StateSnapshotsData::SubtractNearestSnapshotToCenter
SUBTRACT_NEAREST_TRUE	IoData.h	/^  enum SubtractNearestSnapshotToCenter {SUBTRACT_NEAREST_FALSE = 0, SUBTRACT_NEAREST_TRUE = 1} subtractNearestSnapsToCenters;$/;"	e	enum:StateSnapshotsData::SubtractNearestSnapshotToCenter
SUBTRACT_REF_STATE_FALSE	IoData.h	/^  enum SubtractRefState {SUBTRACT_REF_STATE_FALSE = 0, SUBTRACT_REF_STATE_TRUE = 1} subtractRefState;$/;"	e	enum:StateSnapshotsData::SubtractRefState
SUBTRACT_REF_STATE_TRUE	IoData.h	/^  enum SubtractRefState {SUBTRACT_REF_STATE_FALSE = 0, SUBTRACT_REF_STATE_TRUE = 1} subtractRefState;$/;"	e	enum:StateSnapshotsData::SubtractRefState
SUGGEST_DT_TAG	StructExc.C	29;"	d	file:
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct SUM<T1,T_ARRAY2,typename ENABLE_IF<ARRAY_PLUS_SCALAR_VALID<T1,typename T_ARRAY2::ELEMENT>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct SUM<T_ARRAY2,T1,typename ENABLE_IF<ARRAY_PLUS_SCALAR_VALID<T1,typename T_ARRAY2::ELEMENT>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^template<class T_ARRAY1,class T_ARRAY2> struct SUM<T_ARRAY1,T_ARRAY2,typename ENABLE_IF<IS_ARRAY<T_ARRAY1>::value && IS_ARRAY<T_ARRAY2>::value>::TYPE>$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,float>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,int>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,int>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,double>{typedef double TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,float>{typedef float TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,int>{typedef int TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct SUM<TWIST<TV>,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	s	namespace:PhysBAM
SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^template<class T_VECTOR1,class T_VECTOR2> struct SUM<T_VECTOR1,T_VECTOR2,typename ENABLE_IF<INEFFICIENT_VECTOR<T_VECTOR1>::value && INEFFICIENT_VECTOR<T_VECTOR2>::value>::TYPE>$/;"	s	namespace:PhysBAM
SUPERLUC_H	arpack++/include/superluc.h	18;"	d
SUPERLU_FREE	arpack++/include/arlutil.h	39;"	d
SUPERLU_MALLOC	arpack++/include/arlutil.h	33;"	d
SUPERMAN	IoDataCore.C	7740;"	d	file:
SURFACE	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:DeformingData::Domain
SURFACE	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:HeavingData::Domain
SURFACE	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:PitchingData::Domain
SURFACE	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:SpiralingData::Domain
SURFACE_HEAT_FLUX	PostFcn.h	/^                   SURFACE_HEAT_FLUX = 26, PRESSURECOEFFICIENT = 27, CONTROL_VOLUME = 28, FLUIDID = 29,$/;"	e	enum:PostFcn::ScalarType
SUTHERLAND	IoData.h	/^  enum Type {CONSTANT = 0, SUTHERLAND = 1, PRANDTL = 2} type;$/;"	e	enum:ViscosityModelData::Type
SVD	AlternatingLeastSquare/als_io.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	e	enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
SVD	IoData.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	e	enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
SVD	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::SVD(VecSet< DistSVec<double, dim> >*& snapshots, VecSet< DistSVec<double, dim> > &Utrue,$/;"	f	class:NonlinearRomDatabaseConstruction
SVec	Vector.h	/^SVec<Scalar,dim>::SVec(const Expr<T, Scalar> &expr) $/;"	f	class:SVec
SVec	Vector.h	/^SVec<Scalar,dim>::SVec(const SVec<Scalar,dim> &y) $/;"	f	class:SVec
SVec	Vector.h	/^SVec<Scalar,dim>::SVec(int l, Scalar (*vv)[dim]) $/;"	f	class:SVec
SVec	Vector.h	/^class SVec { $/;"	c
SYL	arpack++/include/arlsupm.h	/^    SYL,       \/* symmetric, store lower half *\/$/;"	e	enum:__anon44
SYMMETRIC_CG	CorotSolver.C	558;"	d	file:
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef MATRIX<T,0> SYMMETRIC_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef MATRIX<T,1> SYMMETRIC_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::SYMMETRIC_MATRIX<T,2> SYMMETRIC_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::SYMMETRIC_MATRIX<T,3> SYMMETRIC_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(2),INITIAL_SIZE nn=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX(const DIAGONAL_MATRIX<T,2>& matrix_input)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX(const SYMMETRIC_MATRIX<T2,2>& matrix_input)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX(const T y11,const T y21,const T y22)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^class SYMMETRIC_MATRIX<T,2>$/;"	c	namespace:PhysBAM
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(3),INITIAL_SIZE nn=INITIAL_SIZE(3))$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX(const DIAGONAL_MATRIX<T,3>& matrix_input)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX(const SYMMETRIC_MATRIX<T2,3>& matrix_input)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX(const T y11,const T y21,const T y31,const T y22,const T y32,const T y33)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^class SYMMETRIC_MATRIX<T,3>$/;"	c	namespace:PhysBAM
SYNC_MAP_RECV_TAG	IntersectorPhysBAM/Mpi_Utilities.h	38;"	d
SYNC_MAP_SEND_TAG	IntersectorPhysBAM/Mpi_Utilities.h	37;"	d
SYSTEM	arpack++/include/arlspdef.h	/^typedef enum {SYSTEM, USER}            LU_space_t;$/;"	e	enum:__anon34
SYSTEM_APPROXIMATION_NONE	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	e	enum:NonlinearRomOnlineData::SystemApproximation
SYU	arpack++/include/arlsupm.h	/^    SYU,       \/* symmetric, store upper half *\/$/;"	e	enum:__anon44
Safe_Open_Input	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::istream* Safe_Open_Input(const std::string& filename,bool binary)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Safe_Open_Output	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^std::ostream* Safe_Open_Output(const std::string& filename,bool binary,bool write_compressed_if_possible)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Same_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    Same_Array(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	f	class:PhysBAM::ARRAY_BASE
Same_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T_ARRAY1> static bool Same_Array(const T_ARRAY1& array1,const T_ARRAY1& array2)$/;"	f	class:PhysBAM::ARRAY_BASE
Same_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct SAME_ARRAY_CANONICAL{static bool Same_Array(const T_ARRAY1& array1,const T_ARRAY2& array2)$/;"	f	struct:PhysBAM::SAME_ARRAY_CANONICAL
Same_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^template<class T_ARRAY> struct SAME_ARRAY_CANONICAL<T_ARRAY,T_ARRAY>{static bool Same_Array(const T_ARRAY& array1,const T_ARRAY& array2)$/;"	f	struct:PhysBAM::SAME_ARRAY_CANONICAL
Same_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    static bool Same_Array(const ARRAY_VIEW& array1,const ARRAY_VIEW& array2)$/;"	f	class:PhysBAM::ARRAY_VIEW
SampledMeshUsed	IoData.h	/^  enum SampledMeshUsed {SAMPLED_MESH_NOT_USED = 0, SAMPLED_MESH_USED = 1} sampledMeshUsed;$/;"	g	struct:GappyConstructionData
SaveOldState	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^SaveOldState()$/;"	f	class:PhysBAMInterface
Save_Intersection_Information	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    void Save_Intersection_Information(RAY<TV>& storage_ray) const$/;"	f	class:PhysBAM::RAY
Scalar	AutoDiff/Function.h	/^    typedef _Scalar Scalar;$/;"	t	class:MatrixValuedFunction
Scalar	AutoDiff/Function.h	/^    typedef _Scalar Scalar;$/;"	t	class:ScalarValuedFunction
Scalar	AutoDiff/Function.h	/^    typedef _Scalar Scalar;$/;"	t	class:VectorValuedFunction
Scalar	AutoDiff/SpaceDerivatives.h	/^    typedef _Scalar Scalar;$/;"	t	class:FirstPartialSpaceDerivatives
Scalar	AutoDiff/SpaceDerivatives.h	/^    typedef _Scalar Scalar;$/;"	t	class:SpatialView
Scalar	AutoDiff/SpaceDerivatives.h	/^    typedef typename MatrixValuedFunctionBase::Scalar Scalar;$/;"	t	class:Jacobian
Scalar	DistLeastSquareSolver.h	/^  typedef double Scalar;$/;"	t	class:DistLeastSquareSolver
ScalarAvgType	PostFcn.h	/^  enum ScalarAvgType {DENSITYAVG = 0, MACHAVG = 1, PRESSUREAVG = 2, TEMPERATUREAVG = 3,$/;"	g	class:PostFcn
ScalarConstantType	AutoDiff/Function.h	/^    typedef _ScalarConstantType ScalarConstantType;$/;"	t	class:MatrixValuedFunction
ScalarConstantType	AutoDiff/Function.h	/^    typedef _ScalarConstantType ScalarConstantType;$/;"	t	class:ScalarValuedFunction
ScalarConstantType	AutoDiff/Function.h	/^    typedef _ScalarConstantType ScalarConstantType;$/;"	t	class:VectorValuedFunction
ScalarConstantType	AutoDiff/SpaceDerivatives.h	/^    typedef typename FunctionTemplate<Scalar>::ScalarConstantType ScalarConstantType;$/;"	t	class:FirstPartialSpaceDerivatives
ScalarConstantType	AutoDiff/SpaceDerivatives.h	/^    typedef typename MatrixValuedFunctionBase::ScalarConstantType ScalarConstantType;$/;"	t	class:Jacobian
ScalarDerivativeType	PostFcn.h	/^  enum ScalarDerivativeType {DERIVATIVE_DENSITY = 0, DERIVATIVE_MACH = 1, DERIVATIVE_PRESSURE = 2, $/;"	g	class:PostFcn
ScalarGlob	KDTree.h	/^  struct ScalarGlob {$/;"	s	class:KDTree
ScalarType	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	g	class:PostFcn
ScalarValuedFunction	AutoDiff/Function.h	/^class ScalarValuedFunction {$/;"	c
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    void Scale_About_Center(const T factor)$/;"	f	class:PhysBAM::ORIENTED_BOX
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    void Scale_About_Center(const TV factor)$/;"	f	class:PhysBAM::ORIENTED_BOX
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    void Scale_About_Center(const T factor)$/;"	f	class:PhysBAM::INTERVAL
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Scale_About_Center(const T factor)$/;"	f	class:PhysBAM::RANGE
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Scale_About_Center(const T x_factor,const T y_factor)$/;"	f	class:PhysBAM::RANGE
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Scale_About_Center(const T x_factor,const T y_factor,const T z_factor)$/;"	f	class:PhysBAM::RANGE
Scale_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    void Scale_About_Center(const TV factor)$/;"	f	class:PhysBAM::RANGE
Scale_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Scale_Angle(const T a) const$/;"	f	class:ROTATION
Scale_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION Scale_Angle() const$/;"	f	class:PhysBAM::ROTATION
Scale_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Scale_Matrix(const T scale)$/;"	f	class:PhysBAM::MATRIX
Scale_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Scale_Matrix(const VECTOR<T,2>& scale_vector)$/;"	f	class:PhysBAM::MATRIX
Scale_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Scale_Matrix(const T scale)$/;"	f	class:PhysBAM::MATRIX
Scale_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Scale_Matrix(const VECTOR<T,3>& scale_vector)$/;"	f	class:PhysBAM::MATRIX
Scaled_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX Scaled_About_Center(const T factor) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Scaled_About_Center	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX Scaled_About_Center(const TV edge_factor)$/;"	f	class:PhysBAM::ORIENTED_BOX
SchemeData	IoData.h	/^struct SchemeData {$/;"	s
SchemeData	IoDataCore.C	/^SchemeData::SchemeData(int af) : allowsFlux(af)$/;"	f	class:SchemeData
SchemeFixData	IoData.h	/^struct SchemeFixData {$/;"	s
SchemeFixData	IoDataCore.C	/^SchemeFixData::SchemeFixData()$/;"	f	class:SchemeFixData
SchemesData	IoData.h	/^struct SchemesData {$/;"	s
SchemesData	IoDataCore.C	/^SchemesData::SchemesData() : ls(0), tm(0)$/;"	f	class:SchemesData
SchurOK	arpack++/include/arrseig.h	/^  bool    SchurOK;    \/\/ Indicates if Schur vectors were determined.$/;"	m	class:ARrcStdEig
SchurVector	arpack++/include/arrseig.h	/^inline ARTYPE ARrcStdEig<ARFLOAT, ARTYPE>::SchurVector(int i, int j)$/;"	f	class:ARrcStdEig
SchurVectorsFound	arpack++/include/arrseig.h	/^  bool SchurVectorsFound() { return SchurOK; }$/;"	f	class:ARrcStdEig
Secant_Root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Secant_Root(NONLINEAR_FUNCTION<T(T)>& F,T x0,T x1)$/;"	f	class:ITERATIVE_SOLVER
SeedNodeChoice	MultiGridLevel.h	/^    enum SeedNodeChoice { Random, Mavripilis };$/;"	g	class:MultiGridLevel
Segment	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    int Segment(const int node1,const int node2) const$/;"	f	class:PhysBAM::SEGMENT_MESH
Segment_In_Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    bool Segment_In_Triangle(const int segment_node_1,const int segment_node_2,const int triangle_index)$/;"	f	class:PhysBAM::TRIANGLE_MESH
Segment_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Segment_Intersection(const TV& endpoint1,const TV& endpoint2,T& interpolation_fraction) const$/;"	f	class:PhysBAM::LINE_2D
Segment_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    bool Segment_Intersection(const TV& endpoint1,const TV& endpoint2,T& interpolation_fraction) const$/;"	f	class:PhysBAM::PLANE
Segment_Line_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    bool Segment_Line_Intersection(const TV& endpoint1,const TV& endpoint2,T& interpolation_fraction) const $/;"	f	class:PhysBAM::LINE_2D
Segment_Line_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Segment_Line_Intersection(const VECTOR<T,2>& point_on_line,const VECTOR<T,2>& normal_of_line,T &interpolation_fraction) const$/;"	f	class:SEGMENT_2D
Segment_Plane_Intersection	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.cpp	/^Segment_Plane_Intersection(const TV& endpoint1,const TV& endpoint2,T& interpolation_fraction) const$/;"	f	class:PLANE
Segment_Segment_Interaction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Segment_Segment_Interaction(const SEGMENT_2D<T>& segment,const VECTOR<T,2>& v1,const VECTOR<T,2>& v2,const VECTOR<T,2>& v3,const VECTOR<T,2>& v4,const T interaction_distance,$/;"	f	class:SEGMENT_2D
Segments_Adjacent	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    bool Segments_Adjacent(const int segment1,const int segment2) const$/;"	f	class:PhysBAM::SEGMENT_MESH
SelectSampledNodes	IoData.h	/^  enum SelectSampledNodes {SELECT_SAMPLED_NODES_FALSE = 0, SELECT_SAMPLED_NODES_TRUE = 1} selectSampledNodes;$/;"	g	struct:GappyConstructionData
Sensitivities	Manual/Aerof3d.html	/^<a name="Sensitivities"><\/a>$/;"	a
SensitivityAOA	IoData.h	/^  enum SensitivityAOA {OFF_SENSITIVITYALPHA = 0, ON_SENSITIVITYALPHA = 1} sensAlpha;$/;"	g	struct:SensitivityAnalysis
SensitivityAnalysis	IoData.h	/^struct SensitivityAnalysis {$/;"	s
SensitivityAnalysis	IoDataCore.C	/^SensitivityAnalysis::SensitivityAnalysis()$/;"	f	class:SensitivityAnalysis
SensitivityAnalysis	Manual/Aerof3d.html	/^<a name="SensitivityAnalysis"><\/a>$/;"	a
SensitivityComputation	IoData.h	/^  enum SensitivityComputation {ANALYTICAL = 0, SEMIANALYTICAL = 1,  FINITEDIFFERENCE = 2} scFlag;$/;"	g	struct:SensitivityAnalysis
SensitivityData	IoData.h	/^struct SensitivityData {$/;"	s
SensitivityData	IoDataCore.C	/^SensitivityData::SensitivityData()$/;"	f	class:SensitivityData
SensitivityFSI	IoData.h	/^  enum SensitivityFSI  {OFF_SENSITIVITYFSI  = 0, ON_SENSITIVITYFSI  = 1} sensFSI;$/;"	g	struct:SensitivityAnalysis
SensitivityLiftx	IoData.h	/^  enum SensitivityLiftx {OFF_SENSITIVITYLIFTX = 0, ON_SENSITIVITYLIFTX = 1} sensLiftx;$/;"	g	struct:SensitivityAnalysis
SensitivityLifty	IoData.h	/^  enum SensitivityLifty {OFF_SENSITIVITYLIFTY = 0, ON_SENSITIVITYLIFTY = 1} sensLifty;$/;"	g	struct:SensitivityAnalysis
SensitivityLiftz	IoData.h	/^  enum SensitivityLiftz {OFF_SENSITIVITYLIFTZ = 0, ON_SENSITIVITYLIFTZ = 1} sensLiftz;$/;"	g	struct:SensitivityAnalysis
SensitivityMach	IoData.h	/^  enum SensitivityMach {OFF_SENSITIVITYMACH = 0, ON_SENSITIVITYMACH = 1} sensMach;$/;"	g	struct:SensitivityAnalysis
SensitivityMesh	IoData.h	/^  enum SensitivityMesh {OFF_SENSITIVITYMESH = 0, ON_SENSITIVITYMESH = 1} sensMesh;$/;"	g	struct:SensitivityAnalysis
SensitivityYAW	IoData.h	/^  enum SensitivityYAW {OFF_SENSITIVITYBETA = 0, ON_SENSITIVITYBETA = 1} sensBeta;$/;"	g	struct:SensitivityAnalysis
Separating_Test	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Separating_Test(const ORIENTED_BOX& box,const TV& direction) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Separating_Test	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Separating_Test(const RANGE<TV>& box,const TV& direction) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Set	ArpackUtil.h	/^void ArpackError::Set(ErrorCode error, char* where)$/;"	f	class:ArpackError
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Set(const TK& v) \/\/ insert entry if doesn't already exists, returns whether it added a new entry$/;"	f	class:PhysBAM::HASHTABLE
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    bool Set(const TK& v,const T_UNLESS_VOID& value) \/\/ if v doesn't exist insert value, else sets its value, returns whether it added a new entry$/;"	f	class:PhysBAM::HASHTABLE
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Set(const T& element1,const T& element2,const T& element3,const T& element4)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Set(const T& element1,const T& element2,const T& element3,const T& element4,const T& element5)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Set(const T& element1,const T& element2,const T& element3,const T& element4,const T& element5,const T& element6)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Set(const T& element1,const T& element2,const T& element3,const T& element4,const T& element5,const T& element6,const T& element7)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    void Set(const T& element1,const T& element2,const T& element3,const T& element4,const T& element5,const T& element6,const T& element7,const T& element8)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    void Set(const T& element1)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Set(const T& element1,const T& element2)$/;"	f	class:PhysBAM::VECTOR
Set	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Set(const T& element1,const T& element2,const T& element3)$/;"	f	class:PhysBAM::VECTOR
Set	arpack++/include/arerror.h	/^void ArpackError::Set(ErrorCode error, char* where)$/;"	f	class:ArpackError
SetBucklingMode	arpack++/include/arbgsym.h	/^SetBucklingMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetBucklingMode	arpack++/include/ardgsym.h	/^SetBucklingMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetBucklingMode	arpack++/include/argsym.h	/^SetBucklingMode(ARFLOAT sigmap, ARFOP* objOPp, $/;"	f	class:ARSymGenEig
SetBucklingMode	arpack++/include/arlgsym.h	/^SetBucklingMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetBucklingMode	arpack++/include/arrgsym.h	/^void ARrcSymGenEig<ARFLOAT>::SetBucklingMode(ARFLOAT sigmap)$/;"	f	class:ARrcSymGenEig
SetBucklingMode	arpack++/include/arugsym.h	/^SetBucklingMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetCayleyMode	arpack++/include/arbgsym.h	/^SetCayleyMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetCayleyMode	arpack++/include/ardgsym.h	/^SetCayleyMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetCayleyMode	arpack++/include/argsym.h	/^SetCayleyMode(ARFLOAT sigmap, ARFOP* objOPp, $/;"	f	class:ARSymGenEig
SetCayleyMode	arpack++/include/arlgsym.h	/^SetCayleyMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetCayleyMode	arpack++/include/arrgsym.h	/^void ARrcSymGenEig<ARFLOAT>::SetCayleyMode(ARFLOAT sigmap)$/;"	f	class:ARrcSymGenEig
SetCayleyMode	arpack++/include/arugsym.h	/^SetCayleyMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetComplexPointers	arpack++/include/ardfmat.h	/^SetComplexPointers(char* num, char* &realp, char* &imagp)$/;"	f	class:ARdfMatrix
SetComplexShiftMode	arpack++/include/arbgnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
SetComplexShiftMode	arpack++/include/ardgnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
SetComplexShiftMode	arpack++/include/argnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp, $/;"	f	class:ARNonSymGenEig
SetComplexShiftMode	arpack++/include/arlgnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
SetComplexShiftMode	arpack++/include/arrgnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARrcNonSymGenEig
SetComplexShiftMode	arpack++/include/arugnsym.h	/^SetComplexShiftMode(char partp, ARFLOAT sigmaRp, ARFLOAT sigmaIp)$/;"	f	class:ARluNonSymGenEig
SetFirstOrderNodes	DistTimeState.C	/^  SetFirstOrderNodes(VarFcn* varFcn,double t, ErrorHandler* errorHandlerIn,$/;"	f	struct:SetFirstOrderNodes
SetFirstOrderNodes	DistTimeState.C	/^struct SetFirstOrderNodes {$/;"	s	file:
SetOfVec	GappyPreprocessing.h	/^	typedef VecSet< DistSVec<double,dim> > SetOfVec;$/;"	t	class:GappyPreprocessing
SetRegularMode	arpack++/include/arbgcomp.h	/^inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompGenEig
SetRegularMode	arpack++/include/arbgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymGenEig
SetRegularMode	arpack++/include/arbgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymGenEig
SetRegularMode	arpack++/include/arbscomp.h	/^inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompStdEig
SetRegularMode	arpack++/include/arbsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymStdEig
SetRegularMode	arpack++/include/arbssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymStdEig
SetRegularMode	arpack++/include/ardgcomp.h	/^inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompGenEig
SetRegularMode	arpack++/include/ardgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymGenEig
SetRegularMode	arpack++/include/ardgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymGenEig
SetRegularMode	arpack++/include/ardscomp.h	/^inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompStdEig
SetRegularMode	arpack++/include/ardsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymStdEig
SetRegularMode	arpack++/include/ardssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymStdEig
SetRegularMode	arpack++/include/arlgcomp.h	/^inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompGenEig
SetRegularMode	arpack++/include/arlgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymGenEig
SetRegularMode	arpack++/include/arlgsym.h	/^inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymGenEig
SetRegularMode	arpack++/include/arlscomp.h	/^inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompStdEig
SetRegularMode	arpack++/include/arlsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymStdEig
SetRegularMode	arpack++/include/arlssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymStdEig
SetRegularMode	arpack++/include/arrseig.h	/^  virtual void SetRegularMode() { NoShift(); }$/;"	f	class:ARrcStdEig
SetRegularMode	arpack++/include/arseig.h	/^SetRegularMode(ARFOP* objOPp, void (ARFOP::* MultOPxp)(ARTYPE[], ARTYPE[]))$/;"	f	class:ARStdEig
SetRegularMode	arpack++/include/arugcomp.h	/^inline void ARluCompGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompGenEig
SetRegularMode	arpack++/include/arugnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymGenEig
SetRegularMode	arpack++/include/arugsym.h	/^inline void ARluSymGenEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymGenEig
SetRegularMode	arpack++/include/aruscomp.h	/^inline void ARluCompStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluCompStdEig
SetRegularMode	arpack++/include/arusnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluNonSymStdEig
SetRegularMode	arpack++/include/arussym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetRegularMode()$/;"	f	class:ARluSymStdEig
SetShiftInvertMode	arpack++/include/arbgcomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompGenEig
SetShiftInvertMode	arpack++/include/arbgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymGenEig
SetShiftInvertMode	arpack++/include/arbgsym.h	/^SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetShiftInvertMode	arpack++/include/arbscomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompStdEig
SetShiftInvertMode	arpack++/include/arbsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymStdEig
SetShiftInvertMode	arpack++/include/arbssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymStdEig
SetShiftInvertMode	arpack++/include/ardgcomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompGenEig
SetShiftInvertMode	arpack++/include/ardgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymGenEig
SetShiftInvertMode	arpack++/include/ardgsym.h	/^SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetShiftInvertMode	arpack++/include/ardscomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompStdEig
SetShiftInvertMode	arpack++/include/ardsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymStdEig
SetShiftInvertMode	arpack++/include/ardssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymStdEig
SetShiftInvertMode	arpack++/include/argnsym.h	/^SetShiftInvertMode(ARFLOAT sigmaRp, ARFOP* objOPp,$/;"	f	class:ARNonSymGenEig
SetShiftInvertMode	arpack++/include/argsym.h	/^SetShiftInvertMode(ARFLOAT sigmap, ARFOP* objOPp,$/;"	f	class:ARSymGenEig
SetShiftInvertMode	arpack++/include/arlgcomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompGenEig
SetShiftInvertMode	arpack++/include/arlgnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymGenEig
SetShiftInvertMode	arpack++/include/arlgsym.h	/^SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetShiftInvertMode	arpack++/include/arlscomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompStdEig
SetShiftInvertMode	arpack++/include/arlsnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymStdEig
SetShiftInvertMode	arpack++/include/arlssym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymStdEig
SetShiftInvertMode	arpack++/include/arrgnsym.h	/^SetShiftInvertMode(ARFLOAT sigmaRp)$/;"	f	class:ARrcNonSymGenEig
SetShiftInvertMode	arpack++/include/arrgsym.h	/^void ARrcSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARrcSymGenEig
SetShiftInvertMode	arpack++/include/arrseig.h	/^  virtual void SetShiftInvertMode(ARTYPE sigmaRp) { ChangeShift(sigmaRp); }$/;"	f	class:ARrcStdEig
SetShiftInvertMode	arpack++/include/arseig.h	/^SetShiftInvertMode(ARTYPE sigmap, ARFOP* objOPp, $/;"	f	class:ARStdEig
SetShiftInvertMode	arpack++/include/arugcomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompGenEig
SetShiftInvertMode	arpack++/include/arugnsym.h	/^inline void ARluNonSymGenEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymGenEig
SetShiftInvertMode	arpack++/include/arugsym.h	/^SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymGenEig
SetShiftInvertMode	arpack++/include/aruscomp.h	/^SetShiftInvertMode(arcomplex<ARFLOAT> sigmap)$/;"	f	class:ARluCompStdEig
SetShiftInvertMode	arpack++/include/arusnsym.h	/^inline void ARluNonSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluNonSymStdEig
SetShiftInvertMode	arpack++/include/arussym.h	/^inline void ARluSymStdEig<ARFLOAT>::SetShiftInvertMode(ARFLOAT sigmap)$/;"	f	class:ARluSymStdEig
SetThickness	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    void SetThickness(const T input_thickness)$/;"	f	class:PhysBAM::PhysBAMInterface
Set_All	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    void Set_All(const T_ARRAY& array)$/;"	f	class:PhysBAM::HASHTABLE
Set_Backtrace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^void Set_Backtrace(const bool enable)$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Set_Closed_Polygon	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^    void Set_Closed_Polygon()$/;"	f	class:PhysBAM::POLYGON
Set_Column	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Column(const int j,const VECTOR_BASE<T,T_VECTOR>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Floating_Point_Exception_Handling	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^void Set_Floating_Point_Exception_Handling(const bool enable,const bool division_by_zero,const bool invalid_operation,$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Set_Identity_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Identity_Matrix()$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Set_Leaf_Boxes(const ARRAY<RANGE<TV> >& boxes,const bool reinitialize)$/;"	f	class:BOX_HIERARCHY
Set_Number_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Set_Number_Nodes(const int number_nodes_input)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Set_Number_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Set_Number_Nodes(const int number_nodes_input)$/;"	f	class:TRIANGLE_MESH
Set_Number_Of_Vertices	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^    void Set_Number_Of_Vertices(const int number_of_vertices)$/;"	f	class:PhysBAM::POLYGON
Set_Open_Polygon	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^    void Set_Open_Polygon()$/;"	f	class:PhysBAM::POLYGON
Set_Row	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Row(const int i,const VECTOR_BASE<T,T_VECTOR>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Seed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^Set_Seed(const unsigned int value)$/;"	f	class:PhysBAM::MT19937
Set_Seed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^Set_Seed(const unsigned int seed_input)$/;"	f	class:PhysBAM::RANDOM_NUMBERS
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    void Set_Submatrix(const int istart,const int jstart,const T_MATRIX& a)$/;"	f	class:PhysBAM::MATRIX
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Submatrix(const int istart,const int jstart,const DIAGONAL_MATRIX<T,3>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Submatrix(const int istart,const int jstart,const MATRIX_BASE<T,T_MATRIX2>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Submatrix(const int istart,const int jstart,const SYMMETRIC_MATRIX<T,2>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Submatrix(const int istart,const int jstart,const SYMMETRIC_MATRIX<T,3>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Submatrix(const int istart,const int jstart,const VECTOR_BASE<T,T_VECTOR>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Set_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    void Set_Subvector(const int istart,const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Set_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    void Set_Subvector(const int istart,const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
Set_Subvector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Set_Subvector(const int istart,const VECTOR_BASE<T,T_VECTOR2>& v)$/;"	f	class:PhysBAM::VECTOR_BASE
Set_Subvector_View	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    void Set_Subvector_View(const VECTOR_ND& v,const INTERVAL<int>& range)$/;"	f	class:PhysBAM::VECTOR_ND
Set_To_Orthogonal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Set_To_Orthogonal_Vector() \/\/ result isn't normalized$/;"	f	class:PhysBAM::VECTOR_BASE
Set_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    void Set_Vector(const VECTOR<T,dimension>& vector)$/;"	f	class:PhysBAM::TWIST
Set_Zero	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Set_Zero()$/;"	f	class:PhysBAM::VECTOR_BASE
Set_Zero_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Set_Zero_Matrix()$/;"	f	class:PhysBAM::MATRIX_BASE
ShapeDerivativeType	IoData.h	/^  enum ShapeDerivativeType {WALL=0, VOLUME=1} shapederivativesType;$/;"	g	struct:InputData
Share	Communicator.h	/^  enum Mode { Share, CopyOnSend };$/;"	e	enum:CommPattern::Mode
Shifted_Get	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Shifted_Get(ARRAY_BASE& new_copy,const ARRAY_BASE& old_copy,const TV_INT& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Shifted_Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Shifted_Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const VECTOR<int,1>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Shifted_Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Shifted_Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const VECTOR<int,2>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Shifted_Put	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    static void Shifted_Put(const ARRAY_BASE& old_copy,ARRAY_BASE& new_copy,const VECTOR<int,3>& shift)$/;"	f	class:PhysBAM::ARRAY_BASE
Shortest_Vector_Between_Lines	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Shortest_Vector_Between_Lines(const SEGMENT_3D<T>& segment,VECTOR<T,2>& weights) const$/;"	f	class:SEGMENT_3D
Shortest_Vector_Between_Segments	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Shortest_Vector_Between_Segments(const SEGMENT_2D<T>& segment,T& a,T& b) const$/;"	f	class:SEGMENT_2D
Shortest_Vector_Between_Segments	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.cpp	/^Shortest_Vector_Between_Segments(const SEGMENT_3D<T>& segment,VECTOR<T,2>& weights) const$/;"	f	class:SEGMENT_3D
Sign	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Sign(const T phi)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
Sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Sign() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Sign() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Sign() const$/;"	f	class:PhysBAM::MATRIX
Sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Sign() const$/;"	f	class:PhysBAM::MATRIX
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	/^Signed_Distance(const TV& X) const$/;"	f	class:BOX
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    T Signed_Distance(const TV& location) const$/;"	f	class:PhysBAM::LINE_2D
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.cpp	/^Signed_Distance(const TV& X) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    T Signed_Distance(const TV& location) const$/;"	f	class:PhysBAM::PLANE
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^Signed_Distance(const TV& location) const$/;"	f	class:IMPLICIT_OBJECT
Signed_Distance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T Signed_Distance(const T& X) const$/;"	f	class:PhysBAM::INTERVAL
Signed_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static T Signed_Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Signed_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    static T Signed_Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_3D
Signed_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Signed_Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::TRIANGLE_3D
Signed_Solid_Angle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.cpp	/^Signed_Solid_Angle(const VECTOR<T,3>& center) const$/;"	f	class:TRIANGLE_3D
Sij_Test	DistDynamicLESTerm.h	/^  DistSVec<double,6> *Sij_Test;$/;"	m	class:DistDynamicLESTerm
SimpleBuffer	SimpleBuffer.h	/^SimpleBuffer<Scalar>::SimpleBuffer(size_t numValues) :$/;"	f	class:SimpleBuffer
SimpleBuffer	SimpleBuffer.h	/^class SimpleBuffer {$/;"	c
Simplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Simplex(const VECTOR<int,d+1>& nodes) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Simplex_Minimum_Altitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Simplex_Minimum_Altitude() const$/;"	f	class:PhysBAM::MATRIX
Simplex_Minimum_Altitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Simplex_Minimum_Altitude() const$/;"	f	class:MATRIX
Simplex_Minimum_Altitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Simplex_Minimum_Altitude() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Simplex_Minimum_Altitude	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Simplex_Minimum_Altitude() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Simplices_On_Subsimplex	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Simplices_On_Subsimplex(const VECTOR<int,d2>& subsimplex_nodes,ARRAY<int>& simplices_on_subsimplex) const$/;"	f	class:PhysBAM::SIMPLEX_MESH
Singleton	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    static T_DERIVED_REGISTRY& Singleton()$/;"	f	class:PhysBAM::REGISTRY
Singleton	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    static inline TIMER* Singleton()$/;"	f	class:PhysBAM::TIMER
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    T Size() const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    T Size() const$/;"	f	class:PhysBAM::SEGMENT_2D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    static T Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_2D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    T Size() const$/;"	f	class:PhysBAM::SEGMENT_3D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    static T Size(const TV& x1,const TV& x2)$/;"	f	class:PhysBAM::SEGMENT_3D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    static T Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::SEGMENT_3D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    T Size() const$/;"	f	class:PhysBAM::TRIANGLE_3D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    static T Size(const T_ARRAY& X)$/;"	f	class:PhysBAM::TRIANGLE_3D
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ID Size() const$/;"	f	class:PhysBAM::ARRAY
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ID Size() const$/;"	f	class:PhysBAM::ARRAY_BASE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Size() const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_DIFFERENCE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_LEFT_MULTIPLE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_NEGATION
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_PLUS_SCALAR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_PRODUCT
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::ARRAY_SUM
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ID Size() const$/;"	f	class:PhysBAM::ARRAY_VIEW
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    ID Size() const$/;"	f	class:PhysBAM::CONSTANT_ARRAY
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    ID Size() const$/;"	f	class:PhysBAM::IDENTITY_ARRAY
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    ID Size() const$/;"	f	class:PhysBAM::INDIRECT_ARRAY
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    INDEX Size() const$/;"	f	class:PhysBAM::PROJECTED_ARRAY
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int Size() const$/;"	f	class:PhysBAM::HASHTABLE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Size() const$/;"	f	class:PhysBAM::UNION_FIND
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T Size() const$/;"	f	class:PhysBAM::INTERVAL
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    T Size() const \/\/ assumes nonnegative entries$/;"	f	class:PhysBAM::RANGE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_BASE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_DIFFERENCE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_NEGATION
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_SCALE
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_SUM
Size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    int Size() const$/;"	f	class:PhysBAM::VECTOR_ND
Sizeof_Clone	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    virtual size_t Sizeof_Clone() const$/;"	f	class:PhysBAM::CLONEABLE
Sleep	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.cpp	/^void Sleep(const double seconds)$/;"	f	namespace:PhysBAM::PROCESS_UTILITIES
Slice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    template<int d1,int d2> VECTOR<T,d2-d1+1> Slice() const$/;"	f	class:PhysBAM::VECTOR
Slice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<int d1,int d2> VECTOR<T,d2-d1+1> Slice() const$/;"	f	class:PhysBAM::VECTOR
Slice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<int d1,int d2> VECTOR<T,d2-d1+1> Slice() const$/;"	f	class:PhysBAM::VECTOR
Slice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<int d1,int d2> VECTOR<T,d2-d1+1> Slice() const$/;"	f	class:PhysBAM::VECTOR
SlidingSurfaceTreatment	IoData.h	/^  enum SlidingSurfaceTreatment {Default = 0, PrescribedAverage = 1} slidingSurfaceTreatment;$/;"	g	struct:DefoMeshMotionData
Smagorinsky	Manual/Aerof3d.html	/^<a name="Smagorinsky"><\/a>$/;"	a
SmagorinskyLESData	IoData.h	/^struct SmagorinskyLESData {$/;"	s
SmagorinskyLESData	IoDataCore.C	/^SmagorinskyLESData::SmagorinskyLESData()$/;"	f	class:SmagorinskyLESData
SmagorinskyLESTerm	SmagorinskyLESTerm.C	/^SmagorinskyLESTerm::SmagorinskyLESTerm(IoData& iod, VarFcn *vf): NavierStokesTerm(iod, vf)$/;"	f	class:SmagorinskyLESTerm
SmagorinskyLESTerm	SmagorinskyLESTerm.h	/^class SmagorinskyLESTerm : public NavierStokesTerm {$/;"	c
SmoothingMode	MultiGridSmoothingMatrix.h	/^  enum SmoothingMode { BlockJacobi, LineJacobi, RAS };$/;"	g	class:MultiGridSmoothingMatrix
SnapshotsData	IoData.h	/^struct SnapshotsData {$/;"	s
SnapshotsData	IoDataCore.C	/^SnapshotsData::SnapshotsData()$/;"	f	class:SnapshotsData
SolVecType	MeshMotionSolver.h	/^  typedef DistSVec<double,3> SolVecType;$/;"	t	class:TetMeshMotionSolver
SolVecType	TsDesc.h	/^  typedef DistSVec<double,dim> SolVecType;$/;"	t	class:TsDesc
SolutionMethod	IoData.h	/^  enum SolutionMethod { TIMESTEPPING = 0, MULTIGRID = 1} solutionMethod;$/;"	g	struct:ProblemData
SolveFluid	IoData.h	/^  enum SolveFluid {OFF = 0, ON = 1} solvefluid;$/;"	g	struct:ProblemData
SolveWithMultipleICs	IoData.h	/^  enum SolveWithMultipleICs {_MULTIPLE_ICS_FALSE_ = 0, _MULTIPLE_ICS_TRUE_ = 1} solveWithMultipleICs;$/;"	g	struct:ProblemData
Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    void Solve_Eigenproblem(MATRIX& D,MATRIX& V) const$/;"	f	class:PhysBAM::MATRIX
Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Solve_Eigenproblem(DIAGONAL_MATRIX<T,2>& eigenvalues,MATRIX<T,2>& eigenvectors) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Solve_Eigenproblem	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.cpp	/^Solve_Eigenproblem(DIAGONAL_MATRIX<T,3>& eigenvalues,MATRIX<T,3>& eigenvectors) const$/;"	f	class:SYMMETRIC_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    VECTOR<T,2> Solve_Linear_System(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    VECTOR<T,3> Solve_Linear_System(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    VECTOR<T,n> Solve_Linear_System(const VECTOR_BASE<T,T_VECTOR>& b)$/;"	f	class:PhysBAM::MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    VECTOR<T,0> Solve_Linear_System(const VECTOR<T,0>& b) const$/;"	f	class:PhysBAM::MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> Solve_Linear_System(const VECTOR<T,1>& b) const$/;"	f	class:PhysBAM::MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> Solve_Linear_System(const VECTOR<T,2>& b) const$/;"	f	class:PhysBAM::MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^Solve_Linear_System(const VECTOR<T,3>& b) const \/\/ 33 mults, 17 adds, 1 div$/;"	f	class:MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> Solve_Linear_System(const VECTOR<T,2>& b) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> Solve_Linear_System(const VECTOR<T,3>& b) const \/\/ 18 mults, 8 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    VECTOR<T,2> Solve_Linear_System(const VECTOR<T,2>& b) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Solve_Linear_System	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    VECTOR<T,3> Solve_Linear_System(const VECTOR<T,3>& b) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
SolverPreconditioner	Manual/Aerof3d.html	/^<a name="SolverPreconditioner"><\/a>$/;"	a
Sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline void Sort(T_ARRAY& array)$/;"	f	namespace:PhysBAM
Sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline void Sort(T_ARRAY& array,const T_COMPARE& comparison)$/;"	f	namespace:PhysBAM
Sorted	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR<T,4> Sorted() const$/;"	f	class:PhysBAM::VECTOR
Sorted	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,2> Sorted() const$/;"	f	class:PhysBAM::VECTOR
Sorted	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR<T,3> Sorted() const$/;"	f	class:PhysBAM::VECTOR
SowerInputs	IoData.h	/^  enum SowerInputs {SOWER_INPUTS_FALSE = 0, SOWER_INPUTS_TRUE = 1} sowerInputs;$/;"	g	struct:GappyConstructionData
SpMat	SubDomain.C	/^typedef Eigen::SparseMatrix<double> SpMat;$/;"	t	file:
SpMat	SubDomainCore.C	/^typedef Eigen::SparseMatrix<double> SpMat;$/;"	t	file:
Space	Manual/Aerof3d.html	/^<a name="Space"><\/a>$/;"	a
SpaceOperator	SpaceOperator.C	/^SpaceOperator<dim>::SpaceOperator(IoData &ioData, VarFcn *vf, DistBcData<dim> *bc,$/;"	f	class:SpaceOperator
SpaceOperator	SpaceOperator.C	/^SpaceOperator<dim>::SpaceOperator(const SpaceOperator<dim> &spo, bool typeAlloc)$/;"	f	class:SpaceOperator
SpaceOperator	SpaceOperator.h	/^class SpaceOperator {$/;"	c
SpaceTurbulenceModel	Manual/Aerof3d.html	/^<a name="SpaceTurbulenceModel"><\/a>$/;"	a
SpalartAllmaras	Manual/Aerof3d.html	/^<a name="SpalartAllmaras"><\/a>$/;"	a
SparseGrid	Manual/Aerof3d.html	/^<a name="SparseGrid"><\/a>$/;"	a
SparseGrid	SparseGrid.h	/^class SparseGrid {$/;"	c
SparseGrid	SparseGridCore.C	/^SparseGrid::SparseGrid(){$/;"	f	class:SparseGrid
SparseGrid	SparseGridCore.C	/^SparseGrid::SparseGrid(SparseGridData &data, double *param, $/;"	f	class:SparseGrid
SparseGridCluster	SparseGridCluster.h	/^class SparseGridCluster$/;"	c
SparseGridCluster	SparseGridClusterCore.C	/^SparseGridCluster::SparseGridCluster()$/;"	f	class:SparseGridCluster
SparseGridData	IoData.h	/^struct SparseGridData {$/;"	s
SparseGridData	IoDataCore.C	/^SparseGridData::SparseGridData()$/;"	f	class:SparseGridData
SparseGridGeneratorDesc	SparseGridGeneratorDesc.h	/^  SparseGridGeneratorDesc(IoData &ioData, Communicator *comm){$/;"	f	class:SparseGridGeneratorDesc
SparseGridGeneratorDesc	SparseGridGeneratorDesc.h	/^class SparseGridGeneratorDesc {$/;"	c
SparseMat	SparseMatrix.h	/^  SparseMat(int _n, int _nnz, int *_ia, int *_ja, Scalar (*_a)[dim*dim],$/;"	f	class:SparseMat
SparseMat	SparseMatrix.h	/^class SparseMat : public GenMat<Scalar,dim> {$/;"	c
SparseSaxpy	arpack++/include/arlnspen.h	/^SparseSaxpy(ARTYPE a, ARTYPE x[], int xind[], int nx, ARTYPE y[],$/;"	f	class:ARluNonSymPencil
SparseSaxpy	arpack++/include/arlnspen.h	/^SparseSaxpy(arcomplex<ARFLOAT> a, ARFLOAT x[], int xind[], int nx, ARFLOAT y[],$/;"	f	class:ARluNonSymPencil
SparseSaxpy	arpack++/include/arlspen.h	/^SparseSaxpy(ARTYPE a, ARTYPE x[], int xind[], int nx, ARTYPE y[],$/;"	f	class:ARluSymPencil
SparseSaxpy	arpack++/include/arunspen.h	/^SparseSaxpy(ARTYPE a, ARTYPE x[], int xind[], int nx, ARTYPE y[],$/;"	f	class:ARumNonSymPencil
SparseSaxpy	arpack++/include/arunspen.h	/^SparseSaxpy(arcomplex<ARFLOAT> a, ARFLOAT x[], int xind[], int nx,$/;"	f	class:ARumNonSymPencil
SparseSaxpy	arpack++/include/aruspen.h	/^SparseSaxpy(ARTYPE a, ARTYPE x[], int xind[], int nx, ARTYPE y[],$/;"	f	class:ARumSymPencil
SpatialLowMachPrec	LowMachPrec.h	/^  SpatialLowMachPrec() : LowMachPrec() {};$/;"	f	class:SpatialLowMachPrec
SpatialLowMachPrec	LowMachPrec.h	/^  SpatialLowMachPrec(IoData &iod) : LowMachPrec(iod) {if (prec>0) setupIodConstants(iod); };$/;"	f	class:SpatialLowMachPrec
SpatialLowMachPrec	LowMachPrec.h	/^class SpatialLowMachPrec : public LowMachPrec {$/;"	c
SpatialView	AutoDiff/SpaceDerivatives.h	/^    SpatialView(const Eigen::Array<typename FunctionTemplate<Scalar>::ScalarConstantType,$/;"	f	class:SpatialView
SpatialView	AutoDiff/SpaceDerivatives.h	/^class SpatialView$/;"	c
Specify_Three_Points	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    void Specify_Three_Points(const TV& x1_input,const TV& x2_input,const TV& x3_input)$/;"	f	class:PhysBAM::PLANE
Specify_Three_Points	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    void Specify_Three_Points(const TV& x1_input,const TV& x2_input,const TV& x3_input)$/;"	f	class:PhysBAM::TRIANGLE_3D
Sphere	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::Sphere$/;"	f	class:KirchhoffIntegrator
Sphere	Manual/Aerof3d.html	/^<a name="Sphere"><\/a>$/;"	a
SphereData	IoData.h	/^struct SphereData {$/;"	s
SphereData	IoDataCore.C	/^SphereData::SphereData()$/;"	f	class:SphereData
SphereFix	Manual/Aerof3d.html	/^<a name="SphereFix"><\/a>$/;"	a
Spherical_Linear_Interpolation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.cpp	/^Spherical_Linear_Interpolation(const ROTATION<TV>& r1,const ROTATION<TV>& r2,const T t)$/;"	f	class:ROTATION
Spherical_Linear_Interpolation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    static ROTATION<TV> Spherical_Linear_Interpolation(const ROTATION<TV>,const ROTATION<TV>,const T)$/;"	f	class:PhysBAM::ROTATION
SpiralingData	IoData.h	/^struct SpiralingData {$/;"	s
SpiralingData	IoDataCore.C	/^SpiralingData::SpiralingData()$/;"	f	class:SpiralingData
SpiralingMeshMotionHandler	MeshMotionHandler.h	/^class SpiralingMeshMotionHandler : public MeshMotionHandler {$/;"	c
SpiralingMeshMotionHandler	MeshMotionHandlerCore.C	/^SpiralingMeshMotionHandler::SpiralingMeshMotionHandler(IoData &iod, Domain *dom) :$/;"	f	class:SpiralingMeshMotionHandler
SpitRank	DebugTools.h	/^  static void SpitRank() {$/;"	f	class:DebugTools
Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^void Split(const std::string& str,const std::string& separator,ARRAY<std::string>& tokens)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    template<int n> void Split(VECTOR<T,n>& v1,VECTOR<T,d-n>& v2) const$/;"	f	class:PhysBAM::VECTOR
Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<int n> void Split(VECTOR<T,n>& v1,VECTOR<T,1-n>& v2) const$/;"	f	class:PhysBAM::VECTOR
Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<int n> void Split(VECTOR<T,n>& v1,VECTOR<T,2-n>& v2) const$/;"	f	class:PhysBAM::VECTOR
Split	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<int n> void Split(VECTOR<T,n>& v1,VECTOR<T,3-n>& v2) const$/;"	f	class:PhysBAM::VECTOR
Split	utils/Predicate.C	199;"	d	file:
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Sqrt() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Sqrt() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Sqrt() const$/;"	f	class:PhysBAM::MATRIX
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Sqrt() const$/;"	f	class:PhysBAM::MATRIX
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Sqrt() const$/;"	f	class:PhysBAM::MATRIX
Sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> Sqrt() const$/;"	f	class:PhysBAM::COMPLEX
Square	utils/Predicate.C	246;"	d	file:
Square_Tail	utils/Predicate.C	240;"	d	file:
Squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Squared() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Stable_Sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline void Stable_Sort(T_ARRAY& array)$/;"	f	namespace:PhysBAM
Stable_Sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^inline void Stable_Sort(T_ARRAY& array,const T_COMPARE& comparison)$/;"	f	namespace:PhysBAM
Standard_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    int Standard_Index(const TV_INT& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Start	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    void Start(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Start	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Start(const int id)$/;"	f	class:PhysBAM::TIMER
Start_XML	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual void Start_XML(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Startup	IoData.h	/^  enum Startup {REGULAR = 0, MODIFIED = 1} startup;$/;"	g	struct:ImplicitData
Stat	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^Stat(const std::string& label,const T_VALUE& value)$/;"	f	namespace:PhysBAM::LOG_REAL
Stat	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^template<class A,class B> inline void Stat(const A&,const B&){}$/;"	f	namespace:PhysBAM::LOG_NULL
Stat_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^void Stat_Helper(const std::string& label,const std::stringstream& s)$/;"	f	namespace:PhysBAM::LOG_REAL
StateData	IoData.h	/^struct StateData {$/;"	s
StateData	IoDataCore.C	/^StateData::StateData()$/;"	f	class:StateData
StateSnapshotsData	IoData.h	/^struct StateSnapshotsData {$/;"	s
StateSnapshotsData	IoDataCore.C	/^StateSnapshotsData::StateSnapshotsData()$/;"	f	class:StateSnapshotsData
StaticArray	GappyPreprocessing.h	/^		StaticArray() { for (int i=0; i<size; ++i) a[i] = static_cast<Scalar>(0);}$/;"	f	class:StaticArray
StaticArray	GappyPreprocessing.h	/^		StaticArray(Scalar b [size]){ for (int i=0; i<size; ++i) a[i] = b[i];}$/;"	f	class:StaticArray
StaticArray	GappyPreprocessing.h	/^		StaticArray(const StaticArray &other){ for (int i=0; i<size; ++i) a[i] = other.a[i];}$/;"	f	class:StaticArray
StaticArray	GappyPreprocessing.h	/^class StaticArray {	\/\/used for the value of a map$/;"	c
Static_Assert_Not_Small	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Static_Assert_Not_Small(const T_VECTOR2*)$/;"	f	class:PhysBAM::VECTOR_BASE
Static_Assert_Not_Small	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    static void Static_Assert_Not_Small(const VECTOR<T,d>*)$/;"	f	class:PhysBAM::VECTOR_BASE
Static_Assert_Not_Small	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    void Static_Assert_Not_Small() const$/;"	f	class:PhysBAM::VECTOR_BASE
Static_Extension	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    static std::string Static_Extension() {return "";}$/;"	f	class:PhysBAM::STRUCTURE
Static_Name	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    static std::string Static_Name() {return "";}$/;"	f	class:PhysBAM::STRUCTURE
Static_Name	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    static std::string Static_Name()$/;"	f	class:PhysBAM::FRAME
Status	arpack++/include/arerror.h	/^  static int Status() { return (int) code; }$/;"	f	class:ArpackError
Steady-flow-computation	Manual/Aerof3d.html	/^<a name="Steady-flow-computation"><\/a>$/;"	a
Steepest_Decent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.cpp	/^Steepest_Decent(NONLINEAR_FUNCTION<T(T,T)>& F,T& x,T& y,const T alpha_max)$/;"	f	class:ITERATIVE_SOLVER
StiffMat	StiffMatrix.C	/^StiffMat<Scalar,dim>::StiffMat(Domain *domain, int **nodeType, MemoryPool *mp, BCApplier* bcs) $/;"	f	class:StiffMat
StiffMat	StiffMatrix.h	/^class StiffMat : public DistMat<Scalar,dim> {$/;"	c
StlArnoldiBasisVector	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT,ARTYPE>::StlArnoldiBasisVector(int i)$/;"	f	class:ARrcStdEig
StlArnoldiBasisVectors	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT, ARTYPE>::StlArnoldiBasisVectors()$/;"	f	class:ARrcStdEig
StlEigenvalues	arpack++/include/arrscomp.h	/^StlEigenvalues(bool ivec, bool ischur)$/;"	f	class:ARrcCompStdEig
StlEigenvalues	arpack++/include/arrsnsym.h	/^StlEigenvalues(bool ivec, bool ischur)$/;"	f	class:ARrcNonSymStdEig
StlEigenvalues	arpack++/include/arrssym.h	/^StlEigenvalues(bool ivec, bool ischur)$/;"	f	class:ARrcSymStdEig
StlEigenvaluesImag	arpack++/include/arrsnsym.h	/^inline vector<ARFLOAT>* ARrcNonSymStdEig<ARFLOAT>::StlEigenvaluesImag()$/;"	f	class:ARrcNonSymStdEig
StlEigenvaluesReal	arpack++/include/arrsnsym.h	/^inline vector<ARFLOAT>* ARrcNonSymStdEig<ARFLOAT>::StlEigenvaluesReal()$/;"	f	class:ARrcNonSymStdEig
StlEigenvector	arpack++/include/arrscomp.h	/^StlEigenvector(int i)$/;"	f	class:ARrcCompStdEig
StlEigenvector	arpack++/include/arrsnsym.h	/^StlEigenvector(int i)$/;"	f	class:ARrcNonSymStdEig
StlEigenvector	arpack++/include/arrssym.h	/^inline vector<ARFLOAT>* ARrcSymStdEig<ARFLOAT>::StlEigenvector(int i)$/;"	f	class:ARrcSymStdEig
StlEigenvectorImag	arpack++/include/arrsnsym.h	/^inline vector<ARFLOAT>* ARrcNonSymStdEig<ARFLOAT>::StlEigenvectorImag(int i)$/;"	f	class:ARrcNonSymStdEig
StlEigenvectorReal	arpack++/include/arrsnsym.h	/^inline vector<ARFLOAT>* ARrcNonSymStdEig<ARFLOAT>::StlEigenvectorReal(int i)$/;"	f	class:ARrcNonSymStdEig
StlEigenvectors	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT,ARTYPE>::StlEigenvectors(bool ischur)$/;"	f	class:ARrcStdEig
StlResidualVector	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT, ARTYPE>::StlResidualVector()$/;"	f	class:ARrcStdEig
StlSchurVector	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT, ARTYPE>::StlSchurVector(int i)$/;"	f	class:ARrcStdEig
StlSchurVectors	arpack++/include/arrseig.h	/^inline vector<ARTYPE>* ARrcStdEig<ARFLOAT, ARTYPE>::StlSchurVectors()$/;"	f	class:ARrcStdEig
Stop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    void Stop(LOG_CLASS& instance)$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
Stop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^Stop(const int id)$/;"	f	class:PhysBAM::TIMER
Stop_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Stop_Time()$/;"	f	namespace:PhysBAM::LOG_REAL
Stop_Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^inline void Stop_Time(){}$/;"	f	namespace:PhysBAM::LOG_NULL
Store	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    void Store(const int self_box_index,const int other_box_index) const$/;"	f	struct:PhysBAM::BOX_VISITOR_TRIVIAL
Store	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    void Store(const int self_box_index,const int other_box_index)$/;"	f	struct:PhysBAM::BOX_VISITOR_MPI
Store	arpack++/include/arlsupm.h	/^	void *Store;   \/* pointer to the actual storage of the matrix *\/$/;"	m	struct:__anon45
StoreAllClusters	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	g	struct:NonlinearRomOnlineData
StoreAllClusters	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	g	struct:ROBConstructionData
Store_Id	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    void Store_Id(bool store=true)$/;"	f	class:PhysBAM::POINT_CLOUD
Store_Velocity	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    void Store_Velocity(bool store=true)$/;"	f	class:PhysBAM::GEOMETRY_PARTICLES
Strategy	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	g	struct:CFLData
StringManager	parser/StringManager.h	/^  StringManager(){}$/;"	f	class:StringManager
StringManager	parser/StringManager.h	/^class StringManager$/;"	c
String_To_Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^template<> inline bool String_To_Value<std::string>(const std::string& str,std::string& value)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
String_To_Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^template<class T> inline bool String_To_Value(const std::string& str,T& value) \/\/ requires operator>>$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Strip_Compression_Suffix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline std::string Strip_Compression_Suffix(const std::string& filename)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Strip_Whitespace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^inline void Strip_Whitespace(std::string& str)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Stripped_Whitespace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^std::string Stripped_Whitespace(const std::string& str)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
StructExc	StructExc.C	/^StructExc::StructExc(IoData& iod, MatchNodeSet** mns, int bs, Communicator* sc, Communicator* fluidCom, int nSub)$/;"	f	class:StructExc
StructExc	StructExc.h	/^class StructExc {$/;"	c
StructureNormal	IoData.h	/^  enum StructureNormal {ELEMENT_BASED = 0, NODE_BASED = 1} structNormal;$/;"	g	struct:EmbeddedFramework
Stype	arpack++/include/arlsupm.h	/^	Stype_t Stype; \/* Storage type: interprets the storage structure $/;"	m	struct:__anon45
Stype_t	arpack++/include/arlsupm.h	/^} Stype_t;$/;"	t	typeref:enum:__anon42
SubD	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ARRAY<SubDInterface<T> > SubD;$/;"	m	class:PhysBAM::PhysBAMInterface
SubDInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    SubDInterface() : scope(0),triangle_list(0),scoped_triangle_mesh(0),triangle_hierarchy(0),candidates(0) {}$/;"	f	struct:PhysBAM::SubDInterface
SubDInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^struct SubDInterface {$/;"	s	namespace:PhysBAM
SubDTopo	Communicator.h	/^class SubDTopo {$/;"	c
SubDTopo	CommunicatorCore.C	/^SubDTopo::SubDTopo(int myCPU, Connectivity *subToSub, Connectivity *CPUToSub)$/;"	f	class:SubDTopo
SubDomain	SubDomain.h	/^class SubDomain {$/;"	c
SubDomain	SubDomainCore.C	/^SubDomain::SubDomain(int locN, int clusN, int globN, int nClNd, char *clstN,$/;"	f	class:SubDomain
SubDomainData	GappyPreprocessing.h	/^	SubDomainData() { };$/;"	f	struct:SubDomainData
SubDomainData	GappyPreprocessing.h	/^	SubDomainData(double (*b)[dim] ) {$/;"	f	struct:SubDomainData
SubDomainData	GappyPreprocessing.h	/^struct SubDomainData { $/;"	s
SubRecInfo	Communicator.h	/^struct SubRecInfo {$/;"	s
SubVecSet	VectorSet.h	/^   SubVecSet(VecSet<VecType> *_vs, int part) : vs(_vs), subIdx(part) {}$/;"	f	class:SubVecSet
SubVecSet	VectorSet.h	/^class SubVecSet {$/;"	c
Sub_KD_Tree_Using_Leaf_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.cpp	/^Sub_KD_Tree_Using_Leaf_Nodes(KD_TREE_NODE<T>* cell,const int first_index,const int last_index,ARRAY_VIEW<const TV> points,ARRAY_VIEW<int> permutation_array,RANGE<TV>& box)$/;"	f	class:KD_TREE
Subset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    INDIRECT_ARRAY<T_ARRAY,T_INDICES&> Subset(const T_INDICES& indices)$/;"	f	class:PhysBAM::ARRAY_BASE
Subset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    INDIRECT_ARRAY<const T_ARRAY,T_INDICES&> Subset(const T_INDICES& indices) const$/;"	f	class:PhysBAM::ARRAY_BASE
Subsimplex_Weights	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    template<class T,int d2> static VECTOR<VECTOR<T,d>,d2> Subsimplex_Weights(const VECTOR<int,d+1>& simplex_nodes,const VECTOR<int,d2>& subsimplex_nodes)$/;"	f	class:PhysBAM::SIMPLEX_MESH
SubtractAsB	arpack++/include/arbnspen.h	/^SubtractAsB(ARFLOAT sigmaR, ARFLOAT sigmaI)$/;"	f	class:ARbdNonSymPencil
SubtractAsB	arpack++/include/arbnspen.h	/^void ARbdNonSymPencil<ARTYPE, ARFLOAT>::SubtractAsB(ARTYPE sigma)$/;"	f	class:ARbdNonSymPencil
SubtractAsB	arpack++/include/arbspen.h	/^void ARbdSymPencil<ARTYPE>::SubtractAsB(ARTYPE sigma)$/;"	f	class:ARbdSymPencil
SubtractAsB	arpack++/include/ardspen.h	/^void ARdsSymPencil<ARTYPE>::SubtractAsB(ARTYPE sigma)$/;"	f	class:ARdsSymPencil
SubtractAsB	arpack++/include/arlnspen.h	/^SubtractAsB(int n, ARFLOAT sigmaR, ARFLOAT sigmaI,$/;"	f	class:ARluNonSymPencil
SubtractAsB	arpack++/include/arlnspen.h	/^SubtractAsB(int n, ARTYPE sigma, NCformat& A, NCformat& B, NCformat& AsB)$/;"	f	class:ARluNonSymPencil
SubtractAsB	arpack++/include/arlspen.h	/^SubtractAsB(int n, ARTYPE sigma, NCformat& matA, NCformat& matB, NCformat& AsB)$/;"	f	class:ARluSymPencil
SubtractAsB	arpack++/include/arunspen.h	/^SubtractAsB(ARFLOAT sigmaR, ARFLOAT sigmaI)$/;"	f	class:ARumNonSymPencil
SubtractAsB	arpack++/include/arunspen.h	/^void ARumNonSymPencil<ARTYPE, ARFLOAT>::SubtractAsB(ARTYPE sigma)$/;"	f	class:ARumNonSymPencil
SubtractAsB	arpack++/include/aruspen.h	/^void ARumSymPencil<ARTYPE>::SubtractAsB(ARTYPE sigma)$/;"	f	class:ARumSymPencil
SubtractAsI	arpack++/include/arbnsmat.h	/^void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::SubtractAsI(ARTYPE sigma)$/;"	f	class:ARbdNonSymMatrix
SubtractAsI	arpack++/include/arbsmat.h	/^void ARbdSymMatrix<ARTYPE>::SubtractAsI(ARTYPE sigma)$/;"	f	class:ARbdSymMatrix
SubtractAsI	arpack++/include/ardsmat.h	/^void ARdsSymMatrix<ARTYPE>::SubtractAsI(ARTYPE sigma)$/;"	f	class:ARdsSymMatrix
SubtractAsI	arpack++/include/arlnsmat.h	/^SubtractAsI(ARTYPE sigma, NCformat& A, NCformat& AsI)$/;"	f	class:ARluNonSymMatrix
SubtractAsI	arpack++/include/arunsmat.h	/^void ARumNonSymMatrix<ARTYPE, ARFLOAT>::SubtractAsI(ARTYPE sigma)$/;"	f	class:ARumNonSymMatrix
SubtractClusterCenters	IoData.h	/^  enum SubtractClusterCenters {SUBTRACT_CENTERS_FALSE = 0, SUBTRACT_CENTERS_TRUE = 1} subtractCenters;$/;"	g	struct:StateSnapshotsData
SubtractNearestSnapshotToCenter	IoData.h	/^  enum SubtractNearestSnapshotToCenter {SUBTRACT_NEAREST_FALSE = 0, SUBTRACT_NEAREST_TRUE = 1} subtractNearestSnapsToCenters;$/;"	g	struct:StateSnapshotsData
SubtractRefState	IoData.h	/^  enum SubtractRefState {SUBTRACT_REF_STATE_FALSE = 0, SUBTRACT_REF_STATE_TRUE = 1} subtractRefState;$/;"	g	struct:StateSnapshotsData
Subtract_From_Submatrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    void Subtract_From_Submatrix(const int istart,const int jstart,const MATRIX_BASE<T,T_MATRIX2>& a)$/;"	f	class:PhysBAM::MATRIX_BASE
Subtract_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Subtract_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Subtract_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Subtract_Times(const MATRIX_BASE<T,T_MATRIX1>& A,const VECTOR_EXPRESSION<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Subtract_Times_Vector_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static void Subtract_Times_Vector_Helper(const T_MATRIX1& A,const VECTOR_BASE<T,T_VECTOR>& v,VECTOR_BASE<T,T_VECTOR2>& y)$/;"	f	class:PhysBAM::MATRIX_BASE
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Sum() const$/;"	f	class:PhysBAM::ARRAY_BASE
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^    T Sum(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Sum() const$/;"	f	class:PhysBAM::ARRAY_BASE
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T Sum() const$/;"	f	class:PhysBAM::VECTOR
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T Sum() const$/;"	f	class:PhysBAM::VECTOR
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T Sum() const$/;"	f	class:PhysBAM::VECTOR
Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Sum() const$/;"	f	class:PhysBAM::VECTOR_BASE
Sum	Vector.h	/^  Sum(T1 aa, T2 bb, int l) : a(aa), b(bb) { len = l; }$/;"	f	class:Sum
Sum	Vector.h	/^class Sum {$/;"	c
Sum_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    TV Sum_Barycentric_Coordinates(const POINT_SIMPLEX_1D<T>& embedded_point_simplex) const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
Sum_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV Sum_Barycentric_Coordinates(const SEGMENT_2D<T>& embedded_segment) const$/;"	f	class:PhysBAM::SEGMENT_2D
Sum_Barycentric_Coordinates	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV Sum_Barycentric_Coordinates(const TRIANGLE_3D<T>& embedded_triangle) const$/;"	f	class:PhysBAM::TRIANGLE_3D
Sum_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    double Sum_Double_Precision() const$/;"	f	class:PhysBAM::ARRAY_BASE
Sum_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^    double Sum_Double_Precision(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Sum_Double_Precision	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    double Sum_Double_Precision() const$/;"	f	class:PhysBAM::VECTOR_BASE
Sumabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T Sumabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Sumabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^    T Sumabs(const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Sumabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T Sumabs() const$/;"	f	class:PhysBAM::ARRAY_BASE
Sup_Norm	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T Sup_Norm() const$/;"	f	class:PhysBAM::VECTOR_BASE
SuperLUStat_t	arpack++/include/arlutil.h	/^} SuperLUStat_t;$/;"	t	typeref:struct:__anon52
SuperMatrix	arpack++/include/arlsupm.h	/^} SuperMatrix;$/;"	t	typeref:struct:__anon45
SurfMeshGen	SurfMeshGen.C	/^SurfMeshGen<dim>::SurfMeshGen(Communicator *_com, IoData &_ioData, Domain &dom, DistGeoState *_geoState) : $/;"	f	class:SurfMeshGen
SurfMeshGen	SurfMeshGen.h	/^class SurfMeshGen : public GappyPreprocessing<dim> {$/;"	c
Surface	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.cpp	/^Surface(const TV& X) const$/;"	f	class:BOX
Surface	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    TV Surface(const TV& location) const$/;"	f	class:PhysBAM::PLANE
SurfaceData	IoData.h	/^struct SurfaceData  {$/;"	s
SurfaceData	IoDataCore.C	/^SurfaceData::SurfaceData()  {$/;"	f	class:SurfaceData
SurfaceData	Manual/Aerof3d.html	/^<a name="SurfaceData"><\/a>$/;"	a
Surface_Area	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    T Surface_Area() const$/;"	f	class:PhysBAM::RANGE
Surfaces	IoData.h	/^struct Surfaces  {$/;"	s
Surfaces	Manual/Aerof3d.html	/^<a name="Surfaces"><\/a>$/;"	a
SurrogateInterface	IoData.h	/^  enum SurrogateInterface{HYBRID = 0, EXTERNAL = 1} surrogateinterface;$/;"	g	struct:EmbeddedFramework
SutherlandViscoFcn	ViscoFcn.h	/^  SutherlandViscoFcn(IoData &iod) : ViscoFcn(iod)$/;"	f	class:SutherlandViscoFcn
SutherlandViscoFcn	ViscoFcn.h	/^class SutherlandViscoFcn : public ViscoFcn {$/;"	c
Swap_Endianity	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^inline void Swap_Endianity(T& x)$/;"	f	namespace:PhysBAM
Sym	Communicator.h	/^  enum Symmetry { Sym, NonSym };$/;"	e	enum:CommPattern::Symmetry
SymAxis	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	m	class:CorotSolver	typeref:enum:CorotSolver::SymmetryAxis
SymAxis	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	m	class:EmbeddedCorotSolver	typeref:enum:EmbeddedCorotSolver::SymmetryAxis
SymFullM	DenseMatrix.C	/^SymFullM<Scalar>::SymFullM()$/;"	f	class:SymFullM
SymFullM	DenseMatrix.C	/^SymFullM<Scalar>::SymFullM(const SymFullM &m)$/;"	f	class:SymFullM
SymFullM	DenseMatrix.C	/^SymFullM<Scalar>::SymFullM(int nr)$/;"	f	class:SymFullM
SymFullM	DenseMatrix.h	/^class SymFullM : public GenFullM<Scalar> {$/;"	c
Symmetric_Conjugate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T Symmetric_Conjugate(const VECTOR_BASE<T,T_VECTOR>& v) const$/;"	f	class:PhysBAM::MATRIX_BASE
Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Symmetric_Part() const$/;"	f	class:PhysBAM::MATRIX
Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Symmetric_Part() const$/;"	f	class:PhysBAM::MATRIX
Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Symmetric_Part() const$/;"	f	class:PhysBAM::MATRIX
Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    SYMMETRIC_MATRIX<T,2> Symmetric_Part() const$/;"	f	class:PhysBAM::MATRIX
Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Symmetric_Part() const \/\/ 3 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
Symmetry	Communicator.h	/^  enum Symmetry { Sym, NonSym };$/;"	g	class:CommPattern
Symmetry	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	g	struct:SchemeFixData
Symmetry	Manual/Aerof3d.html	/^<a name="Symmetry"><\/a>$/;"	a
SymmetryAxis	CorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	g	class:CorotSolver
SymmetryAxis	EmbeddedCorotSolver.h	/^  enum SymmetryAxis {NONE, AXIS_X, AXIS_Y, AXIS_Z} SymAxis;$/;"	g	class:EmbeddedCorotSolver
SymmetryData	IoData.h	/^struct SymmetryData {$/;"	s
SymmetryData	IoDataCore.C	/^SymmetryData::SymmetryData()$/;"	f	class:SymmetryData
Syntactic-rules	Manual/Aerof3d.html	/^<a name="Syntactic-rules"><\/a>$/;"	a
SysDoubleObj	parser/Assigner.h	/^class SysDoubleObj : public Assigner {$/;"	c
SysDoubleObj	parser/AssignerCore.C	/^SysDoubleObj::SysDoubleObj(const char *n, double *p)$/;"	f	class:SysDoubleObj
SysIntObj	parser/Assigner.h	/^class SysIntObj : public Assigner {$/;"	c
SysIntObj	parser/AssignerCore.C	/^SysIntObj::SysIntObj(const char *n, int *p)$/;"	f	class:SysIntObj
SysMapObj	parser/Assigner.C	/^SysMapObj<Target>::SysMapObj(const char *n, map<int, Target *> *_mapObj) : Assigner(n)  {$/;"	f	class:SysMapObj
SysMapObj	parser/Assigner.h	/^class SysMapObj : public Assigner  {$/;"	c
SysSmbMap	parser/Dictionary.h	/^  SysSmbMap(){}$/;"	f	class:SysSmbMap
SysSmbMap	parser/Dictionary.h	/^class SysSmbMap$/;"	c
SysStrObj	parser/Assigner.h	/^class SysStrObj : public Assigner {$/;"	c
SysStrObj	parser/AssignerCore.C	/^SysStrObj::SysStrObj(const char *n, const char **p)$/;"	f	class:SysStrObj
SysTokenObj	parser/Assigner.h	/^class SysTokenObj : public Assigner {$/;"	c
SysTokenObj	parser/AssignerCore.C	/^SysTokenObj::SysTokenObj(const char *n, int *p, int nt, ...) : tk(nt), val(nt),$/;"	f	class:SysTokenObj
SystemApproximation	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	g	struct:NonlinearRomOnlineData
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::BOX
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::ORIENTED_BOX
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::RAY
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::GEOMETRY_PARTICLES
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef typename T_BASE_OBJECT::VECTOR_T TV;typedef typename TV::SCALAR T;$/;"	t	struct:PhysBAM::FACTORY
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef typename T_BASE_OBJECT::VECTOR_T TV;typedef typename TV::SCALAR T;$/;"	t	struct:PhysBAM::FACTORY_BASE
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::BOX_HIERARCHY
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    typedef T_input T;$/;"	t	class:PhysBAM::TRIANGLE_HIERARCHY
T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::STRUCTURE
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    typedef typename T_ARRAY::ELEMENT T;$/;"	t	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    typedef typename T_ARRAY::ELEMENT T;$/;"	t	class:PhysBAM::ARRAY_NEGATION
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename T_ARRAY::ELEMENT T;typedef typename T_INDICES_NO_REFERENCE::INDEX ID;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef typename PROJECTED_ARRAY_ELEMENT<T_ARRAY,T_PROJECTOR>::TYPE T;$/;"	t	class:PhysBAM::PROJECTED_ARRAY
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::KD_TREE
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::RANGE
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::FRAME
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	/^    typedef T_input T;typedef T SCALAR;$/;"	t	class:PhysBAM::MATRIX
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    typedef typename T_MATRIX::SCALAR T;$/;"	t	class:PhysBAM::TRANSPOSE_MATRIX
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::POINT_CLOUD
T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    typedef typename TV::SCALAR T;$/;"	t	class:PhysBAM::TWIST
T1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
T1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
T1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_SUM
T1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename T_VECTOR1::SCALAR T1;typedef typename T_VECTOR2::SCALAR T2;$/;"	t	class:PhysBAM::VECTOR_DIFFERENCE
T1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename T_VECTOR1::SCALAR T1;typedef typename T_VECTOR2::SCALAR T2;$/;"	t	class:PhysBAM::VECTOR_SUM
T1_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef typename IF<HAS_CHEAP_COPY<T1>::value,const T1,const T1&>::TYPE T1_VIEW; \/\/ copy if cheap, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
T1_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef typename IF<HAS_CHEAP_COPY<T1>::value,const T1,const T1&>::TYPE T1_VIEW; \/\/ copy if cheap, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef typename T_ARRAY1::ELEMENT T1;typedef typename T_ARRAY2::ELEMENT T2;$/;"	t	class:PhysBAM::ARRAY_SUM
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename T_VECTOR1::SCALAR T1;typedef typename T_VECTOR2::SCALAR T2;$/;"	t	class:PhysBAM::VECTOR_DIFFERENCE
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename T_VECTOR1::SCALAR T1;typedef typename T_VECTOR2::SCALAR T2;$/;"	t	class:PhysBAM::VECTOR_SUM
T2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    typedef typename T_VECTOR::SCALAR T2;$/;"	t	class:PhysBAM::VECTOR_SCALE
TAB	Manual/Aerof3d.html	/^<a name="TAB"><\/a>$/;"	a
TABULATION2	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	e	enum:MultiFluidData::RiemannComputation
TABULATION5	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	e	enum:MultiFluidData::RiemannComputation
TAIL	arpack++/include/arlspdef.h	/^typedef enum {HEAD, TAIL}              stack_end_t;$/;"	e	enum:__anon33
TAIT	DistBcData.h	/^  enum BoundaryFluid { GAS=0, TAIT=1, JWL=2 } boundaryFluid;$/;"	e	enum:DistBcData::BoundaryFluid
TAIT	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	e	enum:VarFcnBase::Type
TAYLOR_H_	AutoDiff/Taylor.h	2;"	d
TBFixData	IoData.h	/^struct TBFixData {$/;"	s
TBFixData	IoDataCore.C	/^TBFixData::TBFixData()$/;"	f	class:TBFixData
TEMPERATURE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
TEMPERATURE	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	e	enum:PostFcn::ScalarType
TEMPERATUREAVG	PostFcn.h	/^  enum ScalarAvgType {DENSITYAVG = 0, MACHAVG = 1, PRESSUREAVG = 2, TEMPERATUREAVG = 3,$/;"	e	enum:PostFcn::ScalarAvgType
TEMPERATURE_NORMAL_DERIVATIVE	PostFcn.h	/^                   WTMACH = 22, WTSPEED = 23, VELOCITY_NORM = 24, TEMPERATURE_NORMAL_DERIVATIVE = 25, $/;"	e	enum:PostFcn::ScalarType
TEMP_TAG	StructExc.C	15;"	d	file:
TEST_APPROX_METRIC_FALSE	IoData.h	/^  enum TestApproxMetric {TEST_APPROX_METRIC_FALSE = 0, TEST_APPROX_METRIC_TRUE = 1} testApproxMetric;$/;"	e	enum:GappyConstructionData::TestApproxMetric
TEST_APPROX_METRIC_TRUE	IoData.h	/^  enum TestApproxMetric {TEST_APPROX_METRIC_FALSE = 0, TEST_APPROX_METRIC_TRUE = 1} testApproxMetric;$/;"	e	enum:GappyConstructionData::TestApproxMetric
TEST_PROBABILISTIC_SVD_FALSE	IoData.h	/^  enum TestProbabilisticSVD {TEST_PROBABILISTIC_SVD_FALSE = 0, TEST_PROBABILISTIC_SVD_TRUE = 1} testProbabilisticSVD;$/;"	e	enum:DataCompressionData::TestProbabilisticSVD
TEST_PROBABILISTIC_SVD_TRUE	IoData.h	/^  enum TestProbabilisticSVD {TEST_PROBABILISTIC_SVD_FALSE = 0, TEST_PROBABILISTIC_SVD_TRUE = 1} testProbabilisticSVD;$/;"	e	enum:DataCompressionData::TestProbabilisticSVD
TET	Elem.h	/^  enum Type {TET=5};$/;"	e	enum:Elem::Type
TET_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
THERMO	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	e	enum:ProblemData::Type
THESYS	tools/Makefile	/^THESYS     = `\/bin\/uname -s`$/;"	m
THREE_POINT_BDF	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	e	enum:ImplicitData::Type
TIGHT	DistLeastSquareSolver.h	/^  enum BufferResizePolicy { TIGHT, LOOSE };$/;"	e	enum:DistLeastSquareSolver::BufferResizePolicy
TIGHT_BOUNDS	IoData.h	/^  enum KmeansBoundType {TIGHT_BOUNDS = 0, LOOSE_BOUNDS = 1} kmeansBoundType;$/;"	e	enum:ClusteringData::KmeansBoundType
TIME	IoData.h	/^  enum Domain {TIME = 0, FREQUENCY = 1} domain;$/;"	e	enum:LinearizedData::Domain
TIME	IoData.h	/^  enum Tag {MACH = 0, TIME = 1, VELOCITY = 2} tag;$/;"	e	enum:RigidMeshMotionData::Tag
TIMER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^TIMER()$/;"	f	class:PhysBAM::TIMER
TIMER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^class TIMER:public NONCOPYABLE$/;"	c	namespace:PhysBAM
TIMESTEPPING	IoData.h	/^  enum SolutionMethod { TIMESTEPPING = 0, MULTIGRID = 1} solutionMethod;$/;"	e	enum:ProblemData::SolutionMethod
TIME_SIZE	Dunavant.C	3070;"	d	file:
TIME_SIZE	Dunavant.C	3085;"	d	file:
TIME_SIZE	Dunavant.C	3118;"	d	file:
TIME_SIZE	Dunavant.C	3133;"	d	file:
TORSIONAL_SPRINGS	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	e	enum:DefoMeshMotionData::Element
TOTALPRESSURE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
TOTALTEMPERATURE	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
TOTPRESSURE	PostFcn.h	/^  enum ScalarType {DENSITY = 0, MACH = 1, PRESSURE = 2, TEMPERATURE = 3, TOTPRESSURE = 4,$/;"	e	enum:PostFcn::ScalarType
TOTPRESSUREAVG	PostFcn.h	/^                      TOTPRESSUREAVG = 4, VORTICITYAVG = 5, CSDLESAVG = 6, CSDVMSAVG = 7, $/;"	e	enum:PostFcn::ScalarAvgType
TRANSFORMATION_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,2> TRANSFORMATION_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
TRANSFORMATION_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,3> TRANSFORMATION_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
TRANSFORMATION_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	/^    typedef PhysBAM::MATRIX<T,4> TRANSFORMATION_MATRIX;$/;"	t	struct:PhysBAM::MATRIX_POLICY
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<DIAGONAL_MATRIX<T,d> >{typedef DIAGONAL_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<SYMMETRIC_MATRIX<T,d> >{typedef SYMMETRIC_MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	s	namespace:PhysBAM
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct TRANSPOSE<MATRIX<T,m,n> >{typedef MATRIX<T,n,m> TYPE;};$/;"	s	namespace:PhysBAM
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct TRANSPOSE<MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	s	namespace:PhysBAM
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typedef typename MATRIX_INFO<T_MATRIX>::RIGHT_VECTOR RIGHT_VECTOR;typedef typename MATRIX_INFO<T_MATRIX>::TRANSPOSE TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<DIAGONAL_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef DIAGONAL_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct MATRIX_INFO<SYMMETRIC_MATRIX<T,d> >{typedef VECTOR<T,d> LEFT_VECTOR;typedef VECTOR<T,d> RIGHT_VECTOR;typedef SYMMETRIC_MATRIX<T,d> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct MATRIX_INFO<MATRIX<T,m,n> >{typedef VECTOR<T,m> LEFT_VECTOR;typedef VECTOR<T,n> RIGHT_VECTOR;typedef MATRIX<T,n,m> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
TRANSPOSE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T> struct MATRIX_INFO<MATRIX_MXN<T> >{typedef VECTOR_ND<T> LEFT_VECTOR;typedef VECTOR_ND<T> RIGHT_VECTOR;typedef MATRIX_MXN<T> TRANSPOSE;};$/;"	t	struct:PhysBAM::MATRIX_INFO
TRANSPOSE_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    TRANSPOSE_MATRIX()$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
TRANSPOSE_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    TRANSPOSE_MATRIX(INITIAL_SIZE mm,INITIAL_SIZE nn)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
TRANSPOSE_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    TRANSPOSE_MATRIX(const TRANSPOSE_MATRIX& M)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
TRANSPOSE_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    TRANSPOSE_MATRIX(const TRANSPOSE_MATRIX<T_MATRIX2>& M)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
TRANSPOSE_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^class TRANSPOSE_MATRIX:public MATRIX_BASE<typename T_MATRIX::SCALAR,typename TRANSPOSE<T_MATRIX>::TYPE>$/;"	c	namespace:PhysBAM
TRANSPOSE_PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T1,class T2> struct TRANSPOSE_PRODUCT{typedef typename PRODUCT<typename TRANSPOSE<T1>::TYPE,T2>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
TRI2D_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
TRIA	Face.h	/^  enum Type {TRIA=4};$/;"	e	enum:Face::Type
TRIANGLE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef TRIANGLE_2D<T> TRIANGLE;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
TRIANGLE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	/^    typedef TRIANGLE_3D<T> TRIANGLE;$/;"	t	struct:PhysBAM::BASIC_GEOMETRY_POLICY
TRIANGLE_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TRIANGLE_3D()$/;"	f	class:PhysBAM::TRIANGLE_3D
TRIANGLE_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TRIANGLE_3D(const TV& x1_input,const TV& x2_input,const TV& x3_input)$/;"	f	class:PhysBAM::TRIANGLE_3D
TRIANGLE_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TRIANGLE_3D(const T_ARRAY& X_input)$/;"	f	class:PhysBAM::TRIANGLE_3D
TRIANGLE_3D	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^class TRIANGLE_3D:public PLANE<T>$/;"	c	namespace:PhysBAM
TRIANGLE_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^TRIANGLE_HIERARCHY(TRIANGLE_MESH& triangle_mesh_input,GEOMETRY_PARTICLES<VECTOR<T,3> >& particles_input,ARRAY<TRIANGLE_3D<T> >& triangle_list_input,const bool update_boxes,const int triangles_per_group_input)$/;"	f	class:TRIANGLE_HIERARCHY
TRIANGLE_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^TRIANGLE_HIERARCHY(TRIANGLE_MESH& triangle_mesh_input,GEOMETRY_PARTICLES<VECTOR<T,3> >& particles_input,const bool update_boxes,const int triangles_per_group_input)$/;"	f	class:TRIANGLE_HIERARCHY
TRIANGLE_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^class TRIANGLE_HIERARCHY:public BOX_HIERARCHY<VECTOR<T_input,3> >$/;"	c	namespace:PhysBAM
TRIANGLE_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^TRIANGLE_MESH() \/\/ simplest constructor - null mesh$/;"	f	class:TRIANGLE_MESH
TRIANGLE_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^TRIANGLE_MESH(const TRIANGLE_MESH& triangle_mesh)$/;"	f	class:TRIANGLE_MESH
TRIANGLE_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^TRIANGLE_MESH(const int number_nodes_input,const ARRAY<VECTOR<int,3> >& triangle_list)$/;"	f	class:TRIANGLE_MESH
TRIANGLE_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^class TRIANGLE_MESH:public SIMPLEX_MESH<2>$/;"	c	namespace:PhysBAM
TRIANGULATED	IoData.h	/^                        TRIANGULATED = 4} levelSetMethod;$/;"	e	enum:MultiFluidData::LevelSetMethod
TRIPLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    TRIPLE(const T1& x_input,const T2& y_input,const T3& z_input) $/;"	f	class:PhysBAM::TRIPLE
TRIPLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    TRIPLE(int input=0) $/;"	f	class:PhysBAM::TRIPLE
TRIPLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^class TRIPLE$/;"	c	namespace:PhysBAM
TRI_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
TRL	arpack++/include/arlsupm.h	/^    TRL,       \/* lower triangular *\/$/;"	e	enum:__anon44
TRLU	arpack++/include/arlsupm.h	/^    TRLU,      \/* lower triangular, unit diagonal *\/$/;"	e	enum:__anon44
TRSV	arpack++/include/arlutil.h	/^    TRSV,    \/* fraction of FACT spent in xTRSV *\/$/;"	e	enum:__anon51
TRU	arpack++/include/arlsupm.h	/^    TRU,       \/* upper triangular *\/$/;"	e	enum:__anon44
TRUE	IoData.h	/^  enum ComputeForces {FALSE = 0, TRUE = 1 } computeForces;$/;"	e	enum:SurfaceData::ComputeForces
TRUE	IoData.h	/^  enum CopyCloseNodes {FALSE = 0, TRUE = 1} copyCloseNodes;$/;"	e	enum:MultiFluidData::CopyCloseNodes
TRUE	IoData.h	/^  enum InfRadius {FALSE = 0, TRUE = 1} infRadius;$/;"	e	enum:RotationData::InfRadius
TRUE	IoData.h	/^  enum PadeReconstruction {TRUE = 1, FALSE = 0} padeReconst;$/;"	e	enum:LinearizedData::PadeReconstruction
TRUE	arpack++/include/arlutil.h	51;"	d
TRUE_GS	IoData.h	/^  enum GramSchmidt {TRUE_GS = 1, FALSE_GS = 0} doGramSchmidt;$/;"	e	enum:LinearizedData::GramSchmidt
TRUE_HF	IoData.h	/^  enum ComputeHeatPower {FALSE_HF = 0, TRUE_HF = 1 } computeHeatFluxes;$/;"	e	enum:SurfaceData::ComputeHeatPower
TRUE_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct TRUE_TYPE {static const bool value=true;};$/;"	s	namespace:PhysBAM
TRUU	arpack++/include/arlsupm.h	/^    TRUU,      \/* upper triangular, unit diagonal *\/$/;"	e	enum:__anon44
TS_INPUT_H	TsInput.h	2;"	d
TV	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::PhysBAMInterface
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    typedef VECTOR<T,2> TV;$/;"	t	class:PhysBAM::LINE_2D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::PLANE
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	/^    typedef VECTOR<T,2> TV;$/;"	t	class:PhysBAM::POINT_2D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    typedef VECTOR<T,1> TV;$/;"	t	class:PhysBAM::POINT_SIMPLEX_1D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    typedef VECTOR<T,2> TV;$/;"	t	class:PhysBAM::SEGMENT_2D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::SEGMENT_3D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::TRIANGLE_3D
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^    typedef typename T_IMPLICIT_OBJECT::VECTOR_T TV;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^    typedef typename T_IMPLICIT_OBJECT::VECTOR_T TV;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef typename T_BASE_OBJECT::VECTOR_T TV;typedef typename TV::SCALAR T;$/;"	t	struct:PhysBAM::FACTORY
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    typedef typename T_BASE_OBJECT::VECTOR_T TV;typedef typename TV::SCALAR T;$/;"	t	struct:PhysBAM::FACTORY_BASE
TV	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::TRIANGLE_HIERARCHY
TV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::QUATERNION
TV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,1> TV;$/;"	t	class:PhysBAM::ROTATION
TV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,2> TV;$/;"	t	class:PhysBAM::ROTATION
TV	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,3> TV;$/;"	t	class:PhysBAM::ROTATION
TV_INT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    typedef typename TV::template REBIND<int>::TYPE TV_INT;$/;"	t	class:PhysBAM::RAY
TV_INT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    typedef VECTOR<int,d> TV_INT;$/;"	t	class:PhysBAM::ARRAY_BASE
TWIST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST()$/;"	f	class:PhysBAM::TWIST
TWIST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST(const TV& linear_input,const T_SPIN& angular_input)$/;"	f	class:PhysBAM::TWIST
TWIST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    template<class T2> explicit TWIST(const TWIST<VECTOR<T2,TV::m> >& twist_input)$/;"	f	class:PhysBAM::TWIST
TWIST	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^class TWIST$/;"	c	namespace:PhysBAM
TWOTOONE	IoData.h	/^  enum CoarseningRatio { TWOTOONE = 0, FOURTOONE = 1} coarseningRatio;$/;"	e	enum:MultiGridData::CoarseningRatio
TWO_EQUATION_KE	IoData.h	/^  enum Type {ONE_EQUATION_SPALART_ALLMARAS = 0, ONE_EQUATION_DES = 1, TWO_EQUATION_KE = 2} type;$/;"	e	enum:TurbulenceModelData::Type
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    template<class T2> struct REBIND{typedef BOX<T2> TYPE;};$/;"	t	struct:PhysBAM::BOX::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    template<class T2> struct REBIND{typedef ARRAY<T2,ID> TYPE;};$/;"	t	struct:PhysBAM::ARRAY::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T,class T_NEW,class T_ARRAY,class ID> struct REBIND<ARRAY_BASE<T,T_ARRAY,ID>,T_NEW>{typedef ARRAY_BASE<T_NEW,typename T_ARRAY::template REBIND<T_NEW>::TYPE,ID> TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T,class T_NEW> struct REBIND<ARRAY<T>,T_NEW>{typedef ARRAY<T_NEW> TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T_ARRAY> struct ARRAY_RESULT_TYPE<const T_ARRAY>{typedef typename T_ARRAY::CONST_RESULT_TYPE TYPE;};$/;"	t	struct:PhysBAM::ARRAY_RESULT_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	/^template<class T_ARRAY> struct ARRAY_RESULT_TYPE{typedef typename T_ARRAY::RESULT_TYPE TYPE;};$/;"	t	struct:PhysBAM::ARRAY_RESULT_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class S> struct ELEMENT_OF{typedef typename S::ELEMENT TYPE;};$/;"	t	struct:PhysBAM::ARRAY_BASE::ELEMENT_OF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T2> struct REBIND{typedef ARRAY_BASE<T2,typename T_ARRAY::template REBIND<T2>::TYPE,ID> TYPE;};$/;"	t	struct:PhysBAM::ARRAY_BASE::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^{typedef ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^{typedef ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^{typedef ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^{typedef ARRAY_NEGATION<T_ARRAY> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^{typedef ARRAY_PLUS_SCALAR<T1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^{typedef ARRAY_PLUS_SCALAR<T1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^{typedef ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^{typedef ARRAY_SUM<T_ARRAY1,T_ARRAY2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID,class T_NEW> struct REBIND<ARRAY_VIEW<T,ID>,T_NEW>{typedef ARRAY_VIEW<typename IF<IS_CONST<T>::value,const T_NEW,T_NEW>::TYPE,ID> TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typedef typename REMOVE_CONST<typename REMOVE_REFERENCE<typename T_PROJECTOR::template RESULT<typename T_ARRAY::ELEMENT>::TYPE>::TYPE>::TYPE TYPE;$/;"	t	struct:PhysBAM::PROJECTED_ARRAY_ELEMENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    template<class S> struct ELEMENT_OF{typedef typename S::ELEMENT TYPE;};$/;"	t	struct:PhysBAM::ARRAY_BASE::ELEMENT_OF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    template<class T2> struct REBIND{typedef ARRAY_BASE<T2,ARRAYS_ND_BASE,TV_INT> TYPE;};$/;"	t	struct:PhysBAM::ARRAY_BASE::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY<T,FACE_INDEX<d> >,T_NEW>{typedef ARRAY<T_NEW,FACE_INDEX<d> > TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY<T,VECTOR<int,d> >,T_NEW>{typedef ARRAY<T_NEW,VECTOR<int,d> > TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,class T_NEW,int d> struct REBIND<ARRAY_BASE<T,ARRAYS_ND_BASE,VECTOR<int,d> >,T_NEW>{typedef ARRAY_BASE<T_NEW,ARRAYS_ND_BASE,VECTOR<int,d> > TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	/^template<class T,int m,int d,int length_new> struct REBIND_LENGTH<ARRAY<VECTOR<T,d>,VECTOR<int,m> >,length_new>{typedef ARRAY<VECTOR<T,length_new>,VECTOR<int,m> > TYPE;};$/;"	t	struct:PhysBAM::REBIND_LENGTH
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    template<class T2> struct REBIND{typedef INTERVAL<T2> TYPE;};$/;"	t	struct:PhysBAM::INTERVAL::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    template<class T2> struct REBIND{typedef RANGE<T2> TYPE;};$/;"	t	struct:PhysBAM::RANGE::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef DIAGONAL_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<DIAGONAL_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,DIAGONAL_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<MATRIX_MXN<T>,VECTOR<T,d> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<SYMMETRIC_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,DIAGONAL_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,SYMMETRIC_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,UPPER_TRIANGULAR_MATRIX<T,d> >{typedef UPPER_TRIANGULAR_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,VECTOR<T,d> >{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,d>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<DIAGONAL_MATRIX<T,d> >{typedef DIAGONAL_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<SYMMETRIC_MATRIX<T,d> >{typedef SYMMETRIC_MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int d> struct TRANSPOSE<UPPER_TRIANGULAR_MATRIX<T,d> >{typedef MATRIX<T,d> TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n,int k> struct PRODUCT<MATRIX<T,m,k>,MATRIX<T,k,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<DIAGONAL_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,DIAGONAL_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,SYMMETRIC_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,UPPER_TRIANGULAR_MATRIX<T,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,VECTOR<T,n> >{typedef VECTOR<T,m> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX<T,m,n>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<MATRIX_MXN<T>,MATRIX<T,m,n> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<SYMMETRIC_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct PRODUCT<UPPER_TRIANGULAR_MATRIX<T,m>,MATRIX<T,m,n> >{typedef MATRIX<T,m,n> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T,int m,int n> struct TRANSPOSE<MATRIX<T,m,n> >{typedef MATRIX<T,n,m> TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T1,class T2> struct PRODUCT_TRANSPOSE{typedef typename PRODUCT<T1,typename TRANSPOSE<T2>::TYPE>::TYPE TYPE;};$/;"	t	struct:PhysBAM::PRODUCT_TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T1,class T2> struct TRANSPOSE_PRODUCT{typedef typename PRODUCT<typename TRANSPOSE<T1>::TYPE,T2>::TYPE TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE_PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct PRODUCT<MATRIX_MXN<T>,MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct PRODUCT<MATRIX_MXN<T>,VECTOR_ND<T> >{typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class T> struct TRANSPOSE<MATRIX_MXN<T> >{typedef MATRIX_MXN<T> TYPE;};$/;"	t	struct:PhysBAM::TRANSPOSE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	/^template<class TV> struct PRODUCT<FRAME<TV>,TV>{typedef TV TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T const volatile[N]>{typedef T TYPE[N];};$/;"	t	struct:PhysBAM::REMOVE_CV
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T const[N]>{typedef T TYPE[N];};$/;"	t	struct:PhysBAM::REMOVE_CV
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,std::size_t N> struct REMOVE_CV<T volatile[N]>{typedef T TYPE[N];};$/;"	t	struct:PhysBAM::REMOVE_CV
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV<T&>{typedef T& TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<T*>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV_POINTER
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<const T*>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV_POINTER
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<const volatile T*>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV_POINTER
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV_POINTER<volatile T*>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV_POINTER
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct REMOVE_CV{typedef typename REMOVE_CV_POINTER<T*>::TYPE TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CV
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b,class T1,class T2> struct IF{typedef T1 TYPE;};$/;"	t	struct:PhysBAM::IF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2=void,class T3=void,class T4=void> struct FIRST{typedef T1 TYPE;};$/;"	t	struct:PhysBAM::FIRST
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IF<false,T1,T2>{typedef T2 TYPE;};$/;"	t	struct:PhysBAM::IF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_CONST<const T>{typedef T TYPE;};$/;"	t	struct:PhysBAM::ADD_CONST
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_CONST{typedef const T TYPE;};$/;"	t	struct:PhysBAM::ADD_CONST
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_REFERENCE<T&>{typedef T& TYPE;};$/;"	t	struct:PhysBAM::ADD_REFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ADD_REFERENCE{typedef T& TYPE;};$/;"	t	struct:PhysBAM::ADD_REFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct DISABLE_IF<false,T>{typedef T TYPE;};$/;"	t	struct:PhysBAM::DISABLE_IF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct ENABLE_IF<true,T>{typedef T TYPE;};$/;"	t	struct:PhysBAM::ENABLE_IF
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_CONST<const T>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CONST
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_CONST{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_CONST
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_POINTER<T*>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_POINTER
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_REFERENCE<T&>{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_REFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_REFERENCE{typedef T TYPE;};$/;"	t	struct:PhysBAM::REMOVE_REFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,float>{typedef double TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<double,int>{typedef double TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<float,int>{typedef float TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct DIFFERENCE<int,int>{typedef int TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct NEGATION<int>{typedef int TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,float>{typedef double TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<double,int>{typedef double TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<float,int>{typedef float TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct PRODUCT<int,int>{typedef int TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,float>{typedef double TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<double,int>{typedef double TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<float,int>{typedef float TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct QUOTIENT<int,int>{typedef int TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,float>{typedef double TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<double,int>{typedef double TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<float,int>{typedef float TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,double>{typedef double TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,float>{typedef float TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct SUM<int,int>{typedef int TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T,class ENABLER=void> struct SCALAR_POLICY{typedef struct UNUSABLE{} TYPE;};$/;"	t	struct:PhysBAM::SCALAR_POLICY	typeref:struct:PhysBAM::SCALAR_POLICY::UNUSABLE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct SCALAR_POLICY<T,typename ENABLE_IF<IS_SCALAR<T>::value>::TYPE>{typedef T TYPE;};$/;"	t	struct:PhysBAM::SCALAR_POLICY
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct SCALAR_POLICY<T,typename IF<true,void,typename T::SCALAR>::TYPE> {typedef typename T::SCALAR TYPE;};$/;"	t	struct:PhysBAM::SCALAR_POLICY
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct DIFFERENCE<TWIST<TV>,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct NEGATION<TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct PRODUCT<TWIST<TV>,typename TV::SCALAR> {typedef TWIST<TV> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct PRODUCT<typename TV::SCALAR,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct SUM<TWIST<TV>,TWIST<TV> > {typedef TWIST<TV> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,d> TYPE;};$/;"	t	struct:PhysBAM::VECTOR::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct DIFFERENCE<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct DIFFERENCE<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct DIFFERENCE<VECTOR<T,d>,T,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct DIFFERENCE<VECTOR<T,d>,T,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct PRODUCT<VECTOR<T,d>,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct PRODUCT<VECTOR<T,d>,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct QUOTIENT<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct QUOTIENT<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct QUOTIENT<VECTOR<T,d>,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct QUOTIENT<VECTOR<T,d>,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct SUM<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct SUM<T,VECTOR<T,d>,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::SUM::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct SUM<VECTOR<T,d>,T,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	s	class:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^template<class T,int d> struct SUM<VECTOR<T,d>,T,typename ENABLE_IF<(d>3)>::TYPE>{typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::SUM::TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,0> TYPE;};$/;"	t	struct:PhysBAM::VECTOR::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct NEGATION<VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct PRODUCT<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct QUOTIENT<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<T,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<VECTOR<T,0>,T>{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^template<class T> struct SUM<VECTOR<T,0>,VECTOR<T,0> >{typedef VECTOR<T,0> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,1> TYPE;};$/;"	t	struct:PhysBAM::VECTOR::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct NEGATION<VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct PRODUCT<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct QUOTIENT<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<T,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<VECTOR<T,1>,T>{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^template<class T> struct SUM<VECTOR<T,1>,VECTOR<T,1> >{typedef VECTOR<T,1> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,2> TYPE;};$/;"	t	struct:PhysBAM::VECTOR::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct NEGATION<VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct PRODUCT<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct QUOTIENT<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<T,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<VECTOR<T,2>,T>{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^template<class T> struct SUM<VECTOR<T,2>,VECTOR<T,2> >{typedef VECTOR<T,2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<class T2> struct REBIND{typedef VECTOR<T2,3> TYPE;};$/;"	t	struct:PhysBAM::VECTOR::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct DIFFERENCE<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct NEGATION<VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct PRODUCT<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct QUOTIENT<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<T,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<VECTOR<T,3>,T>{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> struct SUM<VECTOR<T,3>,VECTOR<T,3> >{typedef VECTOR<T,3> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> struct VECTOR_TYPE<VECTOR_EXPRESSION<T,T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,int d> struct VECTOR_TYPE<VECTOR<T,d> > {typedef VECTOR<T,d> TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T2,class T_VECTOR> struct VECTOR_TYPE<VECTOR_SCALE<T2,T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct VECTOR_TYPE<VECTOR_ND<T> > {typedef VECTOR_ND<T> TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR,class T_VECTOR2> struct VECTOR_TYPE<VECTOR_DIFFERENCE<T_VECTOR,T_VECTOR2> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR,class T_VECTOR2> struct VECTOR_TYPE<VECTOR_SUM<T_VECTOR,T_VECTOR2> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR> struct VECTOR_TYPE<VECTOR_NEGATION<T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	t	struct:PhysBAM::VECTOR_TYPE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^{typedef VECTOR_DIFFERENCE<T_VECTOR1,T_VECTOR2> TYPE;};$/;"	t	struct:PhysBAM::DIFFERENCE
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^{typedef VECTOR_NEGATION<T_VECTOR> TYPE;};$/;"	t	struct:PhysBAM::NEGATION
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^{typedef VECTOR_SCALE<T1,T_VECTOR2> TYPE;};$/;"	t	struct:PhysBAM::PRODUCT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^{typedef VECTOR_SCALE<T1,T_VECTOR2> TYPE;};$/;"	t	struct:PhysBAM::QUOTIENT
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^{typedef VECTOR_SUM<T_VECTOR1,T_VECTOR2> TYPE;};$/;"	t	struct:PhysBAM::SUM
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d,class T_NEW> struct REBIND<VECTOR<T,d>,T_NEW>{typedef VECTOR<T_NEW,d> TYPE;};$/;"	t	struct:PhysBAM::REBIND
TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    template<class T2> struct REBIND{typedef VECTOR_ND<T2> TYPE;};$/;"	t	struct:PhysBAM::VECTOR_ND::REBIND
TYPED_ISTREAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    TYPED_ISTREAM(std::istream& stream_input,const STREAM_TYPE type_input)$/;"	f	class:PhysBAM::TYPED_ISTREAM
TYPED_ISTREAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^class TYPED_ISTREAM$/;"	c	namespace:PhysBAM
TYPED_OSTREAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    TYPED_OSTREAM(std::ostream& stream_input,const STREAM_TYPE type_input)$/;"	f	class:PhysBAM::TYPED_OSTREAM
TYPED_OSTREAM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^class TYPED_OSTREAM$/;"	c	namespace:PhysBAM
T_ARRAY1_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY1>::value,const T_ARRAY1,const T_ARRAY1&>::TYPE T_ARRAY1_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
T_ARRAY1_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY1>::value,const T_ARRAY1,const T_ARRAY1&>::TYPE T_ARRAY1_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_PRODUCT
T_ARRAY1_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY1>::value,const T_ARRAY1,const T_ARRAY1&>::TYPE T_ARRAY1_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_SUM
T_ARRAY2_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY2>::value,const T_ARRAY2,const T_ARRAY2&>::TYPE T_ARRAY2_VIEW;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
T_ARRAY2_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY2>::value,const T_ARRAY2,const T_ARRAY2&>::TYPE T_ARRAY2_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
T_ARRAY2_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY2>::value,const T_ARRAY2,const T_ARRAY2&>::TYPE T_ARRAY2_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
T_ARRAY2_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY2>::value,const T_ARRAY2,const T_ARRAY2&>::TYPE T_ARRAY2_VIEW;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
T_ARRAY2_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY2>::value,const T_ARRAY2,const T_ARRAY2&>::TYPE T_ARRAY2_VIEW;$/;"	t	class:PhysBAM::ARRAY_SUM
T_ARRAY_COLLECTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    typedef ARRAY_COLLECTION<int> T_ARRAY_COLLECTION;$/;"	t	class:PhysBAM::POINT_CLOUD
T_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY>::value,const T_ARRAY,const T_ARRAY&>::TYPE T_ARRAY_VIEW; \/\/ if it's an array view we can copy it, otherwise store a reference$/;"	t	class:PhysBAM::ARRAY_NEGATION
T_ARRAY_VIEW	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename IF<IS_ARRAY_VIEW<T_ARRAY>::value,T_ARRAY,T_ARRAY&>::TYPE T_ARRAY_VIEW;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
T_BOUNDARY_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    typedef MESH_POLICY<BASE::dimension-1>::MESH T_BOUNDARY_MESH; \/\/ encourage this to eventually be "lifted" to SIMPLEX_MESH$/;"	t	class:PhysBAM::TRIANGLE_MESH
T_CURVATURES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    typedef VECTOR<T,d-1> T_CURVATURES;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT
T_DIAGONAL_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    typedef typename MATRIX_POLICY<TV>::DIAGONAL_MATRIX T_DIAGONAL_MATRIX;$/;"	t	class:PhysBAM::ORIENTED_BOX
T_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    typedef typename DIFFERENCE<T1,T2>::TYPE T_DIFFERENCE;$/;"	t	class:PhysBAM::ARRAY_DIFFERENCE
T_HASHTABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    typedef typename IF<OR<IS_SAME<T,void>::value,IS_CONST<T>::value>::value,const HASHTABLE<TK,typename REMOVE_CONST<T>::TYPE>,HASHTABLE<TK,T> >::TYPE T_HASHTABLE;$/;"	t	class:PhysBAM::HASHTABLE_ITERATOR
T_HYPERPLANE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    typedef typename BASIC_GEOMETRY_POLICY<TV>::HYPERPLANE T_HYPERPLANE;$/;"	t	class:PhysBAM::BOX_HIERARCHY
T_IF_CLASS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef typename IF<IS_CLASS<T>::value,T,UNUSABLE>::TYPE T_IF_CLASS;$/;"	t	class:PhysBAM::ARRAY_BASE
T_INDICES_NO_REFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    typedef typename REMOVE_REFERENCE<T_INDICES>::TYPE T_INDICES_NO_REFERENCE;$/;"	t	class:PhysBAM::INDIRECT_ARRAY
T_PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    typedef typename PRODUCT<T1,T2>::TYPE T_PRODUCT;$/;"	t	class:PhysBAM::ARRAY_LEFT_MULTIPLE
T_PRODUCT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    typedef typename PRODUCT<T1,T2>::TYPE T_PRODUCT;$/;"	t	class:PhysBAM::ARRAY_PRODUCT
T_RANK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    typedef unsigned char T_RANK;$/;"	t	class:PhysBAM::UNION_FIND
T_SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,0> T_SPIN;$/;"	t	class:PhysBAM::ROTATION
T_SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,1> T_SPIN;$/;"	t	class:PhysBAM::ROTATION
T_SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    typedef VECTOR<T,3> T_SPIN;$/;"	t	class:PhysBAM::ROTATION
T_SPIN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    typedef typename TV::SPIN T_SPIN;$/;"	t	class:PhysBAM::TWIST
T_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    typedef typename SUM<T1,T2>::TYPE T_SUM;$/;"	t	class:PhysBAM::ARRAY_PLUS_SCALAR
T_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    typedef typename SUM<T1,T2>::TYPE T_SUM;$/;"	t	class:PhysBAM::ARRAY_SUM
T_SYMMETRIC_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    typedef typename MATRIX_POLICY<TV>::SYMMETRIC_MATRIX T_SYMMETRIC_MATRIX;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT
T_UNLESS_VOID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef typename IF<IS_SAME<T,void>::value,UNUSABLE,T>::TYPE T_UNLESS_VOID;$/;"	t	class:PhysBAM::HASHTABLE
T_UNLESS_VOID	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    typedef typename IF<IS_SAME<T,void>::value,UNUSABLE,T>::TYPE T_UNLESS_VOID;$/;"	t	class:PhysBAM::HASHTABLE_ITERATOR
Tag	IoData.h	/^  enum Tag {MACH = 0, TIME = 1, VELOCITY = 2} tag;$/;"	g	struct:RigidMeshMotionData
Tag	LevelSet.h	/^  DistVec<int> Tag;			\/\/ node tags for reinitialization in a narrow band$/;"	m	class:LevelSet
TagInterfaceNodes	Domain.C	/^void Domain::TagInterfaceNodes(int lsdim, DistSVec<bool,2> &Tag, DistSVec<double,dimLS> &Phi,$/;"	f	class:Domain
TagInterfaceNodes	Domain.C	/^void Domain::TagInterfaceNodes(int lsdim, DistVec<int> &Tag, DistSVec<double,dimLS> &Phi,$/;"	f	class:Domain
TagInterfaceNodes	Edge.C	/^void EdgeSet::TagInterfaceNodes(int lsdim, Vec<int> &Tag, SVec<double,dimLS> &Phi, LevelSetStructure *LSS)$/;"	f	class:EdgeSet
TagInterfaceNodes	SubDomain.C	/^void SubDomain::TagInterfaceNodes(int lsdim, SVec<bool,2> &Tag, SVec<double,dimLS> &Phi, LevelSetStructure *LSS)$/;"	f	class:SubDomain
TagInterfaceNodes	SubDomain.C	/^void SubDomain::TagInterfaceNodes(int lsdim, Vec<int> &Tag, SVec<double,dimLS> &Phi, int level,LevelSetStructure *LSS)$/;"	f	class:SubDomain
TagPsiExchangeData	SubDomain.C	/^void SubDomain::TagPsiExchangeData(CommPattern<Scalar1> &splevel, Scalar1 (*level)[dim1],$/;"	f	class:SubDomain
Take	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int Take(ARRAY_COLLECTION& source,int from)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Take	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Take(ARRAY_COLLECTION& source)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
TakeStep	arpack++/include/arrseig.h	/^int ARrcStdEig<ARFLOAT, ARTYPE>::TakeStep()$/;"	f	class:ARrcStdEig
TavF	TsOutput.h	/^  Vec3D *TavF, *TavM; $/;"	m	class:TsOutput
TavL	TsOutput.h	/^  Vec3D *TavL;$/;"	m	class:TsOutput
TavM	TsOutput.h	/^  Vec3D *TavF, *TavM; $/;"	m	class:TsOutput
Taylor2	AutoDiff/Taylor.h	/^    Taylor2() {};$/;"	f	class:Taylor2
Taylor2	AutoDiff/Taylor.h	/^    Taylor2(Scalar v, int idx) { $/;"	f	class:Taylor2
Taylor2	AutoDiff/Taylor.h	/^class Taylor2 {$/;"	c
Temp	DistBcData.h	/^  DistVec<double> Temp;$/;"	m	class:DistBcData
Temporary_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.cpp	/^FILE* Temporary_File()$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Test	IoData.h	/^  enum Test {REGULAR = 0} test;$/;"	g	struct:ProblemData
TestApproxMetric	IoData.h	/^  enum TestApproxMetric {TEST_APPROX_METRIC_FALSE = 0, TEST_APPROX_METRIC_TRUE = 1} testApproxMetric;$/;"	g	struct:GappyConstructionData
TestProbabilisticSVD	IoData.h	/^  enum TestProbabilisticSVD {TEST_PROBABILISTIC_SVD_FALSE = 0, TEST_PROBABILISTIC_SVD_TRUE = 1} testProbabilisticSVD;$/;"	g	struct:DataCompressionData
Test_Aliased	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static bool Test_Aliased(const T_MATRIX1& A,const T_MATRIX1& B)$/;"	f	class:PhysBAM::MATRIX_BASE
Test_Aliased	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static bool Test_Aliased(const T_MATRIX1& A,const T_MATRIX2& B)$/;"	f	class:PhysBAM::MATRIX_BASE
TetMeshMotionSolver	MeshMotionSolver.C	/^TetMeshMotionSolver::TetMeshMotionSolver$/;"	f	class:TetMeshMotionSolver
TetMeshMotionSolver	MeshMotionSolver.h	/^  TetMeshMotionSolver(Domain *dom) : domain(dom) {};$/;"	f	class:TetMeshMotionSolver
TetMeshMotionSolver	MeshMotionSolver.h	/^class TetMeshMotionSolver : public MeshMotionSolver {$/;"	c
ThermalCondFcn	ThermalCondFcn.h	/^  ThermalCondFcn() {}$/;"	f	class:ThermalCondFcn
ThermalCondFcn	ThermalCondFcn.h	/^class ThermalCondFcn {$/;"	c
ThermalCondModelData	IoData.h	/^struct ThermalCondModelData {$/;"	s
ThermalCondModelData	IoDataCore.C	/^ThermalCondModelData::ThermalCondModelData()$/;"	f	class:ThermalCondModelData
ThermalConductivityModel	Manual/Aerof3d.html	/^<a name="ThermalConductivityModel"><\/a>$/;"	a
Theta	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static T Theta(const T phi_left,const T phi_right)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
Theta_Cubic	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.cpp	/^Theta_Cubic(const T phi_left_left,const T phi_left,const T phi_right,const T phi_right_right,const T dx)$/;"	f	class:LEVELSET_UTILITIES
Theta_Quadratic	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.cpp	/^Theta_Quadratic(const T phi_left_left,const T phi_left,const T phi_right,const T dx)$/;"	f	class:LEVELSET_UTILITIES
Thicken_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Thicken_Leaf_Boxes(const T extra_thickness)$/;"	f	class:BOX_HIERARCHY
Thickened	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    ORIENTED_BOX Thickened(const T thickness) const$/;"	f	class:PhysBAM::ORIENTED_BOX
Thickened	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL Thickened(const T thickness_over_two) const$/;"	f	class:PhysBAM::INTERVAL
Thickened	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> Thickened(const T thickness_over_two) const$/;"	f	class:PhysBAM::RANGE
Thickened_Oriented_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.cpp	/^Thickened_Oriented_Box(const T thickness_over_two) const $/;"	f	class:SEGMENT_2D
Thin_Shells_Interface	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    static int Thin_Shells_Interface(const T phi_1,const T phi_2)$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
ThrowError	arpack++/include/arbnsmat.h	/^inline void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::ThrowError()$/;"	f	class:ARbdNonSymMatrix
ThrowError	arpack++/include/arbsmat.h	/^inline void ARbdSymMatrix<ARTYPE>::ThrowError()$/;"	f	class:ARbdSymMatrix
ThrowError	arpack++/include/ardnsmat.h	/^inline void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::ThrowError()$/;"	f	class:ARdsNonSymMatrix
ThrowError	arpack++/include/ardsmat.h	/^inline void ARdsSymMatrix<ARTYPE>::ThrowError()$/;"	f	class:ARdsSymMatrix
ThrowError	arpack++/include/arunsmat.h	/^inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::ThrowError()$/;"	f	class:ARumNonSymMatrix
ThrowError	arpack++/include/arusmat.h	/^inline void ARumSymMatrix<ARTYPE>::ThrowError()$/;"	f	class:ARumSymMatrix
Time	Manual/Aerof3d.html	/^<a name="Time"><\/a>$/;"	a
Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^inline void Time(const std::string& format)$/;"	f	namespace:PhysBAM::LOG_REAL
Time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^template<class T> inline void Time(const T&){}$/;"	f	namespace:PhysBAM::LOG_NULL
TimeData	TimeData.C	/^TimeData::TimeData(IoData &ioData)$/;"	f	class:TimeData
TimeData	TimeData.h	/^class TimeData {$/;"	c
TimeFDCoefs	TimeState.h	/^  struct TimeFDCoefs {$/;"	s	class:TimeState
TimeIntegrator	MeshMotionHandler.h	/^  enum TimeIntegrator {IMPLICIT_FIRST_ORDER, IMPLICIT_SECOND_ORDER} timeIntegrator;$/;"	g	class:AeroMeshMotionHandler
TimeLowMachPrec	LowMachPrec.h	/^  TimeLowMachPrec() : LowMachPrec() {};$/;"	f	class:TimeLowMachPrec
TimeLowMachPrec	LowMachPrec.h	/^  TimeLowMachPrec(IoData &iod) : LowMachPrec(iod) {if (prec==2) setupIodConstants(iod); };$/;"	f	class:TimeLowMachPrec
TimeLowMachPrec	LowMachPrec.h	/^class TimeLowMachPrec : public LowMachPrec {$/;"	c
TimeState	TimeState.C	/^TimeState<dim>::TimeState(TimeData &_data, Vec<double> &_dt, Vec<double> &_idti, $/;"	f	class:TimeState
TimeState	TimeState.h	/^class TimeState {$/;"	c
TimeStepCalculation	IoData.h	/^  enum TimeStepCalculation {CFL = 0, ERRORESTIMATION = 1} timeStepCalculation;$/;"	g	struct:TsData
TimeVelocity	Manual/Aerof3d.html	/^<a name="TimeVelocity"><\/a>$/;"	a
Time_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^Time_Helper(const std::string& label)$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
Timer	Timer.C	/^Timer::Timer(Communicator *communicator) : com(communicator)$/;"	f	class:Timer
Timer	Timer.h	/^class Timer {$/;"	c
TimerIndex	Timer.h	/^  enum TimerIndex {$/;"	g	class:Timer
Times_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Times_Cross_Product_Matrix(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,2> Times_Cross_Product_Matrix(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX<T,1,2> Times_Cross_Product_Matrix(VECTOR<T,2> v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Times_Cross_Product_Matrix(const VECTOR<T,3>& v) const \/\/ (*this) * (v*)$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX<T,3> Times_Cross_Product_Matrix(const VECTOR<T,3>& v) const \/\/ (*this) * (v*)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Times_Cross_Product_Matrix_Transpose(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,1> Times_Cross_Product_Matrix_Transpose(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX<T,1> Times_Cross_Product_Matrix_Transpose(VECTOR<T,2> v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Times_Cross_Product_Matrix_Transpose(const VECTOR<T,3>& v) const \/\/ (*this) * (v*)^T$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Times_Cross_Product_Matrix_Transpose(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX_MXN
Times_Cross_Product_Matrix_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Times_Cross_Product_Matrix_Transpose(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX_MXN
Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,1> Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX<T,1> Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result(VECTOR<T,2> v) const$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Times_Cross_Product_Matrix_Transpose_With_Symmetric_Result(const VECTOR<T,3>& v) const \/\/ (*this) * (v*)^T$/;"	f	class:PhysBAM::MATRIX
Times_Cross_Product_Matrix_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Times_Cross_Product_Matrix_With_Symmetric_Result(const VECTOR<T,3>& v) const \/\/ (*this) * (v*)$/;"	f	class:PhysBAM::MATRIX
Times_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Times_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const ARRAY_BASE<T2,T_ARRAY_T2,ID>& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Times_Equals	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	/^    Times_Equals(ARRAY_BASE<T,T_ARRAY,ID>& a,const typename T_ARRAY::SCALAR& b)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Times_Transpose(const DIAGONAL_MATRIX& M) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    typename PRODUCT_TRANSPOSE<DIAGONAL_MATRIX,T_MATRIX>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX>& B) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^Times_Transpose(const MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^Times_Transpose(const MATRIX<T,3,2>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Times_Transpose(const DIAGONAL_MATRIX& M) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    typename PRODUCT_TRANSPOSE<DIAGONAL_MATRIX,T_MATRIX>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX>& B) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^Times_Transpose(const MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,p> Times_Transpose(const MATRIX<T,p,n>& A) const$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    typename TRANSPOSE<T_MATRIX>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX>& A) const$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Times_Transpose(const MATRIX& A) const \/\/ 8 mults, 4 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Times_Transpose(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 6 mults, 2 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX<T,2,3> Times_Transpose(const MATRIX<T,3,2>& A) const \/\/ 12 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX Times_Transpose(const MATRIX<T,2>& A) const \/\/ 12 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX Times_Transpose(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 9 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,3> Times_Transpose(const MATRIX& A) const \/\/ 18 mults, 9 adds$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Times_Transpose(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Times_Transpose(const UPPER_TRIANGULAR_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,DIAGONAL_MATRIX<T,d> >::TYPE Times_Transpose(const DIAGONAL_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,SYMMETRIC_MATRIX<T,d> >::TYPE Times_Transpose(const SYMMETRIC_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT_TRANSPOSE<T_MATRIX,T_MATRIX1>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX1>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    MATRIX<T,2,3> Times_Transpose(const MATRIX<T,3,2>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    MATRIX<T,2> Times_Transpose(const DIAGONAL_MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    MATRIX<T,2> Times_Transpose(const MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    MATRIX<T,2> Times_Transpose(const SYMMETRIC_MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    typename PRODUCT_TRANSPOSE<SYMMETRIC_MATRIX,T_MATRIX>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^Times_Transpose(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 6 mults, 2 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX<T,3> Times_Transpose(const SYMMETRIC_MATRIX& M) const \/\/ 27 mults, 18 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    typename PRODUCT_TRANSPOSE<SYMMETRIC_MATRIX,T_MATRIX>::TYPE Times_Transpose(const MATRIX_BASE<T,T_MATRIX>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    template<class TM> typename PRODUCT<DERIVED,typename TRANSPOSE<TM>::TYPE>::TYPE Times_Transpose(const TM& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Times_Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    MATRIX<T,2,3> Times_Transpose(const MATRIX<T,3,2>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Times_Transpose_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Times_Transpose_With_Symmetric_Result(const MATRIX<T,3,2>& A,const MATRIX<T,3,2>& B) \/\/ A*B^t and assume symmetric result, 12 mults, 6 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Times_Transpose_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Times_Transpose_With_Symmetric_Result(const MATRIX<T,3>& A,const MATRIX<T,3>& B) \/\/ A*B^t and assume symmetric result, 18 mults, 12 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Title	arpack++/include/arhbmat.h	/^  char* Title() { return title; }$/;"	f	class:ARhbMatrix
To_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    VECTOR<T,2> To_Vector() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
To_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    VECTOR<T,3> To_Vector() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
To_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> To_Vector() const$/;"	f	class:PhysBAM::MATRIX
Token	parser/ParseTree.h	/^typedef int Token;$/;"	t
TokenMap	parser/Dictionary.h	/^typedef map<int, string> TokenMap;$/;"	t
Top	Manual/Aerof3d.html	/^<a name="Top"><\/a>$/;"	a
TopoFace	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultiGridLevel::Topology
TopoFace	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultigridSubdomain::Topology
TopoInterior	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultiGridLevel::Topology
TopoInterior	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultigridSubdomain::Topology
TopoLine	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultiGridLevel::Topology
TopoLine	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultigridSubdomain::Topology
TopoUnknown	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultiGridLevel::Topology
TopoUnknown	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultigridSubdomain::Topology
TopoVertex	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultiGridLevel::Topology
TopoVertex	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	e	enum:MultigridSubdomain::Topology
Topology	MultiGridLevel.h	/^    enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	g	class:MultiGridLevel
Topology	MultiGridLevel.h	/^  enum Topology { TopoVertex = 0, TopoLine = 1, TopoFace = 2, TopoInterior = 3, TopoUnknown = 4 };$/;"	g	struct:MultigridSubdomain
TorsionSpring	f77src/torsionspring.f	/^      subroutine TorsionSpring(/;"	s
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T Trace() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T Trace() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    T Trace() const$/;"	f	class:PhysBAM::MATRIX_MXN
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T Trace() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T Trace() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T Trace() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Trace	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T Trace() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Trace	arpack++/include/arrscomp.h	/^  void Trace(const int digit = -5, const int getv0 = 0, const int aupd = 1,$/;"	f	class:ARrcCompStdEig
Trace	arpack++/include/arrseig.h	/^  virtual void Trace() {$/;"	f	class:ARrcStdEig
Trace	arpack++/include/arrsnsym.h	/^  void Trace(const int digit = -5, const int getv0 = 0, const int aupd = 1,$/;"	f	class:ARrcNonSymStdEig
Trace	arpack++/include/arrssym.h	/^  void Trace(const int digit = -5, const int getv0 = 0, const int aupd = 1,$/;"	f	class:ARrcSymStdEig
TraceOff	arpack++/include/debug.h	/^inline void TraceOff()$/;"	f
Transform_2X2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,2> Transform_2X2(const VECTOR<T,2>& v) const \/\/ multiplies vector by upper 2x2 of matrix only$/;"	f	class:PhysBAM::MATRIX
Transform_3X3	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    VECTOR<T,3> Transform_3X3(const VECTOR<T,3>& v) const \/\/ multiplies vector by upper 3x3 of matrix only$/;"	f	class:PhysBAM::MATRIX
TransientData	IoData.h	/^struct TransientData {$/;"	s
TransientData	IoDataCore.C	/^TransientData::TransientData()$/;"	f	class:TransientData
Translate	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Translate(const TV& translation){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,2>& Translation()$/;"	f	class:PhysBAM::MATRIX
Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    const VECTOR<T,2>& Translation() const$/;"	f	class:PhysBAM::MATRIX
Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    VECTOR<T,3>& Translation()$/;"	f	class:PhysBAM::MATRIX
Translation	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    const VECTOR<T,3>& Translation() const$/;"	f	class:PhysBAM::MATRIX
Translation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Translation_Matrix(const VECTOR<T,2>& translation) \/\/ treating the 3x3 matrix as a homogeneous transformation on 2d vectors$/;"	f	class:PhysBAM::MATRIX
Translation_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    static MATRIX Translation_Matrix(const VECTOR<T,3>& translation)$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    void Transpose()$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    void Transpose()$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    static MATRIX Transpose(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    static MATRIX Transpose(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    void Transpose()$/;"	f	class:PhysBAM::MATRIX_MXN
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    void Transpose()$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    void Transpose()$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Lower_Triangular_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    LEFT_VECTOR Transpose_Lower_Triangular_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    typename PRODUCT<DIAGONAL_MATRIX,T_MATRIX>::TYPE Transpose_Times(const T_MATRIX& M) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    typename PRODUCT<DIAGONAL_MATRIX,T_MATRIX>::TYPE Transpose_Times(const T_MATRIX& M) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,n,p> Transpose_Times(const MATRIX<T,m,p>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    VECTOR<T,n> Transpose_Times(const VECTOR<T,m>& y) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T_MATRIX Transpose_Times(const MATRIX_BASE<T,T_MATRIX>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> Transpose_Times(const VECTOR<T,1>& v) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    VECTOR<T,2> Transpose_Times(const VECTOR<T,1>& v) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Transpose_Times(const MATRIX& A) const \/\/ 8 mults, 4 adds$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> Transpose_Times(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2,3> Transpose_Times(const DIAGONAL_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2,3> Transpose_Times(const MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2,3> Transpose_Times(const SYMMETRIC_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2,3> Transpose_Times(const UPPER_TRIANGULAR_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2> Transpose_Times(const MATRIX& A) const \/\/ 12 mults, 8 adds$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    VECTOR<T,2> Transpose_Times(const VECTOR<T,3>& v) const \/\/ 6 mults, 4 adds$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Transpose_Times(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> Transpose_Times(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename TRANSPOSE_PRODUCT<T_MATRIX,DIAGONAL_MATRIX<T,d> >::TYPE Transpose_Times(const DIAGONAL_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename TRANSPOSE_PRODUCT<T_MATRIX,SYMMETRIC_MATRIX<T,d> >::TYPE Transpose_Times(const SYMMETRIC_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename TRANSPOSE_PRODUCT<T_MATRIX,T_MATRIX1>::TYPE Transpose_Times(const MATRIX_BASE<T,T_MATRIX1>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename TRANSPOSE_PRODUCT<T_MATRIX,typename VECTOR_TYPE<T_VECTOR>::TYPE>::TYPE Transpose_Times(const VECTOR_BASE<T,T_VECTOR>& y) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    typename PRODUCT<SYMMETRIC_MATRIX,T_MATRIX>::TYPE Transpose_Times(const T_MATRIX& M) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    typename PRODUCT<SYMMETRIC_MATRIX,T_MATRIX>::TYPE Transpose_Times(const T_MATRIX& M) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    template<class TM> typename PRODUCT<T_MATRIX,TM>::TYPE Transpose_Times(const TM& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Transpose_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Transpose_Times_With_Symmetric_Result(const MATRIX<T,2>& A,const MATRIX<T,2>& B) \/\/ A^t*B and assume symmetric result, 6 mults, 3 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Transpose_Times_With_Symmetric_Result(const MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B) \/\/ A^t*B and assume symmetric result, 4 mults, 1 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Transpose_Times_With_Symmetric_Result(const MATRIX<T,3,2>& A,const MATRIX<T,3,2>& B) \/\/ A^t*B and assume symmetric result, 9 mults, 6 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Transpose_Times_With_Symmetric_Result(const MATRIX<T,3>& A,const MATRIX<T,3>& B) \/\/ A^t*B and assume symmetric result, 18 mults, 12 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Times_With_Symmetric_Result	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Transpose_Times_With_Symmetric_Result(const MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B) \/\/ A^t*B and assume symmetric result, 10 mults, 4 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transpose_Upper_Triangular_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    LEFT_VECTOR Transpose_Upper_Triangular_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX Transposed() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX Transposed() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,n,m> Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX<T,2,1> Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX<T,2,3> Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX Transposed() const$/;"	f	class:PhysBAM::MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Transposed() const$/;"	f	class:PhysBAM::MATRIX_MXN
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX Transposed() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX Transposed() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    const T_MATRIX& Transposed() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Transposed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    static DERIVED Transposed(const T_MATRIX& A)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
TriID_SI	LevelSet/LevelSetStructure.h	/^	 DistVec<int>  *TriID_SI;$/;"	m	class:DistLevelSetStructure
TriID_SI	LevelSet/LevelSetStructure.h	/^	 Vec<int>   &TriID_SI; \/\/ ID of the element of the embedded $/;"	m	class:LevelSetStructure
TriID_node	LevelSet/LevelSetStructure.h	/^	 DistVec<int>  *TriID_node;$/;"	m	class:DistLevelSetStructure
TriID_node	LevelSet/LevelSetStructure.h	/^	 Vec<int>   &TriID_node; \/\/ ID of the element of the embedded $/;"	m	class:LevelSetStructure
Tria	FSI/DynamicNodalTransfer.h	/^  int    (*Tria)[3]; \/\/mesh topology (activated only if the mesh is provided by FEM)$/;"	m	class:EmbeddedStructure
Triangle	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    int Triangle(const int node1,const int node2,const int node3) const$/;"	f	class:PhysBAM::TRIANGLE_MESH
Triangle_On_Edge	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Triangle_On_Edge(const int node1,const int node2) const$/;"	f	class:TRIANGLE_MESH
Triangles_Across_Edge	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Triangles_Across_Edge(const int triangle,const int node1,const int node2,ARRAY<int>& triangles_across_edge) const$/;"	f	class:TRIANGLE_MESH
Triangles_On_Edge	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^Triangles_On_Edge(const int node1,const int node2,ARRAY<int>* triangles_on_edge) const$/;"	f	class:TRIANGLE_MESH
TriangulatedInterface	TriangulatedInterface.C	/^TriangulatedInterface::TriangulatedInterface() {$/;"	f	class:TriangulatedInterface
TriangulatedInterface	TriangulatedInterface.h	/^class TriangulatedInterface {$/;"	c
TriangulatedSurface	TriangulatedSurface.C	/^TriangulatedSurface::TriangulatedSurface()$/;"	f	class:TriangulatedSurface
TriangulatedSurface	TriangulatedSurface.h	/^class TriangulatedSurface {$/;"	c
Trilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Trilinear(const T2& u1,const T2& u2,const T2& u3,const T2& u4,const T2& u5,const T2& u6,const T2& u7,const T2& u8,$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Trilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Trilinear(const T2& u1,const T2& u2,const T2& u3,const T2& u4,const T2& u5,const T2& u6,const T2& u7,const T2& u8,const VECTOR<T,3>& X)$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
Trilinear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	/^    static T2 Trilinear(const T2& u1,const T2& u3,const T2& u5,const T2& u7,T one_over_y_top_minus_y_bottom,T one_over_z_back_minus_z_front,const T x_left,const T y_bottom,const T z_front,$/;"	f	class:PhysBAM::LINEAR_INTERPOLATION
TripDomainData	IoData.h	/^struct TripDomainData {$/;"	s
TripDomainData	IoDataCore.C	/^TripDomainData::TripDomainData()$/;"	f	class:TripDomainData
Triple_Product	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    static T Triple_Product(const VECTOR& u,const VECTOR& v,const VECTOR& w)$/;"	f	class:PhysBAM::VECTOR
Tripping	Manual/Aerof3d.html	/^<a name="Tripping"><\/a>$/;"	a
TryWaitForDebug	DebugTools.h	/^  static bool TryWaitForDebug() {$/;"	f	class:DebugTools
Ts	ViscoFcn.h	/^  double Ts;$/;"	m	class:SutherlandViscoFcn
TsData	IoData.h	/^struct TsData {$/;"	s
TsData	IoDataCore.C	/^TsData::TsData()$/;"	f	class:TsData
TsDesc	TsDesc.C	/^TsDesc<dim>::TsDesc(IoData &ioData, GeoSource &geoSource, Domain *dom) : domain(dom),fluidIdDummy(dom->getNodeDistInfo())$/;"	f	class:TsDesc
TsDesc	TsDesc.h	/^class TsDesc {$/;"	c
TsInput	TsInput.C	/^TsInput::TsInput(IoData &iod) {$/;"	f	class:TsInput
TsInput	TsInput.h	/^struct TsInput {$/;"	s
TsOutput	TsOutput.C	/^TsOutput<dim>::TsOutput(IoData &iod, RefVal *rv, Domain *dom, PostOperator<dim> *po) : $/;"	f	class:TsOutput
TsOutput	TsOutput.h	/^class TsOutput {$/;"	c
TsParameters	TsParameters.C	/^TsParameters::TsParameters(IoData &ioData)$/;"	f	class:TsParameters
TsParameters	TsParameters.h	/^class TsParameters {$/;"	c
TsRestart	TsRestart.h	/^class TsRestart {$/;"	c
TsRestart	TsRestartCore.C	/^TsRestart::TsRestart(IoData &iod, RefVal *rv) : refVal(rv)$/;"	f	class:TsRestart
TsSolver	TsSolver.h	/^TsSolver<ProblemDescriptor>::TsSolver(ProblemDescriptor *prbd)$/;"	f	class:TsSolver
TsSolver	TsSolver.h	/^class TsSolver {$/;"	c
Tuple	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^inline PAIR<T1,T2> Tuple(const T1& x,const T2& y)$/;"	f	namespace:PhysBAM
Tuple	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^inline TRIPLE<T1,T2,T3> Tuple(const T1& x,const T2& y,const T3& z)$/;"	f	namespace:PhysBAM
TurbulenceClosure	Manual/Aerof3d.html	/^<a name="TurbulenceClosure"><\/a>$/;"	a
TurbulenceClosureData	IoData.h	/^struct TurbulenceClosureData {$/;"	s
TurbulenceClosureData	IoDataCore.C	/^TurbulenceClosureData::TurbulenceClosureData()$/;"	f	class:TurbulenceClosureData
TurbulenceModel	Manual/Aerof3d.html	/^<a name="TurbulenceModel"><\/a>$/;"	a
TurbulenceModelCoupling	IoData.h	/^  enum TurbulenceModelCoupling {WEAK = 0, STRONG = 1} tmcoupling;$/;"	g	struct:ImplicitData
TurbulenceModelData	IoData.h	/^struct TurbulenceModelData {$/;"	s
TurbulenceModelData	IoDataCore.C	/^TurbulenceModelData::TurbulenceModelData()$/;"	f	class:TurbulenceModelData
Twall	IntersectorFRG/IntersectorFRG.h	/^	 double Twall;$/;"	m	class:DistIntersectorFRG
Twall	IntersectorPhysBAM/IntersectorPhysBAM.h	/^	 double Twall;$/;"	m	class:DistIntersectorPhysBAM
Twice_Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    SYMMETRIC_MATRIX<T,2> Twice_Symmetric_Part() const$/;"	f	class:PhysBAM::MATRIX
Twice_Symmetric_Part	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    SYMMETRIC_MATRIX<T,3> Twice_Symmetric_Part() const \/\/ 3 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
Two_Diff	utils/Predicate.C	195;"	d	file:
Two_Diff_Tail	utils/Predicate.C	188;"	d	file:
Two_One_Diff	utils/Predicate.C	257;"	d	file:
Two_One_Product	utils/Predicate.C	303;"	d	file:
Two_One_Sum	utils/Predicate.C	253;"	d	file:
Two_Product	utils/Predicate.C	213;"	d	file:
Two_Product_2Presplit	utils/Predicate.C	231;"	d	file:
Two_Product_Presplit	utils/Predicate.C	220;"	d	file:
Two_Product_Tail	utils/Predicate.C	205;"	d	file:
Two_Square	utils/Predicate.C	353;"	d	file:
Two_Sum	utils/Predicate.C	184;"	d	file:
Two_Sum_Tail	utils/Predicate.C	177;"	d	file:
Two_Two_Diff	utils/Predicate.C	265;"	d	file:
Two_Two_Product	utils/Predicate.C	323;"	d	file:
Two_Two_Sum	utils/Predicate.C	261;"	d	file:
Type	DiagMatrix.h	/^  enum Type {DENSE = 0, DIAGONAL = 1} type;$/;"	g	class:DiagMat
Type	Elem.h	/^  enum Type {TET=5};$/;"	g	class:Elem
Type	EmbeddedCorotSolver.h	/^  enum Type {BASIC, COROTATIONAL} type;$/;"	g	class:EmbeddedCorotSolver
Type	EmbeddedTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	g	class:EmbeddedTsDesc
Type	ErrorHandler.h	/^  enum Type {ALL = 0, SOLVER = 1};$/;"	g	struct:ErrorHandler
Type	Face.h	/^  enum Type {TRIA=4};$/;"	g	class:Face
Type	FluxFcnBase.h	/^  enum Type {CONSERVATIVE = 0, PRIMITIVE = 1} typeJac;$/;"	g	class:FluxFcnBase
Type	IoData.h	/^   enum Type {PSEUDOSTRUCTURAL = 0, ALGEBRAIC = 1 } type;$/;"	g	struct:BLMeshMotionData
Type	IoData.h	/^  enum Type { ADIABATIC = 1, ISOTHERMAL = 2 } type;$/;"	g	struct:SurfaceData
Type	IoData.h	/^  enum Type { COMPRESSIBLE = 0 } type;$/;"	g	struct:LiquidModelData
Type	IoData.h	/^  enum Type { STEGER_WARMING = 0,$/;"	g	struct:BoundarySchemeData
Type	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	g	struct:ImplicitData
Type	IoData.h	/^  enum Type {BASIC = 0, COROTATIONAL = 1} type;$/;"	g	struct:DefoMeshMotionData
Type	IoData.h	/^  enum Type {CONSTANT = 0, SUTHERLAND = 1, PRANDTL = 2} type;$/;"	g	struct:ViscosityModelData
Type	IoData.h	/^  enum Type {CONSTANT_PRANDTL = 0, CONSTANT = 1} type;$/;"	g	struct:ThermalCondModelData
Type	IoData.h	/^  enum Type {CYLINDRICAL = 0, SPHERICAL = 1} d_surfaceType;$/;"	g	struct:KirchhoffData
Type	IoData.h	/^  enum Type {D1VMSLES = 0, D2VMSLES = 1, D3VMSLES = 2} type;$/;"	g	struct:DynamicVMSData
Type	IoData.h	/^  enum Type {DEFAULT = 0, ROM = 1, FORCED = 2} type;$/;"	g	struct:LinearizedData
Type	IoData.h	/^  enum Type {DIRECTSTATE = 1, MASSFLOW = 2, POROUSWALL = 3} type;$/;"	g	struct:BoundaryData
Type	IoData.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} type;$/;"	g	struct:EquationsData
Type	IoData.h	/^  enum Type {EXPLICIT = 0, IMPLICIT = 1} type;$/;"	g	struct:TsData
Type	IoData.h	/^  enum Type {EXTERNAL = 0, INTERNAL = 1} type;$/;"	g	struct:BcsFreeStreamData
Type	IoData.h	/^  enum Type {FLUID = 0, POROUS = 1} type;$/;"	g	struct:VolumeData
Type	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	g	struct:ForcedData
Type	IoData.h	/^  enum Type {IDEAL = 0, JWL = 1} type;$/;"	g	struct:JWLModelData
Type	IoData.h	/^  enum Type {IDEAL = 0, STIFFENED = 1} type;$/;"	g	struct:GasModelData
Type	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	g	struct:PcData
Type	IoData.h	/^  enum Type {ISOTHERMAL = 0, ADIABATIC = 1} type;$/;"	g	struct:BcsWallData
Type	IoData.h	/^  enum Type {ITERATIVE = 0, NONITERATIVE = 1, HYBRID = 2} type;$/;"	g	struct:WallDistanceMethodData
Type	IoData.h	/^  enum Type {NONE = 0, BACKTRACKING = 1} type;$/;"	g	struct:LineSearchData
Type	IoData.h	/^  enum Type {NONE = 0, EDDY_VISCOSITY = 1, LES = 2} type;$/;"	g	struct:TurbulenceClosureData
Type	IoData.h	/^  enum Type {ONE_EQUATION_SPALART_ALLMARAS = 0, ONE_EQUATION_DES = 1, TWO_EQUATION_KE = 2} type;$/;"	g	struct:TurbulenceModelData
Type	IoData.h	/^  enum Type {POD = 0, BALANCED_POD = 1} type;$/;"	g	struct:DataCompressionData
Type	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	g	struct:KspData
Type	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	g	struct:ExplicitData
Type	IoData.h	/^  enum Type {SINGLE = 0, DOUBLE = 1} type;$/;"	g	struct:RestartData
Type	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	g	struct:LESModelData
Type	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	g	struct:ProblemData
Type	IoData.h	/^  enum Type{LINEAR=0, SMOOTHSTEP=1} type;$/;"	g	struct:ImplosionSetup
Type	MultiPhysicsTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	g	class:MultiPhysicsTsDesc
Type	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	g	class:VarFcnBase
Type	arpack++/include/arhbmat.h	/^  char* Type() { return type; }$/;"	f	class:ARhbMatrix
TypeBx	arpack++/include/argeig.h	/^  typedef void (ARFB::* TypeBx)(ARTYPE[], ARTYPE[]);$/;"	t	class:ARGenEig
TypeBx	arpack++/include/argnsym.h	/^  typedef void (ARFB::* TypeBx)(ARFLOAT[], ARFLOAT[]);$/;"	t	class:ARNonSymGenEig
TypeBx	arpack++/include/argsym.h	/^  typedef void (ARFB::* TypeBx)(ARFLOAT[], ARFLOAT[]);$/;"	t	class:ARSymGenEig
TypeGamma	KirchhoffIntegrator.h	/^  enum TypeGamma {SPHERE = 0, CYLINDER = 1} d_SurfType;$/;"	g	class:KirchhoffIntegrator
TypeOPx	arpack++/include/argeig.h	/^  typedef void (ARFOP::* TypeOPx)(ARTYPE[], ARTYPE[]);$/;"	t	class:ARGenEig
TypeOPx	arpack++/include/arseig.h	/^  typedef void (ARFOP::* TypeOPx)(ARTYPE[], ARTYPE[]);$/;"	t	class:ARStdEig
TypePhaseChange	IoData.h	/^  enum TypePhaseChange {ASIS = 0, RIEMANN_SOLUTION = 1, EXTRAPOLATION = 2} typePhaseChange;$/;"	g	struct:MultiFluidData
TypeTimeStep	IoData.h	/^  enum TypeTimeStep {AUTO = 0, LOCAL = 1, GLOBAL = 2} typeTimeStep;$/;"	g	struct:TsData
U	FSI/DynamicNodalTransfer.h	/^  double (*U)[3]; \/\/displacement$/;"	m	class:EmbeddedStructure
U	KspBinaryOutput.h	/^  VecType* U;$/;"	m	class:KspBinaryOutput
U	MatVecProd.h	/^  DistSVec<double,dim> *U;$/;"	m	class:MatVecProdLS
U	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
U	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
U	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
U	OneDimensionalSolver.h	/^  SVec<double,5> U;$/;"	m	class:OneDimensional
U	arpack++/include/arlnsmat.h	/^  SuperMatrix U;$/;"	m	class:ARluNonSymMatrix
U	arpack++/include/arlnspen.h	/^  SuperMatrix                        U;$/;"	m	class:ARluNonSymPencil
U	arpack++/include/arlsmat.h	/^  SuperMatrix U;$/;"	m	class:ARluSymMatrix
U	arpack++/include/arlspen.h	/^  SuperMatrix            U;$/;"	m	class:ARluSymPencil
U0	ExplicitEmbeddedTsDesc.h	/^  DistSVec<double,dim> U0;$/;"	m	class:ExplicitEmbeddedTsDesc
U0	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> U0;$/;"	m	class:ExplicitLevelSetTsDesc
U0	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> U0;$/;"	m	class:ExplicitMultiPhysicsTsDesc
U0	ExplicitTsDesc.h	/^  DistSVec<double,dim> U0;$/;"	m	class:ExplicitTsDesc
U0	ImplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> U0,Fold;$/;"	m	class:ImplicitLevelSetTsDesc
UCNTL2	arpack++/include/arch.h	50;"	d
UCOL	arpack++/include/arlspdef.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;$/;"	e	enum:__anon32
UCopy	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *UCopy;     \/\/<! the primitive variables.$/;"	m	class:EmbeddedTsDesc
UICNTL5	arpack++/include/arch.h	49;"	d
UICNTL7	arpack++/include/arch.h	48;"	d
UKEEP7	arpack++/include/arch.h	51;"	d
UKEEP8	arpack++/include/arch.h	53;"	d
UMFPACKC_H	arpack++/include/umfpackc.h	21;"	d
UMFPACKF_H	arpack++/include/umfpackf.h	18;"	d
UNDECIDED	IntersectorFRG/IntersectorFRG.C	/^const int IntersectorFRG::UNDECIDED, IntersectorFRG::INSIDE, IntersectorFRG::OUTSIDE;$/;"	m	class:IntersectorFRG	file:
UNDECIDED	IntersectorFRG/IntersectorFRG.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: ~~$/;"	m	class:IntersectorFRG
UNDECIDED	IntersectorPhysBAM/IntersectorPhysBAM.C	/^const int IntersectorPhysBAM::UNDECIDED, IntersectorPhysBAM::INSIDE, IntersectorPhysBAM::OUTSIDE;$/;"	m	class:IntersectorPhysBAM	file:
UNDECIDED	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    static const int OUTSIDE = -2, UNDECIDED = -1, INSIDE = 0; \/\/INSIDE: inside real fluid, OUTSIDE: not a fluid$/;"	m	class:IntersectorPhysBAM
UNDEFINED	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	e	enum:FluidModelData::Fluid
UNEXPECTED_EOF	arpack++/include/arerror.h	/^    UNEXPECTED_EOF      = -555,$/;"	e	enum:ArpackError::ErrorCode
UNIFORMRAND	utils/Predicate.C	137;"	d	file:
UNION_COLORS_TAG	IntersectorPhysBAM/Mpi_Utilities.h	39;"	d
UNION_FALSE	IoData.h	/^  enum UseUnionOfSampledNodes {UNION_FALSE = 0, UNION_TRUE = 1} useUnionOfSampledNodes;$/;"	e	enum:GappyConstructionData::UseUnionOfSampledNodes
UNION_FIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    explicit UNION_FIND(const ID entries=ID())$/;"	f	class:PhysBAM::UNION_FIND
UNION_FIND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^class UNION_FIND$/;"	c	namespace:PhysBAM
UNION_TRUE	IoData.h	/^  enum UseUnionOfSampledNodes {UNION_FALSE = 0, UNION_TRUE = 1} useUnionOfSampledNodes;$/;"	e	enum:GappyConstructionData::UseUnionOfSampledNodes
UNKNOWN_FILE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^enum FILE_TYPE{RGD_FILE,RGD2D_FILE,TRI_FILE,PHI_FILE,PHI2D_FILE,OCT_FILE,PLY_FILE,PLY2D_FILE,RGB_FILE,TRI2D_FILE,CURVE_FILE,CURVE2D_FILE,TET_FILE,HEX_FILE,BOX_FILE,PHONEME_FILE,UNKNOWN_FILE};$/;"	e	enum:PhysBAM::FILE_UTILITIES::FILE_TYPE
UNPHYSICAL	ErrorHandler.h	/^  enum Error {UNPHYSICAL = 0, SATURATED_LS = 1, BAD_RIEMANN = 2, REDUCE_TIMESTEP = 3, PRESSURE_CLIPPING = 4, DENSITY_CLIPPING = 5, REDO_TIMESTEP = 6, LARGE_VELOCITY = 7, RAPIDLY_CHANGING_PRESSURE = 8, RAPIDLY_CHANGING_DENSITY = 9, REDUCE_TIMESTEP_TIME = 10, SIZE = 11};$/;"	e	enum:ErrorHandler::Error
UNSPECIFIED	IoData.h	/^  static const int UNSPECIFIED = -1;$/;"	m	struct:BoundaryData
UNSPECIFIED	IoData.h	/^  static const int UNSPECIFIED = -1;$/;"	m	struct:SurfaceData
UNSPECIFIED_GREEDY	IoData.h	/^  enum greedyData {UNSPECIFIED_GREEDY = -1, STATE_ROB_GREEDY = 0, RESIDUAL_ROB_GREEDY = 1,$/;"	e	enum:GappyConstructionData::greedyData
UNSPECIFIED_HF	IoData.h	/^  enum HeatFluxResults {UNSPECIFIED_HF = -1, NO_HF = 0, YES_HF = 1} heatFluxResults;$/;"	e	enum:SurfaceData::HeatFluxResults
UNSTEADY	IoData.h	/^  enum Type {UNSTEADY = 0, ACCELERATED = 1, AERO = 2, THERMO = 3, FORCED = 4,$/;"	e	enum:ProblemData::Type
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::ARRAY
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::ARRAY_BASE
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::ARRAY_VIEW
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::INDIRECT_ARRAY
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    struct UNUSABLE{void F(){}};$/;"	s	class:PhysBAM::ELEMENT_ID
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::HASHTABLE
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::HASHTABLE_ITERATOR
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::ARRAY_BASE
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::MATRIX
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::MATRIX
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    struct UNUSABLE{};$/;"	s	struct:PhysBAM::__anon21::ASSERT_EFFICIENT
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    class UNUSABLE {};$/;"	c	class:PhysBAM::ROTATION
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::Read_Write
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T,class ENABLER=void> struct SCALAR_POLICY{typedef struct UNUSABLE{} TYPE;};$/;"	s	struct:PhysBAM::SCALAR_POLICY
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::VECTOR
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::VECTOR
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::VECTOR
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::VECTOR
UNUSABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    struct UNUSABLE{};$/;"	s	class:PhysBAM::VECTOR
UPCASE	arpack++/include/arlnames.h	31;"	d
UPDATES_FAST_APPROX	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	e	enum:NonlinearRomOnlineData::BasisUpdates
UPDATES_FAST_EXACT	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	e	enum:NonlinearRomOnlineData::BasisUpdates
UPDATES_OFF	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	e	enum:NonlinearRomOnlineData::BasisUpdates
UPDATES_OFF	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1} basisUpdates;$/;"	e	enum:RelativeProjectionErrorData::BasisUpdates
UPDATES_SIMPLE	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	e	enum:NonlinearRomOnlineData::BasisUpdates
UPDATES_SIMPLE	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1} basisUpdates;$/;"	e	enum:RelativeProjectionErrorData::BasisUpdates
UPPER_MASK	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    static const unsigned int a=0x9908b0df,UPPER_MASK=0x80000000,LOWER_MASK=0x7fffffff;$/;"	m	class:PhysBAM::MT19937
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(2),INITIAL_SIZE nn=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX(const T x11_input,const T x12_input,const T x22_input)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX(const UPPER_TRIANGULAR_MATRIX<T2,2>& matrix_input)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^class UPPER_TRIANGULAR_MATRIX<T,2>$/;"	c	namespace:PhysBAM
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX(INITIAL_SIZE mm=INITIAL_SIZE(3),INITIAL_SIZE nn=INITIAL_SIZE(3))$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX(const T x11_input,const T x12_input,const T x22_input,const T x13_input,const T x23_input,const T x33_input)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX(const UPPER_TRIANGULAR_MATRIX<T2,3>& matrix_input)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
UPPER_TRIANGULAR_MATRIX	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^class UPPER_TRIANGULAR_MATRIX<T,3>$/;"	c	namespace:PhysBAM
USER	arpack++/include/arlspdef.h	/^typedef enum {SYSTEM, USER}            LU_space_t;$/;"	e	enum:__anon34
USER_ABORT	arpack++/include/arlutil.h	20;"	d
USER_FREE	arpack++/include/arlutil.h	36;"	d
USER_MALLOC	arpack++/include/arlutil.h	30;"	d
USE_EXISTING_CLUSTERS_FALSE	IoData.h	/^  enum UseExistingClusters {USE_EXISTING_CLUSTERS_FALSE = 0, USE_EXISTING_CLUSTERS_TRUE = 1} useExistingClusters;$/;"	e	enum:ClusteringData::UseExistingClusters
USE_EXISTING_CLUSTERS_TRUE	IoData.h	/^  enum UseExistingClusters {USE_EXISTING_CLUSTERS_FALSE = 0, USE_EXISTING_CLUSTERS_TRUE = 1} useExistingClusters;$/;"	e	enum:ClusteringData::UseExistingClusters
USE_IOSTREAM	VectorSet.h	3;"	d
USE_OLD_FALSE	IoData.h	/^  enum UseOldReducedSVecFunction {USE_OLD_FALSE = 0, USE_OLD_TRUE = 1} useOldReducedSVecFunction;$/;"	e	enum:GappyConstructionData::UseOldReducedSVecFunction
USE_OLD_TRUE	IoData.h	/^  enum UseOldReducedSVecFunction {USE_OLD_FALSE = 0, USE_OLD_TRUE = 1} useOldReducedSVecFunction;$/;"	e	enum:GappyConstructionData::UseOldReducedSVecFunction
USUB	arpack++/include/arlspdef.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB} MemType;$/;"	e	enum:__anon32
UScale	FSI/DynamicNodalTransfer.h	/^        const double UScale; \/\/scaling factor for velocity$/;"	m	class:DynamicNodalTransfer
UScale	FSI/DynamicNodalTransfer.h	/^  double UScale;$/;"	m	class:EmbeddedStructure
UT	AlternatingLeastSquare/als_lapack.h	/^    double *UT;$/;"	m	class:AlternatingLeastSquare
U_NZ_START	arpack++/include/arlsupm.h	140;"	d
U_SUB	arpack++/include/arlsupm.h	141;"	d
U_smoothed	MultiGridEmbeddedTsDesc.h	/^  DistSVec<double,dim>* U_smoothed;$/;"	m	class:MultiGridEmbeddedTsDesc
U_vec_smooth	MultiGridSolver.h	/^  typename ProblemDescriptor::SolVecType* U_vec_smooth;$/;"	m	class:MultiGridSolver
Ub	DistBcData.h	/^  double Ub[dim];$/;"	m	class:DistBcData
Ubc	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> Ubc;$/;"	m	class:ExplicitMultiPhysicsTsDesc
Ubc	ExplicitTsDesc.h	/^  DistSVec<double,dim> Ubc;$/;"	m	class:ExplicitTsDesc
Uc	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> Uc;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Uc	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> Uc;$/;"	m	class:FluidGnatShapeOptimizationHandler
Uc	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> Uc;$/;"	m	class:FluidMetricShapeOptimizationHandler
Uc	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> Uc;$/;"	m	class:FluidRomShapeOptimizationHandler
Uc	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> Uc;$/;"	m	class:FluidShapeOptimizationHandler
Udot	FSI/DynamicNodalTransfer.h	/^  double (*Udot)[3]; \/\/velocity$/;"	m	class:EmbeddedStructure
Uface	BcData.h	/^  SVec<double,dim> &Uface;$/;"	m	class:BcData
Uface	DistBcData.h	/^  DistSVec<double,dim> Uface;$/;"	m	class:DistBcData
Ufarin	BcData.h	/^  SVec<double,dim> &Ufarin;$/;"	m	class:BcData
Ufarin	DistBcData.h	/^  DistSVec<double,dim> Ufarin;$/;"	m	class:DistBcData
Ufarout	BcData.h	/^  SVec<double,dim> &Ufarout;$/;"	m	class:BcData
Ufarout	DistBcData.h	/^  DistSVec<double,dim> Ufarout;$/;"	m	class:DistBcData
Uic	NonlinearRom.h	/^  DistSVec<double, dim>* Uic;$/;"	m	class:NonlinearRom
Uic	TsDesc.h	/^  DistSVec<double,dim> *Uic;$/;"	m	class:TsDesc
Uin	DistBcData.h	/^  double Uin[dim], Vin[dim];$/;"	m	class:DistBcData
Uinit	ImplicitRomTsDesc.h	/^  DistSVec<double, dim>* Uinit;  \/\/ initial condition of the steady state simulation, $/;"	m	class:ImplicitRomTsDesc
Uinitial	ImplicitRomPostproTsDesc.h	/^  DistSVec<double, dim> Uinitial;	\/\/ solution increment at EACH NEWTON ITERATION in full coordinates$/;"	m	class:ImplicitRomPostproTsDesc
Uinletnode	BcData.h	/^  SVec<double,dim> &Uinletnode;$/;"	m	class:BcData
Uinletnode	DistBcData.h	/^  DistSVec<double,dim> Uinletnode;$/;"	m	class:DistBcData
Um	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Um	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Um	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:FluidGnatShapeOptimizationHandler
Um	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:FluidMetricShapeOptimizationHandler
Um	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:FluidRomShapeOptimizationHandler
Um	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Um;$/;"	m	class:FluidShapeOptimizationHandler
Un	DistTimeState.h	/^  DistSVec<double,dim> *Un;$/;"	m	class:DistTimeState
Un	TimeState.h	/^  SVec<double,dim> &Un;$/;"	m	class:TimeState
UnBar	DistTimeState.h	/^  DistSVec<double,dim> *UnBar;$/;"	m	class:DistTimeState
Union	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Union(const ID i,const ID j)$/;"	f	class:PhysBAM::UNION_FIND
Union	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ID Union(const VECTOR<ID,d>& indices)$/;"	f	class:PhysBAM::UNION_FIND
Unit_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Unit_Box()$/;"	f	class:PhysBAM::INTERVAL
Unit_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Unit_Box()$/;"	f	class:PhysBAM::RANGE
Unit_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    static SYMMETRIC_MATRIX Unit_Matrix(const T scale=1)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Unit_Matrix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    static SYMMETRIC_MATRIX Unit_Matrix(const T scale=1)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Unit_Orthogonal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR Unit_Orthogonal_Vector() const$/;"	f	class:PhysBAM::VECTOR
Unit_Orthogonal_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR Unit_Orthogonal_Vector() const \/\/ roughly 6 mults, 2 adds, 1 div, 1 sqrt$/;"	f	class:PhysBAM::VECTOR
Unit_Polar	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    static COMPLEX<T> Unit_Polar(const T theta)$/;"	f	class:PhysBAM::COMPLEX
Unm1	DistTimeState.h	/^  DistSVec<double,dim> *Unm1;$/;"	m	class:DistTimeState
Unm1	TimeState.h	/^  SVec<double,dim> &Unm1;$/;"	m	class:TimeState
Unm1Bar	DistTimeState.h	/^  DistSVec<double,dim> *Unm1Bar;$/;"	m	class:DistTimeState
Unm2	DistTimeState.h	/^  DistSVec<double,dim> *Unm2;$/;"	m	class:DistTimeState
Unm2	TimeState.h	/^  SVec<double,dim> &Unm2;$/;"	m	class:TimeState
Unm2Bar	DistTimeState.h	/^  DistSVec<double,dim> *Unm2Bar;$/;"	m	class:DistTimeState
Unode	BcData.h	/^  SVec<double,dim> &Unode;$/;"	m	class:BcData
Unode	DistBcData.h	/^  DistSVec<double,dim> Unode;$/;"	m	class:DistBcData
Unpack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    void Unpack(const T_ARRAY1& buffer,typename T_ARRAY1::INDEX& position,const ID p)$/;"	f	class:PhysBAM::ARRAY_BASE
Unpack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    void Unpack(ARRAY_VIEW<const char> buffer,int& position,const int p)$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Unpack	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    void Unpack(ARRAY_VIEW<const char> buffer,int& position,const int p)$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
Unpermute	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    static void Unpermute(const T_ARRAY1& source,T_ARRAY1& destination,const T_ARRAY_INT& permutation)$/;"	f	class:PhysBAM::ARRAY_BASE
Unpermute	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T_VECTOR Unpermute(const VECTOR_BASE<int,T_VECTOR2>& p) const$/;"	f	class:PhysBAM::VECTOR_BASE
Unpermute_Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX Unpermute_Columns(const VECTOR<int,n>& p) const$/;"	f	class:PhysBAM::MATRIX
Unpermute_Columns	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T> Unpermute_Columns(const VECTOR_ND<int>& p) const$/;"	f	class:PhysBAM::MATRIX_MXN
Unsteady-aeroelastic-computation	Manual/Aerof3d.html	/^<a name="Unsteady-aeroelastic-computation"><\/a>$/;"	a
Uold	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
Uold	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
Uold	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
Uout	DistBcData.h	/^  double Uout[dim], Vout[dim];$/;"	m	class:DistBcData
Up	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
Up	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Up	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:FluidGnatShapeOptimizationHandler
Up	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:FluidMetricShapeOptimizationHandler
Up	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:FluidRomShapeOptimizationHandler
Up	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> *Up;$/;"	m	class:FluidShapeOptimizationHandler
Update	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^Update(const int numLocSub,const bool rebuild_hierarchy)$/;"	f	class:PhysBAMInterface
UpdateScope	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^UpdateScope(const int subD,const bool use_global_scope)$/;"	f	class:PhysBAMInterface
Update_Adjacent_Elements_From_Incident_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Update_Adjacent_Elements_From_Incident_Elements(const int node)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Update_Box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Update_Box(){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Update_Box_Radii	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    void Update_Box_Radii()$/;"	f	class:PhysBAM::BOX_HIERARCHY
Update_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Boxes(const FRAME<TV>& start_frame,const FRAME<TV>& end_frame,const T extra_thickness=0) \/\/ for moving triangles$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Boxes(const T extra_thickness=0)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Boxes(const T_ARRAY_TV& X,const T extra_thickness=0) \/\/ use X instead of the current particle positions$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Boxes(const T_ARRAY_TV& start_X,const T_ARRAY_TV& end_X,const T extra_thickness=0) \/\/ bound triangles moving from start_X to end_X$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Leaf_Box_Radii	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    void Update_Leaf_Box_Radii()$/;"	f	class:PhysBAM::BOX_HIERARCHY
Update_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Leaf_Boxes(const FRAME<TV>& start_frame,const FRAME<TV>& end_frame,const T extra_thickness=0) \/\/ for moving triangles$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Leaf_Boxes(const T extra_thickness=0)$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Leaf_Boxes(const T_ARRAY_TV& X,const T extra_thickness=0) \/\/ use X instead of the current particle positions$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Leaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    void Update_Leaf_Boxes(const T_ARRAY_TV& start_X,const T_ARRAY_TV& end_X,const T extra_thickness=0) \/\/ bound triangles moving from start_X to end_X$/;"	f	class:PhysBAM::TRIANGLE_HIERARCHY
Update_Max_Off_Diagonal_Element_Of_Row_After_Column_Change	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.cpp	/^Update_Max_Off_Diagonal_Element_Of_Row_After_Column_Change(const MATRIX_MXN<T>& A,ARRAY<PAIR<int,T> >& max_off_diagonal_element_of_row,const int j)$/;"	f	namespace:__anon22
Update_Max_Off_Diagonal_Element_Of_Row_After_Row_Change	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.cpp	/^Update_Max_Off_Diagonal_Element_Of_Row_After_Row_Change(const MATRIX_MXN<T>& A,ARRAY<PAIR<int,T> >& max_off_diagonal_element_of_row,const int i)$/;"	f	namespace:__anon22
Update_Minimum_Cell_Size	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> void IMPLICIT_OBJECT<TV>::Update_Minimum_Cell_Size(const int maximum_depth){PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
Update_Modified_Nonleaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Update_Modified_Nonleaf_Boxes(ARRAY<bool>& modified)$/;"	f	class:BOX_HIERARCHY
Update_Neighbor_Nodes_From_Incident_Elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^Update_Neighbor_Nodes_From_Incident_Elements(const int node)$/;"	f	class:PhysBAM::SIMPLEX_MESH
Update_Nonleaf_Box_Radii	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Update_Nonleaf_Box_Radii()$/;"	f	class:BOX_HIERARCHY
Update_Nonleaf_Boxes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^Update_Nonleaf_Boxes()$/;"	f	class:BOX_HIERARCHY
Update_Number_Nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    virtual void Update_Number_Nodes(){}$/;"	f	class:PhysBAM::STRUCTURE
Uporouswall	BcData.h	/^  SVec<double,dim> &Uporouswall;$/;"	m	class:BcData
Uporouswall	DistBcData.h	/^  DistSVec<double,dim> Uporouswall;$/;"	m	class:DistBcData
Upper_Triangular_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    RIGHT_VECTOR Upper_Triangular_Solve(const VECTOR_BASE<T,T_VECTOR>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Upper_Triangular_Solve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX2 Upper_Triangular_Solve(const MATRIX_BASE<T,T_MATRIX2>& b) const$/;"	f	class:PhysBAM::MATRIX_BASE
Uprev	ImplicitRomTsDesc.h	/^  DistSVec<double, dim>* Uprev;  \/\/ solution at the beginning of the previous time step (needed for model II incremental bases) $/;"	m	class:ImplicitRomTsDesc
Uref	Modal.h	/^    DistSVec<double,dim> Uref;$/;"	m	class:ModalSolver
Uref	NonlinearRom.h	/^  DistSVec<double, dim>* Uref;$/;"	m	class:NonlinearRom
Uref	TsOutput.h	/^  DistSVec<double,dim> *Uref;$/;"	m	class:TsOutput
Uref_norm	TsOutput.h	/^  double Uref_norm;$/;"	m	class:TsOutput
UromCurrentROB	ImplicitRomTsDesc.h	/^  Vec<double> UromCurrentROB;   \/\/ for projection only: initialized at each cluster switch$/;"	m	class:ImplicitRomTsDesc
UseExistingClusters	IoData.h	/^  enum UseExistingClusters {USE_EXISTING_CLUSTERS_FALSE = 0, USE_EXISTING_CLUSTERS_TRUE = 1} useExistingClusters;$/;"	g	struct:ClusteringData
UseFirstStateAsRefStateForIncrBasis	IoData.h	/^  enum UseFirstStateAsRefStateForIncrBasis {ASSUME_INCR_REFSTATE_FALSE = 0, ASSUME_INCR_REFSTATE_TRUE = 1} useFirstStateAsRefStateForIncrBasis;$/;"	g	struct:RelativeProjectionErrorData
UseMultiSolutionsGappy	IoData.h	/^  enum UseMultiSolutionsGappy {MULTI_SOLUTIONS_GAPPY_FALSE=0, MULTI_SOLUTIONS_GAPPY_TRUE=1} useMultiSolutionsGappy;$/;"	g	struct:InputData
UseOldReducedSVecFunction	IoData.h	/^  enum UseOldReducedSVecFunction {USE_OLD_FALSE = 0, USE_OLD_TRUE = 1} useOldReducedSVecFunction;$/;"	g	struct:GappyConstructionData
UseUnionOfSampledNodes	IoData.h	/^  enum UseUnionOfSampledNodes {UNION_FALSE = 0, UNION_TRUE = 1} useUnionOfSampledNodes;$/;"	g	struct:GappyConstructionData
Use_Secondary_Interpolation	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    void Use_Secondary_Interpolation(const bool use_secondary_interpolation_input=true)$/;"	f	class:PhysBAM::IMPLICIT_OBJECT
Using_Externally_Allocated_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    bool Using_Externally_Allocated_Pointer() const$/;"	f	class:PhysBAM::ARRAY
Using_Externally_Allocated_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    bool Using_Externally_Allocated_Pointer()$/;"	f	class:PhysBAM::ARRAY
Using_Externally_Allocated_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    bool Using_Externally_Allocated_Pointer() const$/;"	f	class:PhysBAM::ARRAY_VIEW
Using_Externally_Allocated_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    bool Using_Externally_Allocated_Pointer()$/;"	f	class:PhysBAM::ARRAY_VIEW
Using_Externally_Allocated_Pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    bool Using_Externally_Allocated_Pointer()$/;"	f	class:PhysBAM::INDIRECT_ARRAY
Utilde	LevelSetTsDesc.h	/^  DistSVec<double,dim> Utilde;$/;"	m	class:LevelSetTsDesc
V	AlternatingLeastSquare/als_lapack.h	/^    double *V;$/;"	m	class:AlternatingLeastSquare
V	AutoDiff/SpaceDerivatives.h	/^    Eigen::Array<typename Base::ScalarConstantType, FunctionTemplate<Scalar>::NumberOfGeneralizedCoordinates, 1> V;$/;"	m	class:JacobianVectorProduct
V	DistTimeState.h	/^  DistSVec<double,dim> *V;$/;"	m	class:DistTimeState
V	GhostPoint.h	/^  double *V;    \/\/ Stores the final primitive states$/;"	m	class:GhostPoint
V	KspSolver.h	/^  VecSet<VecType> V;$/;"	m	class:GmresSolver
V	MatVecProd.h	/^  DistSVec<double,dim> *V;$/;"	m	class:MatVecProdLS
V	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
V	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
V	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
V	OneDimensionalSolver.h	/^  SVec<double,5> V;$/;"	m	class:OneDimensional
V	PostOperator.h	/^  DistSVec<double,dim> *V;$/;"	m	class:PostOperator
V	SpaceOperator.h	/^  DistSVec<double,dim> *V;$/;"	m	class:SpaceOperator
V	TsDesc.h	/^  DistSVec<double,dim> *V;$/;"	m	class:TsDesc
V	arpack++/include/arrseig.h	/^  ARTYPE  *V;         \/\/ Arnoldi basis \/ Schur vectors.$/;"	m	class:ARrcStdEig
V0	LevelSetTsDesc.h	/^  DistSVec<double,dim> V0;$/;"	m	class:LevelSetTsDesc
V0	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> V0;$/;"	m	class:MultiPhysicsTsDesc
V6NodeData	V6NodeData.h	/^  V6NodeData() { tet = -1; face = -1; r = 0.0; t = 0.0; }$/;"	f	struct:V6NodeData
V6NodeData	V6NodeData.h	/^struct V6NodeData {$/;"	s
V6NodeDataOf2	EdgeGrad.h	/^  typedef V6NodeData (*V6NodeDataOf2)[2];$/;"	t	class:EdgeGrad
VALUE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    typedef T VALUE;$/;"	t	class:PhysBAM::ELEMENT_ID
VALUES_NOT_OK	arpack++/include/arerror.h	/^    VALUES_NOT_OK       = -406,$/;"	e	enum:ArpackError::ErrorCode
VANALBADA	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	e	enum:SchemeData::Limiter
VANLEER	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	e	enum:SchemeData::Flux
VBar	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> **VBar;$/;"	m	class:DistDynamicVMSTerm
VCYCLE	IoData.h	/^  enum CycleScheme { VCYCLE = 0, WCYCLE = 1} cycle_scheme;$/;"	e	enum:MultiGridData::CycleScheme
VCap	DistDynamicLESTerm.h	/^  DistSVec<double,dim> *VCap;$/;"	m	class:DistDynamicLESTerm
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const T& x1,const T& x2,const T& x3,const T& x4)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const T& x1,const T& x2,const T& x3,const T& x4,const T& x5)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const T& x1,const T& x2,const T& x3,const T& x4,const T& x5,const T& x6)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const T& x1,const T& x2,const T& x3,const T& x4,const T& x5,const T& x6,const T& x7)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const T& x1,const T& x2,const T& x3,const T& x4,const T& x5,const T& x6,const T& x7,const T& x8)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const VECTOR<T,n>& v1,const VECTOR<T,d-n>& v2)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR(const VECTOR_EXPRESSION<T,T_VECTOR>& v,typename ENABLE_IF<IS_SAME<typename VECTOR_TYPE<T_VECTOR>::TYPE,VECTOR>::value,UNUSABLE>::TYPE unusable=UNUSABLE())$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    explicit VECTOR(INITIAL_SIZE n=INITIAL_SIZE(d))$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    explicit VECTOR(const INDIRECT_ARRAY<T_VECTOR,T_INDICES>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    explicit VECTOR(const VECTOR<T2,d2>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    explicit VECTOR(const VECTOR_BASE<T,T_VECTOR>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^class VECTOR:public VECTOR_BASE<T,VECTOR<T,d> >$/;"	c	namespace:PhysBAM
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR(const VECTOR& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    explicit VECTOR(INITIAL_SIZE n=INITIAL_SIZE())$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    template<class T2> explicit VECTOR(const VECTOR<T2,0>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^class VECTOR<T,0>:public VECTOR_BASE<T,VECTOR<T,0> >$/;"	c	namespace:PhysBAM
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR(const VECTOR& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR(const VECTOR<T,n>& v1,const VECTOR<T,1-n>& v2)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR(const VECTOR_ND<T>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    explicit VECTOR(INITIAL_SIZE n=INITIAL_SIZE(1))$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    explicit VECTOR(const T& x_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    explicit VECTOR(const VECTOR_BASE<T,T_VECTOR>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    template<class T2> explicit VECTOR(const VECTOR<T2,1>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^class VECTOR<T,1>:public VECTOR_BASE<T,VECTOR<T,1> >$/;"	c	namespace:PhysBAM
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR(const T& x_input,const T& y_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR(const VECTOR& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR(const VECTOR_ND<T>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    explicit VECTOR(INITIAL_SIZE n=INITIAL_SIZE(2))$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    explicit VECTOR(const ARRAY<T>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    explicit VECTOR(const ARRAY_BASE<T,T_ARRAY>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    explicit VECTOR(const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    explicit VECTOR(const VECTOR_BASE<T,T_VECTOR>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<class T2> explicit VECTOR(const VECTOR<T2,1>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    template<class T2> explicit VECTOR(const VECTOR<T2,2>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^class VECTOR<T,2>:public VECTOR_BASE<T,VECTOR<T,2> >$/;"	c	namespace:PhysBAM
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR(const T& x_input,const T& y_input,const T& z_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR(const VECTOR& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR(const VECTOR<T,n>& v1,const VECTOR<T,3-n>& v2)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR(const VECTOR_ND<T>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    explicit VECTOR(INITIAL_SIZE n=INITIAL_SIZE(3))$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    explicit VECTOR(const ARRAY<T>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    explicit VECTOR(const INDIRECT_ARRAY<T_VECTOR,T_INDICES>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    explicit VECTOR(const VECTOR<T,2>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    explicit VECTOR(const VECTOR_BASE<T,T_VECTOR>& v)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    template<class T2> explicit VECTOR(const VECTOR<T2,3>& vector_input)$/;"	f	class:PhysBAM::VECTOR
VECTOR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^class VECTOR<T,3>:public VECTOR_BASE<T,VECTOR<T,3> >$/;"	c	namespace:PhysBAM
VECTORS_NOT_OK	arpack++/include/arerror.h	/^    VECTORS_NOT_OK      = -407,$/;"	e	enum:ArpackError::ErrorCode
VECTOR_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    VECTOR_BASE()$/;"	f	class:PhysBAM::VECTOR_BASE
VECTOR_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    VECTOR_BASE(const VECTOR_BASE&)$/;"	f	class:PhysBAM::VECTOR_BASE
VECTOR_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^class VECTOR_BASE$/;"	c	namespace:PhysBAM
VECTOR_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_DIFFERENCE(const T_VECTOR1& array1,const T_VECTOR2& array2)$/;"	f	class:PhysBAM::VECTOR_DIFFERENCE
VECTOR_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_DIFFERENCE(const VECTOR_DIFFERENCE& v)$/;"	f	class:PhysBAM::VECTOR_DIFFERENCE
VECTOR_DIFFERENCE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^class VECTOR_DIFFERENCE:public VECTOR_EXPRESSION<typename SUM<typename T_VECTOR1::SCALAR,typename T_VECTOR2::SCALAR>::TYPE,VECTOR_DIFFERENCE<T_VECTOR1,T_VECTOR2> >$/;"	c	namespace:PhysBAM
VECTOR_EXPRESSION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^class VECTOR_EXPRESSION:public VECTOR_BASE<T,T_EXPRESSION>$/;"	c	namespace:PhysBAM
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    VECTOR_ND(const VECTOR_ND& v)$/;"	f	class:PhysBAM::VECTOR_ND
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    explicit VECTOR_ND(const INITIAL_SIZE n_input)$/;"	f	class:PhysBAM::VECTOR_ND
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    explicit VECTOR_ND(const VECTOR_BASE<T,T_VECTOR>& vector)$/;"	f	class:PhysBAM::VECTOR_ND
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    explicit VECTOR_ND(const VECTOR_BASE<T2,T_VECTOR>& vector)$/;"	f	class:PhysBAM::VECTOR_ND
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    explicit VECTOR_ND(const int n_input=0,const bool initialize=true)$/;"	f	class:PhysBAM::VECTOR_ND
VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^class VECTOR_ND:public VECTOR_BASE<T,VECTOR_ND<T> >$/;"	c	namespace:PhysBAM
VECTOR_NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_NEGATION(const T_VECTOR& array)$/;"	f	class:PhysBAM::VECTOR_NEGATION
VECTOR_NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_NEGATION(const VECTOR_NEGATION& v)$/;"	f	class:PhysBAM::VECTOR_NEGATION
VECTOR_NEGATION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^class VECTOR_NEGATION:public VECTOR_EXPRESSION<typename T_VECTOR::SCALAR,VECTOR_NEGATION<T_VECTOR> >$/;"	c	namespace:PhysBAM
VECTOR_SCALE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_SCALE(const T1& scalar,const T_VECTOR& array)$/;"	f	class:PhysBAM::VECTOR_SCALE
VECTOR_SCALE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_SCALE(const VECTOR_SCALE& v)$/;"	f	class:PhysBAM::VECTOR_SCALE
VECTOR_SCALE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^class VECTOR_SCALE:public VECTOR_EXPRESSION<typename SUM<T1,typename T_VECTOR::SCALAR>::TYPE,VECTOR_SCALE<T1,T_VECTOR> >$/;"	c	namespace:PhysBAM
VECTOR_SET_OP_H_	VecSetOp.h	2;"	d
VECTOR_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_SUM(const T_VECTOR1& array1,const T_VECTOR2& array2)$/;"	f	class:PhysBAM::VECTOR_SUM
VECTOR_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    VECTOR_SUM(const VECTOR_SUM& v)$/;"	f	class:PhysBAM::VECTOR_SUM
VECTOR_SUM	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^class VECTOR_SUM:public VECTOR_EXPRESSION<typename SUM<typename T_VECTOR1::SCALAR,typename T_VECTOR2::SCALAR>::TYPE,VECTOR_SUM<T_VECTOR1,T_VECTOR2> >$/;"	c	namespace:PhysBAM
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::BOX
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::LINE_2D
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::ORIENTED_BOX
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::PLANE
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::IMPLICIT_OBJECT
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::STRUCTURE
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::RANGE
VECTOR_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    typedef TV VECTOR_T;$/;"	t	class:PhysBAM::POINT_CLOUD
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> struct VECTOR_TYPE<VECTOR_EXPRESSION<T,T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,int d> struct VECTOR_TYPE<VECTOR<T,d> > {typedef VECTOR<T,d> TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T2,class T_VECTOR> struct VECTOR_TYPE<VECTOR_SCALE<T2,T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct VECTOR_TYPE<VECTOR_ND<T> > {typedef VECTOR_ND<T> TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR,class T_VECTOR2> struct VECTOR_TYPE<VECTOR_DIFFERENCE<T_VECTOR,T_VECTOR2> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR,class T_VECTOR2> struct VECTOR_TYPE<VECTOR_SUM<T_VECTOR,T_VECTOR2> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
VECTOR_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T_VECTOR> struct VECTOR_TYPE<VECTOR_NEGATION<T_VECTOR> > {typedef typename VECTOR_TYPE<T_VECTOR>::TYPE TYPE;};$/;"	s	namespace:PhysBAM
VELOCITY	IoData.h	/^  enum InitialCondition {DISPLACEMENT = 0, VELOCITY = 1} initCond;$/;"	e	enum:LinearizedData::InitialCondition
VELOCITY	IoData.h	/^  enum Tag {MACH = 0, TIME = 1, VELOCITY = 2} tag;$/;"	e	enum:RigidMeshMotionData::Tag
VELOCITY	IoData.h	/^  enum Type {HEAVING = 0, PITCHING = 1, VELOCITY = 2, DEFORMING = 3, DEBUGDEFORMING=4,$/;"	e	enum:ForcedData::Type
VELOCITY	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	e	enum:PostFcn::VectorType
VELOCITYAVG	PostFcn.h	/^  enum VectorAvgType {VELOCITYAVG = 0, DISPLACEMENTAVG = 1, AVVSIZE = 2};$/;"	e	enum:PostFcn::VectorAvgType
VELOCITYPOINTS	IoData.h	/^  enum LawType {VELOCITYPOINTS = 0, CONSTANTACCELERATION = 1} lawtype;$/;"	e	enum:RigidMeshMotionData::LawType
VELOCITY_NORM	PostFcn.h	/^                   WTMACH = 22, WTSPEED = 23, VELOCITY_NORM = 24, TEMPERATURE_NORMAL_DERIVATIVE = 25, $/;"	e	enum:PostFcn::ScalarType
VENKAT	IoData.h	/^  enum Limiter {NONE = 0, VANALBADA = 1, BARTH = 2, VENKAT = 3, P_SENSOR = 4,$/;"	e	enum:SchemeData::Limiter
VMS	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	e	enum:LESModelData::Type
VMS	Manual/Aerof3d.html	/^<a name="VMS"><\/a>$/;"	a
VMSLESData	IoData.h	/^struct VMSLESData {$/;"	s
VMSLESData	IoDataCore.C	/^VMSLESData::VMSLESData()$/;"	f	class:VMSLESData
VMSLESTerm	VMSLESTerm.C	/^VMSLESTerm::VMSLESTerm(IoData& iod, VarFcn *vf): NavierStokesTerm(iod, vf)$/;"	f	class:VMSLESTerm
VMSLESTerm	VMSLESTerm.h	/^class VMSLESTerm : public NavierStokesTerm  {$/;"	c
VOLUME	IoData.h	/^  enum Delta {VOLUME = 0, SIDE = 1} delta;$/;"	e	enum:LESModelData::Delta
VOLUME	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:DeformingData::Domain
VOLUME	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:HeavingData::Domain
VOLUME	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:PitchingData::Domain
VOLUME	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	e	enum:SpiralingData::Domain
VOLUME	IoData.h	/^  enum ShapeDerivativeType {WALL=0, VOLUME=1} shapederivativesType;$/;"	e	enum:InputData::ShapeDerivativeType
VOLUME_WEIGHTED	IoData.h	/^  enum RestrictMethod { VOLUME_WEIGHTED = 0, AVERAGE = 1 } restrictMethod;$/;"	e	enum:MultiGridData::RestrictMethod
VORTICITY	PostFcn.h	/^		   VORTICITY = 5, CSDLES = 6, CSDVMS = 7, SKIN_FRICTION = 8, NUT_TURB = 9, $/;"	e	enum:PostFcn::ScalarType
VORTICITYAVG	PostFcn.h	/^                      TOTPRESSUREAVG = 4, VORTICITYAVG = 5, CSDLESAVG = 6, CSDVMSAVG = 7, $/;"	e	enum:PostFcn::ScalarAvgType
VSIZE	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	e	enum:PostFcn::VectorType
VWeights	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *VWeights; \/\/<! stores U*Weights for each node. Used in updating phase change.$/;"	m	class:EmbeddedTsDesc
VWeights	LevelSetTsDesc.h	/^  DistSVec<double,dim> VWeights;$/;"	m	class:LevelSetTsDesc
VWeights	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> *VWeights; \/\/<! stores U*Weights for each node. Used in updating phase change.$/;"	m	class:MultiPhysicsTsDesc
VX	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
VY	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
VZ	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	e	enum:BoundaryData::vars
V_tmp	GhostPoint.h	/^  double* V_tmp;$/;"	m	class:GhostPoint
ValAllocate	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::ValAllocate()$/;"	f	class:ARrcStdEig
ValAllocate	arpack++/include/arrsnsym.h	/^inline void ARrcNonSymStdEig<ARFLOAT>::ValAllocate()$/;"	f	class:ARrcNonSymStdEig
ValSize	arpack++/include/arrseig.h	/^  virtual int ValSize() { return nev; }$/;"	f	class:ARrcStdEig
ValSize	arpack++/include/arrsnsym.h	/^  int ValSize() { return nev+1; }$/;"	f	class:ARrcNonSymStdEig
Valid	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    bool Valid() const$/;"	f	class:PhysBAM::HASHTABLE_ITERATOR
Valid	SubDomain.C	/^    bool Valid(Elem*) { return true; }$/;"	f	class:ElemForceCalcValid
Valid	SubDomainCore.C	/^    bool Valid(Elem*) { return true; }$/;"	f	class:ElemSearchValid
ValidInput	parser/Parser.y	/^ValidInput: $/;"	l
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    bool Valid_Index(const ID i) const$/;"	f	class:PhysBAM::ARRAY
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool Valid_Index(const ID i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    bool Valid_Index(const int p) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    bool Valid_Index(const ID i) const$/;"	f	class:PhysBAM::ARRAY_VIEW
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool Valid_Index(const TV_INT& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool Valid_Index(const int i) const$/;"	f	class:PhysBAM::ARRAY_BASE
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::ARRAY_BASE
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool Valid_Index(const int i,const int j,const int ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX_MXN
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Valid_Index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    bool Valid_Index(const int i,const int j) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    T Value() const$/;"	f	class:PhysBAM::ELEMENT_ID
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^Value(ID i)$/;"	f	namespace:PhysBAM
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^Value(T i)$/;"	f	namespace:PhysBAM
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    static int Value(const HASH key)$/;"	f	class:PhysBAM::HASH
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    static int Value(const T& key)$/;"	f	class:PhysBAM::HASH
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    static int Value(const int key)$/;"	f	class:PhysBAM::HASH
Value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T Value(const T x) const$/;"	f	class:PhysBAM::CUBIC
ValueType	AutoDiff/SpaceDerivatives.h	/^    typedef Eigen::Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	class:SpatialView
Value_To_String	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^template<> inline std::string Value_To_String<std::string>(const std::string& str)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
Value_To_String	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^template<class T> inline std::string Value_To_String(const T& str)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
ValuesAtCompileTime	AutoDiff/SpaceDerivatives.h	/^      ValuesAtCompileTime = FunctionTemplate<Scalar>::NumberOfValues$/;"	e	enum:SpatialView::__anon4
ValuesOK	arpack++/include/arrseig.h	/^  bool    ValuesOK;   \/\/ Indicates if eigenvalues were calculated.$/;"	m	class:ARrcStdEig
VarFcn	VarFcn.h	/^  VarFcn() { meshVel = 0.0; fprintf(stderr, "MeshVel initialized: %e %e %e\\n", meshVel[0], meshVel[1], meshVel[2]);}$/;"	f	class:VarFcn
VarFcn	VarFcn.h	/^VarFcn::VarFcn(IoData &iod)$/;"	f	class:VarFcn
VarFcn	VarFcn.h	/^class VarFcn {$/;"	c
VarFcnBase	VarFcnBase.h	/^  VarFcnBase(FluidModelData &data) {$/;"	f	class:VarFcnBase
VarFcnBase	VarFcnBase.h	/^class VarFcnBase {$/;"	c
VarFcnJwl	VarFcnJwl.h	/^VarFcnJwl::VarFcnJwl(FluidModelData &data) : VarFcnBase(data) {$/;"	f	class:VarFcnJwl
VarFcnJwl	VarFcnJwl.h	/^class VarFcnJwl : public VarFcnBase {$/;"	c
VarFcnSGEuler	VarFcnSGEuler.h	/^VarFcnSGEuler::VarFcnSGEuler(FluidModelData &data) : VarFcnBase(data) {$/;"	f	class:VarFcnSGEuler
VarFcnSGEuler	VarFcnSGEuler.h	/^class VarFcnSGEuler : public VarFcnBase {$/;"	c
VarFcnSGKE	VarFcnSGKE.h	/^VarFcnSGKE::VarFcnSGKE(FluidModelData &data) : VarFcnBase(data) {$/;"	f	class:VarFcnSGKE
VarFcnSGKE	VarFcnSGKE.h	/^class VarFcnSGKE: public VarFcnBase {$/;"	c
VarFcnSGSA	VarFcnSGSA.h	/^VarFcnSGSA::VarFcnSGSA(FluidModelData &data) : VarFcnBase(data) {$/;"	f	class:VarFcnSGSA
VarFcnSGSA	VarFcnSGSA.h	/^class VarFcnSGSA: public VarFcnBase {$/;"	c
VarFcnTait	VarFcnTait.h	/^VarFcnTait::VarFcnTait(FluidModelData &data, bool baseClass) : VarFcnBase(data) {$/;"	f	class:VarFcnTait
VarFcnTait	VarFcnTait.h	/^class VarFcnTait : public VarFcnBase {$/;"	c
VarFcnTaitKE	VarFcnTaitKE.h	/^VarFcnTaitKE::VarFcnTaitKE(FluidModelData &data) : VarFcnTait(data, true) {$/;"	f	class:VarFcnTaitKE
VarFcnTaitKE	VarFcnTaitKE.h	/^class VarFcnTaitKE : public VarFcnTait {$/;"	c
VarFcnTaitSA	VarFcnTaitSA.h	/^VarFcnTaitSA::VarFcnTaitSA(FluidModelData &data) : VarFcnTait(data, true) {$/;"	f	class:VarFcnTaitSA
VarFcnTaitSA	VarFcnTaitSA.h	/^class VarFcnTaitSA : public VarFcnTait {$/;"	c
Variable	IoData.h	/^   enum ClosestNeighbor {Fixed = 1, Variable = 0} bestNeiStrategy;$/;"	e	enum:BLMeshMotionData::ClosestNeighbor
Vec	Vector.h	/^Vec<Scalar>::Vec()$/;"	f	class:Vec
Vec	Vector.h	/^Vec<Scalar>::Vec(const Expr<T, Scalar> &expr) $/;"	f	class:Vec
Vec	Vector.h	/^Vec<Scalar>::Vec(const Vec<Scalar> &y) $/;"	f	class:Vec
Vec	Vector.h	/^Vec<Scalar>::Vec(int l, Scalar *vv) $/;"	f	class:Vec
Vec	Vector.h	/^class Vec {$/;"	c
Vec3D	Vector3D.h	/^  Vec3D() {v[0] = v[1] = v[2] = 0.0; }$/;"	f	struct:Vec3D
Vec3D	Vector3D.h	/^  Vec3D(const Vec3D &v2) { v[0] = v2.v[0]; v[1] = v2.v[1]; v[2] = v2.v[2]; }$/;"	f	struct:Vec3D
Vec3D	Vector3D.h	/^  Vec3D(double x) { v[0] = v[1] = v[2] = x; }$/;"	f	struct:Vec3D
Vec3D	Vector3D.h	/^  Vec3D(double x, double y, double z) { v[0] = x; v[1] = y; v[2] = z; }$/;"	f	struct:Vec3D
Vec3D	Vector3D.h	/^  Vec3D(double x[3]) { v[0] = x[0]; v[1] = x[1]; v[2] = x[2]; }$/;"	f	struct:Vec3D
Vec3D	Vector3D.h	/^struct Vec3D {$/;"	s
VecAllocate	arpack++/include/arrseig.h	/^inline void ARrcStdEig<ARFLOAT, ARTYPE>::VecAllocate(bool newV)$/;"	f	class:ARrcStdEig
VecSet	VectorSet.h	/^VecSet<VecType>::VecSet(VecSet<VecType> &vectorSet)  : len(vectorSet.size())$/;"	f	class:VecSet
VecSet	VectorSet.h	/^VecSet<VecType>::VecSet(int _numVec, const typename VecType::InfoType &_len) : len(_len)$/;"	f	class:VecSet
VecSet	VectorSet.h	/^class VecSet {$/;"	c
VecSet5	ParallelRomCore.C	/^typedef VecSet< DistSVec<double,5> > VecSet5;$/;"	t	file:
VecSet6	ParallelRomCore.C	/^typedef VecSet< DistSVec<double,6> > VecSet6;$/;"	t	file:
VecSet7	ParallelRomCore.C	/^typedef VecSet< DistSVec<double,7> > VecSet7;$/;"	t	file:
VecSetArray	GappyPreprocessing.h	/^class VecSetArray {$/;"	c
VecSubDomainData	GappyPreprocessing.h	/^struct VecSubDomainData { $/;"	s
Vector	DenseMatrix.h	/^typedef Vec<double> Vector;$/;"	t
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    VECTOR<T,4> Vector() const$/;"	f	class:PhysBAM::QUATERNION
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    VECTOR<T,2> Vector() const$/;"	f	class:PhysBAM::COMPLEX
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3,const T& d4)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3,const T& d4,const T& d5)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3,const T& d4,const T& d5,const T& d6)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3,const T& d4,const T& d5,const T& d6,const T& d7)$/;"	f	namespace:PhysBAM
Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^Vector(const T& d1,const T& d2,const T& d3,const T& d4,const T& d5,const T& d6,const T& d7,const T& d8)$/;"	f	namespace:PhysBAM
VectorAvgType	PostFcn.h	/^  enum VectorAvgType {VELOCITYAVG = 0, DISPLACEMENTAVG = 1, AVVSIZE = 2};$/;"	g	class:PostFcn
VectorDerivativeType	PostFcn.h	/^  enum VectorDerivativeType {DERIVATIVE_VELOCITY_VECTOR = 0, DERIVATIVE_DISPLACEMENT = 1, DVSIZE = 2};$/;"	g	class:PostFcn
VectorOp	DenseMatrixOps.h	/^class VectorOp {$/;"	c
VectorOp	DenseMatrixOps.h	/^class VectorOp<Scalar,5> {$/;"	c
VectorType	PostFcn.h	/^  enum VectorType {VELOCITY = 0, DISPLACEMENT = 1, FLIGHTDISPLACEMENT = 2, LOCALFLIGHTDISPLACEMENT = 3, VSIZE = 4};$/;"	g	class:PostFcn
VectorValuedFunction	AutoDiff/Function.h	/^class VectorValuedFunction {$/;"	c
VectorsOK	arpack++/include/arrseig.h	/^  bool    VectorsOK;  \/\/ Indicates if eigenvectors were determined.$/;"	m	class:ARrcStdEig
Velocities	IoData.h	/^  enum Velocities {AUTO_VEL = 0, IMPLICIT_BACKWARD_EULER_VEL = 1, IMPLICIT_THREE_POINT_BDF_VEL = 2,$/;"	g	struct:DGCLData
Velocity	IoData.h	/^struct Velocity  {$/;"	s
Velocity	Manual/Aerof3d.html	/^<a name="Velocity"><\/a>$/;"	a
Velocity	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> TV IMPLICIT_OBJECT<TV>::Velocity(const TV& location) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
VelocityPoints	IoData.h	/^struct VelocityPoints {$/;"	s
VelocityPoints	IoDataCore.C	/^VelocityPoints::VelocityPoints()$/;"	f	class:VelocityPoints
Vertical_Vector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR<T,1> Vertical_Vector() const$/;"	f	class:PhysBAM::VECTOR
Veval	OneDimensionalSolver.h	/^    Veval(VarFcn* _vf,OneDimensionalInputData* _oned,FluidSelector* _fluidSelector,double* _x, double* _v,int* _fids,SVec<double,3>* _X,int _np,$/;"	f	class:OneDimensional::Veval
Veval	OneDimensionalSolver.h	/^  class Veval {$/;"	c	class:OneDimensional
Vg	GhostPoint.h	/^  double* Vg;	\/\/ Sum of weighted states (rho,u,v,w,T) at the ghost-point. $/;"	m	class:GhostPoint
Vin	DistBcData.h	/^  double Uin[dim], Vin[dim];$/;"	m	class:DistBcData
Vintegrator	OneDimensionalSolver.h	/^  RKIntegrator< SVec<double, 5> >* Vintegrator;$/;"	m	class:OneDimensional
ViscoFcn	ViscoFcn.h	/^  ViscoFcn(IoData &iod) { $/;"	f	class:ViscoFcn
ViscoFcn	ViscoFcn.h	/^class ViscoFcn {$/;"	c
ViscosityModel	Manual/Aerof3d.html	/^<a name="ViscosityModel"><\/a>$/;"	a
ViscosityModelData	IoData.h	/^struct ViscosityModelData {$/;"	s
ViscosityModelData	IoDataCore.C	/^ViscosityModelData::ViscosityModelData()$/;"	f	class:ViscosityModelData
ViscousBoundaryCondition	IoData.h	/^  enum ViscousBoundaryCondition {WEAK = 0, STRONG = 1} viscousboundarycondition;$/;"	g	struct:EmbeddedFramework
ViscousInterfaceOrder	IoData.h	/^  enum ViscousInterfaceOrder {FIRST = 0, SECOND = 1} viscousinterfaceorder;$/;"	g	struct:EmbeddedFramework
Vmax	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *Vmax;$/;"	m	class:DistNodalGrad
Vmin	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *Vmin;$/;"	m	class:DistNodalGrad
Vn	DistTimeState.h	/^  DistSVec<double,dim> *Vn;$/;"	m	class:DistTimeState
VnBar	DistTimeState.h	/^  DistSVec<double,dim> *VnBar;$/;"	m	class:DistTimeState
VolVecType	MeshMotionSolver.h	/^  typedef DistVec<double> VolVecType;$/;"	t	class:TetMeshMotionSolver
VolVecType	TsDesc.h	/^  typedef DistVec<double> VolVecType;$/;"	t	class:TsDesc
VolumeData	IoData.h	/^struct VolumeData  {$/;"	s
VolumeData	IoDataCore.C	/^VolumeData::VolumeData()  {$/;"	f	class:VolumeData
VolumeData	Manual/Aerof3d.html	/^<a name="VolumeData"><\/a>$/;"	a
VolumeType	IoData.h	/^  enum VolumeType { CONSTANT_VOLUME = 0, REAL_VOLUME = 1} volumeType;$/;"	g	struct:OneDimensionalInfo
Volumes	IoData.h	/^struct Volumes  {$/;"	s
Volumes	Manual/Aerof3d.html	/^<a name="Volumes"><\/a>$/;"	a
VolumicForceTerm	VolumicForceTerm.h	/^  VolumicForceTerm(IoData &iod){$/;"	f	class:VolumicForceTerm
VolumicForceTerm	VolumicForceTerm.h	/^class VolumicForceTerm {$/;"	c
Vout	DistBcData.h	/^  double Uout[dim], Vout[dim];$/;"	m	class:DistBcData
Vslope	OneDimensionalSolver.h	/^  SVec<double,5> Vslope;$/;"	m	class:OneDimensional
VtBar	DistVMSLESTerm.h	/^  DistSVec<double,dim> *VtBar;$/;"	m	class:DistVMSLESTerm
Vtemp	EmbeddedTsDesc.h	/^  DistSVec<double,dim> Vtemp;     \/\/<! the primitive variables.$/;"	m	class:EmbeddedTsDesc
Vtemp	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> Vtemp;     \/\/<! the primitive variables.$/;"	m	class:MultiPhysicsTsDesc
WALE	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	e	enum:LESModelData::Type
WALE	Manual/Aerof3d.html	/^<a name="WALE"><\/a>$/;"	a
WALL	IoData.h	/^  enum ShapeDerivativeType {WALL=0, VOLUME=1} shapederivativesType;$/;"	e	enum:InputData::ShapeDerivativeType
WALL_FUNCTION	IoData.h	/^  enum Integration {AUTO = 0, WALL_FUNCTION = 1, FULL = 2} integration;$/;"	e	enum:BcsWallData::Integration
WARN_IF_NOT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	51;"	d
WARN_IF_NOT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	54;"	d
WARN_IF_NOT_EFFICIENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	56;"	d
WCYCLE	IoData.h	/^  enum CycleScheme { VCYCLE = 0, WCYCLE = 1} cycle_scheme;$/;"	e	enum:MultiGridData::CycleScheme
WCsDelSq	Domain.h	/^  DistVec<double> *WCsDelSq;$/;"	m	class:Domain
WEAK	IoData.h	/^  enum TurbulenceModelCoupling {WEAK = 0, STRONG = 1} tmcoupling;$/;"	e	enum:ImplicitData::TurbulenceModelCoupling
WEAK	IoData.h	/^  enum ViscousBoundaryCondition {WEAK = 0, STRONG = 1} viscousboundarycondition;$/;"	e	enum:EmbeddedFramework::ViscousBoundaryCondition
WET_SURF_TAG1	StructExc.C	24;"	d	file:
WET_SURF_TAG2	StructExc.C	25;"	d	file:
WET_SURF_TAG3	StructExc.C	26;"	d	file:
WET_SURF_TAG4	StructExc.C	27;"	d	file:
WHICH_UNDEFINED	arpack++/include/arerror.h	/^    WHICH_UNDEFINED     = -104,$/;"	e	enum:ArpackError::ErrorCode
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    enum WORKAROUND {d=TV::dimension};$/;"	g	class:PhysBAM::BOX
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    enum WORKAROUND{d=TV::dimension};$/;"	g	class:PhysBAM::ORIENTED_BOX
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum WORKAROUND {d=TV::m};$/;"	g	class:PhysBAM::RAY
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    enum WORKAROUND {d=TV::m};$/;"	g	class:PhysBAM::IMPLICIT_OBJECT
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    enum WORKAROUND {dimension=d};$/;"	g	class:PhysBAM::SIMPLEX_MESH
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    enum WORKAROUND {d=dimension};$/;"	g	class:PhysBAM::ARRAY_BASE
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    enum WORKAROUND {d=TV::dimension};$/;"	g	class:PhysBAM::RANGE
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    enum WORKAROUND {d=TV::m};$/;"	g	class:PhysBAM::FRAME
WORKAROUND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    enum WORKAROUND {dimension=TV::m+T_SPIN::m,m=dimension};$/;"	g	class:PhysBAM::TWIST
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	g	class:PhysBAM::DIAGONAL_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	g	class:PhysBAM::DIAGONAL_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    enum WORKAROUND1 {m=m_input,n=n_input,size=n_input*m_input};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    enum WORKAROUND1 {m=0,n=0};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    enum WORKAROUND1 {m=0,n=1};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    enum WORKAROUND1 {m=1,n=1};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    enum WORKAROUND1 {m=1,n=2};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    enum WORKAROUND1 {m=3,n=2};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	g	class:PhysBAM::MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	g	class:PhysBAM::SYMMETRIC_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	g	class:PhysBAM::SYMMETRIC_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    enum WORKAROUND1 {m=T_MATRIX::n,n=T_MATRIX::m};$/;"	g	class:PhysBAM::TRANSPOSE_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	g	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	g	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    enum WORKAROUND1 {dimension=d};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    enum WORKAROUND1 {dimension=0};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    enum WORKAROUND1 {dimension=1};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    enum WORKAROUND1 {dimension=2};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    enum WORKAROUND1 {dimension=3};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    enum WORKAROUND2 {m=d};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    enum WORKAROUND2 {m=0};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    enum WORKAROUND2 {m=1};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    enum WORKAROUND2 {m=2};$/;"	g	class:PhysBAM::VECTOR
WORKAROUND2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    enum WORKAROUND2 {m=3};$/;"	g	class:PhysBAM::VECTOR
WPrT	Domain.h	/^  DistVec<double> *WPrT;$/;"	m	class:Domain
WRONG_DATA_TYPE	arpack++/include/arerror.h	/^    WRONG_DATA_TYPE     = -553,$/;"	e	enum:ArpackError::ErrorCode
WRONG_MATRIX_TYPE	arpack++/include/arerror.h	/^    WRONG_MATRIX_TYPE   = -552,$/;"	e	enum:ArpackError::ErrorCode
WTMACH	PostFcn.h	/^                   WTMACH = 22, WTSPEED = 23, VELOCITY_NORM = 24, TEMPERATURE_NORMAL_DERIVATIVE = 25, $/;"	e	enum:PostFcn::ScalarType
WTSPEED	PostFcn.h	/^                   WTMACH = 22, WTSPEED = 23, VELOCITY_NORM = 24, TEMPERATURE_NORMAL_DERIVATIVE = 25, $/;"	e	enum:PostFcn::ScalarType
WaleLESData	IoData.h	/^struct WaleLESData {$/;"	s
WaleLESData	IoDataCore.C	/^WaleLESData::WaleLESData()$/;"	f	class:WaleLESData
WaleLESTerm	WaleLESTerm.C	/^WaleLESTerm::WaleLESTerm(IoData& iod, VarFcn *vf): NavierStokesTerm(iod, vf)$/;"	f	class:WaleLESTerm
WaleLESTerm	WaleLESTerm.h	/^class WaleLESTerm : public NavierStokesTerm {$/;"	c
Wall	Manual/Aerof3d.html	/^<a name="Wall"><\/a>$/;"	a
WallDistanceMethod	Manual/Aerof3d.html	/^<a name="WallDistanceMethod"><\/a>$/;"	a
WallDistanceMethodData	IoData.h	/^struct WallDistanceMethodData {$/;"	s
WallDistanceMethodData	IoDataCore.C	/^WallDistanceMethodData::WallDistanceMethodData()$/;"	f	class:WallDistanceMethodData
WallFcn	WallFcn.h	/^class WallFcn {$/;"	c
WallFcn	WallFcnCore.C	/^WallFcn::WallFcn(IoData &iod, VarFcn *varf, ViscoFcn *visf) : $/;"	f	class:WallFcn
WallFcnKE	WallFcn.h	/^class WallFcnKE : public WallFcn {$/;"	c
WallFcnKE	WallFcnCore.C	/^WallFcnKE::WallFcnKE(IoData &iod, VarFcn *varf, ViscoFcn *visf) : $/;"	f	class:WallFcnKE
WallFcnSA	WallFcn.h	/^class WallFcnSA : public WallFcn {$/;"	c
WallFcnSA	WallFcnCore.C	/^WallFcnSA::WallFcnSA(IoData &iod, VarFcn *varf, ViscoFcn *visf) : $/;"	f	class:WallFcnSA
Warn_If_Not_Overridden	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Warn_If_Not_Overridden(const char* function,const char* file,unsigned int line,const std::type_info& type)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Warning	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.cpp	/^void Warning(const std::string& message,const char* function,const char* file,unsigned int line)$/;"	f	namespace:PhysBAM::DEBUG_UTILITIES
Weighted_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    TV Weighted_Center(const ARRAY<T>& weights)$/;"	f	class:PhysBAM::POINT_CLOUD
Weighted_Center	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/CENTER.h	/^    static TV Weighted_Center(const ARRAY<TV>& X,const ARRAY<typename TV::SCALAR>& weights)$/;"	f	namespace:PhysBAM::POINT_CLOUDS_COMPUTATIONS
Weighted_Normal	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    VECTOR<T,3> Weighted_Normal() const$/;"	f	class:PhysBAM::MATRIX
Weighted_Sum	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	/^    T2 Weighted_Sum(const ARRAY_BASE<T,T_ARRAY1,ID>& weights,const ARRAY_BASE<T2,T_ARRAY2,ID>& array)$/;"	f	namespace:PhysBAM::ARRAYS_COMPUTATIONS
Weights	EmbeddedTsDesc.h	/^  DistVec<double> *Weights;       \/\/<! weights for each node. Used in updating phase change.$/;"	m	class:EmbeddedTsDesc
Weights	LevelSetTsDesc.h	/^  DistVec<double> Weights;$/;"	m	class:LevelSetTsDesc
Weights	MultiPhysicsTsDesc.h	/^  DistVec<double> *Weights;       \/\/<! weights for each node. Used in updating phase change.$/;"	m	class:MultiPhysicsTsDesc
Wextij	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *Wextij;$/;"	m	class:EmbeddedTsDesc
Which-problems-can-AERO-F-actually-solve?	Manual/Aerof3d.html	/^<a name="Which-problems-can-AERO-F-actually-solve?"><\/a>$/;"	a
Which-problems-can-AERO_002dF-actually-solve_003f	Manual/Aerof3d.html	/^<a name="Which-problems-can-AERO_002dF-actually-solve_003f"><\/a>$/;"	a
Window	Communicator.C	/^  Window<Scalar>::Window(Communicator &c, int size, Scalar *s) : com(c) {$/;"	f	class:Communication::Window
Window	Communicator.h	/^  class Window {$/;"	c	namespace:Communication
Wn	MeshMotionHandler.h	/^  double Wn;$/;"	m	class:MeshMotionHandler
WorkspaceAllocate	arpack++/include/arrscomp.h	/^inline void ARrcCompStdEig<ARFLOAT>::WorkspaceAllocate()$/;"	f	class:ARrcCompStdEig
WorkspaceAllocate	arpack++/include/arrseig.h	/^void ARrcStdEig<ARFLOAT, ARTYPE>::WorkspaceAllocate()$/;"	f	class:ARrcStdEig
WorkspaceAllocate	arpack++/include/arrsnsym.h	/^inline void ARrcNonSymStdEig<ARFLOAT>::WorkspaceAllocate()$/;"	f	class:ARrcNonSymStdEig
WorkspaceAllocate	arpack++/include/arrssym.h	/^inline void ARrcSymStdEig<ARFLOAT>::WorkspaceAllocate()$/;"	f	class:ARrcSymStdEig
Wr	OneDimensionalSolver.h	/^  SVec<double,5> Wr;$/;"	m	class:OneDimensional
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	/^    static void Write(std::ostream& output,const ARRAY<T,ID>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY_VIEW.h	/^    static void Write(std::ostream& output,const ARRAY_VIEW<T,ID>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^    static void Write(typename IF<IS_SAME<T,void>::value,UNUSABLE,std::ostream&>::TYPE output,const HASHTABLE<TK,T>& object) \/\/ non-void version$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^    static void Write(typename IF<IS_SAME<T,void>::value,std::ostream&,UNUSABLE>::TYPE output,const HASHTABLE<TK,T>& object) \/\/ void version$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^    static void Write(std::ostream& output,const TWIST<TV>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Write(std::ostream& output,T* const& d)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Write(std::ostream& output,const T& d)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^    static void Write(std::ostream& output,const std::string& d)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    template<class T> void Write(const T& d)$/;"	f	class:PhysBAM::TYPED_OSTREAM
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	/^    static void Write(std::ostream& output,const VECTOR<T,d>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	/^    static void Write(std::ostream& output,const VECTOR<T,0>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	/^    static void Write(std::ostream& output,const VECTOR<T,1>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	/^    static void Write(std::ostream& output,const VECTOR<T,2>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	/^    static void Write(std::ostream& output,const VECTOR<T,3>& object)$/;"	f	class:PhysBAM::Read_Write
Write	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	/^    static void Write(std::ostream& output,const VECTOR_ND<T>& object)$/;"	f	class:PhysBAM::Read_Write
WriteTopFile	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::WriteTopFile(const std::string& fileName) {$/;"	f	class:MultiGridLevel
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Write_Binary(TYPED_OSTREAM& output,const T& d)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Write_Binary(std::ostream& output,const T& d)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(TYPED_OSTREAM& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8,const T9& d9)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8)$/;"	f	namespace:PhysBAM
Write_Binary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline void Write_Binary(std::ostream& output,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8,const T9& d9)$/;"	f	namespace:PhysBAM
Write_Binary_Array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^Write_Binary_Array(std::ostream& output,const T* array,const int number_of_elements)$/;"	f	namespace:PhysBAM
Write_Prefix	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	/^    static void Write_Prefix(std::ostream& output,const ARRAY<T,ID>& object,const ID prefix)$/;"	f	class:PhysBAM::Read_Write
Write_Primitive	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^Write_Primitive(std::ostream& output,const T& d)$/;"	f	namespace:PhysBAM
Write_Primitive	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^inline void Write_Primitive<bool>(std::ostream& output,const bool& d)$/;"	f	namespace:PhysBAM
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const STREAM_TYPE stream_type,const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_File(const std::string& filename,const T1& d1,const T2& d2,const T3& d3,const T4& d4,const T5& d5,const T6& d6,const T7& d7,const T8& d8)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_Text_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_Text_File(const std::string& filename,const T1& d1)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Write_To_Text_File	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^inline void Write_To_Text_File(const std::string& filename,const T1& d1,const T2& d2)$/;"	f	namespace:PhysBAM::FILE_UTILITIES
Ws	GhostPoint.h	/^  double* Ws; 	\/\/ Sum of the weights $/;"	m	class:GhostPoint
Wstarij	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *Wstarij,*Wstarij_nm1;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:EmbeddedTsDesc
Wstarij	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* Wstarij,*Wstarji;$/;"	m	class:MultiGridOperator
Wstarij	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> *Wstarij,*Wstarij_nm1;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:MultiPhysicsTsDesc
WstarijCopy	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *WstarijCopy,*Wstarij_nm1Copy;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:EmbeddedTsDesc
Wstarij_nm1	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *Wstarij,*Wstarij_nm1;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:EmbeddedTsDesc
Wstarij_nm1	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> *Wstarij,*Wstarij_nm1;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:MultiPhysicsTsDesc
Wstarij_nm1Copy	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *WstarijCopy,*Wstarij_nm1Copy;  \/\/<! stores the FS Riemann solution (i->j) along edges$/;"	m	class:EmbeddedTsDesc
Wstarji	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *Wstarji,*Wstarji_nm1;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:EmbeddedTsDesc
Wstarji	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* Wstarij,*Wstarji;$/;"	m	class:MultiGridOperator
Wstarji	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> *Wstarji,*Wstarji_nm1;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:MultiPhysicsTsDesc
WstarjiCopy	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *WstarjiCopy,*Wstarji_nm1Copy;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:EmbeddedTsDesc
Wstarji_nm1	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *Wstarji,*Wstarji_nm1;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:EmbeddedTsDesc
Wstarji_nm1	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> *Wstarji,*Wstarji_nm1;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:MultiPhysicsTsDesc
Wstarji_nm1Copy	EmbeddedTsDesc.h	/^  DistSVec<double,dim> *WstarjiCopy,*Wstarji_nm1Copy;  \/\/<! stores the FS Riemann solution (j->i) along edges$/;"	m	class:EmbeddedTsDesc
Wtemp	EmbeddedTsDesc.h	/^  DistSVec<double,dim> Wtemp;$/;"	m	class:EmbeddedTsDesc
Wtemp	MatVecProd.h	/^    DistSVec<double,dim>* Wtemp;$/;"	m	struct:MatVecProd::_fsi
Wtemp	MatVecProd.h	/^    DistSVec<double,dim>* Wtemp;$/;"	m	struct:MatVecProdMultiPhase::_fsi
Wtemp	MultiPhysicsTsDesc.h	/^  DistSVec<double,dim> Wtemp;$/;"	m	class:MultiPhysicsTsDesc
X	AlternatingLeastSquare/als_lapack.h	/^    double *X;$/;"	m	class:AlternatingLeastSquare
X	FSI/DynamicNodalTransfer.h	/^  double (*X)[3];  \/\/updated node coordinates$/;"	m	class:EmbeddedStructure
X	GappyPreprocessing.h	/^	DistSVec<double,3> &X;$/;"	m	class:GappyPreprocessing
X	GeoState.h	/^  SVec<double,3> * X;$/;"	m	class:GeoState
X	IntersectorFRG/IntersectorFRG.h	/^    DistSVec<double,3> *X; \/\/pointer to fluid node coords$/;"	m	class:DistIntersectorFRG
X	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistSVec<double,3> *X; \/\/pointer to fluid node coords$/;"	m	class:DistIntersectorPhysBAM
X	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	e	enum:SchemeFixData::Symmetry
X	MatVecProd.h	/^  DistSVec<double,3> *X;$/;"	m	class:MatVecProdFD
X	MatVecProd.h	/^  DistSVec<double,3> *X;$/;"	m	class:MatVecProdFDMultiPhase
X	MatVecProd.h	/^  DistSVec<double,3> *X;$/;"	m	class:MatVecProdH2
X	MatVecProd.h	/^  DistSVec<double,3> *X;$/;"	m	class:MatVecProdLS
X	MatVecProd.h	/^  DistSVec<double,3> *X;$/;"	m	class:MatVecProd_dRdX
X	MultiGridLevel.h	/^  Vec3D* X;$/;"	m	struct:MultigridSubdomain
X	OneDimensionalSolver.h	/^    SVec<double,3>* X;$/;"	m	class:OneDimensional::Veval
X	OneDimensionalSolver.h	/^  SVec<double,1> X; \/\/ center of control volumes$/;"	m	class:OneDimensional
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    TV& X(const int i)$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    const TV& X(const int i) const$/;"	f	class:PhysBAM::POINT_SIMPLEX_1D
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^    ARRAY<VECTOR<T,2> > X; \/\/ vertex coordinates$/;"	m	class:PhysBAM::POLYGON
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV& X(const int i)$/;"	f	class:PhysBAM::SEGMENT_2D
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    const TV& X(const int i) const$/;"	f	class:PhysBAM::SEGMENT_2D
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    TV& X(const int i)$/;"	f	class:PhysBAM::TRIANGLE_3D
X	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^    const TV& X(const int i) const$/;"	f	class:PhysBAM::TRIANGLE_3D
X	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    ARRAY<TV> X;$/;"	m	class:PhysBAM::POINT_CLOUD
X	TsDesc.h	/^  PosVecType *X;$/;"	m	class:TsDesc
X0	CorotSolver.h	/^  DistSVec<double,3> X0;$/;"	m	class:CorotSolver
X0	EmbeddedCorotSolver.h	/^  DistSVec<double,3> X0;$/;"	m	class:EmbeddedCorotSolver
X0	FSI/DynamicNodalTransfer.h	/^  double (*X0)[3]; \/\/original node coordinates$/;"	m	class:EmbeddedStructure
X0	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
X0	MeshMotionHandler.h	/^  DistSVec<double,3> X0;$/;"	m	class:MeshMotionHandler
X1	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
XMLARSTR	arpack++/include/arpackf.h	/^extern  struct XMLARSTR { $/;"	s
XScale	FSI/DynamicNodalTransfer.h	/^        const double XScale; \/\/scaling factor for length$/;"	m	class:DynamicNodalTransfer
XScale	FSI/DynamicNodalTransfer.h	/^  double XScale;$/;"	m	class:EmbeddedStructure
X_	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *X_;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
X_norm	AlternatingLeastSquare/als_lapack.h	/^    double X_norm;$/;"	m	class:AlternatingLeastSquare
XandUdot	FSI/DynamicNodalTransfer.h	/^        double *XandUdot; \/\/non-dimensionalized$/;"	m	class:DynamicNodalTransfer
XandUdot	FSI/DynamicNodalTransfer.h	/^  double (*XandUdot)[3]; \/\/displacement and velocity (TODO: this is redundant)$/;"	m	class:EmbeddedStructure
Xc	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> Xc;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Xc	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> Xc;$/;"	m	class:FluidGnatShapeOptimizationHandler
Xc	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> Xc;$/;"	m	class:FluidMetricShapeOptimizationHandler
Xc	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> Xc;$/;"	m	class:FluidRomShapeOptimizationHandler
Xc	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> Xc;$/;"	m	class:FluidShapeOptimizationHandler
Xd	FSI/DynamicNodalTransfer.h	/^  double (*Xd)[3]; \/\/deformed node coordinates$/;"	m	class:EmbeddedStructure
Xdot	DistBcData.h	/^  DistSVec<double,3> Xdot;$/;"	m	class:DistBcData
Xdot	DistGeoState.h	/^  DistSVec<double,3> *Xdot;$/;"	m	class:DistGeoState
Xm	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xm;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Xm	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xm;$/;"	m	class:FluidGnatShapeOptimizationHandler
Xm	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xm;$/;"	m	class:FluidMetricShapeOptimizationHandler
Xm	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xm;$/;"	m	class:FluidRomShapeOptimizationHandler
Xm	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xm;$/;"	m	class:FluidShapeOptimizationHandler
Xminus	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> Xminus;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Xminus	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> Xminus;$/;"	m	class:FluidGnatShapeOptimizationHandler
Xminus	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> Xminus;$/;"	m	class:FluidMetricShapeOptimizationHandler
Xminus	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> Xminus;$/;"	m	class:FluidRomShapeOptimizationHandler
Xminus	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> Xminus;$/;"	m	class:FluidShapeOptimizationHandler
Xn	DistGeoState.h	/^  DistSVec<double,3> *Xn;	\/\/ nodal positions at time n$/;"	m	class:DistGeoState
Xn	IntersectorFRG/IntersectorFRG.h	/^    DistSVec<double,3> *Xn; \/\/pointer to fluid node coords at previous time$/;"	m	class:DistIntersectorFRG
Xn	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistSVec<double,3> *Xn; \/\/pointer to fluid node coords at previous time$/;"	m	class:DistIntersectorPhysBAM
Xn	MultiGridLevel.h	/^    DistSVec<double, 3>* Xn;$/;"	m	class:MultiGridLevel
Xnm1	DistGeoState.h	/^  DistSVec<double,3> *Xnm1;	\/\/ nodal positions at time n-1$/;"	m	class:DistGeoState
Xnm2	DistGeoState.h	/^  DistSVec<double,3> *Xnm2;	\/\/ nodal positions at time n-2$/;"	m	class:DistGeoState
Xp	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xp;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Xp	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xp;$/;"	m	class:FluidGnatShapeOptimizationHandler
Xp	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xp;$/;"	m	class:FluidMetricShapeOptimizationHandler
Xp	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xp;$/;"	m	class:FluidRomShapeOptimizationHandler
Xp	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Xp;$/;"	m	class:FluidShapeOptimizationHandler
Xplus	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> Xplus;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Xplus	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> Xplus;$/;"	m	class:FluidGnatShapeOptimizationHandler
Xplus	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> Xplus;$/;"	m	class:FluidMetricShapeOptimizationHandler
Xplus	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> Xplus;$/;"	m	class:FluidRomShapeOptimizationHandler
Xplus	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> Xplus;$/;"	m	class:FluidShapeOptimizationHandler
Xr	MeshMotionHandler.h	/^  DistSVec<double,3> Xr;$/;"	m	class:RigidMeshMotionHandler
Xref	Modal.h	/^    DistSVec<double,3> Xref;$/;"	m	class:ModalSolver
Xref	NonlinearRomOffline.h	/^    DistSVec<double,3> Xref;$/;"	m	class:NonlinearRomOfflineSolver
Xs	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *Xs;$/;"	m	class:DistIntersectorFRG
Xs	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *Xs;$/;"	m	class:DistIntersectorPhysBAM
Xs	TsDesc.h	/^  PosVecType *Xs;$/;"	m	class:TsDesc
Xs0	EmbeddedCorotSolver.h	/^  double *Xs0;$/;"	m	class:EmbeddedCorotSolver
Xs0	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *Xs0;$/;"	m	class:DistIntersectorFRG
Xs0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *Xs0;$/;"	m	class:DistIntersectorPhysBAM
Xs0	MeshMotionHandler.h	/^  double *Xs0;$/;"	m	class:EmbeddedALEMeshMotionHandler
Xs_n	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *Xs_n;$/;"	m	class:DistIntersectorFRG
Xs_n	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *Xs_n;$/;"	m	class:DistIntersectorPhysBAM
Xs_np1	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *Xs_np1;$/;"	m	class:DistIntersectorFRG
Xs_np1	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *Xs_np1;$/;"	m	class:DistIntersectorPhysBAM
Xsa	DistGeoState.h	/^  DistSVec<double,3> *Xsa;$/;"	m	class:DistGeoState
Xsave	DistGeoState.h	/^  DistSVec<double,3> *Xsave;$/;"	m	class:DistGeoState
Xsdot	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *Xsdot; \/\/velocity$/;"	m	class:DistIntersectorFRG
Xsdot	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *Xsdot; \/\/velocity$/;"	m	class:DistIntersectorPhysBAM
Xtilde	CorotSolver.h	/^  DistSVec<double,3> Xtilde;$/;"	m	class:CorotSolver
Y	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	e	enum:SchemeFixData::Symmetry
Y	OneDimensionalSolver.h	/^  SVec<double,1> Y; \/\/ control surface locations$/;"	m	class:OneDimensional
Y0	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
Y1	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
YES	IoData.h	/^  enum CheckFinalRes {NO = 0, YES = 1} checkFinalRes;$/;"	e	enum:KspData::CheckFinalRes
YES	IoData.h	/^  enum FailSafe {NO = 0, YES = 1, ALWAYS = 2} failsafe;$/;"	e	enum:NewtonData::FailSafe
YES	IoData.h	/^  enum ForceResults {NO = 0, YES = 1} forceResults;$/;"	e	enum:SurfaceData::ForceResults
YES	IoData.h	/^  enum YesNo {YES = 0, NO = 1 };$/;"	e	enum:LiquidModelData::YesNo
YES_GAPPYRES	IoData.h	/^  enum ComputeGappyRes {NO_GAPPYRES = 0, YES_GAPPYRES  = 1} computeGappyRes;$/;"	e	enum:GappyConstructionData::ComputeGappyRes
YES_HF	IoData.h	/^  enum HeatFluxResults {UNSPECIFIED_HF = -1, NO_HF = 0, YES_HF = 1} heatFluxResults;$/;"	e	enum:SurfaceData::HeatFluxResults
YES_TYPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^typedef char YES_TYPE;$/;"	t	namespace:PhysBAM
YesNo	IoData.h	/^  enum YesNo {YES = 0, NO = 1 };$/;"	g	struct:LiquidModelData
Z	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> *Z;$/;"	m	class:FluidCollocationShapeOptimizationHandler
Z	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> *Z;$/;"	m	class:FluidGnatShapeOptimizationHandler
Z	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> *Z;$/;"	m	class:FluidMetricShapeOptimizationHandler
Z	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> *Z;$/;"	m	class:FluidRomShapeOptimizationHandler
Z	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *Z;$/;"	m	class:FluidShapeOptimizationHandler
Z	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	e	enum:SchemeFixData::Symmetry
Z0	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
Z1	IoData.h	/^  double X0,Y0,Z0,X1,Y1,Z1;$/;"	m	struct:PrismData
ZERO	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^struct ZERO$/;"	s	namespace:PhysBAM
Zero_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    static INTERVAL Zero_Box()$/;"	f	class:PhysBAM::INTERVAL
Zero_Box	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    static RANGE<TV> Zero_Box()$/;"	f	class:PhysBAM::RANGE
_ACC_FORCED_	IoData.h	/^                _UNSTEADY_AEROTHERMOELASTIC_ = 9, _FORCED_ = 10, _ACC_FORCED_ = 11,$/;"	e	enum:ProblemData::AllType
_ACC_UNSTEADY_	IoData.h	/^  enum AllType {_STEADY_ = 0, _UNSTEADY_ = 1, _ACC_UNSTEADY_ = 2, _STEADY_AEROELASTIC_ = 3,$/;"	e	enum:ProblemData::AllType
_ACC_UNSTEADY_AEROELASTIC_	IoData.h	/^                _UNSTEADY_AEROELASTIC_ = 4, _ACC_UNSTEADY_AEROELASTIC_ = 5,$/;"	e	enum:ProblemData::AllType
_ACC_UNSTEADY_NONLINEAR_ROM_	IoData.h	/^                _AEROELASTIC_ANALYSIS_ = 34, _GAM_CONSTRUCTION_ = 35, _ACC_UNSTEADY_NONLINEAR_ROM_ = 36,$/;"	e	enum:ProblemData::AllType
_AEROELASTIC_ANALYSIS_	IoData.h	/^                _AEROELASTIC_ANALYSIS_ = 34, _GAM_CONSTRUCTION_ = 35, _ACC_UNSTEADY_NONLINEAR_ROM_ = 36,$/;"	e	enum:ProblemData::AllType
_AEROELASTIC_SHAPE_OPTIMIZATION_	IoData.h	/^                _ROB_INNER_PRODUCT_ = 30, _AERO_ACOUSTIC_ = 31, _SHAPE_OPTIMIZATION_ = 32, _AEROELASTIC_SHAPE_OPTIMIZATION_ = 33,$/;"	e	enum:ProblemData::AllType
_AERO_ACOUSTIC_	IoData.h	/^                _ROB_INNER_PRODUCT_ = 30, _AERO_ACOUSTIC_ = 31, _SHAPE_OPTIMIZATION_ = 32, _AEROELASTIC_SHAPE_OPTIMIZATION_ = 33,$/;"	e	enum:ProblemData::AllType
_ARPACKUTIL_H_	ArpackUtil.h	2;"	d
_ASSIGNER_H_	parser/Assigner.h	2;"	d
_BCOND_H_	BCond.h	2;"	d
_BC_APPLIER_H_	BCApplier.h	2;"	d
_BC_DATA_H_	BcData.h	2;"	d
_BC_DEF_H_	BcDef.h	2;"	d
_BC_FCN_H_	BcFcn.h	2;"	d
_BIN_FILE_HANDLER_H_	BinFileHandler.h	2;"	d
_BLOCK_ALLOC_H_	BlockAlloc.h	2;"	d
_C	arpack++/include/arlsupm.h	/^    _C,         \/* single complex *\/$/;"	e	enum:__anon43
_COMMUNICATOR_H_	Communicator.h	2;"	d
_CONNECTIVITY_H_	Connectivity.h	2;"	d
_COROT_SOLVER_H_	CorotSolver.h	2;"	d
_CURVATURE_DETECTION_H_	CurvatureDetection.h	2;"	d
_D	arpack++/include/arlsupm.h	/^    _D,         \/* double *\/$/;"	e	enum:__anon43
_DEBUG_TOOLS_H_	DebugTools.h	4;"	d
_DENSE_MATRIX_H_	DenseMatrix.h	2;"	d
_DENSE_MATRIX_OPS_H_	DenseMatrixOps.h	2;"	d
_DES_TERM_H_	DESTerm.h	2;"	d
_DIAG_MATRIX_H_	DiagMatrix.h	2;"	d
_DICTIONARY	parser/Dictionary.h	2;"	d
_DIST_BC_DATA_H_	DistBcData.h	2;"	d
_DIST_DYNAMIC_LES_TERM_H_	DistDynamicLESTerm.h	2;"	d
_DIST_DYNAMIC_VMS_TERM_H_	DistDynamicVMSTerm.h	2;"	d
_DIST_EDGE_GRAD_H_	DistEdgeGrad.h	2;"	d
_DIST_EMBEDDED_VECTOR_H_	DistEmbeddedVector.h	2;"	d
_DIST_EXACT_RIEMANN_H_	DistExactRiemannSolver.h	2;"	d
_DIST_EXTRAPOLATION_H_	DistExtrapolation.h	2;"	d
_DIST_GEO_STATE_H_	DistGeoState.h	2;"	d
_DIST_INFO_H_	DistInfo.h	2;"	d
_DIST_MACRO_CELL__H_	DistMacroCell.h	2;"	d
_DIST_MATRIX_H_	DistMatrix.h	2;"	d
_DIST_MVP_MATRIX_H_	DistMvpMatrix.h	2;"	d
_DIST_NODAL_GRAD_H_	DistNodalGrad.h	2;"	d
_DIST_TIME_STATE_H_	DistTimeState.h	2;"	d
_DIST_VECTOR_H_	DistVector.h	2;"	d
_DIST_VMS_LES_TERM_H_	DistVMSLESTerm.h	2;"	d
_DNDGRAD_TMPL_	DistDynamicVMSTerm.h	18;"	d
_DNDGRAD_TMPL_	DistNodalGrad.h	19;"	d
_DNDGRAD_TMPL_	Domain.h	69;"	d
_DNDGRAD_TMPL_	LevelSet.h	13;"	d
_DNDGRAD_TMPL_	SpaceOperator.h	41;"	d
_DOMAIN_H_	Domain.h	2;"	d
_DYNAMIC_LES_TERM_H_	DynamicLESTerm.h	2;"	d
_DYNAMIC_VMS_TERM_H_	DynamicVMSTerm.h	2;"	d
_EDGE_GALERKIN_H_	EdgeGalerkin.h	2;"	d
_EDGE_GRAD_H_	EdgeGrad.h	2;"	d
_EDGE_H_	Edge.h	2;"	d
_ELEMTET_H_	ElemTet.h	2;"	d
_ELEM_H_	Elem.h	2;"	d
_EMBCOROT_SOLVER_H_	EmbeddedCorotSolver.h	2;"	d
_EMBEDDED_ALS_ROM_	IoData.h	/^                _EMBEDDED_ALS_ROM_ = 41 \/* Lei Lei, 02\/13\/2016 *\/,_EMBEDDED_ALS_ROM_ONLINE_ = 42 \/* Lei Lei, 05\/15\/2016 *\/ } alltype;$/;"	e	enum:ProblemData::AllType
_EMBEDDED_ALS_ROM_ONLINE_	IoData.h	/^                _EMBEDDED_ALS_ROM_ = 41 \/* Lei Lei, 02\/13\/2016 *\/,_EMBEDDED_ALS_ROM_ONLINE_ = 42 \/* Lei Lei, 05\/15\/2016 *\/ } alltype;$/;"	e	enum:ProblemData::AllType
_EMBEDDED_ALTERNATING_LEAST_SQUARE_H	EmbeddedAlternatingLeastSquare.h	6;"	d
_EMBEDDED_TS_DESC_H_	EmbeddedTsDesc.h	2;"	d
_EMB_FLUID_SHAPE_OPTIMIZATION_HANDLER_H_	EmbeddedFluidShapeOptimizationHandler.h	2;"	d
_ERROR_HANDLER_H_	ErrorHandler.h	2;"	d
_EXACT_RIEMANN_SOLVER_H	ExactRiemannSolver.h	2;"	d
_EXPLICIT_EMBEDDED_TS_DESC_H_	ExplicitEmbeddedTsDesc.h	2;"	d
_EXPLICIT_LEVELSET_TS_DESC_H_	ExplicitLevelSetTsDesc.h	18;"	d
_EXPLICIT_MULTIPHYSICS_TS_DESC_H_	ExplicitMultiPhysicsTsDesc.h	2;"	d
_EXPLICIT_TS_DESC_H_	ExplicitTsDesc.h	2;"	d
_EXTRAPOLATION_H_	Extrapolation.h	2;"	d
_FACETRIA_H_	FaceTria.h	2;"	d
_FACE_H_	Face.h	2;"	d
_FEM_EQUATION_TERM_DESC_H_	FemEquationTermDesc.h	2;"	d
_FEM_EQUATION_TERM_H_	FemEquationTerm.h	2;"	d
_FLOODFILL_H_	IntersectorPhysBAM/FloodFill.h	2;"	d
_FLUID_COLLOCATION_SHAPE_OPTIMIZATION_HANDLER_H_	FluidCollocationShapeOptimizationHandler.h	2;"	d
_FLUID_GNAT_SHAPE_OPTIMIZATION_HANDLER_H_	FluidGnatShapeOptimizationHandler.h	2;"	d
_FLUID_METRIC_SHAPE_OPTIMIZATION_HANDLER_H_	FluidMetricShapeOptimizationHandler.h	2;"	d
_FLUID_ROM_SHAPE_OPTIMIZATION_HANDLER_H_	FluidRomShapeOptimizationHandler.h	2;"	d
_FLUID_SELECTOR_H_	FluidSelector.h	2;"	d
_FLUID_SHAPE_OPTIMIZATION_HANDLER_H_	FluidShapeOptimizationHandler.h	2;"	d
_FLUX_FCN_BASE_H_	FluxFcnBase.h	2;"	d
_FLUX_FCN_DESC_H_	FluxFcnDesc.h	2;"	d
_FLUX_FCN_DESC_JWL_H_	FluxFcnDescJwl.h	2;"	d
_FLUX_FCN_DESC_SG_H_	FluxFcnDescSG.h	2;"	d
_FLUX_FCN_DESC_TAIT_H_	FluxFcnDescTait.h	2;"	d
_FLUX_FCN_H_	FluxFcn.h	2;"	d
_FORCED_	IoData.h	/^                _UNSTEADY_AEROTHERMOELASTIC_ = 9, _FORCED_ = 10, _ACC_FORCED_ = 11,$/;"	e	enum:ProblemData::AllType
_FORCED_LINEARIZED_	IoData.h	/^                _ROM_AEROELASTIC_ = 17, _ROM_ = 18, _FORCED_LINEARIZED_ = 19,$/;"	e	enum:ProblemData::AllType
_FORCED_NONLINEAR_ROM_	IoData.h	/^                _STEADY_NONLINEAR_ROM_ = 37, _FORCED_NONLINEAR_ROM_ = 38, _ROM_SHAPE_OPTIMIZATION_ = 39, _STEADY_NONLINEAR_ROM_POST_ = 40,$/;"	e	enum:ProblemData::AllType
_GAM_CONSTRUCTION_	IoData.h	/^                _AEROELASTIC_ANALYSIS_ = 34, _GAM_CONSTRUCTION_ = 35, _ACC_UNSTEADY_NONLINEAR_ROM_ = 36,$/;"	e	enum:ProblemData::AllType
_GAPPY_H_	GappyPreprocessing.h	2;"	d
_GEN_MATRIX_H_	GenMatrix.h	2;"	d
_GEO_DATA_H_	GeoData.h	2;"	d
_GEO_SOURCE_H_	GeoSource.h	2;"	d
_GEO_STATE_H_	GeoState.h	2;"	d
_GHOST_POINT_H_	GhostPoint.h	2;"	d
_HEAT_TRANSFER_HANDLER_H_	HeatTransferHandler.h	2;"	d
_HIGHER_ORDER_FSI_H_	HigherOrderFSI.h	2;"	d
_IMPLICIT_COUPLED_TS_DESC_H_	ImplicitCoupledTsDesc.h	2;"	d
_IMPLICIT_LEVELSET_TS_DESC_H_	ImplicitLevelSetTsDesc.h	2;"	d
_IMPLICIT_MULTIPHYSICS_TS_DESC_H_	ImplicitMultiPhysicsTsDesc.h	2;"	d
_IMPLICIT_PG_TS_DESC_H_	ImplicitPGTsDesc.h	2;"	d
_IMPLICIT_ROM_POSTPRO_TS_DESC_H_	ImplicitRomPostproTsDesc.h	2;"	d
_IMPLICIT_ROM_TS_DESC_H_	ImplicitRomTsDesc.h	2;"	d
_IMPLICIT_SEG_TS_DESC_H_	ImplicitSegTsDesc.h	2;"	d
_IMPLICIT_TS_DESC_H_	ImplicitTsDesc.h	2;"	d
_INLET_NODE_H_	InletNode.h	2;"	d
_INTERPOLATION_	IoData.h	/^                _INTERPOLATION_ = 20, _NONLINEAR_EIGEN_ERROR_INDICATOR_ = 21,$/;"	e	enum:ProblemData::AllType
_INTERSECTORFRG_H_	IntersectorFRG/IntersectorFRG.h	2;"	d
_INTERSECTORPHYSBAM_H_	IntersectorPhysBAM/IntersectorPhysBAM.h	2;"	d
_IO_DATA_H_	IoData.h	2;"	d
_KD_TREE_	IntersectorFRG/Geometry/KDTree.h	2;"	d
_KIRCHHOFF_INTEGRATOR_H	KirchhoffIntegrator.h	2;"	d
_KSPSLVR_TMPL_	FluidShapeOptimizationHandler.h	21;"	d
_KSPSLVR_TMPL_	ImplicitCoupledTsDesc.h	12;"	d
_KSPSLVR_TMPL_	ImplicitLevelSetTsDesc.h	17;"	d
_KSPSLVR_TMPL_	ImplicitSegTsDesc.h	10;"	d
_KSPSLVR_TMPL_	ImplicitTsDesc.h	19;"	d
_KSPSLVR_TMPL_	KspSolver.h	17;"	d
_KSPSLVR_TMPL_	MeshMotionSolver.h	21;"	d
_KSP_BINARY_OUTPUT_H_	KspBinaryOutput.h	2;"	d
_KSP_CONV_CRITERION_H_	KspConvCriterion.h	2;"	d
_KSP_MG_PREC_H_	MultiGridPrec.h	2;"	d
_KSP_PREC_H_	KspPrec.h	2;"	d
_KSP_SOLVER_H_	KspSolver.h	2;"	d
_K_EPSILON_TERM_H_	KEpsilonTerm.h	2;"	d
_LEVELSETSOLVER_H_	Solvers/LevelSetSolver.h	2;"	d
_LEVELSET_TS_DESC_H_	LevelSetTsDesc.h	2;"	d
_LEVEL_SET_H_	LevelSet.h	2;"	d
_LEVEL_SET_STRUCTURE_H_	LevelSet/LevelSetStructure.h	2;"	d
_LOCAL_RIEMANN_DESC_H	LocalRiemannDesc.h	2;"	d
_LOCAL_RIEMANN_H	LocalRiemann.h	2;"	d
_LOW_MACH_PREC_H	LowMachPrec.h	44;"	d
_MACRO_CELL_H_	MacroCell.h	2;"	d
_MAP_FACE_H_	MapFace.h	2;"	d
_MATCH_NODE_H_	MatchNode.h	2;"	d
_MAT_VEC_PROD_H_	MatVecProd.h	2;"	d
_MEMORY_POOL_H_	MemoryPool.h	2;"	d
_MESH_MOTION_HANDLER_H_	MeshMotionHandler.h	2;"	d
_MESH_MOTION_SOLVER_H_	MeshMotionSolver.h	2;"	d
_MODAL_H_	Modal.h	2;"	d
_MULTIGRID_LEVEL_H_	MultiGridLevel.h	2;"	d
_MULTIGRID_LEVEL_SET_STRUCTURE_H_	LevelSet/MultiGridLevelSetStructure.h	2;"	d
_MULTIGRID_SMOOTHING_MATRIX_H_	MultiGridSmoothingMatrix.h	2;"	d
_MULTIPHYSICS_TS_DESC_H_	MultiPhysicsTsDesc.h	2;"	d
_MULTIPLE_ICS_FALSE_	IoData.h	/^  enum SolveWithMultipleICs {_MULTIPLE_ICS_FALSE_ = 0, _MULTIPLE_ICS_TRUE_ = 1} solveWithMultipleICs;$/;"	e	enum:ProblemData::SolveWithMultipleICs
_MULTIPLE_ICS_TRUE_	IoData.h	/^  enum SolveWithMultipleICs {_MULTIPLE_ICS_FALSE_ = 0, _MULTIPLE_ICS_TRUE_ = 1} solveWithMultipleICs;$/;"	e	enum:ProblemData::SolveWithMultipleICs
_MVP_MATRIX_H_	MvpMatrix.h	2;"	d
_NAVIERSTOKESCOUPLEDSOLVER_H_	Solvers/NavierStokesCoupledSolver.h	2;"	d
_NAVIERSTOKESSEGSOLVER_H_	Solvers/NavierStokesSegSolver.h	2;"	d
_NAVIER_STOKES_EMBEDDED_COUPLEDSOLVER_H_	Solvers/NavierStokesEmbeddedCoupledSolver.h	2;"	d
_NAVIER_STOKES_EMBEDDED_H_	Solvers/NavierStokesEmbedded.h	2;"	d
_NAVIER_STOKES_EMBEDDED_H_	Solvers/NavierStokesMultiPhysicsEmbedded.h	2;"	d
_NAVIER_STOKES_EMBEDDED_SEGSOLVER_H_	Solvers/NavierStokesEmbeddedSegSolver.h	2;"	d
_NAVIER_STOKES_TERM_H_	NavierStokesTerm.h	2;"	d
_NDGRAD_TMPL_	DistNodalGrad.h	11;"	d
_NDGRAD_TMPL_	Edge.h	46;"	d
_NDGRAD_TMPL_	NodalGrad.h	8;"	d
_NEWTON_SOLVER_H_	NewtonSolver.h	2;"	d
_NLROM_H_	NonlinearRomOffline.h	2;"	d
_NODAL_GRAD_H_	NodalGrad.h	2;"	d
_NODE_H_	Node.h	2;"	d
_NONLINEAR_EIGEN_ERROR_INDICATOR_	IoData.h	/^                _INTERPOLATION_ = 20, _NONLINEAR_EIGEN_ERROR_INDICATOR_ = 21,$/;"	e	enum:ProblemData::AllType
_NONLINEAR_ROM_DATABASE_CONSTRUCTION_H_	NonlinearRomDatabaseConstruction.h	2;"	d
_NONLINEAR_ROM_H_	NonlinearRom.h	2;"	d
_NONLINEAR_ROM_OFFLINE_	IoData.h	/^                _UNSTEADY_LINEARIZED_ = 15, _NONLINEAR_ROM_OFFLINE_ = 16,$/;"	e	enum:ProblemData::AllType
_NONLINEAR_ROM_ONLINE_III_H_	NonlinearRomOnlineIII.h	2;"	d
_NONLINEAR_ROM_ONLINE_II_H_	NonlinearRomOnlineII.h	2;"	d
_NONLINEAR_ROM_PREPROCESSING_	IoData.h	/^                _SPARSEGRIDGEN_ = 22, _ONE_DIMENSIONAL_ = 23, _UNSTEADY_NONLINEAR_ROM_ = 24, _NONLINEAR_ROM_PREPROCESSING_ = 25,$/;"	e	enum:ProblemData::AllType
_ODE_INTEGRATOR_H	ODEIntegrator.h	7;"	d
_ONE_DIMENSIONAL_	IoData.h	/^                _SPARSEGRIDGEN_ = 22, _ONE_DIMENSIONAL_ = 23, _UNSTEADY_NONLINEAR_ROM_ = 24, _NONLINEAR_ROM_PREPROCESSING_ = 25,$/;"	e	enum:ProblemData::AllType
_ONE_DIMENSIONAL_SOLVER_H_	OneDimensionalSolver.h	2;"	d
_ONE_DIMENSIONAL_SOURCE_TERM_H_	OneDimensionalSourceTerm.h	2;"	d
_PARALLEL_ROM_H_	ParallelRom.h	2;"	d
_POD_CONSTRUCTION_	IoData.h	/^                _SURFACE_MESH_CONSTRUCTION_ = 26, _SAMPLE_MESH_SHAPE_CHANGE_ = 27, _UNSTEADY_NONLINEAR_ROM_POST_ = 28, _POD_CONSTRUCTION_ = 29, $/;"	e	enum:ProblemData::AllType
_POLYGONRECONSTRUCTIONDATA_H_	PolygonReconstructionData.h	2;"	d
_POST_FCN_H_	PostFcn.h	2;"	d
_POST_OPERATOR_H_	PostOperator.h	2;"	d
_QUADRATURE_H_	Quadrature.h	2;"	d
_RBM_	IoData.h	/^                _ROLL_ = 12, _RBM_ = 13, _UNSTEADY_LINEARIZED_AEROELASTIC_ = 14,$/;"	e	enum:ProblemData::AllType
_RECTANGULAR_SPARSE_MATRIX_H_	RectangularSparseMatrix.h	2;"	d
_REC_FCN_DESC_H_	RecFcnDesc.h	2;"	d
_REC_FCN_H_	RecFcn.h	2;"	d
_REDUCED_MESH_SHAPE_CHANGER_H_	ReducedMeshShapeChanger.h	2;"	d
_REF_VAL_H_	RefVal.h	2;"	d
_REF_VECTOR_H_	RefVector.h	2;"	d
_RESIZE_ARRAY_H_	ResizeArray.h	2;"	d
_ROB_INNER_PRODUCT_	IoData.h	/^                _ROB_INNER_PRODUCT_ = 30, _AERO_ACOUSTIC_ = 31, _SHAPE_OPTIMIZATION_ = 32, _AEROELASTIC_SHAPE_OPTIMIZATION_ = 33,$/;"	e	enum:ProblemData::AllType
_ROETURKELJAC5_H_	AutoDiff/roeturkeljac5.h	2;"	d
_ROLL_	IoData.h	/^                _ROLL_ = 12, _RBM_ = 13, _UNSTEADY_LINEARIZED_AEROELASTIC_ = 14,$/;"	e	enum:ProblemData::AllType
_ROM_	IoData.h	/^                _ROM_AEROELASTIC_ = 17, _ROM_ = 18, _FORCED_LINEARIZED_ = 19,$/;"	e	enum:ProblemData::AllType
_ROM_AEROELASTIC_	IoData.h	/^                _ROM_AEROELASTIC_ = 17, _ROM_ = 18, _FORCED_LINEARIZED_ = 19,$/;"	e	enum:ProblemData::AllType
_ROM_SHAPE_OPTIMIZATION_	IoData.h	/^                _STEADY_NONLINEAR_ROM_ = 37, _FORCED_NONLINEAR_ROM_ = 38, _ROM_SHAPE_OPTIMIZATION_ = 39, _STEADY_NONLINEAR_ROM_POST_ = 40,$/;"	e	enum:ProblemData::AllType
_S	arpack++/include/arlsupm.h	/^    _S,         \/* single *\/$/;"	e	enum:__anon43
_SAMPLE_MESH_SHAPE_CHANGE_	IoData.h	/^                _SURFACE_MESH_CONSTRUCTION_ = 26, _SAMPLE_MESH_SHAPE_CHANGE_ = 27, _UNSTEADY_NONLINEAR_ROM_POST_ = 28, _POD_CONSTRUCTION_ = 29, $/;"	e	enum:ProblemData::AllType
_SA_TERM_H_	SpalartAllmarasTerm.h	2;"	d
_SHAPE_OPTIMIZATION_	IoData.h	/^                _ROB_INNER_PRODUCT_ = 30, _AERO_ACOUSTIC_ = 31, _SHAPE_OPTIMIZATION_ = 32, _AEROELASTIC_SHAPE_OPTIMIZATION_ = 33,$/;"	e	enum:ProblemData::AllType
_SMAGORINSKY_LES_TERM_H_	SmagorinskyLESTerm.h	2;"	d
_SOLVERS_H_	Solvers/Solvers.h	77;"	d
_SPACEDERIVATIVES_H_	AutoDiff/SpaceDerivatives.h	2;"	d
_SPACE_OPERATOR_H_	SpaceOperator.h	2;"	d
_SPARSEGRIDGENERATOR_DESC_H_	SparseGridGeneratorDesc.h	2;"	d
_SPARSEGRIDGEN_	IoData.h	/^                _SPARSEGRIDGEN_ = 22, _ONE_DIMENSIONAL_ = 23, _UNSTEADY_NONLINEAR_ROM_ = 24, _NONLINEAR_ROM_PREPROCESSING_ = 25,$/;"	e	enum:ProblemData::AllType
_SPARSE_MATRIX_H_	SparseMatrix.h	2;"	d
_SPATIOTEMPORALFUNCTION_H_	AutoDiff/Function.h	2;"	d
_STEADY_	IoData.h	/^  enum AllType {_STEADY_ = 0, _UNSTEADY_ = 1, _ACC_UNSTEADY_ = 2, _STEADY_AEROELASTIC_ = 3,$/;"	e	enum:ProblemData::AllType
_STEADY_AEROELASTIC_	IoData.h	/^  enum AllType {_STEADY_ = 0, _UNSTEADY_ = 1, _ACC_UNSTEADY_ = 2, _STEADY_AEROELASTIC_ = 3,$/;"	e	enum:ProblemData::AllType
_STEADY_AEROTHERMOELASTIC_	IoData.h	/^                _STEADY_THERMO_ = 6, _UNSTEADY_THERMO_ = 7, _STEADY_AEROTHERMOELASTIC_ = 8,$/;"	e	enum:ProblemData::AllType
_STEADY_NONLINEAR_ROM_	IoData.h	/^                _STEADY_NONLINEAR_ROM_ = 37, _FORCED_NONLINEAR_ROM_ = 38, _ROM_SHAPE_OPTIMIZATION_ = 39, _STEADY_NONLINEAR_ROM_POST_ = 40,$/;"	e	enum:ProblemData::AllType
_STEADY_NONLINEAR_ROM_POST_	IoData.h	/^                _STEADY_NONLINEAR_ROM_ = 37, _FORCED_NONLINEAR_ROM_ = 38, _ROM_SHAPE_OPTIMIZATION_ = 39, _STEADY_NONLINEAR_ROM_POST_ = 40,$/;"	e	enum:ProblemData::AllType
_STEADY_THERMO_	IoData.h	/^                _STEADY_THERMO_ = 6, _UNSTEADY_THERMO_ = 7, _STEADY_AEROTHERMOELASTIC_ = 8,$/;"	e	enum:ProblemData::AllType
_STIFF_MAT_H_	StiffMatrix.h	2;"	d
_STRING_MANAGER_H_	parser/StringManager.h	2;"	d
_STRUCT_EXC_H_	StructExc.h	2;"	d
_SUBDOMAIN_H_	SubDomain.h	2;"	d
_SURFACE_MESH_CONSTRUCTION_	IoData.h	/^                _SURFACE_MESH_CONSTRUCTION_ = 26, _SAMPLE_MESH_SHAPE_CHANGE_ = 27, _UNSTEADY_NONLINEAR_ROM_POST_ = 28, _POD_CONSTRUCTION_ = 29, $/;"	e	enum:ProblemData::AllType
_SURF_MESH_GEN_H_	SurfMeshGen.h	2;"	d
_THERMAL_COND_FCN_H_	ThermalCondFcn.h	2;"	d
_TIMER_H_	Timer.h	2;"	d
_TIME_DATA_H_	TimeData.h	2;"	d
_TIME_STATE_H_	TimeState.h	2;"	d
_TRIANGULATEDSURFACE_H_	TriangulatedSurface.h	2;"	d
_TS_DESC_H_	TsDesc.h	2;"	d
_TS_OUTPUT_H_	TsOutput.h	2;"	d
_TS_PARAMETERS_H_	TsParameters.h	2;"	d
_TS_RESTART_H_	TsRestart.h	2;"	d
_TS_SOLVER_H_	TsSolver.h	2;"	d
_UH_DEBUG_	KirchhoffIntegrator.C	27;"	d	file:
_UNSTEADY_	IoData.h	/^  enum AllType {_STEADY_ = 0, _UNSTEADY_ = 1, _ACC_UNSTEADY_ = 2, _STEADY_AEROELASTIC_ = 3,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_AEROELASTIC_	IoData.h	/^                _UNSTEADY_AEROELASTIC_ = 4, _ACC_UNSTEADY_AEROELASTIC_ = 5,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_AEROTHERMOELASTIC_	IoData.h	/^                _UNSTEADY_AEROTHERMOELASTIC_ = 9, _FORCED_ = 10, _ACC_FORCED_ = 11,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_LINEARIZED_	IoData.h	/^                _UNSTEADY_LINEARIZED_ = 15, _NONLINEAR_ROM_OFFLINE_ = 16,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_LINEARIZED_AEROELASTIC_	IoData.h	/^                _ROLL_ = 12, _RBM_ = 13, _UNSTEADY_LINEARIZED_AEROELASTIC_ = 14,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_NONLINEAR_ROM_	IoData.h	/^                _SPARSEGRIDGEN_ = 22, _ONE_DIMENSIONAL_ = 23, _UNSTEADY_NONLINEAR_ROM_ = 24, _NONLINEAR_ROM_PREPROCESSING_ = 25,$/;"	e	enum:ProblemData::AllType
_UNSTEADY_NONLINEAR_ROM_POST_	IoData.h	/^                _SURFACE_MESH_CONSTRUCTION_ = 26, _SAMPLE_MESH_SHAPE_CHANGE_ = 27, _UNSTEADY_NONLINEAR_ROM_POST_ = 28, _POD_CONSTRUCTION_ = 29, $/;"	e	enum:ProblemData::AllType
_UNSTEADY_THERMO_	IoData.h	/^                _STEADY_THERMO_ = 6, _UNSTEADY_THERMO_ = 7, _STEADY_AEROTHERMOELASTIC_ = 8,$/;"	e	enum:ProblemData::AllType
_VAR_FCN_BASE_H_	VarFcnBase.h	2;"	d
_VAR_FCN_H_	VarFcn.h	2;"	d
_VAR_FCN_JWL_H	VarFcnJwl.h	2;"	d
_VAR_FCN_SGEULER_H	VarFcnSGEuler.h	2;"	d
_VAR_FCN_SGKE_H	VarFcnSGKE.h	2;"	d
_VAR_FCN_SGSA_H	VarFcnSGSA.h	2;"	d
_VAR_FCN_TAIT_H	VarFcnTait.h	2;"	d
_VAR_FCN_TAIT_KE_H	VarFcnTaitKE.h	2;"	d
_VAR_FCN_TAIT_SA_H	VarFcnTaitSA.h	2;"	d
_VECTOR3D_H_	Vector3D.h	2;"	d
_VECTOR_H_	Vector.h	2;"	d
_VECTOR_SET_H_	VectorSet.h	2;"	d
_VISCO_FCN_H_	ViscoFcn.h	2;"	d
_VMS_LES_TERM_H_	VMSLESTerm.h	2;"	d
_VOLUMIC_FORCE_TERM_H_	VolumicForceTerm.h	2;"	d
_WALE_LES_TERM_H_	WaleLESTerm.h	2;"	d
_WALL_FCN_H_	WallFcn.h	2;"	d
_Z	arpack++/include/arlsupm.h	/^    _Z          \/* double complex *\/$/;"	e	enum:__anon43
__ARITHMETIC_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	8;"	d
__ARRAYS_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAYS_FORWARD.h	8;"	d
__ARRAYS_ND_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	8;"	d
__ARRAYS_UNIFORM_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_UNIFORM_FORWARD.h	8;"	d
__ARRAY_ARITHMETIC__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_ARITHMETIC.h	8;"	d
__ARRAY_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	8;"	d
__ARRAY_COLLECTION_ELEMENT_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT_BASE.h	8;"	d
__ARRAY_COLLECTION_ELEMENT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	8;"	d
__ARRAY_COLLECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	8;"	d
__ARRAY_COPY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_COPY.h	8;"	d
__ARRAY_DIFFERENCE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	8;"	d
__ARRAY_EXPRESSION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_EXPRESSION.h	8;"	d
__ARRAY_LEFT_MULTIPLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	8;"	d
__ARRAY_MIN_MAX__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/ARRAY_MIN_MAX.h	8;"	d
__ARRAY_NEGATION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	8;"	d
__ARRAY_PLUS_SCALAR__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	8;"	d
__ARRAY_PRODUCT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	8;"	d
__ARRAY_SUM__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	8;"	d
__ARRAY_VIEW__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	8;"	d
__ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	8;"	d
__BASIC_GEOMETRY_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_FORWARD.h	8;"	d
__BASIC_GEOMETRY_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BASIC_GEOMETRY_POLICY.h	8;"	d
__BOX_HIERARCHY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	8;"	d
__BOX_LINE_2D_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_LINE_2D_INTERSECTION.h	8;"	d
__BOX_PLANE_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_PLANE_INTERSECTION.h	8;"	d
__BOX_POINT_SIMPLEX_1D_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/BOX_POINT_SIMPLEX_1D_INTERSECTION.h	8;"	d
__BOX__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	9;"	d
__CENTER__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/CENTER.h	8;"	d
__CLONEABLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	8;"	d
__COMPLEX__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	8;"	d
__CONSTANT_ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	8;"	d
__CUBIC__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	8;"	d
__DATA_STRUCTURES_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/DATA_STRUCTURES_FORWARD.h	8;"	d
__DEBUG_PRINT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_PRINT.h	8;"	d
__DEBUG_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/DEBUG_UTILITIES.h	8;"	d
__DIAGONAL_MATRIX_2X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	8;"	d
__DIAGONAL_MATRIX_3X3__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	8;"	d
__DOT_PRODUCT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/DOT_PRODUCT.h	8;"	d
__Dot_Product__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/Dot_Product.h	8;"	d
__EDGE_EDGE_COLLISION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/EDGE_EDGE_COLLISION.h	6;"	d
__ELEMENT_ID__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	8;"	d
__EULER_STEP__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds_Computations/EULER_STEP.h	8;"	d
__EXCEPTIONS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/EXCEPTIONS.h	8;"	d
__FILE_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	9;"	d
__FRAME__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	8;"	d
__GEOMETRY_PARTICLES_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES_FORWARD.h	6;"	d
__GEOMETRY_PARTICLES__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	8;"	d
__HASHTABLE_ITERATOR__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	15;"	d
__HASHTABLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	8;"	d
__Hash__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	8;"	d
__IDENTITY_ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	8;"	d
__IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	8;"	d
__IMPLICIT_OBJECT_ON_A_RAY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	8;"	d
__IMPLICIT_OBJECT__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	8;"	d
__INDIRECT_ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	8;"	d
__INNER_PRODUCT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/INNER_PRODUCT.h	8;"	d
__INTERVAL__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	8;"	d
__ITERATIVE_SOLVER__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	8;"	d
__Inverse__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	8;"	d
__KD_TREE_NODE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	8;"	d
__KD_TREE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	8;"	d
__LEVELSET_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	8;"	d
__LINEAR_INTERPOLATION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Interpolation/LINEAR_INTERPOLATION.h	8;"	d
__LINE_2D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	8;"	d
__LOCAL_LEVELSET__	PhysBAM_Interface/LOCAL_LEVELSET.h	2;"	d
__LOG_ENTRY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	8;"	d
__LOG_SCOPE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	8;"	d
__LOG__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	8;"	d
__MAGNITUDE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/MAGNITUDE.h	8;"	d
__MATRIX_0X0__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	6;"	d
__MATRIX_0X1__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	6;"	d
__MATRIX_1X1__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	6;"	d
__MATRIX_1X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	6;"	d
__MATRIX_2X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	8;"	d
__MATRIX_2X3__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X3.h	8;"	d
__MATRIX_3X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	8;"	d
__MATRIX_3X3__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	9;"	d
__MATRIX_4X4__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	8;"	d
__MATRIX_ARITHMETIC_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_ARITHMETIC_POLICY.h	8;"	d
__MATRIX_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	8;"	d
__MATRIX_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	8;"	d
__MATRIX_MXN__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	8;"	d
__MATRIX_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_POLICY.h	8;"	d
__MATRIX__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	8;"	d
__MESH_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TOPOLOGY_POLICY.h	8;"	d
__MT19937__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	10;"	d
__NONCOPYABLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/NONCOPYABLE.h	8;"	d
__NONLINEAR_FUNCTION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	8;"	d
__ONE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	8;"	d
__ORIENTED_BOX__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	8;"	d
__PAIR__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	8;"	d
__PHYSBAM_INTERFACE__	PhysBAM_Interface/PHYSBAM_INTERFACE.h	8;"	d
__PHYSBAM_MPI_UTILITIES_H__	IntersectorPhysBAM/Mpi_Utilities.h	2;"	d
__PHYSBAM_OVERRIDE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PHYSBAM_OVERRIDE.h	6;"	d
__PLANE__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	8;"	d
__POINTER_POOL__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	8;"	d
__POINT_2D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_2D.h	8;"	d
__POINT_CLOUD_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD_FORWARD.h	8;"	d
__POINT_CLOUD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	8;"	d
__POINT_FACE_COLLISION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Continuous_Collision_Detection/POINT_FACE_COLLISION.h	6;"	d
__POINT_SIMPLEX_1D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	8;"	d
__POINT_SIMPLEX_MESH__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/POINT_SIMPLEX_MESH.h	6;"	d
__POLYGON__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	8;"	d
__PROCESS_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/PROCESS_UTILITIES.h	8;"	d
__PROJECTED_ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	8;"	d
__QUADRATIC__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	8;"	d
__QUATERNION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	8;"	d
__RANDOM_NUMBERS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	8;"	d
__RANGE_COMPUTATIONS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/RANGE_COMPUTATIONS.h	8;"	d
__RANGE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	9;"	d
__RAY_BOX_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_BOX_INTERSECTION.h	8;"	d
__RAY_ORIENTED_BOX_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_ORIENTED_BOX_INTERSECTION.h	8;"	d
__RAY_PLANE_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_PLANE_INTERSECTION.h	8;"	d
__RAY_SEGMENT_2D_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_SEGMENT_2D_INTERSECTION.h	8;"	d
__RAY_TRIANGLE_3D_INTERSECTION__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Intersections/RAY_TRIANGLE_3D_INTERSECTION.h	8;"	d
__RAY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	8;"	d
__READ_WRITE_ARRAY_VIEW__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY_VIEW.h	9;"	d
__READ_WRITE_ARRAY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Arrays/READ_WRITE_ARRAY.h	9;"	d
__READ_WRITE_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FORWARD.h	9;"	d
__READ_WRITE_FUNCTIONS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	12;"	d
__READ_WRITE_HASHTABLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	9;"	d
__READ_WRITE_TWIST__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	9;"	d
__READ_WRITE_VECTOR_0D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	9;"	d
__READ_WRITE_VECTOR_1D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	9;"	d
__READ_WRITE_VECTOR_2D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	9;"	d
__READ_WRITE_VECTOR_3D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	9;"	d
__READ_WRITE_VECTOR_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_BASE.h	9;"	d
__READ_WRITE_VECTOR_ND__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	9;"	d
__READ_WRITE_VECTOR__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	9;"	d
__REGISTRY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	8;"	d
__REINITIALIZE_DISTANCE_TO_WALL_H__	ReinitializeDistanceToWall.h	2;"	d
__ROBUST_FUNCTIONS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	8;"	d
__ROTATION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	8;"	d
__Read_Write__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	12;"	d
__SCALAR_POLICY__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	8;"	d
__SEGMENT_2D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	8;"	d
__SEGMENT_3D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	8;"	d
__SEGMENT_MESH__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	8;"	d
__SIMPLEX_MESH__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	8;"	d
__SORT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	8;"	d
__STACK__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	8;"	d
__STATIC_ASSERT__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/STATIC_ASSERT.h	8;"	d
__STRING_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	8;"	d
__STRUCTURE_REGISTRY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/STRUCTURE_REGISTRY.h	8;"	d
__STRUCTURE__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.h	8;"	d
__SUMMATIONS__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays_Computations/SUMMATIONS.h	8;"	d
__SUPERLU_CNAMES	arpack++/include/arlnames.h	17;"	d
__SUPERLU_DCOMPLEX	arpack++/include/arlcomp.h	19;"	d
__SUPERLU_SCOMPLEX	arpack++/include/arlcomp.h	80;"	d
__SUPERLU_SP_DEFS	arpack++/include/arlspdef.h	12;"	d
__SUPERLU_SUPERMATRIX	arpack++/include/arlsupm.h	10;"	d
__SUPERLU_UTIL	arpack++/include/arlutil.h	10;"	d
__SYMMETRIC_MATRIX_2X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	8;"	d
__SYMMETRIC_MATRIX_3X3__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	8;"	d
__TIMER__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	8;"	d
__TRANSPOSE_MATRIX__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	8;"	d
__TRIANGLE_3D__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	8;"	d
__TRIANGLE_HIERARCHY__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	8;"	d
__TRIANGLE_MESH__	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	8;"	d
__TRIPLE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	8;"	d
__TWIST__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	8;"	d
__TYPED_STREAM__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	9;"	d
__TYPE_UTILITIES__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	8;"	d
__UNION_FIND__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	8;"	d
__UPPER_TRIANGULAR_MATRIX_2X2__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	8;"	d
__UPPER_TRIANGULAR_MATRIX_3X3__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	8;"	d
__VECTOR_0D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	8;"	d
__VECTOR_1D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	8;"	d
__VECTOR_2D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	8;"	d
__VECTOR_3D__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	8;"	d
__VECTOR_BASE__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	8;"	d
__VECTOR_EXPRESSION__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	8;"	d
__VECTOR_FORWARD__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	8;"	d
__VECTOR_ND__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	8;"	d
__VECTOR__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	8;"	d
__ZERO__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	8;"	d
__argmax__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmax.h	8;"	d
__argmin__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmin.h	8;"	d
__choice__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	8;"	d
__clamp__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	8;"	d
__constants__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	6;"	d
__cube__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cube.h	12;"	d
__cyclic_shift__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	12;"	d
__exchange__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	12;"	d
__exchange_sort__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange_sort.h	12;"	d
__integer_log__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	12;"	d
__max__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	8;"	d
__maxabs__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	12;"	d
__maxmag__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	12;"	d
__min__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	8;"	d
__minabs__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	12;"	d
__minmag__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minmag.h	12;"	d
__rint__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/rint.h	8;"	d
__safe_arithmetic__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Arithmetic.h	6;"	d
__sign__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sign.h	12;"	d
__sqr__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sqr.h	12;"	d
__wrap__	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	13;"	d
_fsi	MatVecProd.h	/^  struct _fsi {$/;"	s	class:MatVecProd
_fsi	MatVecProd.h	/^  struct _fsi {$/;"	s	class:MatVecProdMultiPhase
_m_from	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static T1 _m_from;$/;"	m	struct:PhysBAM::IS_CONVERTIBLE_BASIC_IMPL
_solveLinearSystem	ImplicitEmbeddedRomTsDesc.cpp	/^int ImplicitEmbeddedRomTsDesc<dim>::_solveLinearSystem(int it , DistSVec<double, dim> &rhs, Vec<double> &sol)$/;"	f	class:ImplicitEmbeddedRomTsDesc
a	AutoDiff/Taylor.h	/^    Scalar a[nvar];$/;"	m	class:Taylor2
a	DiagMatrix.h	/^  SVec<Scalar,dim*dim> a;$/;"	m	class:DiagMat
a	DistEmbeddedVector.h	/^  Scalar a; $/;"	m	class:EmbeddedScaleExpr
a	GappyPreprocessing.h	/^		Scalar a [size];$/;"	m	class:StaticArray
a	GappyPreprocessing.h	/^		VecSet< DistSVec<double,dim> > *(a[2]);	\/\/ B[0] = *(a[0])$/;"	m	class:VecSetArray
a	GappyPreprocessing.h	/^	double (*a) [dim];$/;"	m	struct:SubDomainData
a	GappyPreprocessing.h	/^	std::vector< SubDomainData<dim> > a [2];	\/\/ array of two vectors, each vector is nRhs long$/;"	m	struct:VecSubDomainData
a	MeshMotionHandler.h	/^  Vec3D a;$/;"	m	class:RigidMeshMotionHandler
a	MultiGridSmoothingMatrix.h	/^  SVec<Scalar,dim*dim> a;$/;"	m	class:MultiGridSmoothingMatrix
a	MvpMatrix.h	/^  SVec<Scalar,dim*dim> a;$/;"	m	class:MvpMat
a	OneDimensionalSourceTerm.h	/^    double* a;$/;"	m	struct:OneDimensionalSourceTerm::MyLU
a	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^    int a;$/;"	m	struct:PhysBAM::INT_INVERSE
a	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T a,b,c; \/\/ coefficients$/;"	m	class:PhysBAM::QUADRATIC
a	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    static const unsigned int a=0x9908b0df,UPPER_MASK=0x80000000,LOWER_MASK=0x7fffffff;$/;"	m	class:PhysBAM::MT19937
a	RectangularSparseMatrix.h	/^  SVec<Scalar,dim*dim2> a;   \/\/ data stored in CSR format$/;"	m	class:RectangularSparseMat
a	SparseMatrix.h	/^  SVec<Scalar,dim*dim> a;   \/\/ data stored in CSR format$/;"	m	class:SparseMat
a	Vector.h	/^  T a;$/;"	m	class:OuterProd
a	Vector.h	/^  T1 a;$/;"	m	class:Diff
a	Vector.h	/^  T1 a;$/;"	m	class:Div
a	Vector.h	/^  T1 a;$/;"	m	class:InnerProd
a	Vector.h	/^  T1 a;$/;"	m	class:Sum
a	arpack++/include/arlnsmat.h	/^  ARTYPE*     a;$/;"	m	class:ARluNonSymMatrix
a	arpack++/include/arlsmat.h	/^  ARTYPE*     a;$/;"	m	class:ARluSymMatrix
a	arpack++/include/arunsmat.h	/^  ARTYPE* a;$/;"	m	class:ARumNonSymMatrix
a	arpack++/include/arusmat.h	/^  ARTYPE* a;$/;"	m	class:ARumSymMatrix
a_	VarFcnTait.h	/^  double a_;$/;"	m	class:VarFcnTait
abc	TriangulatedInterface.h	/^  int (*abc)[3];$/;"	m	class:TriangulatedInterface
abort_sigaction	Main.C	/^void abort_sigaction(int signal, siginfo_t *si, void *arg)$/;"	f
abs	DenseMatrixOps.h	/^  inline static double abs(bcomp x) { return std::abs(x); }$/;"	f	class:DenseMatrixOp
abs	DenseMatrixOps.h	/^  inline static double abs(double x) { return (x > 0.0 ? x : (-x)); }$/;"	f	class:DenseMatrixOp
abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^abs(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^abs(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^abs(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
abs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^abs(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
absAccuracy	IoData.h	/^  double absAccuracy;$/;"	m	struct:SparseGridData
absAccuracy	SparseGrid.h	/^  double absAccuracy;     \/\/ required absolute accuracy$/;"	m	class:SparseGrid
absoluteEps	IoData.h	/^  double absoluteEps;$/;"	m	struct:KspData
absoluteEps	KspSolver.h	/^  double absoluteEps;$/;"	m	class:KspSolver
absolutePath	TsInput.C	/^TsInput::absolutePath(const std::string & rawPath, const std::string & prefix) {$/;"	f	class:TsInput
absvelocity	IoData.h	/^  const char *absvelocity;$/;"	m	struct:TransientData
accumulate	Communicator.C	/^  void Window<Scalar>::accumulate(Scalar *a, int locOff, int size, int prNum, int remOff, int op) {$/;"	f	class:Communication::Window
accumulator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^        double start,elapsed,accumulator;$/;"	m	struct:PhysBAM::TIMER::DATA
acquire	MultiGridSmoothingMatrices.C	/^acquire(DistMat<Scalar,dim>& mvp) {$/;"	f	class:MultiGridSmoothingMatrices
acquire	MultiGridSmoothingMatrices.C	/^acquire(int lvl, MultiGridMvpMatrix<Scalar,dim>& mvp) {$/;"	f	class:MultiGridSmoothingMatrices
active	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool active;$/;"	m	class:PhysBAM::LOG_REAL::SCOPE
active	SparseGrid.h	/^  bool *active;           \/\/ for each subgrid, checks if it is active$/;"	m	class:SparseGrid
activeCost	SparseGrid.h	/^  double *activeCost;     \/\/ cost of each subgrid (same indexation as multiIndex)$/;"	m	class:SparseGrid
activeError	SparseGrid.h	/^  double *activeError;    \/\/ error of each subgrid (same indexation as multiIndex)$/;"	m	class:SparseGrid
activeHeapCost	SparseGrid.h	/^  Heap activeHeapCost;    \/\/ heap that contains the indices of the active subgrids$/;"	m	class:SparseGrid
activeHeapError	SparseGrid.h	/^  Heap activeHeapError;   \/\/ heap that contains the indices of the active subgrids$/;"	m	class:SparseGrid
actualAbsAcc	SparseGrid.h	/^  double actualAbsAcc;$/;"	m	class:SparseGrid
actualRelAcc	SparseGrid.h	/^  double actualRelAcc;$/;"	m	class:SparseGrid
actvar	EmbeddedFluidShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
actvar	FluidCollocationShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:FluidCollocationShapeOptimizationHandler
actvar	FluidGnatShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:FluidGnatShapeOptimizationHandler
actvar	FluidMetricShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:FluidMetricShapeOptimizationHandler
actvar	FluidRomShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:FluidRomShapeOptimizationHandler
actvar	FluidShapeOptimizationHandler.h	/^  int actvar;$/;"	m	class:FluidShapeOptimizationHandler
adaptiveEpsFSI	IoData.h	/^  enum AdaptiveEpsFSI {OFF_ADAPTIVEEPSFSI = 0, ON_ADAPTIVEEPSFSI = 1} adaptiveEpsFSI;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::AdaptiveEpsFSI
add	DenseMatrix.C	/^GenFullM<Scalar>::add(GenFullM &mat, int fRow, int fCol)$/;"	f	class:GenFullM
add	DenseMatrixOps.h	/^  static void add(Scalar (*b)[5], int i, Scalar (*c)[5], int j) {$/;"	f	class:VectorOp
add	DenseMatrixOps.h	/^  static void add(Scalar (*b)[dim], int i, Scalar (*c)[dim], int j) {$/;"	f	class:VectorOp
addAJTime	Timer.C	/^double Timer::addAJTime(double t0)$/;"	f	class:Timer
addApproxMetricPreproTime	Timer.C	/^double Timer::addApproxMetricPreproTime(double t0) {$/;"	f	class:Timer
addBinaryReadTime	Timer.C	/^double Timer::addBinaryReadTime(double t0) $/;"	f	class:Timer
addBinaryWriteTime	Timer.C	/^double Timer::addBinaryWriteTime(double t0) $/;"	f	class:Timer
addCell	MacroCellCore.C	/^bool MacroCell::addCell(int subCellID)$/;"	f	class:MacroCell
addCheckConvergenceTime	Timer.C	/^double Timer::addCheckConvergenceTime(double t0)$/;"	f	class:Timer
addClusteringTime	Timer.C	/^double Timer::addClusteringTime(double t0) {$/;"	f	class:Timer
addContrib	DiagMatrix.C	/^void DiagMat<Scalar,dim>::addContrib(int nnd, int *nd, double *K)$/;"	f	class:DiagMat
addContrib	MultiGridSmoothingMatrix.h	/^  void addContrib(int nnd, int *nd, double *K) {}$/;"	f	class:MultiGridSmoothingMatrix
addContrib	MvpMatrix.h	/^  void addContrib(int nnd, int *nd, double *K) {}$/;"	f	class:MvpMat
addContrib	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::addContrib(int nNd, int *ndList, double *C)$/;"	f	class:RectangularSparseMat
addContrib	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::addContrib(int row, int col, double *C)$/;"	f	class:RectangularSparseMat
addContrib	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::addContrib(int row, int col, double C)$/;"	f	class:RectangularSparseMat
addContrib	SparseMatrix.C	/^void SparseMat<Scalar,dim>::addContrib(int nNd, int *ndList, double *C)$/;"	f	class:SparseMat
addCorrelMatrixTime	Timer.C	/^double Timer::addCorrelMatrixTime(double t0)$/;"	f	class:Timer
addDiagonalInMatVecProdH2transpose	SubDomain.C	/^void SubDomain::addDiagonalInMatVecProdH2transpose(Vec<double> &ctrlVol, GenMat<Scalar1,dim> &A,$/;"	f	class:SubDomain
addDistCalcsPreproTime	Timer.C	/^double Timer::addDistCalcsPreproTime(double t0) {$/;"	f	class:Timer
addDouble	parser/ParseTree.cpp	/^void ParseTree::addDouble(Token token, double val) {$/;"	f	class:ParseTree
addDynamicVMSLESTime	Timer.C	/^double Timer::addDynamicVMSLESTime(double t0)$/;"	f	class:Timer
addEigSolvTime	Timer.C	/^double Timer::addEigSolvTime(double t0)$/;"	f	class:Timer
addElem	Elem.h	/^  void addElem(int i, Elem *elem) { elems[i] = elem; }$/;"	f	class:ElemSet
addElementOfFace	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::addElementOfFace(FaceSet&$/;"	f	class:GappyPreprocessing
addEmbedPhaseChangeTime	Timer.C	/^double Timer::addEmbedPhaseChangeTime(double t0)$/;"	f	class:Timer
addEmbeddedForceTime	Timer.C	/^double Timer::addEmbeddedForceTime(double t0)$/;"	f	class:Timer
addExactUpdatesPreproTime	Timer.C	/^double Timer::addExactUpdatesPreproTime(double t0) {$/;"	f	class:Timer
addFace	Face.h	/^  void addFace(int i, Face *face) { faces[i] = face; }$/;"	f	class:FaceSet
addFaceNodesElements	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::addFaceNodesElements(FaceSet&$/;"	f	class:GappyPreprocessing
addFiniteElementJacTime	Timer.C	/^double Timer::addFiniteElementJacTime(double t0) $/;"	f	class:Timer
addFiniteElementTermTime	Timer.C	/^double Timer::addFiniteElementTermTime(double t0) $/;"	f	class:Timer
addFiniteVolumeJacTime	Timer.C	/^double Timer::addFiniteVolumeJacTime(double t0) $/;"	f	class:Timer
addFiniteVolumeTermTime	Timer.C	/^double Timer::addFiniteVolumeTermTime(double t0) $/;"	f	class:Timer
addFluidSolutionTime	Timer.C	/^double Timer::addFluidSolutionTime(double t0)$/;"	f	class:Timer
addGlobalComTime	Timer.C	/^double Timer::addGlobalComTime(double t0) $/;"	f	class:Timer
addGramSchmidtTime	Timer.C	/^double Timer::addGramSchmidtTime(double t0)$/;"	f	class:Timer
addH2SetupTime	Timer.C	/^double Timer::addH2SetupTime(double t0) $/;"	f	class:Timer
addHHBoundaryTerm	DistEmbeddedVector.h	/^  void addHHBoundaryTerm(const DistInfo & I) { hhBoundaryTerm = new DistVec<Scalar>(I); }$/;"	f	class:DistEmbeddedVec
addICInterpTime	Timer.C	/^double Timer::addICInterpTime(double t0)$/;"	f	class:Timer
addInt	parser/ParseTree.cpp	/^void ParseTree::addInt(Token token, int val) {$/;"	f	class:ParseTree
addInterComTime	Timer.C	/^double Timer::addInterComTime(double t0) $/;"	f	class:Timer
addIntersectionTime	Timer.C	/^double Timer::addIntersectionTime(double t0)$/;"	f	class:Timer
addJacApplyTime	Timer.C	/^double Timer::addJacApplyTime(double t0)$/;"	f	class:Timer
addJacEvaluateTime	Timer.C	/^double Timer::addJacEvaluateTime(double t0)$/;"	f	class:Timer
addKspTime	Timer.C	/^double Timer::addKspTime(double t0) $/;"	f	class:Timer
addLSFiniteVolumeJacTime	Timer.C	/^double Timer::addLSFiniteVolumeJacTime(double t0) $/;"	f	class:Timer
addLSFiniteVolumeTermTime	Timer.C	/^double Timer::addLSFiniteVolumeTermTime(double t0)$/;"	f	class:Timer
addLSKspTime	Timer.C	/^double Timer::addLSKspTime(double t0)$/;"	f	class:Timer
addLSNodalWeightsAndGradTime	Timer.C	/^double Timer::addLSNodalWeightsAndGradTime(double t0)  {$/;"	f	class:Timer
addLSPrecSetupTime	Timer.C	/^double Timer::addLSPrecSetupTime(double t0) $/;"	f	class:Timer
addLSReinitializationTime	Timer.C	/^double Timer::addLSReinitializationTime(double t0) $/;"	f	class:Timer
addLevelSetSolutionTime	Timer.C	/^double Timer::addLevelSetSolutionTime(double t0)$/;"	f	class:Timer
addLinearSystemFormTime	Timer.C	/^double Timer::addLinearSystemFormTime(double t0)$/;"	f	class:Timer
addLinearSystemSolveTime	Timer.C	/^double Timer::addLinearSystemSolveTime(double t0)$/;"	f	class:Timer
addLocalComTime	Timer.C	/^double Timer::addLocalComTime(double t0) $/;"	f	class:Timer
addLocalForce	SubDomainCore.C	/^void SubDomain::addLocalForce(int METHOD, Vec3D nf, double p1, double p2, double p3,$/;"	f	class:SubDomain
addMDSTime	Timer.C	/^double Timer::addMDSTime(double t0) {$/;"	f	class:Timer
addMeshAssemblyTime	Timer.C	/^double Timer::addMeshAssemblyTime(double t0)$/;"	f	class:Timer
addMeshKspTime	Timer.C	/^double Timer::addMeshKspTime(double t0)$/;"	f	class:Timer
addMeshMetricsTime	Timer.C	/^double Timer::addMeshMetricsTime(double t0) $/;"	f	class:Timer
addMeshPrecSetupTime	Timer.C	/^double Timer::addMeshPrecSetupTime(double t0) $/;"	f	class:Timer
addMeshSolutionTime	Timer.C	/^double Timer::addMeshSolutionTime(double t0)$/;"	f	class:Timer
addNeighbors	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::addNeighbors(int iIslands, int startingNodeWithNeigh) {$/;"	f	class:GappyPreprocessing
addNeighbour	GhostPoint.h	/^void addNeighbour(bool w1, double *Vi_1, int fId1, $/;"	f	class:GhostPoint
addNeighbour	GhostPoint.h	/^void addNeighbour(double *Vi, double *Wi, int tag) $/;"	f	class:GhostPoint
addNodalGradTime	Timer.C	/^double Timer::addNodalGradTime(double t0) $/;"	f	class:Timer
addNodalWeightsTime	Timer.C	/^double Timer::addNodalWeightsTime(double t0) $/;"	f	class:Timer
addNodesOnFace	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::addNodesOnFace(FaceSet&$/;"	f	class:GappyPreprocessing
addPODTime	Timer.C	/^double Timer::addPODTime(double t0) {$/;"	f	class:Timer
addPadeReconstrTime	Timer.C	/^double Timer::addPadeReconstrTime(double t0)$/;"	f	class:Timer
addPodConstrTime	Timer.C	/^double Timer::addPodConstrTime(double t0)$/;"	f	class:Timer
addPrecSetupTime	Timer.C	/^double Timer::addPrecSetupTime(double t0) $/;"	f	class:Timer
addProj	BCApplierCore.C	/^BCApplier::addProj(int locSubNum, int nd, double nrm[3]) $/;"	f	class:BCApplier
addProjErrorTime	Timer.C	/^double Timer::addProjErrorTime(double t0) {$/;"	f	class:Timer
addPseudoInvTime	Timer.C	/^double Timer::addPseudoInvTime(double t0) {$/;"	f	class:Timer
addRMAComTime	Timer.C	/^double Timer::addRMAComTime(double t0)$/;"	f	class:Timer
addRcvData	SubDomain.C	/^void SubDomain::addRcvData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
addRcvDiagBlocks	SubDomain.C	/^void SubDomain::addRcvDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
addRcvDiagInletBlocks	SubDomain.C	/^void SubDomain::addRcvDiagInletBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
addRcvEdgeData	SubDomain.C	/^void SubDomain::addRcvEdgeData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
addRcvGhostOffDiagBlocks	SubDomain.C	/^void SubDomain::addRcvGhostOffDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
addRcvInletData	SubDomain.C	/^void SubDomain::addRcvInletData(CommPattern<Scalar> &sp, Scalar (*w)[dim], bool ForExtrapolation)$/;"	f	class:SubDomain
addRcvInletRhsData	SubDomain.C	/^void SubDomain::addRcvInletRhsData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
addRcvOffDiagBlocks	SubDomain.C	/^void SubDomain::addRcvOffDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
addReadSnapshotFileTime	Timer.C	/^double Timer::addReadSnapshotFileTime(double t0) {$/;"	f	class:Timer
addResidualTime	Timer.C	/^double Timer::addResidualTime(double t0)$/;"	f	class:Timer
addRestrictionTime	Timer.C	/^double Timer::addRestrictionTime(double t0)$/;"	f	class:Timer
addRigidMotion	MeshMotionHandlerCore.C	/^void RigidMeshMotionHandler::addRigidMotion(double t, DistSVec<double,3> &Xrel,$/;"	f	class:RigidMeshMotionHandler
addRomConstrTime	Timer.C	/^double Timer::addRomConstrTime(double t0)$/;"	f	class:Timer
addRomSolTime	Timer.C	/^double Timer::addRomSolTime(double t0)$/;"	f	class:Timer
addRomTimeIntegTime	Timer.C	/^double Timer::addRomTimeIntegTime(double t0)$/;"	f	class:Timer
addSampleNodesAndNeighbors	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::addSampleNodesAndNeighbors() {$/;"	f	class:GappyPreprocessing
addSampledMeshConstructionTime	Timer.C	/^double Timer::addSampledMeshConstructionTime(double t0) {$/;"	f	class:Timer
addSampledOutputTime	Timer.C	/^double Timer::addSampledOutputTime(double t0) {$/;"	f	class:Timer
addSecondTets	InletNodeCore.C	/^void InletNode::addSecondTets( int* listtets)$/;"	f	class:InletNode
addSmb	parser/AssignerCore.C	/^ClassAssigner::addSmb(const char *smb, Assigner *asgn)$/;"	f	class:ClassAssigner
addSnapsLinSolvTime	Timer.C	/^double Timer::addSnapsLinSolvTime(double t0)$/;"	f	class:Timer
addSolutionIncrementTime	Timer.C	/^double Timer::addSolutionIncrementTime(double t0)$/;"	f	class:Timer
addStateToKrylov	IoData.h	/^  enum AddStateToKrylov {ADD_STATE_TO_KRYLOV_OFF = 0, ADD_STATE_TO_KRYLOV_ON = 1} addStateToKrylov;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::AddStateToKrylov
addString	parser/ParseTree.cpp	/^void ParseTree::addString(Token token, const char *val) {$/;"	f	class:ParseTree
addStructUpdTime	Timer.C	/^double Timer::addStructUpdTime(double t0)$/;"	f	class:Timer
addSurfaceFromFace	TriangulatedSurface.C	/^void TriangulatedSurface::addSurfaceFromFace( FaceSet &boundaryFaces )$/;"	f	class:TriangulatedSurface
addSurfaceFromFace	TriangulatedSurface.C	/^void TriangulatedSurface::addSurfaceFromFace( SVec<double,3> &X, FaceSet &boundaryFaces )$/;"	f	class:TriangulatedSurface
addSurfaceMeshConstructionTime	Timer.C	/^double Timer::addSurfaceMeshConstructionTime(double t0) {$/;"	f	class:Timer
addSurfaceOutputTime	Timer.C	/^double Timer::addSurfaceOutputTime(double t0) {$/;"	f	class:Timer
addSysSymbol	parser/Dictionary.C	/^int addSysSymbol(const char *name, Assigner *a)$/;"	f
addTimeStepTime	Timer.C	/^double Timer::addTimeStepTime(double t0) $/;"	f	class:Timer
addToH1	DistTimeState.C	/^void DistTimeState<dim>::addToH1(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A)$/;"	f	class:DistTimeState
addToH1	DistTimeState.C	/^void DistTimeState<dim>::addToH1(DistVec<double> &ctrlVol,$/;"	f	class:DistTimeState
addToH1	TimeState.C	/^void TimeState<dim>::addToH1(bool *nodeFlag, Vec<double> &ctrlVol, GenMat<Scalar,neq> &A)$/;"	f	class:TimeState
addToH1	TimeState.C	/^void TimeState<dim>::addToH1(bool *nodeFlag, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToH2	DistTimeState.C	/^void DistTimeState<dim>::addToH2(DistVec<double> &ctrlVol, DistSVec<double,dim> &U,$/;"	f	class:DistTimeState
addToH2	DistTimeState.C	/^void DistTimeState<dim>::addToH2(DistVec<double> &ctrlVol,$/;"	f	class:DistTimeState
addToH2	TimeState.C	/^void TimeState<dim>::addToH2(bool *nodeFlag, VarFcn *varFcn, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToH2	TimeState.C	/^void TimeState<dim>::addToH2(bool *nodeFlag, VarFcn *varFcn,$/;"	f	class:TimeState
addToH2GasPrec	TimeState.C	/^void TimeState<dim>::addToH2GasPrec(bool *nodeFlag, VarFcn *varFcn, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToH2GasPrecLocal	TimeState.C	/^void TimeState<dim>::addToH2GasPrecLocal(int i, double vol, VarFcn *vf, double gam, $/;"	f	class:TimeState
addToH2LiquidPrec	TimeState.C	/^void TimeState<dim>::addToH2LiquidPrec(bool *nodeFlag, VarFcn *varFcn, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToH2LiquidPrecLocal	TimeState.C	/^void TimeState<dim>::addToH2LiquidPrecLocal(int i, double vol, VarFcn *vf,$/;"	f	class:TimeState
addToH2Minus	DistTimeState.C	/^void DistTimeState<dim>::addToH2Minus(DistVec<double> &ctrlVol, DistSVec<double,dim> &U,$/;"	f	class:DistTimeState
addToH2Minus	TimeState.C	/^void TimeState<dim>::addToH2Minus(bool *nodeFlag, VarFcn *varFcn, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToH2NoPrec	TimeState.C	/^void TimeState<dim>::addToH2NoPrec(bool *nodeFlag, VarFcn *varFcn, Vec<double> &ctrlVol,$/;"	f	class:TimeState
addToHHJacobian	DistTimeState.C	/^void DistTimeState<dim>::addToHHJacobian(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobian	DistTimeState.C	/^void DistTimeState<dim>::addToJacobian(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobianGasPrec	DistTimeState.C	/^void DistTimeState<dim>::addToJacobianGasPrec(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobianGasPrec	TimeState.C	/^void TimeState<dim>::addToJacobianGasPrec(bool *nodeFlag, Vec<double> &ctrlVol, GenMat<Scalar,neq> &A,$/;"	f	class:TimeState
addToJacobianGasPrecLocal	TimeState.C	/^void TimeState<dim>::addToJacobianGasPrecLocal(int i, double vol, double gam, $/;"	f	class:TimeState
addToJacobianHH	TimeState.C	/^void TimeState<dim>::addToJacobianHH(Vec<double>& ctrlVol,  GenMat<Scalar,neq> & A,$/;"	f	class:TimeState
addToJacobianLS	DistTimeState.C	/^void DistTimeState<dim>::addToJacobianLS(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobianLS	TimeState.C	/^void TimeState<dim>::addToJacobianLS(bool* nodeFlag,Vec<double> &ctrlVol, GenMat<Scalar,neq> &A,$/;"	f	class:TimeState
addToJacobianLiquidPrec	DistTimeState.C	/^void DistTimeState<dim>::addToJacobianLiquidPrec(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobianLiquidPrec	TimeState.C	/^void TimeState<dim>::addToJacobianLiquidPrec(bool *nodeFlag, Vec<double> &ctrlVol, GenMat<Scalar,neq> &A,$/;"	f	class:TimeState
addToJacobianLiquidPrecLocal	TimeState.C	/^void TimeState<dim>::addToJacobianLiquidPrecLocal(int i, double vol, VarFcn *vf,$/;"	f	class:TimeState
addToJacobianNoPrec	DistTimeState.C	/^void DistTimeState<dim>::addToJacobianNoPrec(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A,$/;"	f	class:DistTimeState
addToJacobianNoPrec	TimeState.C	/^void TimeState<dim>::addToJacobianNoPrec(bool *nodeFlag, Vec<double> &ctrlVol, GenMat<Scalar,neq> &A,$/;"	f	class:TimeState
addToJacobianNoPrecLocal	TimeState.C	/^void TimeState<dim>::addToJacobianNoPrecLocal(int i, double vol, $/;"	f	class:TimeState
addToMatVecProdH2transposeGalerkinNew	SubDomain.C	/^void SubDomain::addToMatVecProdH2transposeGalerkinNew(Vec<double> &ctrlVol, SVec<Scalar,dim> &ddxt,$/;"	f	class:SubDomain
addToMatVecProdH2transposeLeastSquareNew	SubDomain.C	/^void SubDomain::addToMatVecProdH2transposeLeastSquareNew(SVec<double,3> &X, SVec<double,6> &R, SVec<Scalar,dim> &ddxt,$/;"	f	class:SubDomain
addToPackage	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::addToPackage(int iNode, int trID)$/;"	f	class:IntersectorFRG
addToPackage	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::addToPackage(const int i, const int candidate)$/;"	f	class:IntersectorPhysBAM
addToken	parser/ParseTree.cpp	/^void ParseTree::addToken(Token token, int val) {$/;"	f	class:ParseTree
addTotalGappyOfflineTime	Timer.C	/^double Timer::addTotalGappyOfflineTime(double t0) {$/;"	f	class:Timer
addTotalOfflineTime	Timer.C	/^double Timer::addTotalOfflineTime(double t0) {$/;"	f	class:Timer
addTriangle	TriangulatedSurface.C	/^void TriangulatedSurface::addTriangle( Vec3D &Node1, Vec3D &Node2, Vec3D &Node3 ) \/\/ add a new triangle.$/;"	f	class:TriangulatedSurface
addTriangle	TriangulatedSurface.C	/^void TriangulatedSurface::addTriangle(int Node1, int Node2, int Node3)$/;"	f	class:TriangulatedSurface
addTurbulenceTerms	IoData.h	/^  int addTurbulenceTerms;$/;"	m	struct:MultiGridData
addTurbulenceTerms	MultiGridSegTsDesc.h	/^  int addTurbulenceTerms;$/;"	m	class:MultiGridSegTsDesc
addVMSLESTime	Timer.C	/^double Timer::addVMSLESTime(double t0)$/;"	f	class:Timer
addViscousTerms	IoData.h	/^  int addViscousTerms;$/;"	m	struct:MultiGridData
addViscousTerms	MultiGridOperator.h	/^  int addViscousTerms;$/;"	m	class:MultiGridOperator
addWaitAndReceiveDisp	Timer.C	/^double Timer::addWaitAndReceiveDisp(double t0)$/;"	f	class:Timer
addWallDistanceTime	Timer.C	/^double Timer::addWallDistanceTime(double t0)$/;"	f	class:Timer
add_GASPrec_dAW_dt	TimeState.C	/^void TimeState<dim>::add_GASPrec_dAW_dt(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_GASPrec_dAW_dtau	TimeState.C	/^void TimeState<dim>::add_GASPrec_dAW_dtau(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_LiquidPrec_dAW_dt	TimeState.C	/^void TimeState<dim>::add_LiquidPrec_dAW_dt(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_LiquidPrec_dAW_dtau	TimeState.C	/^void TimeState<dim>::add_LiquidPrec_dAW_dtau(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_T	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
add_dAW_dt	DistTimeState.C	/^void DistTimeState<dim>::add_dAW_dt(int it, DistGeoState &geoState, $/;"	f	class:DistTimeState
add_dAW_dt	TimeState.C	/^void TimeState<dim>::add_dAW_dt(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_dAW_dtEmbedded	MultiGridOperator.C	/^add_dAW_dtEmbedded(DistSVec<Scalar2,dim>& U,$/;"	f	class:MultiGridOperator
add_dAW_dtEmbedded	MultiGridSpaceOperator.C	/^add_dAW_dtEmbedded(int lvl,MultiGridDistSVec<Scalar,dim>& U,$/;"	f	class:MultiGridSpaceOperator
add_dAW_dtLS	DistTimeState.C	/^void DistTimeState<dim>::add_dAW_dtLS(int it, DistGeoState &geoState,$/;"	f	class:DistTimeState
add_dAW_dtLS	TimeState.C	/^void TimeState<dim>::add_dAW_dtLS(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_dAW_dtRestrict	DistTimeState.C	/^void DistTimeState<dim>::add_dAW_dtRestrict(int it, DistGeoState &geoState, $/;"	f	class:DistTimeState
add_dAW_dtRestrict	TimeState.C	/^void TimeState<dim>::add_dAW_dtRestrict(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_dAW_dt_HH	DistTimeState.C	/^void DistTimeState<dim>::add_dAW_dt_HH(int it, DistGeoState &geoState, $/;"	f	class:DistTimeState
add_dAW_dt_HH	TimeState.C	/^void TimeState<dim>::add_dAW_dt_HH(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
add_dAW_dtau	DistTimeState.C	/^void DistTimeState<dim>::add_dAW_dtau(int it, DistGeoState &geoState, $/;"	f	class:DistTimeState
add_dAW_dtau	TimeState.C	/^void TimeState<dim>::add_dAW_dtau(bool *nodeFlag, GeoState &geoState, $/;"	f	class:TimeState
adjacent_elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    ARRAY<ARRAY<int> >* adjacent_elements; \/\/ for each simplex, list of (up to d+1) adjacent neighboring simplices$/;"	m	class:PhysBAM::SIMPLEX_MESH
adjointFlag	MeshMotionSolver.h	/^  bool adjointFlag;$/;"	m	class:TetMeshMotionSolver
admissible	SparseGridCore.C	/^bool SparseGrid::admissible(const int currentMultiIndex,$/;"	f	class:SparseGrid
advanceDistanceComparisons	NonlinearRom.C	/^void NonlinearRom<dim>::advanceDistanceComparisons(int currentCluster, Vec<double> dUromTimeIt, Vec<double> UromCurrentROB) {$/;"	f	class:NonlinearRom
advectiveOperator	IoData.h	/^  enum AdvectiveOperator {FINITE_VOLUME = 0, FE_GALERKIN = 1} advectiveOperator;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::AdvectiveOperator
aero	IoData.h	/^  AeroelasticData aero;$/;"	m	class:IoData
aeroelasticEigenvalues	IoData.h	/^  const char *aeroelasticEigenvalues;$/;"	m	struct:TransientData
aerof_isnan	utils/Aerof_math.h	/^inline int aerof_isnan(const T& t) {$/;"	f
agg_face	MultiGridLevel.C	/^struct agg_face {$/;"	s	file:
agglomFaceDistInfo	MultiGridLevel.h	/^    DistInfo* agglomFaceDistInfo;$/;"	m	class:MultiGridLevel
agglomType	MultiGridLevel.h	/^  AgglomerationType agglomType;$/;"	m	class:MultiGridLevel
agglom_size	MultiGridKernel.h	/^  const int num_levels, agglom_size, numLocSub;$/;"	m	class:MultiGridKernel
agglomerate	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::agglomerate(const DistInfo& refinedNodeDistInfo,$/;"	f	class:MultiGridLevel
agglomerate	SubDomainCore.C	/^Connectivity *SubDomain::agglomerate(Connectivity &nToN, int maxLevel, bool *masterFlag)$/;"	f	class:SubDomain
agglomeratedFaces	MultiGridLevel.h	/^    AgglomeratedFaceSet** agglomeratedFaces;$/;"	m	class:MultiGridLevel
agglomerationFile	IoData.h	/^  const char* agglomerationFile;$/;"	m	struct:MultiGridData
agglomerationFile	MultiGridKernel.h	/^  const char* agglomerationFile;$/;"	m	class:MultiGridKernel
agglomeration_depth	IoData.h	/^  int agglomeration_depth;$/;"	m	struct:VMSLESData
agglomeration_depth1	IoData.h	/^  int agglomeration_depth1;$/;"	m	struct:DynamicVMSData
agglomeration_depth2	IoData.h	/^  int agglomeration_depth2;$/;"	m	struct:DynamicVMSData
agglomeration_width	IoData.h	/^  int agglomeration_width;$/;"	m	struct:DynamicVMSData
agglomeration_width	IoData.h	/^  int agglomeration_width;$/;"	m	struct:VMSLESData
aggregate_id	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    int aggregate_id; \/\/ indicates the piece of an aggregate object that is intersected by t_max$/;"	m	class:PhysBAM::RAY
aij	MatVecProd.h	/^  DistSVec<double,dim> aij; $/;"	m	class:MatVecProdH2
aj	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
aji	MatVecProd.h	/^  DistSVec<double,dim> aji;$/;"	m	class:MatVecProdH2
algNum	FSI/DynamicNodalTransfer.h	/^        int algNum;$/;"	m	class:DynamicNodalTransfer
algNum	FSI/DynamicNodalTransfer.h	/^  int algNum;$/;"	m	class:EmbeddedStructure
algNum	StructExc.h	/^  int algNum;$/;"	m	class:StructExc
algorithmType_	DistExactRiemannSolver.h	/^  MultiFluidData::Method algorithmType_;$/;"	m	class:DistExactRiemannSolver
alias	DistVector.h	/^DistSVec<Scalar,dim>::alias() const$/;"	f	class:DistSVec
alias	DistVector.h	/^DistVec<Scalar>::alias() const$/;"	f	class:DistVec
align	tools/alloca.cougar.c	/^  char align[ALIGN_SIZE];	\/* To force sizeof(header).  *\/$/;"	m	union:hdr	file:
allBlocks	BlockAlloc.h	/^    ResizeArray<char *> allBlocks;$/;"	m	class:BlockAlloc
allColumnSumsV	NonlinearRom.h	/^  std::vector<double>** allColumnSumsV; $/;"	m	class:NonlinearRom
allJacMat	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >** allJacMat;$/;"	m	class:NonlinearRom
allKrylovBases	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >** allKrylovBases;$/;"	m	class:NonlinearRom
allKrylovSVals	NonlinearRom.h	/^  std::vector<double>** allKrylovSVals;$/;"	m	class:NonlinearRom
allMetrics	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >** allMetrics;$/;"	m	class:NonlinearRom
allNBuffer	NonlinearRom.h	/^  std::vector<int> allNBuffer;$/;"	m	class:NonlinearRom
allPairs	Communicator.h	/^  CPair *allPairs;$/;"	m	class:SubDTopo
allRefStates	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* allRefStates;$/;"	m	class:NonlinearRom
allResMat	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >** allResMat;$/;"	m	class:NonlinearRom
allRestrictionMappings	NonlinearRom.h	/^  RestrictionMapping<dim>** allRestrictionMappings;$/;"	m	class:NonlinearRom
allSampleNodes	NonlinearRom.h	/^  std::vector<int>** allSampleNodes;$/;"	m	class:NonlinearRom
allStateBases	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >** allStateBases;$/;"	m	class:NonlinearRom
allStateSVals	NonlinearRom.h	/^  std::vector<double>** allStateSVals; $/;"	m	class:NonlinearRom
alloc	VectorSet.h	/^  allocator<VecType> alloc;$/;"	m	class:VecSet
alloca	tools/alloca.cougar.c	/^alloca (size)$/;"	f
allowIntPair	parser/Assigner.h	/^    void allowIntPair(int T::*sp) { tokenInt = sp; }$/;"	f	class:ClassToken
allowcflstop	DistTimeState.h	/^  bool allowcflstop;$/;"	m	class:DistTimeState
allowdtstop	DistTimeState.h	/^  bool allowdtstop;$/;"	m	class:DistTimeState
allowsFlux	IoData.h	/^  int allowsFlux;$/;"	m	struct:SchemeData
allowstop	TsParameters.h	/^  bool allowstop;$/;"	m	class:TsParameters
alltype	IoData.h	/^                _EMBEDDED_ALS_ROM_ = 41 \/* Lei Lei, 02\/13\/2016 *\/,_EMBEDDED_ALS_ROM_ONLINE_ = 42 \/* Lei Lei, 05\/15\/2016 *\/ } alltype;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::AllType
alpha	DESTerm.h	/^  double alpha;$/;"	m	class:DESTerm
alpha	IoData.h	/^  double alpha, beta;$/;"	m	struct:InitialConditions
alpha	IoData.h	/^  double alpha;   \/\/ In the case of solve Riemann problem at intersection, this parameter$/;"	m	struct:EmbeddedFramework
alpha	IoData.h	/^  double alpha;$/;"	m	struct:BcsFreeStreamData
alpha	IoData.h	/^  double alpha;$/;"	m	struct:LiquidModelData
alpha	KEpsilonTerm.h	/^  double alpha;$/;"	m	class:KEpsilonTerm
alpha	KspSolver.h	/^  ScalarT alpha, beta;$/;"	m	class:GcrSolver
alpha	LevelSet/LevelSetStructure.h	/^  double alpha;$/;"	m	struct:LevelSetResult
alpha	OneDimensionalSolver.h	/^    std::vector<double> alpha;$/;"	m	struct:OneDimensional::__anon12
alpha	OneDimensionalSourceTerm.h	/^  double alpha; \/\/ 1 for cylindrical, 2 for spherical$/;"	m	class:OneDimensionalSourceTerm
alpha	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^  T alpha; \/\/ Intersection is at alpha*edgeNode1 + (1-alpha)*edgeNode2$/;"	m	struct:PhysBAM::IntersectionResult
alpha	PostFcn.h	/^  double alpha;$/;"	m	class:PostFcnEuler
alpha	SpalartAllmarasTerm.h	/^  double alpha;$/;"	m	class:SATerm
alpha	ViscoFcn.h	/^  double alpha;$/;"	m	class:PrandtlViscoFcn
alpha	ViscoFcn.h	/^  double alpha;$/;"	m	class:SutherlandViscoFcn
alpha_in	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
alpha_in	IoData.h	/^  double alpha_in;$/;"	m	struct:PitchingData
alpha_in	MeshMotionHandler.h	/^  double alpha_in;$/;"	m	class:PitchingMeshMotionHandler
alpha_in	MeshMotionHandler.h	/^  double alpha_in;$/;"	m	class:RigidRollMeshMotionHandler
alpha_max	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
alpha_max	IoData.h	/^  double alpha_max;$/;"	m	struct:PitchingData
alpha_max	MeshMotionHandler.h	/^  double alpha_max;$/;"	m	class:PitchingMeshMotionHandler
alpha_n	TimeData.h	/^  double alpha_n;$/;"	m	class:TimeData
alpha_nm1	TimeData.h	/^  double alpha_nm1;$/;"	m	class:TimeData
alpha_nm2	TimeData.h	/^  double alpha_nm2;$/;"	m	class:TimeData
alpha_np1	TimeData.h	/^  double alpha_np1;$/;"	m	class:TimeData
alpha_slope	IoData.h	/^  double alpha_slope;$/;"	m	struct:PitchingData
alpha_slope	MeshMotionHandler.h	/^  double alpha_slope;$/;"	m	class:PitchingMeshMotionHandler
alpharef	IoData.h	/^  double alpharef;$/;"	m	struct:SensitivityAnalysis
alphax	IoData.h	/^  double alphax,alphay,alphaz;$/;"	m	struct:PorousMedia
alphay	IoData.h	/^  double alphax,alphay,alphaz;$/;"	m	struct:PorousMedia
alphaz	IoData.h	/^  double alphax,alphay,alphaz;$/;"	m	struct:PorousMedia
alprad	EmbeddedFluidShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
alprad	FluidCollocationShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:FluidCollocationShapeOptimizationHandler
alprad	FluidGnatShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:FluidGnatShapeOptimizationHandler
alprad	FluidMetricShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:FluidMetricShapeOptimizationHandler
alprad	FluidRomShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:FluidRomShapeOptimizationHandler
alprad	FluidShapeOptimizationHandler.h	/^  double alprad;$/;"	m	class:FluidShapeOptimizationHandler
amax	arpack++/include/blas1c.h	/^inline ARint amax(const ARint &n, const arcomplex<double> dx[], $/;"	f
amax	arpack++/include/blas1c.h	/^inline ARint amax(const ARint &n, const arcomplex<float> dx[], $/;"	f
amax	arpack++/include/blas1c.h	/^inline ARint amax(const ARint &n, const double dx[], const ARint &incx) {$/;"	f
amax	arpack++/include/blas1c.h	/^inline ARint amax(const ARint &n, const float dx[], const ARint &incx) {$/;"	f
amplification	IoData.h	/^  double amplification;$/;"	m	struct:DeformingData
amplification	IoData.h	/^  double amplification;$/;"	m	struct:LinearizedData
angleFull	NonlinearRom.C	/^double NonlinearRom<dim>::angleFull(DistSVec<double, dim> &U1, DistSVec<double, dim> &U2) {$/;"	f	class:NonlinearRom
angleRad	IoData.h	/^  enum AngleRadians {OFF_ANGLERAD = 0, ON_ANGLERAD = 1} angleRad;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::AngleRadians
angle_growth	IoData.h	/^  double angle_growth;$/;"	m	struct:CFLData
angle_growth	TsParameters.h	/^  double angle_growth;$/;"	m	class:TsParameters
angle_zero	IoData.h	/^  double angle_zero;$/;"	m	struct:CFLData
angle_zero	TsParameters.h	/^  double angle_zero;$/;"	m	class:TsParameters
angles	DistBcData.h	/^  double angles[2];$/;"	m	class:DistBcData
angular	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    T_SPIN angular;$/;"	m	class:PhysBAM::TWIST
appendNonStateDataToBasis	NonlinearRom.h	/^  virtual void appendNonStateDataToBasis(int, const char*, bool relProjError = false) {};$/;"	f	class:NonlinearRom
appendNonStateDataToBasis	NonlinearRomOnlineII.C	/^void NonlinearRomOnlineII<dim>::appendNonStateDataToBasis(int cluster, const char* basisType, bool relProjError) {$/;"	f	class:NonlinearRomOnlineII
appendNonStateDataToBasis	NonlinearRomOnlineIII.C	/^void NonlinearRomOnlineIII<dim>::appendNonStateDataToBasis(int cluster, const char* basisType, bool relProjError) {$/;"	f	class:NonlinearRomOnlineIII
appendVectorToBasis	NonlinearRom.h	/^  virtual void appendVectorToBasis(DistSVec<double, dim>&, int numVec = 0) {};$/;"	f	class:NonlinearRom
appendVectorToBasis	NonlinearRomOnlineII.C	/^void NonlinearRomOnlineII<dim>::appendVectorToBasis(DistSVec<double,dim> &vec, int numKeep) {$/;"	f	class:NonlinearRomOnlineII
apply	BCApplier.h	/^  void apply(double u[3]) {$/;"	f	struct:ProjData
apply	DiagMatrix.C	/^void DiagMat<Scalar,dim>::apply(SVec<double,dim> &y, SVec<double,dim> &x)$/;"	f	class:DiagMat
apply	Domain.h	/^   static inline Scalar apply(Scalar a, Scalar b) { return a+b; }$/;"	f	class:operAdd
apply	Domain.h	/^   static inline Scalar apply(Scalar a, Scalar b) { return std::max(a,b); }$/;"	f	class:operMax
apply	Domain.h	/^   static inline Scalar apply(Scalar a, Scalar b) { return std::min(a,b); }$/;"	f	class:operMin
apply	KspPrec.C	/^IdentityPrec<dim,Scalar2>::apply(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix) $/;"	f	class:IdentityPrec
apply	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::apply(DistSVec<Scalar2,dim> &y, DistSVec<Scalar2,dim> &x) $/;"	f	class:IluPrec
apply	KspPrec.C	/^void JacobiPrec<Scalar,dim, Scalar2>::apply(DistSVec<Scalar2,dim> &y, DistSVec<Scalar2,dim> &x) $/;"	f	class:JacobiPrec
apply	KspPrec.h	/^  virtual void apply(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default apply function in KspPrec" << endl; }$/;"	f	class:KspPrec
apply	KspPrec.h	/^  virtual void apply(DistVec<Scalar2> &, DistVec<Scalar2> &)  { std::cout << "  ERROR: Using default apply function in KspPrec" << endl; }$/;"	f	class:KspPrec
apply	KspPrec.h	/^  void apply(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { $/;"	f	class:KspPrec
apply	MatVecProd.C	/^void MatVecProdFD<dim, neq>::apply(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdFD
apply	MatVecProd.C	/^void MatVecProdFD<dim,neq>::apply(DistEmbeddedVec<double,neq> & p, DistEmbeddedVec<double,neq> & prod) $/;"	f	class:MatVecProdFD
apply	MatVecProd.C	/^void MatVecProdFDMultiPhase<dim, dimLS>::apply(DistEmbeddedVec<double,dim> &p,$/;"	f	class:MatVecProdFDMultiPhase
apply	MatVecProd.C	/^void MatVecProdFDMultiPhase<dim, dimLS>::apply(DistSVec<double,dim> &p,$/;"	f	class:MatVecProdFDMultiPhase
apply	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::apply(DistEmbeddedVec<double,neq> &p, DistEmbeddedVec<double,neq> &prod)$/;"	f	class:MatVecProdH1
apply	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::apply(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdH1
apply	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::apply(DistEmbeddedVec<double,dim> &p, DistEmbeddedVec<double,dim> &prod)$/;"	f	class:MatVecProdH1MultiPhase
apply	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::apply(DistSVec<double,dim> &p, DistSVec<double,dim> &prod)$/;"	f	class:MatVecProdH1MultiPhase
apply	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::apply(DistEmbeddedVec<double,dim> &p, DistEmbeddedVec<double,dim> &prod)$/;"	f	class:MatVecProdH2
apply	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::apply(DistSVec<bcomp,neq> &p,$/;"	f	class:MatVecProdH2
apply	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::apply(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdH2
apply	MatVecProd.C	/^void MatVecProdLS<dim,dimLS>::apply(DistSVec<double,dimLS> &p, DistSVec<double,dimLS> &prod)$/;"	f	class:MatVecProdLS
apply	MatVecProd.h	/^  virtual void apply(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }$/;"	f	class:MatVecProdMultiPhase
apply	MatVecProd.h	/^  virtual void apply(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) {}$/;"	f	class:MatVecProd
apply	MatVecProd.h	/^  virtual void apply(DistVec<double> &, DistVec<double> &) { }$/;"	f	class:MatVecProd
apply	MatVecProd.h	/^  void apply(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &)$/;"	f	class:MatVecProd_dRdX
apply	MatVecProd.h	/^  void apply(DistSVec<bcomp,neq>         &, DistSVec<bcomp,neq> &)$/;"	f	class:MatVecProd_dRdX
apply	MatVecProd.h	/^  void apply(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &)  {$/;"	f	class:MatVecProdFD
apply	MatVecProd.h	/^  void apply(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &)  {$/;"	f	class:MatVecProdH1
apply	MatVecProd.h	/^  void apply(DistSVec<double,neq>        &, DistSVec<double,neq> &)$/;"	f	class:MatVecProd_dRdX
apply	MeshMotionSolver.C	/^void TetMeshMotionSolver::apply(DistSVec<double,3> &b,$/;"	f	class:TetMeshMotionSolver
apply	MeshMotionSolver.h	/^  virtual void apply(DistSVec<double,3> &, DistSVec<double,3> &) {}$/;"	f	class:MeshMotionSolver
apply	MultiGridKspSolver.h	/^  void apply(DistSVec<Scalar,neq>& x, DistSVec<Scalar,neq>& b) {                                      $/;"	f	class:MultiGridMatVecProd
apply	MultiGridKspSolver.h	/^  void apply(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {$/;"	f	class:MultiGridJacobiPrec
apply	MultiGridKspSolver.h	/^  void apply(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {$/;"	f	class:MultiGridRASPrec
apply	MultiGridPrec.C	/^void MultiGridPrec<Scalar,dim,Scalar2>::apply(DistSVec<Scalar2,dim> & x, DistSVec<Scalar2,dim> & Px)$/;"	f	class:MultiGridPrec
apply	MultiGridSmoothingMatrices.C	/^apply(int lvl, MultiGridDistSVec<Scalar,dim>& dx, $/;"	f	class:MultiGridSmoothingMatrices
apply	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::apply(SVec<double,dim> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
apply	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::apply(SVec<double,dim> &x, Vec<Vec3D> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
apply	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::apply(SVec<double,dim> &x, Vec<double> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
apply	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::apply(Vec<Vec3D> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
apply	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::apply(Vec<double> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
apply	SparseMatrix.C	/^void SparseMat<Scalar,dim>::apply(SVec<double,dim> &x, SVec<double,dim> &Ax, int *ndType)$/;"	f	class:SparseMat
apply	StiffMatrix.C	/^void StiffMat<Scalar,dim>::apply(DistSVec<double,dim> &x, DistSVec<double,dim> &Ax)$/;"	f	class:StiffMat
applyAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyAndAdd(SVec<double,dim> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
applyAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyAndAdd(SVec<double,dim> &x, Vec<Vec3D> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
applyAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyAndAdd(SVec<double,dim> &x, Vec<double> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
applyAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyAndAdd(Vec<Vec3D> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
applyAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyAndAdd(Vec<double> &x, SVec<double,dim2> &Ax, int *ndType)$/;"	f	class:RectangularSparseMat
applyAndAddToVector	DenseMatrixOps.h	/^    static void applyAndAddToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[1], int k, Scalar2 (*b), int i,$/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[1], int k, Scalar2 (*b)[1], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[49], int k, Scalar2 (*b)[7], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[4], int k, Scalar2 (*b)[2], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[9], int k, Scalar2 (*b)[3], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[dim2], int k, Scalar2 (*b)[dim], int i, $/;"	f	class:DenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[dim3], int k, Scalar2 (*b)[dim], int i, $/;"	f	class:RectangularDenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[dim3], int k, Scalar2 *b, int i, Scalar2 (*c)[dim2], int j) { $/;"	f	class:RectangularDenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(Scalar (*a)[dim3], int k, Vec3D *b, int i, Scalar2 (*c)[dim2], int j) { $/;"	f	class:RectangularDenseMatrixOp
applyAndAddToVector	DenseMatrixOps.h	/^  static void applyAndAddToVector(bcomp (*a)[36], int k, double (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^    static void applyAndSubToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[1], int k, Scalar2 (*b)[1], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[49], int k, Scalar2 (*b)[7], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[4], int k, Scalar2 (*b)[2], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[9], int k, Scalar2 (*b)[3], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(Scalar (*a)[dim2], int k, Scalar2 (*b)[dim], int i, $/;"	f	class:DenseMatrixOp
applyAndSubToVector	DenseMatrixOps.h	/^  static void applyAndSubToVector(bcomp (*a)[36], int k, double (*b)[6], int i,                                   double (*c)[6], int j) {$/;"	f	class:DenseMatrixOp
applyBCsToDerivativeOfResidual	Domain.C	/^void Domain::applyBCsToDerivativeOfResidual(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToDerivativeOfResidual	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToDerivativeOfResidual(DistSVec<double,dim> &U, DistSVec<double,dim> &dR)$/;"	f	class:SpaceOperator
applyBCsToDerivativeOfResidual	SubDomain.C	/^void SubDomain::applyBCsToDerivativeOfResidual(BcFcn *bcFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
applyBCsToH2Jacobian	Domain.C	/^void Domain::applyBCsToH2Jacobian(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToH2Jacobian	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToH2Jacobian(DistSVec<double,dim> &U, DistMat<Scalar,dim> &A)$/;"	f	class:SpaceOperator
applyBCsToH2Jacobian	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToH2Jacobian(DistSVec<double,dim> &U, DistMat<Scalar,neq> &A)$/;"	f	class:SpaceOperator
applyBCsToH2Jacobian	SubDomain.C	/^void SubDomain::applyBCsToH2Jacobian(BcFcn *bcFcn, BcData<dim> &bcs,$/;"	f	class:SubDomain
applyBCsToJacobian	Domain.C	/^void Domain::applyBCsToJacobian(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToJacobian	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::applyBCsToJacobian(DistSVec<Scalar2,dim>& U,$/;"	f	class:MultiGridOperator
applyBCsToJacobian	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToJacobian(DistSVec<double,dim> &U, DistMat<Scalar,neq> &A, DistLevelSetStructure *distLSS)$/;"	f	class:SpaceOperator
applyBCsToJacobian	SubDomain.C	/^void SubDomain::applyBCsToJacobian(BcFcn *bcFcn, BcData<dim> &bcs,$/;"	f	class:SubDomain
applyBCsToJacobianWallValues	Domain.C	/^void Domain::applyBCsToJacobianWallValues(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToJacobianWallValues	SubDomain.C	/^void SubDomain::applyBCsToJacobianWallValues(BcFcn *bcFcn, BcData<dim> &bcs,$/;"	f	class:SubDomain
applyBCsToProduct	Domain.C	/^void Domain::applyBCsToProduct(BcFcn *bcFcn, DistBcData<dim> &bcData, DistSVec<double,dim> &U, DistSVec<Scalar2,dim> &Prod)$/;"	f	class:Domain
applyBCsToProduct	SubDomain.C	/^void SubDomain::applyBCsToProduct(BcFcn *bcFcn, BcData<dim> &bcs, SVec<double,dim> &U, SVec<Scalar,dim> &Prod)$/;"	f	class:SubDomain
applyBCsToResidual	Domain.C	/^void Domain::applyBCsToResidual(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToResidual	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::applyBCsToResidual(DistSVec<Scalar2,dim>& U,$/;"	f	class:MultiGridOperator
applyBCsToResidual	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToResidual(DistSVec<double,dim> &U, DistSVec<double,dim> &R, DistLevelSetStructure *distLSS)$/;"	f	class:SpaceOperator
applyBCsToResidual	SubDomain.C	/^void SubDomain::applyBCsToResidual(BcFcn *bcFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
applyBCsToSolutionVector	Domain.C	/^void Domain::applyBCsToSolutionVector(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToSolutionVector	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToSolutionVector(DistSVec<double,dim> &U, DistLevelSetStructure *distLSS)$/;"	f	class:SpaceOperator
applyBCsToSolutionVector	SubDomain.C	/^void SubDomain::applyBCsToSolutionVector(BcFcn *bcFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
applyBCsToTurbSolutionVector	Domain.C	/^void Domain::applyBCsToTurbSolutionVector(BcFcn *bcFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
applyBCsToTurbSolutionVector	SpaceOperator.C	/^void SpaceOperator<dim>::applyBCsToTurbSolutionVector(DistSVec<double,dim> &U, DistLevelSetStructure *distLSS)$/;"	f	class:SpaceOperator
applyBCsToTurbSolutionVector	SubDomain.C	/^void SubDomain::applyBCsToTurbSolutionVector(BcFcn *bcFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
applyD	BCApplier.C	/^BCApplier::applyD(DistSVec<double,dim> &X)$/;"	f	class:BCApplier
applyD2	BCApplier.C	/^BCApplier::applyD2(DistSVec<double,dim> &X, double dX[dim])$/;"	f	class:BCApplier
applyDt	BCApplier.h	/^    template<int dim> void applyDt(DistSVec<double,dim> &X) { applyD(X); }$/;"	f	class:BCApplier
applyExtrapolationToSolutionVector	Domain.C	/^void Domain::applyExtrapolationToSolutionVector(DistExtrapolation<dim> *xpol, DistSVec<double,dim> &U,$/;"	f	class:Domain
applyExtrapolationToSolutionVector	InletNode.C	/^void InletNodeSet::applyExtrapolationToSolutionVector(Extrapolation<dim>* xpol, SVec<double,dim> &U, SVec<double,dim> &Ubc, int* locToGlobNodeMap)$/;"	f	class:InletNodeSet
applyExtrapolationToSolutionVector	SpaceOperator.C	/^void SpaceOperator<dim>::applyExtrapolationToSolutionVector(DistSVec<double,dim> &U,$/;"	f	class:SpaceOperator
applyExtrapolationToSolutionVector	SubDomain.C	/^void SubDomain::applyExtrapolationToSolutionVector(Extrapolation<dim>* xpol,SVec<double,dim> &U,$/;"	f	class:SubDomain
applyFixes	MultiGridKernel.C	/^applyFixes(int lvl,DistSVec<Scalar2,dim>& f) {$/;"	f	class:MultiGridKernel
applyH2	SpaceOperator.C	/^void SpaceOperator<dim>::applyH2(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
applyH2T	SpaceOperator.C	/^void SpaceOperator<dim>::applyH2T(DistSVec<double,3> &X,$/;"	f	class:SpaceOperator
applyH2transposeNew	SpaceOperator.C	/^void SpaceOperator<dim>::applyH2transposeNew(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
applyInviscid	MatVecProd.C	/^void MatVecProdFD<dim, neq>::applyInviscid(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdFD
applyInviscid	MatVecProd.h	/^  virtual void applyInviscid(DistSVec<double,neq> &, DistSVec<double,neq> &){$/;"	f	class:MatVecProd
applyNewRotation	KspSolver.C	/^applyNewRotation(int j, GenFullM<ScalarT> &H, GenFullM<ScalarT> &cs, Vec<ScalarT> &g)$/;"	f	class:GmresSolver
applyP	BCApplier.C	/^BCApplier::applyP(DistSVec<double,dim> &X)$/;"	f	class:BCApplier
applyPD	BCApplier.h	/^    template<int dim> void applyPD(DistSVec<double,dim> &X) { applyD(X); applyP(X); }$/;"	f	class:BCApplier
applyPDt	BCApplier.h	/^    template<int dim> void applyPDt(DistSVec<double,dim> &X) { applyPt(X); applyDt(X); }$/;"	f	class:BCApplier
applyPreviousRotations	KspSolver.C	/^applyPreviousRotations(int j, GenFullM<ScalarT> &H, GenFullM<ScalarT> &cs)$/;"	f	class:GmresSolver
applyProjector	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::applyProjector(DistSVec<double,3> &Xdot)$/;"	f	class:EmbeddedCorotSolver
applyProjector	MeshMotionSolver.C	/^TetMeshMotionSolver::applyProjector(DistSVec<double,3> &X)$/;"	f	class:TetMeshMotionSolver
applyProjector	MeshMotionSolver.h	/^  virtual void applyProjector(DistSVec<double,3> &dX) {}$/;"	f	class:MeshMotionSolver
applyProjectorTranspose	MeshMotionSolver.C	/^void TetMeshMotionSolver::applyProjectorTranspose(DistSVec<double,3> &X)$/;"	f	class:TetMeshMotionSolver
applyProjectorTranspose	MeshMotionSolver.h	/^  virtual void applyProjectorTranspose(DistSVec<double,3> &dX) {}$/;"	f	class:MeshMotionSolver
applyPt	BCApplier.h	/^    template<int dim> void applyPt(DistSVec<double,dim> &X) { applyP(X); }$/;"	f	class:BCApplier
applyRestrict	MatVecProd.C	/^void MatVecProdFD<dim, neq>::applyRestrict(DistSVec<double,neq> &p,$/;"	f	class:MatVecProdFD
applyRestrict	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::applyRestrict(DistSVec<double,neq> &p, DistSVec<double,neq> &prod,$/;"	f	class:MatVecProdH1
applyRestrict	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::applyRestrict(DistSVec<double,neq> &p, DistSVec<double,neq> &prod,$/;"	f	class:MatVecProdH2
applyRestrict	MatVecProd.h	/^  virtual void applyRestrict(DistSVec<double,neq> &, DistSVec<double,neq> &, RestrictionMapping<neq> &,$/;"	f	class:MatVecProd
applySmoothing	DomainCore.C	/^void Domain::applySmoothing(DistVec<double> &ctrlVol, DistSVec<double,2> &Q)$/;"	f	class:Domain
applySmoothing	DomainCore.C	/^void Domain::applySmoothing(DistVec<double> &ctrlVol, DistVec<double> &Q)$/;"	f	class:Domain
applySmoothing	SubDomainCore.C	/^void SubDomain::applySmoothing(Vec<double> &ctrlVol, SVec<double,2> &Q)$/;"	f	class:SubDomain
applySmoothing	SubDomainCore.C	/^void SubDomain::applySmoothing(Vec<double> &ctrlVol, Vec<double> &Q)$/;"	f	class:SubDomain
applyT	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::applyT(DistSVec<Scalar2,dim> &y, DistSVec<Scalar2,dim> &x)$/;"	f	class:IluPrec
applyT	KspPrec.h	/^  virtual void applyT(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { std::cout<< " ERROR: Using default applyT function in KspPrec" << endl; }$/;"	f	class:KspPrec
applyT	KspPrec.h	/^  virtual void applyT(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default applyT function in KspPrec" << endl; }$/;"	f	class:KspPrec
applyT	KspPrec.h	/^  void applyT(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix) { Ix = x; }$/;"	f	class:IdentityPrec
applyT	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::applyT(DistSVec<bcomp,neq> &p,$/;"	f	class:MatVecProdH2
applyT	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::applyT(DistSVec<double,neq> &p,$/;"	f	class:MatVecProdH2
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,dim> &x, DistSVec<bcomp,dim> &y) {}$/;"	f	class:MatVecProdFDMultiPhase
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,dim> &x, DistSVec<bcomp,dim> &y) {}$/;"	f	class:MatVecProdH1MultiPhase
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,dimLS> &x, DistSVec<bcomp,dimLS> &y) {}$/;"	f	class:MatVecProdLS
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y)  {$/;"	f	class:MatVecProdFD
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y) { $/;"	f	class:MatVecProdH1
applyT	MatVecProd.h	/^  void applyT(DistSVec<bcomp,neq> &x, DistSVec<bcomp,neq> &y)$/;"	f	class:MatVecProd_dRdX
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,dim> &, DistSVec<double,dim> &) {}$/;"	f	class:MatVecProdFDMultiPhase
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,dim> &, DistSVec<double,dim> &) {}$/;"	f	class:MatVecProdH1MultiPhase
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,dimLS> &, DistSVec<double,dimLS> &) {}$/;"	f	class:MatVecProdLS
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &)  {$/;"	f	class:MatVecProdFD
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &)  {$/;"	f	class:MatVecProdH1
applyT	MatVecProd.h	/^  void applyT(DistSVec<double,neq> &, DistSVec<double,neq> &)$/;"	f	class:MatVecProd_dRdX
applyT	MultiGridKspSolver.h	/^  void applyT(DistSVec<Scalar,neq>& x, DistSVec<Scalar,neq>& b) {}$/;"	f	class:MultiGridMatVecProd
applyT	MultiGridKspSolver.h	/^  void applyT(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {}$/;"	f	class:MultiGridRASPrec
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[1], int k, Scalar (*b)[1], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[25], int k, Scalar (*b)[25], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[36], int k, Scalar (*b)[36], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[49], int k, Scalar (*b)[49], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[4], int k, Scalar (*b)[4], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[9], int k, Scalar (*b)[9], int i, $/;"	f	class:DenseMatrixOp
applyToDenseMatrix	DenseMatrixOps.h	/^  static void applyToDenseMatrix(Scalar (*a)[dim2], int k, Scalar (*b)[dim2], int i, $/;"	f	class:DenseMatrixOp
applyToDerivativeOfResidualTerm	BcFcnCore.C	/^void BcFcn::applyToDerivativeOfResidualTerm(int t, double *v, double *dv, double *u, double *du, double *df)$/;"	f	class:BcFcn
applyToDerivativeOfResidualTerm	BcFcnCore.C	/^void BcFcnKE::applyToDerivativeOfResidualTerm(int type, double *Vwall, double *dVwall, double *U, double *dU, double *dF)$/;"	f	class:BcFcnKE
applyToDerivativeOfResidualTerm	BcFcnCore.C	/^void BcFcnNS::applyToDerivativeOfResidualTerm(int type, double *Vwall, double *dVwall, double *U, double *dU, double *dF)$/;"	f	class:BcFcnNS
applyToDerivativeOfResidualTerm	BcFcnCore.C	/^void BcFcnSA::applyToDerivativeOfResidualTerm(int type, double *Vwall, double *dVwall, double *U, double *dU, double *dF)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, bcomp *a) {}$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, bcomp *a) {}$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, bcomp *a) {}$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, bcomp *a) {}$/;"	f	class:BcFcnSAturb
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, double *a) {}$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, double *a) {}$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, double *a) {}$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, double *a) {}$/;"	f	class:BcFcnSAturb
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, float *a) {}$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, float *a) {}$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, float *a) {}$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcn.h	/^  void applyToDiagonalTerm(int c, double *vw, double *dvw, double *u, float *a) {}$/;"	f	class:BcFcnSAturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToDiagonalTerm(int t, double *v, double *u, bcomp *a)$/;"	f	class:BcFcn
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToDiagonalTerm(int t, double *v, double *u, double *a)$/;"	f	class:BcFcn
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToDiagonalTerm(int t, double *v, double *u, float *a)$/;"	f	class:BcFcn
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnKE
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnKEturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnNS
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *dVwall, double *U, bcomp *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *dVwall, double *U, double *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToDiagonalTerm(int type, double *Vwall, double *dVwall, double *U, float *A)$/;"	f	class:BcFcnSA
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnSAturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnSAturb
applyToDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnSAturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToOffDiagonalTerm(int t, bcomp *a)$/;"	f	class:BcFcn
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToOffDiagonalTerm(int t, double *a)$/;"	f	class:BcFcn
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToOffDiagonalTerm(int t, float *a)$/;"	f	class:BcFcn
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnKE
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnKE
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnKE
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnKEturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnKEturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnKEturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnNS
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnNS
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::applyToOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnNS
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnSA
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnSA
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnSA
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnSAturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnSAturb
applyToOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnSAturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, bcomp *f) {}$/;"	f	class:BcFcnKE
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, bcomp *f) {}$/;"	f	class:BcFcnKEturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, bcomp *f) {}$/;"	f	class:BcFcnNS
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, bcomp *f) {}$/;"	f	class:BcFcnSAturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, double *f) {}$/;"	f	class:BcFcnKE
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, double *f) {}$/;"	f	class:BcFcnKEturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, double *f) {}$/;"	f	class:BcFcnNS
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, double *f) {}$/;"	f	class:BcFcnSAturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, float *f) {}$/;"	f	class:BcFcnKE
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, float *f) {}$/;"	f	class:BcFcnKEturb
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, float *f) {}$/;"	f	class:BcFcnNS
applyToProductTerm	BcFcn.h	/^  void applyToProductTerm(int c, float *f) {}$/;"	f	class:BcFcnSAturb
applyToProductTerm	BcFcnCore.C	/^void BcFcnSA::applyToProductTerm(int type, bcomp *Prod)$/;"	f	class:BcFcnSA
applyToProductTerm	BcFcnCore.C	/^void BcFcnSA::applyToProductTerm(int type, double *Prod)$/;"	f	class:BcFcnSA
applyToProductTerm	BcFcnCore.C	/^void BcFcnSA::applyToProductTerm(int type, float *Prod)$/;"	f	class:BcFcnSA
applyToResidualTerm	BcFcnCore.C	/^void BcFcn::applyToResidualTerm(int t, double *v, double *u, double *f)$/;"	f	class:BcFcn
applyToResidualTerm	BcFcnCore.C	/^void BcFcnKE::applyToResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnKE
applyToResidualTerm	BcFcnCore.C	/^void BcFcnNS::applyToResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnNS
applyToResidualTerm	BcFcnCore.C	/^void BcFcnSA::applyToResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnSA
applyToSolutionVector	BcFcnCore.C	/^void BcFcn::applyToSolutionVector(int t, double *v, double *u)$/;"	f	class:BcFcn
applyToSolutionVector	BcFcnCore.C	/^void BcFcnKE::applyToSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnKE
applyToSolutionVector	BcFcnCore.C	/^void BcFcnNS::applyToSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnNS
applyToSolutionVector	BcFcnCore.C	/^void BcFcnSA::applyToSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnSA
applyToSolutionVector	BcFcnCore.C	/^void BcFcnSAturb::applyToSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnSAturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbDiagonalTerm(int t, double *v, double *u, bcomp *a)$/;"	f	class:BcFcn
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbDiagonalTerm(int t, double *v, double *u, double *a)$/;"	f	class:BcFcn
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbDiagonalTerm(int t, double *v, double *u, float *a)$/;"	f	class:BcFcn
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnKE
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnKE
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnKE
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnKEturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnKEturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnKEturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnSA
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnSA
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnSA
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, bcomp *A)$/;"	f	class:BcFcnSAturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, double *A)$/;"	f	class:BcFcnSAturb
applyToTurbDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbDiagonalTerm(int type, double *Vwall, double *U, float *A)$/;"	f	class:BcFcnSAturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbOffDiagonalTerm(int t, bcomp *a)$/;"	f	class:BcFcn
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbOffDiagonalTerm(int t, double *a)$/;"	f	class:BcFcn
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcn::applyToTurbOffDiagonalTerm(int t, float *a)$/;"	f	class:BcFcn
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnKE
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnKE
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnKE
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnKEturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnKEturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnKEturb::applyToTurbOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnKEturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnSA
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnSA
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnSA
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbOffDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnSAturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbOffDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnSAturb
applyToTurbOffDiagonalTerm	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbOffDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnSAturb
applyToTurbResidualTerm	BcFcnCore.C	/^void BcFcn::applyToTurbResidualTerm(int t, double *v, double *u, double *f)$/;"	f	class:BcFcn
applyToTurbResidualTerm	BcFcnCore.C	/^void BcFcnKE::applyToTurbResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnKE
applyToTurbResidualTerm	BcFcnCore.C	/^void BcFcnSA::applyToTurbResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnSA
applyToTurbSolutionVector	BcFcnCore.C	/^void BcFcn::applyToTurbSolutionVector(int t, double *v, double *u)$/;"	f	class:BcFcn
applyToTurbSolutionVector	BcFcnCore.C	/^void BcFcnKE::applyToTurbSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnKE
applyToTurbSolutionVector	BcFcnCore.C	/^void BcFcnSA::applyToTurbSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnSA
applyToTurbSolutionVector	BcFcnCore.C	/^void BcFcnSAturb::applyToTurbSolutionVector(int type, double *Vwall, double *U)$/;"	f	class:BcFcnSAturb
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[1], int k, Scalar2 (*b), int i,$/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[1], int k, Scalar2 (*b)[1], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[49], int k, Scalar2 (*b)[7], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[4], int k, Scalar2 (*b)[2], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[9], int k, Scalar2 (*b)[3], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(Scalar (*a)[dim2], int k, Scalar2 (*b)[dim], int i, $/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(bcomp (*a)[36], int k, double (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyToVector	DenseMatrixOps.h	/^  static void applyToVector(bcomp (*a)[dim2], int k, double (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[1], int k, Scalar2 (*b)[1], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[49], int k, Scalar2 (*b)[7], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[4], int k, Scalar2 (*b)[2], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[9], int k, Scalar2 (*b)[3], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(Scalar (*a)[dim2], int k, Scalar2 (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTransAndAddToVector	DenseMatrixOps.h	/^  static void applyTransAndAddToVector(bcomp (*a)[36], int k, double (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[1], int k, double (*b)[1], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[49], int k, double (*b)[7], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[4], int k, double (*b)[2], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[9], int k, Scalar2 (*b)[3], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[dim2], int k, bcomp (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(Scalar (*a)[dim2], int k, double (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTransAndSubToVector	DenseMatrixOps.h	/^  static void applyTransAndSubToVector(bcomp (*a)[36], int k, double (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[1], int k, double (*b)[1], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[25], int k, Scalar2 (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[36], int k, Scalar2 (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[36], int k, double (*b)[6], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[49], int k, Scalar2 (*b)[7], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[49], int k, double (*b)[7], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[4], int k, double (*b)[2], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[9], int k, double (*b)[3], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[dim2], int k, bcomp (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(Scalar (*a)[dim2], int k, double (*b)[dim], int i,$/;"	f	class:DenseMatrixOp
applyTransToVector	DenseMatrixOps.h	/^  static void applyTransToVector(bcomp (*a)[25], int k, double (*b)[5], int i,$/;"	f	class:DenseMatrixOp
applyTranspose	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::applyTranspose(DistSVec<Scalar2,dim> &y, DistSVec<Scalar2,dim> &x)$/;"	f	class:IluPrec
applyTranspose	KspPrec.h	/^  virtual void applyTranspose(DistEmbeddedVec<Scalar2,dim>& x, DistEmbeddedVec<Scalar2,dim>& Px) { std::cout<< " ERROR: Using default applyTranspose function in KspPrec" << endl; }$/;"	f	class:KspPrec
applyTranspose	KspPrec.h	/^  virtual void applyTranspose(DistSVec<Scalar2,dim> &, DistSVec<Scalar2,dim> &)  { std::cout << "  ERROR: Using default applyTranspose function in KspPrec" << endl; }$/;"	f	class:KspPrec
applyTranspose	KspPrec.h	/^  void applyTranspose(DistSVec<Scalar2,dim> &x, DistSVec<Scalar2,dim> &Ix) { Ix = x; }$/;"	f	class:IdentityPrec
applyTranspose	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::applyTranspose(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdH1
applyTranspose	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::applyTranspose(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdH2
applyTranspose	MatVecProd.h	/^  virtual void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }$/;"	f	class:MatVecProdMultiPhase
applyTranspose	MatVecProd.h	/^  virtual void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }$/;"	f	class:MatVecProd
applyTranspose	MatVecProd.h	/^  virtual void applyTranspose(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &) { }$/;"	f	class:MatVecProd
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }$/;"	f	class:MatVecProdFDMultiPhase
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,dim> &, DistEmbeddedVec<double,dim> &) { }$/;"	f	class:MatVecProdH1MultiPhase
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,dimLS> &, DistEmbeddedVec<double,dimLS> &) { }$/;"	f	class:MatVecProdLS
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }$/;"	f	class:MatVecProdFD
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }$/;"	f	class:MatVecProdH1
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &) { }$/;"	f	class:MatVecProdH2
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistEmbeddedVec<double,neq> &, DistEmbeddedVec<double,neq> &)$/;"	f	class:MatVecProd_dRdX
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &) {}$/;"	f	class:MatVecProdFDMultiPhase
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &) {}$/;"	f	class:MatVecProdH1MultiPhase
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistSVec<double,dimLS> &, DistSVec<double,dimLS> &) {}$/;"	f	class:MatVecProdLS
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &) {}$/;"	f	class:MatVecProdFD
applyTranspose	MatVecProd.h	/^  void applyTranspose(DistSVec<double,neq> &, DistSVec<double,neq> &)$/;"	f	class:MatVecProd_dRdX
applyTranspose	MultiGridKspSolver.h	/^  void applyTranspose(DistSVec<Scalar,neq>& x, DistSVec<Scalar,neq>& b) {}$/;"	f	class:MultiGridMatVecProd
applyTranspose	MultiGridKspSolver.h	/^  void applyTranspose(DistSVec<Scalar2,neq>& x, DistSVec<Scalar2,neq>& b) {}$/;"	f	class:MultiGridRASPrec
applyTranspose	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTranspose(SVec<double,dim2> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTranspose	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTranspose(SVec<double,dim2> &x, Vec<Vec3D> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTranspose	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTranspose(SVec<double,dim2> &x, Vec<double> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTranspose	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTranspose(Vec<Vec3D> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTranspose	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTranspose(Vec<double> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTranspose	StiffMatrix.h	/^  void applyTranspose(DistSVec<double,dim> &, DistSVec<double,dim> &)$/;"	f	class:StiffMat
applyTransposeAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTransposeAndAdd(SVec<double,dim2> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTransposeAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTransposeAndAdd(SVec<double,dim2> &x, Vec<Vec3D> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTransposeAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTransposeAndAdd(SVec<double,dim2> &x, Vec<double> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTransposeAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTransposeAndAdd(Vec<Vec3D> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTransposeAndAdd	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::applyTransposeAndAdd(Vec<double> &x, SVec<double,dim> &ATx, int *ndType)$/;"	f	class:RectangularSparseMat
applyTransposeAndAddToVector	DenseMatrixOps.h	/^  static void applyTransposeAndAddToVector(Scalar (*a)[dim3], int k, Scalar2 (*b)[dim2], int i, $/;"	f	class:RectangularDenseMatrixOp
applyTransposeAndAddToVector	DenseMatrixOps.h	/^  static void applyTransposeAndAddToVector(Scalar (*a)[dim3], int k, Scalar2 *b, int i, $/;"	f	class:RectangularDenseMatrixOp
applyTransposeAndAddToVector	DenseMatrixOps.h	/^  static void applyTransposeAndAddToVector(Scalar (*a)[dim3], int k, Vec3D *b, int i, $/;"	f	class:RectangularDenseMatrixOp
applyViscous	MatVecProd.C	/^void MatVecProdFD<dim, neq>::applyViscous(DistSVec<double,neq> &p, DistSVec<double,neq> &prod)$/;"	f	class:MatVecProdFD
applyViscous	MatVecProd.h	/^  virtual void applyViscous(DistSVec<double,neq> &, DistSVec<double,neq> &){$/;"	f	class:MatVecProd
applyViscous	MatVecProd.h	/^  void applyViscous(DistSVec<bcomp,neq> &, DistSVec<bcomp,neq> &)$/;"	f	class:MatVecProdFD
applyWeighted	MatVecProd.C	/^void MatVecProdFD<dim, neq>::applyWeighted(DistSVec<double,neq> &p, DistSVec<double,neq> &prod, VarFcn *varFcn)$/;"	f	class:MatVecProdFD
applyWeighted	MatVecProd.h	/^  virtual void applyWeighted(DistSVec<double,neq> &, DistSVec<double,neq> &, VarFcn *){$/;"	f	class:MatVecProd
applyWeightedRestrict	MatVecProd.C	/^void MatVecProdFD<dim, neq>::applyWeightedRestrict(DistSVec<double,neq> &p,$/;"	f	class:MatVecProdFD
applyWeightedRestrict	MatVecProd.h	/^  virtual void applyWeightedRestrict(DistSVec<double,neq> &, DistSVec<double,neq> &, RestrictionMapping<dim> &, VarFcn *,$/;"	f	class:MatVecProd
approxMetricData	GappyPreprocessing.h	/^        ApproximatedMetricData* approxMetricData;$/;"	m	class:GappyPreprocessing
approxMetricNonlinear	IoData.h	/^  ApproximatedMetricData approxMetricNonlinear;$/;"	m	struct:GappyConstructionData
approxMetricNonlinearLowRankFullCoordsName	IoData.h	/^  const char *approxMetricNonlinearLowRankFullCoordsName;$/;"	m	struct:NonlinearRomFilesData
approxMetricNonlinearLowRankFullCoordsName	NonlinearRom.h	/^  char* approxMetricNonlinearLowRankFullCoordsName;$/;"	m	class:NonlinearRom
approxMetricNonlinearLowRankName	IoData.h	/^  const char *approxMetricNonlinearLowRankName;$/;"	m	struct:NonlinearRomFilesData
approxMetricNonlinearLowRankName	NonlinearRom.h	/^  char* approxMetricNonlinearLowRankName;$/;"	m	class:NonlinearRom
approxMetricNonlinearName	IoData.h	/^  const char *approxMetricNonlinearName; \/\/ ascii file$/;"	m	struct:NonlinearRomFilesData
approxMetricNonlinearName	NonlinearRom.h	/^  char* approxMetricNonlinearName;$/;"	m	class:NonlinearRom
approxMetricNonlinearSnapFile	IoData.h	/^  const char *approxMetricNonlinearSnapFile;$/;"	m	struct:InputData
approxMetricPrepro	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
approxMetricState	IoData.h	/^  ApproximatedMetricData approxMetricState;$/;"	m	struct:BasisUpdatesData
approxMetricStateLowRankFullCoordsName	IoData.h	/^  const char *approxMetricStateLowRankFullCoordsName; \/\/ approximated metric in full mesh coordinates$/;"	m	struct:NonlinearRomFilesData
approxMetricStateLowRankFullCoordsName	NonlinearRom.h	/^  char* approxMetricStateLowRankFullCoordsName;$/;"	m	class:NonlinearRom
approxMetricStateLowRankName	IoData.h	/^  const char *approxMetricStateLowRankName; \/\/ approximated metric in reduced mesh coordinates$/;"	m	struct:NonlinearRomFilesData
approxMetricStateLowRankName	NonlinearRom.h	/^  char* approxMetricStateLowRankName;$/;"	m	class:NonlinearRom
approxMetricStateLowRankSurfaceCoordsName	IoData.h	/^  const char *approxMetricStateLowRankSurfaceCoordsName;$/;"	m	struct:NonlinearRomFilesData
approxMetricStateLowRankSurfaceCoordsName	NonlinearRom.h	/^  char* approxMetricStateLowRankSurfaceCoordsName;$/;"	m	class:NonlinearRom
approxMetricStateSnapFile	IoData.h	/^  const char *approxMetricStateSnapFile;$/;"	m	struct:InputData
apressFlag	IoData.h	/^  bool apressFlag;$/;"	m	struct:SensitivityAnalysis
arcomplex	arpack++/include/arcomp.h	/^    arcomplex(): complex() { }$/;"	f	class:arcomplex
arcomplex	arpack++/include/arcomp.h	/^    arcomplex(ARFLOAT x, ARFLOAT y): complex(x,y) { }$/;"	f	class:arcomplex
arcomplex	arpack++/include/arcomp.h	/^    arcomplex(complex x): complex(x) { }$/;"	f	class:arcomplex
arcomplex	arpack++/include/arcomp.h	/^  class arcomplex: public complex$/;"	c
arcomplex	arpack++/include/arcomp.h	24;"	d
areHHTermsActive	MatVecProd.h	/^  bool areHHTermsActive;$/;"	m	class:MatVecProdH1
areHHTermsActive	MatVecProd.h	/^  bool areHHTermsActive;$/;"	m	class:MatVecProdH1MultiPhase
area	AgglomeratedFace.h	/^  double area;$/;"	m	class:AgglomeratedFace
area	MultiGridLevel.C	/^  double area;$/;"	m	struct:agg_face	file:
area	MultiGridLevel.C	/^  double area;$/;"	m	struct:loc_edge	file:
arenaGrow	Malloc.C	/^void *arenaGrow(size_t size, void *)$/;"	f
arenas	Malloc.C	/^void **arenas = 0;$/;"	v
argmax	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmax.h	/^inline int argmax(const T a,const T b)$/;"	f	namespace:PhysBAM
argmax	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmax.h	/^inline int argmax(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
argmin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmin.h	/^inline int argmin(const T a,const T b)$/;"	f	namespace:PhysBAM
argmin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/argmin.h	/^inline int argmin(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    T_ARRAY* array;$/;"	m	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    T_ARRAY2_VIEW array;$/;"	m	class:PhysBAM::ARRAY_LEFT_MULTIPLE
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    T_ARRAY_VIEW array;$/;"	m	class:PhysBAM::ARRAY_NEGATION
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    T_ARRAY2_VIEW array;$/;"	m	class:PhysBAM::ARRAY_PLUS_SCALAR
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    T_ARRAY_VIEW array;$/;"	m	class:PhysBAM::INDIRECT_ARRAY
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    T_ARRAY& array;$/;"	m	class:PhysBAM::PROJECTED_ARRAY
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    const T_ARRAY& array;$/;"	m	struct:PhysBAM::INDIRECT_COMPARE
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/STACK.h	/^    ARRAY<T> array;$/;"	m	class:PhysBAM::STACK
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_VIEW<T> array; \/\/ one-dimensional data storage$/;"	m	class:PhysBAM::ARRAY_BASE
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    T array[d];$/;"	m	class:PhysBAM::VECTOR
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR& array;$/;"	m	class:PhysBAM::VECTOR_NEGATION
array	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR& array;$/;"	m	class:PhysBAM::VECTOR_SCALE
array	SimpleBuffer.h	/^  Scalar * array() { return values_; }$/;"	f	class:SimpleBuffer
array	SimpleBuffer.h	/^  const Scalar * array() const { return values_; }$/;"	f	class:SimpleBuffer
array1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    T_ARRAY1_VIEW array1;$/;"	m	class:PhysBAM::ARRAY_DIFFERENCE
array1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    T_ARRAY1_VIEW array1;$/;"	m	class:PhysBAM::ARRAY_PRODUCT
array1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    T_ARRAY1_VIEW array1;$/;"	m	class:PhysBAM::ARRAY_SUM
array1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR1& array1;$/;"	m	class:PhysBAM::VECTOR_DIFFERENCE
array1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR1& array1;$/;"	m	class:PhysBAM::VECTOR_SUM
array2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    T_ARRAY2_VIEW array2;$/;"	m	class:PhysBAM::ARRAY_DIFFERENCE
array2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    T_ARRAY2_VIEW array2;$/;"	m	class:PhysBAM::ARRAY_PRODUCT
array2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    T_ARRAY2_VIEW array2;$/;"	m	class:PhysBAM::ARRAY_SUM
array2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR2& array2;$/;"	m	class:PhysBAM::VECTOR_DIFFERENCE
array2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const T_VECTOR2& array2;$/;"	m	class:PhysBAM::VECTOR_SUM
array_collection	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    T_ARRAY_COLLECTION array_collection;$/;"	m	class:PhysBAM::POINT_CLOUD
arrays	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    ARRAY<ARRAY_COLLECTION_ELEMENT_BASE*,ID> arrays;$/;"	m	class:PhysBAM::ARRAY_COLLECTION
assemble	Domain.C	/^void Domain::assemble(CommPattern<Scalar> *commPat, DistSVec<Scalar,dim> &W)$/;"	f	class:Domain
assemble	Domain.C	/^void Domain::assemble(CommPattern<Scalar> *commPat, DistSVec<Scalar,dim> &W, const OpType &oper)$/;"	f	class:Domain
assemble	Domain.C	/^void Domain::assemble(CommPattern<Scalar> *commPat, DistVec<Scalar> &W)$/;"	f	class:Domain
assemble	Domain.C	/^void Domain::assemble(CommPattern<Scalar> *commPat, DistVec<Scalar> &W, const OpType& oper)$/;"	f	class:Domain
assemble	Domain.h	/^  void assemble(DistSVec<double,3> &v) {$/;"	f	class:Domain
assemble	Domain.h	/^  void assemble(DistSVec<double,3> &v, const OpType &oper) {$/;"	f	class:Domain
assemble	Domain.h	/^  void assemble(DistVec<double> &v) {$/;"	f	class:Domain
assemble	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assemble(DistMat<Scalar2,dim>& A)$/;"	f	class:MultiGridLevel
assemble	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assemble(DistSVec<Scalar2,dim>& V)$/;"	f	class:MultiGridLevel
assemble	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assemble(DistVec<Scalar2>& V)$/;"	f	class:MultiGridLevel
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<T> & commPat, Connectivity ** sharedNodes, DistSVec<T,dim> & data, const OperType & op,std::map<int,std::map<int,int> >* locToGlobMap = NULL) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<T> & commPat, Connectivity ** sharedNodes, DistVec<T> & data, const OperType & op) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<T> & commPatDiag, Connectivity ** sharedNodes, DistMat<T,dim> & A) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<T> & commPatOffDiag, int **numSharedEdges, EdgeDef ***sharedEdges, DistMat<T,dim> & A) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<T> & edgePat, int **numSharedEdges, EdgeDef ***sharedEdges, DistVec<T> & V) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<double> & commPat, Connectivity ** sharedNodes, std::list<Vec3D>** data, int max_node_adj) {$/;"	f	namespace:__anon11
assemble	MultiGridLevel.C	/^void assemble(Domain & domain, CommPattern<double> & edgePat, int **numSharedEdges, EdgeDef ***sharedEdges, DistVec<Vec3D> & V) {$/;"	f	namespace:__anon11
assembleEdge	DomainCore.C	/^void Domain::assembleEdge(CommPattern<double> *commPat, DistVec<double> &W)$/;"	f	class:Domain
assembleGhostPoints	Domain.C	/^void Domain::assembleGhostPoints(DistVec<GhostPoint<dim>*> &ghostPoints, VarFcn *varFcn)$/;"	f	class:Domain
assembleInternal	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assembleInternal(DistMat<T,dim> & A) const {$/;"	f	class:MultiGridLevel
assembleInternal	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assembleInternal(DistSVec<T,dim> & A) const {$/;"	f	class:MultiGridLevel
assembleInternal	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assembleInternal(DistVec<T> & A) const {$/;"	f	class:MultiGridLevel
assembleInternalMax	MultiGridLevel.C	/^assembleInternalMax(DistVec<T> & A) const {$/;"	f	class:MultiGridLevel
assembleIntoSets	IntersectorPhysBAM/Mpi_Utilities.C	/^void assembleIntoSets(Domain& domain, Communicator& com,DistVec<pair<int,int> >& localColor,DistVec<set<pair<int,int> > >& nodeLocalColors){$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
assembleMax	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assembleMax(DistSVec<Scalar2,dim>& V)$/;"	f	class:MultiGridLevel
assembleMax	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::assembleMax(DistVec<Scalar2>& V) {$/;"	f	class:MultiGridLevel
assembleOnlineMatrices	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::assembleOnlineMatrices() {$/;"	f	class:GappyPreprocessing
assembleOnlineMatrices	SurfMeshGen.h	/^	void assembleOnlineMatrices() { ;}$/;"	f	class:SurfMeshGen
assemble_dWdt	Domain.C	/^void Domain::assemble_dWdt(DistSVec<double, dim> &dWdt, DistSVec<double, dim> &Sigma)$/;"	f	class:Domain
assignDouble	parser/Assigner.h	/^    void assignDouble(double v) { ptr->*sp = v; }$/;"	f	class:ClassDouble
assignDouble	parser/Assigner.h	/^   void assignDouble(double v) { *val = int(v); }$/;"	f	class:SysIntObj
assignDouble	parser/Assigner.h	/^   void assignDouble(double v) { *val = v; }$/;"	f	class:SysDoubleObj
assignDouble	parser/AssignerCore.C	/^Assigner::assignDouble(double)$/;"	f	class:Assigner
assignDouble	parser/ParseTree.h	/^    void assignDouble(double val) {$/;"	f	class:ParseNode
assignErrorHandler	DomainCore.C	/^void Domain::assignErrorHandler(){$/;"	f	class:Domain
assignErrorHandler	Edge.h	/^  void assignErrorHandler(ErrorHandler* in){errorHandler = in;}$/;"	f	class:EdgeSet
assignErrorHandler	SubDomainCore.C	/^void SubDomain::assignErrorHandler(ErrorHandler* in){$/;"	f	class:SubDomain
assignErrorHandler	TsParameters.h	/^  void assignErrorHandler(ErrorHandler* in){errorHandler = in; }$/;"	f	class:TsParameters
assignFreeStreamValues	Face.C	/^void Face::assignFreeStreamValues(double *Uin, double *Uout, double *U)$/;"	f	class:Face
assignFreeStreamValues	InletNode.C	/^void InletNode::assignFreeStreamValues(int type, double *Uin, double *Uout, double *U)$/;"	f	class:InletNode
assignFreeStreamValues	SubDomain.C	/^void SubDomain::assignFreeStreamValues(double *Uin, double *Uout, SVec<double,dim> &U, SVec<double,dim> &Uinlet)$/;"	f	class:SubDomain
assignFreeStreamValues2	AgglomeratedFace.C	/^void AgglomeratedFace::assignFreeStreamValues2(SVec<double,dim> &Uin, SVec<double,dim> &Uout, double *U)$/;"	f	class:AgglomeratedFace
assignFreeStreamValues2	Face.C	/^void Face::assignFreeStreamValues2(SVec<double,dim> &Uin, SVec<double,dim> &Uout, double *U)$/;"	f	class:Face
assignFreeStreamValues2	SubDomain.C	/^void SubDomain::assignFreeStreamValues2(SVec<double,dim> &Uin, SVec<double,dim> &Uout,$/;"	f	class:SubDomain
assignInt	parser/Assigner.h	/^    void assignInt(int v) { ptr->*sp = v; }$/;"	f	class:ClassDouble
assignInt	parser/Assigner.h	/^    void assignInt(int v) { ptr->*sp = v; }$/;"	f	class:ClassInt
assignInt	parser/Assigner.h	/^   void assignInt(int v) { *val = v; }$/;"	f	class:SysDoubleObj
assignInt	parser/Assigner.h	/^   void assignInt(int v) { *val = v; }$/;"	f	class:SysIntObj
assignInt	parser/AssignerCore.C	/^Assigner::assignInt(int)$/;"	f	class:Assigner
assignInt	parser/ParseTree.h	/^    void assignInt(int val) {$/;"	f	class:ParseNode
assignList	parser/Assigner.C	/^ClassArray<T>::assignList(int nt, int *(list[]))$/;"	f	class:ClassArray
assignList	parser/AssignerCore.C	/^Assigner::assignList(int n,int *(list[]))$/;"	f	class:Assigner
assignPorousWallValues	Face.C	/^void Face::assignPorousWallValues(SVec<double,dim> &Uin, double *U)$/;"	f	class:Face
assignPorousWallValues	SubDomain.C	/^void SubDomain::assignPorousWallValues(SVec<double,dim> &Uin, SVec<double,dim> &U)$/;"	f	class:SubDomain
assignString	parser/Assigner.C	/^ClassStr<T>::assignString(const char *string)$/;"	f	class:ClassStr
assignString	parser/Assigner.h	/^  virtual void assignString(const char *p) {$/;"	f	class:SysStrObj
assignString	parser/AssignerCore.C	/^Assigner::assignString(const char *)$/;"	f	class:Assigner
assignString	parser/ParseTree.h	/^    void assignString(const char *val) {$/;"	f	class:ParseNode
assignToken	parser/Assigner.C	/^ClassToken<T>::assignToken(int t)$/;"	f	class:ClassToken
assignToken	parser/AssignerCore.C	/^Assigner::assignToken(int)$/;"	f	class:Assigner
assignToken	parser/AssignerCore.C	/^SysTokenObj::assignToken(int t)$/;"	f	class:SysTokenObj
assignToken	parser/ParseTree.h	/^    void assignToken(int val) {$/;"	f	class:ParseNode
assignTokenIntPair	parser/Assigner.C	/^ClassToken<T>::assignTokenIntPair(int t,int s)$/;"	f	class:ClassToken
assignTokenIntPair	parser/AssignerCore.C	/^Assigner::assignTokenIntPair(int,int)$/;"	f	class:Assigner
assign_coherent	AutoDiff/SpaceDerivatives.h	/^void assign_coherent(const A& a, B& b)$/;"	f
assign_coherent_impl	AutoDiff/SpaceDerivatives.h	/^struct assign_coherent_impl {$/;"	s
assign_coherent_impl	AutoDiff/SpaceDerivatives.h	/^struct assign_coherent_impl<Eigen::Matrix<Scalar, 1, 1, Options, MaxRows, MaxCols>, Scalar> {$/;"	s
assign_coherent_impl	AutoDiff/SpaceDerivatives.h	/^struct assign_coherent_impl<Eigen::Matrix<Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>, $/;"	s
assign_coherent_impl	AutoDiff/SpaceDerivatives.h	/^struct assign_coherent_impl<Eigen::Matrix<Scalar, B_Rows*B_Cols, A_Cols, A_Options, A_MaxRows, A_MaxCols>,$/;"	s
assign_coherent_impl	AutoDiff/SpaceDerivatives.h	/^struct assign_coherent_impl<Scalar, Eigen::Matrix<Scalar, 1, 1, Options, MaxRows, MaxCols> > {$/;"	s
assimilateCells	SubDomainCore.C	/^void SubDomain::assimilateCells(int baseNode,$/;"	f	class:SubDomain
assum	arpack++/include/blas1c.h	/^inline double assum(const ARint &n, const arcomplex<double> dx[],$/;"	f
assum	arpack++/include/blas1c.h	/^inline double assum(const ARint &n, const double dx[], const ARint &incx) {$/;"	f
assum	arpack++/include/blas1c.h	/^inline float assum(const ARint &n, const arcomplex<float> dx[],$/;"	f
assum	arpack++/include/blas1c.h	/^inline float assum(const ARint &n, const float dx[], const ARint &incx) {$/;"	f
atan2_y_x_over_y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	/^inline T atan2_y_x_over_y(const T y,const T x) \/\/ atan2(y,x)\/y$/;"	f	namespace:PhysBAM
attachHH	DistTimeState.C	/^void DistTimeState<dim>::attachHH(DistVec<double>& hh) {$/;"	f	class:DistTimeState
attachHH	MatVecProd.C	/^void MatVecProdFD<dim, neq>::attachHH(DistEmbeddedVec<double,dim>& v) {$/;"	f	class:MatVecProdFD
attachHH	MatVecProd.C	/^void MatVecProdFDMultiPhase<dim, dimLS>::attachHH(DistEmbeddedVec<double,dim>& v) {$/;"	f	class:MatVecProdFDMultiPhase
attachHH	MatVecProd.C	/^void MatVecProdH1<dim,Scalar, neq>::attachHH(DistEmbeddedVec<double,dim>& v) {$/;"	f	class:MatVecProdH1
attachHH	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::attachHH(DistEmbeddedVec<double,dim>& v) {$/;"	f	class:MatVecProdH1MultiPhase
attachHH	MatVecProd.h	/^  virtual void attachHH(DistEmbeddedVec<double,dim>& v) { }$/;"	f	class:MatVecProd
attachHH	MatVecProd.h	/^  virtual void attachHH(DistEmbeddedVec<double,dim>& v) { }$/;"	f	class:MatVecProdMultiPhase
attachHH	TimeState.C	/^void TimeState<dim>::attachHH(Vec<double> *hhn_,Vec<double> *hhnm1_) {$/;"	f	class:TimeState
attachHigherOrderFSI	EdgeCore.C	/^void EdgeSet::attachHigherOrderFSI(HigherOrderFSI* fsi) {$/;"	f	class:EdgeSet
attachHigherOrderMF	Face.h	/^  void attachHigherOrderMF(class HigherOrderMultiFluid* mf) { higherOrderMF = mf; }$/;"	f	class:Face
attachHigherOrderMF	FaceCore.C	/^void FaceSet::attachHigherOrderMF(class HigherOrderMultiFluid* mf) {$/;"	f	class:FaceSet
attachHigherOrderMultiFluid	EdgeCore.C	/^void EdgeSet::attachHigherOrderMultiFluid(HigherOrderMultiFluid* mf) {$/;"	f	class:EdgeSet
attachProgrammedBurn	EdgeCore.C	/^void EdgeSet::attachProgrammedBurn(ProgrammedBurn* p) {$/;"	f	class:EdgeSet
attachProgrammedBurn	FluidSelector.h	/^  void attachProgrammedBurn(ProgrammedBurn* p) { programmedBurn = p; }$/;"	f	class:FluidSelector
attachTriangulatedInterface	DomainCore.C	/^void Domain::attachTriangulatedInterface(TriangulatedInterface* T) {$/;"	f	class:Domain
attachTriangulatedInterface	SpaceOperator.C	/^attachTriangulatedInterface(TriangulatedInterface* T) {$/;"	f	class:MultiPhaseSpaceOperator
attachTriangulatedInterfaceLSS	EdgeCore.C	/^void EdgeSet::attachTriangulatedInterfaceLSS(LevelSetStructure* LSS) {$/;"	f	class:EdgeSet
attachTriangulatedInterfaceLSS	SubDomainCore.C	/^void SubDomain::attachTriangulatedInterfaceLSS(LevelSetStructure* LSS) {$/;"	f	class:SubDomain
autoInit	MatchNodeCore.C	/^void MatchNodeSet::autoInit(int nNodes) $/;"	f	class:MatchNodeSet
average	DistVector.h	/^DistSVec<Scalar,dim>::average()$/;"	f	class:DistSVec
avgIncrementalStates	IoData.h	/^  enum AvgIncrementalStates {AVG_INCREMENTAL_STATES_FALSE = 0, AVG_INCREMENTAL_STATES_TRUE = 1} avgIncrementalStates;$/;"	m	struct:NonlinearRomFileSystemData	typeref:enum:NonlinearRomFileSystemData::AvgIncrementalStates
avgStateIncrements	IoData.h	/^  enum AvgStateIncrements {AVG_STATE_INCREMENTS_OFF = 0, AVG_STATE_INCREMENTS_ON = 1} avgStateIncrements;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::AvgStateIncrements
avgsIt	IoData.h	/^  int avgsIt;$/;"	m	struct:SensitivityAnalysis
avoidNewPhaseCreation	DistExactRiemannSolver.C	/^void DistExactRiemannSolver<dim>::avoidNewPhaseCreation(DistSVec<double,dimLS> &Phi, DistSVec<double,dimLS> &Phin, DistLevelSetStructure *distLSS)$/;"	f	class:DistExactRiemannSolver
avoidNewPhaseCreation	Domain.C	/^void Domain::avoidNewPhaseCreation(DistSVec<double,dimLS> &Phi, DistSVec<double,dimLS> &Phin){$/;"	f	class:Domain
avoidNewPhaseCreation	Domain.C	/^void Domain::avoidNewPhaseCreation(DistSVec<double,dimLS> &Phi, DistSVec<double,dimLS> &Phin, DistVec<double> &weight, DistLevelSetStructure *distLSS, $/;"	f	class:Domain
avoidNewPhaseCreation	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::avoidNewPhaseCreation(DistSVec<double,dimLS> &localPhi)$/;"	f	class:LevelSetTsDesc
avoidNewPhaseCreation	SubDomain.C	/^void SubDomain::avoidNewPhaseCreation(SVec<double,dimLS> &Phi, SVec<double,dimLS> &Phin)$/;"	f	class:SubDomain
avoidNewPhaseCreation	SubDomain.C	/^void SubDomain::avoidNewPhaseCreation(SVec<double,dimLS> &Phi, SVec<double,dimLS> &Phin, Vec<double> &weight, LevelSetStructure *LSS, Vec<int>* fluidIdToSet)$/;"	f	class:SubDomain
avscalars	TsOutput.h	/^  char *avscalars[PostFcn::AVSSIZE];$/;"	m	class:TsOutput
avsscale	TsOutput.h	/^  double avsscale[PostFcn::AVSSIZE];$/;"	m	class:TsOutput
avvectors	TsOutput.h	/^  char *avvectors[PostFcn::AVVSIZE];$/;"	m	class:TsOutput
avvscale	TsOutput.h	/^  double avvscale[PostFcn::AVVSIZE];$/;"	m	class:TsOutput
ax	IoData.h	/^  double ax;$/;"	m	struct:HeavingData
ax	IoData.h	/^  double ax;$/;"	m	struct:RigidMeshMotionData
axis	KDTree.h	/^    int axis;$/;"	m	struct:KDTree::KDTreeNode
axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less
axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less_Equal
axpy	arpack++/include/blas1c.h	/^inline void axpy(const ARint &n, const arcomplex<double> &da,$/;"	f
axpy	arpack++/include/blas1c.h	/^inline void axpy(const ARint &n, const arcomplex<float> &da,$/;"	f
axpy	arpack++/include/blas1c.h	/^inline void axpy(const ARint &n, const double &da, const double dx[],$/;"	f
axpy	arpack++/include/blas1c.h	/^inline void axpy(const ARint &n, const float &da, const float dx[],$/;"	f
ay	IoData.h	/^  double ay;$/;"	m	struct:HeavingData
ay	IoData.h	/^  double ay;$/;"	m	struct:RigidMeshMotionData
az	IoData.h	/^  double az;$/;"	m	struct:HeavingData
az	IoData.h	/^  double az;$/;"	m	struct:RigidMeshMotionData
b	AutoDiff/Taylor.h	/^    Scalar b[nvar][nvar];$/;"	m	class:Taylor2
b	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T a,b,c; \/\/ coefficients$/;"	m	class:PhysBAM::QUADRATIC
b	Vector.h	/^  T2 b;$/;"	m	class:Diff
b	Vector.h	/^  T2 b;$/;"	m	class:Div
b	Vector.h	/^  T2 b;$/;"	m	class:InnerProd
b	Vector.h	/^  T2 b;$/;"	m	class:Sum
b1	ImplicitSegTsDesc.h	/^  DistSVec<double,neq1> b1, dQ1;$/;"	m	class:ImplicitSegTsDesc
b2	ImplicitSegTsDesc.h	/^  DistSVec<double,neq2> b2, dQ2;$/;"	m	class:ImplicitSegTsDesc
b_	VarFcnTait.h	/^  double b_;$/;"	m	class:VarFcnTait
backupAsciiFile	TsOutput.C	/^FILE *TsOutput<dim>::backupAsciiFile(char *name)$/;"	f	class:TsOutput
backuptag	DistEdgeGrad.h	/^  DistVec<bool> *backuptag;$/;"	m	class:DistEdgeGrad
backuptag	DistNodalGrad.h	/^  DistVec<bool> *backuptag;$/;"	m	class:DistNodalGrad
backwardSolve	KspSolver.C	/^backwardSolve(int m, GenFullM<ScalarT> &H, Vec<ScalarT> &g, Vec<ScalarT> &y)$/;"	f	class:GmresSolver
bandlevel	IoData.h	/^  int bandlevel;$/;"	m	struct:MultiFluidData
bandlevel	LevelSet.h	/^  int bandlevel;                                   \/\/ number of node layers to reinitialize $/;"	m	class:LevelSet
barrier	CommunicatorMPI.C	/^int Communicator::barrier()$/;"	f	class:Communicator
barth	RecFcn.h	/^void RecFcn::barth(double Vimax, double Vimin, double Vi, double Vij, double ctrlVoli,$/;"	f	class:RecFcn
barthDerivative	RecFcn.h	/^void RecFcn::barthDerivative(double Vimax, double dVimax, double Vimin, double dVimin, double Vi, double dVi, double Vij, double dVij, double ctrlVoli, double dCtrlVoli,$/;"	f	class:RecFcn
base_	SparseGrid.h	/^  	double base_;$/;"	m	class:SparseGrid::LogarithmicMapping
base_pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    T* base_pointer;$/;"	m	class:PhysBAM::ARRAY
base_pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typename COPY_CONST<T*>::TYPE base_pointer;$/;"	m	class:PhysBAM::ARRAY_VIEW
base_pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T* base_pointer;$/;"	m	class:PhysBAM::ARRAY_BASE
basis	NonlinearRom.h	/^  VecSet< DistSVec<double, dim> >* basis;$/;"	m	class:NonlinearRom
basisBasisProducts	NonlinearRom.h	/^  std::vector<std::vector<std::vector<std::vector<double> > > > basisBasisProducts;  \/\/ [iCluster][pCluster][:][:]$/;"	m	class:NonlinearRom
basisBasisProductsName	NonlinearRom.h	/^  char* basisBasisProductsName;     \/\/ for exact updates (exactUpdateInfoPrefix.exactUpdates_F)$/;"	m	class:NonlinearRom
basisComponentwiseSums	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > basisComponentwiseSums;  \/\/ [iCluster][iVec][1:dim]$/;"	m	class:NonlinearRom
basisComponentwiseSumsName	NonlinearRom.h	/^  char* basisComponentwiseSumsName; \/\/ for exact updates with uniform IC (exactUpdateInfoPrefix.exactUpdates_StateBasisComponentwiseSums)$/;"	m	class:NonlinearRom
basisMultiUicProducts	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > basisMultiUicProducts; \/\/ [iCluster][Uj][1:nPod]$/;"	m	class:NonlinearRom
basisMultiUicProductsName	NonlinearRom.h	/^  char* basisMultiUicProductsName;$/;"	m	class:NonlinearRom
basisNormalizedCenterProducts	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > basisNormalizedCenterProducts; \/\/ [Cluster_Basis][Cluster_Center][:]$/;"	m	class:NonlinearRom
basisNormalizedCenterProductsName	IoData.h	/^  const char *basisNormalizedCenterProductsName;$/;"	m	struct:NonlinearRomFilesData
basisNormalizedCenterProductsName	NonlinearRom.h	/^  char* basisNormalizedCenterProductsName;   \/\/ for velocity-based local ROMs (incremental bases)$/;"	m	class:NonlinearRom
basisUicProducts	NonlinearRom.h	/^  std::vector<std::vector<double> > basisUicProducts;  \/\/ [iCluster][1:nPod] only precomputed if Uic specified$/;"	m	class:NonlinearRom
basisUicProductsName	NonlinearRom.h	/^  char* basisUicProductsName;       \/\/ for exact updates (exactUpdateInfoPrefix.exactUpdates_d)$/;"	m	class:NonlinearRom
basisUpdateFreq	ImplicitRomTsDesc.h	/^  int basisUpdateFreq;  $/;"	m	class:ImplicitRomTsDesc
basisUpdateFreq	IoData.h	/^  int basisUpdateFreq;$/;"	m	struct:NonlinearRomOnlineData
basisUpdateTolerance	IoData.h	/^  double basisUpdateTolerance;$/;"	m	struct:NonlinearRomOnlineData
basisUpdates	IoData.h	/^  BasisUpdatesData basisUpdates;$/;"	m	struct:ROBConstructionData
basisUpdates	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1, UPDATES_FAST_EXACT = 2, UPDATES_FAST_APPROX = 3} basisUpdates;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::BasisUpdates
basisUpdates	IoData.h	/^  enum BasisUpdates {UPDATES_OFF = 0, UPDATES_SIMPLE = 1} basisUpdates;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::BasisUpdates
basisUrefProducts	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > basisUrefProducts;  \/\/ [Cluster_Basis][Cluster_Uref][:]$/;"	m	class:NonlinearRom
basisUrefProductsName	NonlinearRom.h	/^  char* basisUrefProductsName;      \/\/ for exact updates (exactUpdateInfoPrefix.exactUpdates_e)$/;"	m	class:NonlinearRom
bbox	RTree.h	/^    double bbox[6];$/;"	m	struct:RTree::Node
bc	IoData.h	/^  BcsData bc;$/;"	m	class:IoData
bc	IoData.h	/^  BoundarySchemeData bc;$/;"	m	struct:SchemesData
bcData	Modal.h	/^    DistBcData<dim> *bcData;$/;"	m	class:ModalSolver
bcData	NonlinearRomOffline.h	/^    DistBcData<dim> *bcData;$/;"	m	class:NonlinearRomOfflineSolver
bcData	PostOperator.h	/^  DistBcData<dim> *bcData;$/;"	m	class:PostOperator
bcData	SpaceOperator.h	/^  DistBcData<dim> *bcData;$/;"	m	class:SpaceOperator
bcData	TsDesc.h	/^  DistBcData<dim> *bcData;$/;"	m	class:TsDesc
bcDataTmp	GappyPreprocessing.h	/^  DistBcData<dim> *bcDataTmp;$/;"	m	class:GappyPreprocessing
bcFaceSurfID	GappyPreprocessing.h	/^  std::vector< int > *(bcFaceSurfID [2]);	\/\/ codes for the above boundary faces. bcFaceSurfID[iSign][BCtype][iFace] returns the surfaceID of the iFace face corresponding to iSign\/BCtype$/;"	m	class:GappyPreprocessing::std
bcFaces	GappyPreprocessing.h	/^  std::vector< int > *(bcFaces [2][3]);	\/\/ boundary faces. bcfaces[iSign][whichNode][BCtype][iFace] returns the global node number of whichNode on the iFace face corresponding to iSign\/BCtype. iSign = 0 if the BC definition is negative, and iSign = 1 if positive. BCtype can be found in BcDefs.h$/;"	m	class:GappyPreprocessing::std
bcFacesInfo	GappyPreprocessing.h	/^  std::set<StaticArray <int, 3> > bcFacesInfo;	\/\/ {iCPU,iSub,iFace}$/;"	m	class:GappyPreprocessing
bcFcn	MultiGridOperator.h	/^  BcFcn* bcFcn,*bcFcn1,*bcFcn2;$/;"	m	class:MultiGridOperator
bcFcn	SpaceOperator.h	/^  BcFcn *bcFcn;$/;"	m	class:SpaceOperator
bcFcn1	MultiGridOperator.h	/^  BcFcn* bcFcn,*bcFcn1,*bcFcn2;$/;"	m	class:MultiGridOperator
bcFcn2	MultiGridOperator.h	/^  BcFcn* bcFcn,*bcFcn1,*bcFcn2;$/;"	m	class:MultiGridOperator
bcID	IoData.h	/^  int bcID;$/;"	m	struct:SurfaceData
bcMap	IoData.h	/^  ObjectMap<BoundaryData> bcMap;$/;"	m	struct:BcsData
bcMap	SubDomain.h	/^  map<int, int> bcMap;$/;"	m	class:SubDomain
bcomp	BcFcn.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	DenseMatrixOps.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	DistMatrix.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	DistVector.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	Domain.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	KspPrec.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	KspSolver.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	MatVecProd.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	Modal.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	RectangularSparseMatrix.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	SpaceOperator.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	SparseMatrix.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	SubDomain.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	VarFcn.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	VarFcnBase.h	/^typedef std::complex<double> bcomp;$/;"	t
bcomp	utils/Laguerre.C	/^typedef std::complex<double> bcomp;$/;"	t	file:
bcs	BCond.h	/^  BCond *bcs;$/;"	m	class:BCondSet
begin	LevelSet/LevelSetStructure.h	/^   iterator begin() { return iterator(xi, trNodes); }$/;"	f	struct:LevelSetResult
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T* begin() \/\/ for stl$/;"	f	class:PhysBAM::ARRAY_BASE
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    const T* begin() const \/\/ for stl$/;"	f	class:PhysBAM::ARRAY_BASE
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    ENTRY* begin()$/;"	f	class:PhysBAM::HASHTABLE
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    const ENTRY* begin() const$/;"	f	class:PhysBAM::HASHTABLE
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    T* begin() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    const T* begin() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T* begin() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    const T* begin() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T* begin() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    const T* begin() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T* begin() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    const T* begin() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
begin_ghostGhostNodes	GenMatrix.h	/^  virtual AuxilliaryIterator* begin_ghostGhostNodes() { return NULL; } $/;"	f	class:GenMat
begin_ghostGhostNodes	MvpMatrix.h	/^  typename GenMat<Scalar,dim>::AuxilliaryIterator* begin_ghostGhostNodes() {$/;"	f	class:MvpMat
begin_ghostNodes	GenMatrix.h	/^  virtual AuxilliaryIterator* begin_ghostNodes() { return NULL; } $/;"	f	class:GenMat
begin_ghostNodes	MvpMatrix.h	/^  typename GenMat<Scalar,dim>::AuxilliaryIterator* begin_ghostNodes() {$/;"	f	class:MvpMat
begin_realNodes	GenMatrix.h	/^  virtual AuxilliaryIterator* begin_realNodes() { return NULL; }$/;"	f	class:GenMat
begin_realNodes	MvpMatrix.h	/^  typename GenMat<Scalar,dim>::AuxilliaryIterator* begin_realNodes() {$/;"	f	class:MvpMat
besselh	KirchhoffIntegrator.C	/^std::complex<double> KirchhoffIntegrator::besselh$/;"	f	class:KirchhoffIntegrator
besselh_prime	KirchhoffIntegrator.C	/^std::complex<double> KirchhoffIntegrator::besselh_prime$/;"	f	class:KirchhoffIntegrator
bestNeiStrategy	IoData.h	/^   enum ClosestNeighbor {Fixed = 1, Variable = 0} bestNeiStrategy;$/;"	m	struct:BLMeshMotionData	typeref:enum:BLMeshMotionData::ClosestNeighbor
bestTrId	IntersectorFRG/IntersectorFRG.C	/^  int bestTrId;$/;"	m	class:ClosestTriangle	file:
bestTriangle	IntersectorFRG/IntersectorFRG.C	/^  int bestTriangle() const { return bestTrId; }$/;"	f	class:ClosestTriangle
beta	EdgeGrad.h	/^  double beta;$/;"	m	class:EdgeGrad
beta	IoData.h	/^  double alpha, beta;$/;"	m	struct:InitialConditions
beta	IoData.h	/^  double beta;$/;"	m	struct:BcsFreeStreamData
beta	IoData.h	/^  double beta;$/;"	m	struct:LiquidModelData
beta	IoData.h	/^  double beta;$/;"	m	struct:SchemeData
beta	KspSolver.h	/^  ScalarT alpha, beta;$/;"	m	class:GcrSolver
beta	LocalRiemann.h	/^  double beta;$/;"	m	class:LocalRiemannLowMach
beta	MultiGridKernel.h	/^  double beta; $/;"	m	class:MultiGridKernel
beta	OneDimensionalSolver.h	/^  double beta;$/;"	m	class:OneDimensional
beta	PostFcn.h	/^  double beta;$/;"	m	class:PostFcnEuler
beta	RecFcn.h	/^  double beta;$/;"	m	class:RecFcn
beta1	RecFcn.h	/^  double beta1;$/;"	m	class:RecFcn
beta2	RecFcn.h	/^  double beta2;$/;"	m	class:RecFcn
beta_in	FSI/DynamicNodalTransfer.h	/^  double beta_in, beta_max, y1[3], y2[3];$/;"	m	class:EmbeddedStructure
beta_in	IoData.h	/^  double beta_in;$/;"	m	struct:PitchingData
beta_in	MeshMotionHandler.h	/^  double beta_in;$/;"	m	class:PitchingMeshMotionHandler
beta_in	MeshMotionHandler.h	/^  double beta_in;$/;"	m	class:RigidRollMeshMotionHandler
beta_max	FSI/DynamicNodalTransfer.h	/^  double beta_in, beta_max, y1[3], y2[3];$/;"	m	class:EmbeddedStructure
beta_max	IoData.h	/^  double beta_max;$/;"	m	struct:PitchingData
beta_max	MeshMotionHandler.h	/^  double beta_max;$/;"	m	class:PitchingMeshMotionHandler
beta_slope	IoData.h	/^  double beta_slope;$/;"	m	struct:PitchingData
beta_slope	MeshMotionHandler.h	/^  double beta_slope;$/;"	m	class:PitchingMeshMotionHandler
betaij	MatVecProd.h	/^  DistSVec<double,dim> betaij;$/;"	m	class:MatVecProdH2
betaji	MatVecProd.h	/^  DistSVec<double,dim> betaji;$/;"	m	class:MatVecProdH2
betaref	IoData.h	/^  double betaref;$/;"	m	struct:SensitivityAnalysis
betav	IoData.h	/^  double betav;$/;"	m	struct:PreconditionData
betaviscous	LowMachPrec.h	/^  double betaviscous;$/;"	m	class:LowMachPrec
betax	IoData.h	/^  double betax,betay,betaz;$/;"	m	struct:PorousMedia
betay	IoData.h	/^  double betax,betay,betaz;$/;"	m	struct:PorousMedia
betaz	IoData.h	/^  double betax,betay,betaz;$/;"	m	struct:PorousMedia
bfix	IoData.h	/^  TBFixData bfix;$/;"	m	struct:TripDomainData
bfix1	IoData.h	/^  BFixData bfix1;$/;"	m	struct:SchemeFixData
bfix10	IoData.h	/^  BFixData bfix10;$/;"	m	struct:SchemeFixData
bfix2	IoData.h	/^  BFixData bfix2;$/;"	m	struct:SchemeFixData
bfix3	IoData.h	/^  BFixData bfix3;$/;"	m	struct:SchemeFixData
bfix4	IoData.h	/^  BFixData bfix4;$/;"	m	struct:SchemeFixData
bfix5	IoData.h	/^  BFixData bfix5;$/;"	m	struct:SchemeFixData
bfix6	IoData.h	/^  BFixData bfix6;$/;"	m	struct:SchemeFixData
bfix7	IoData.h	/^  BFixData bfix7;$/;"	m	struct:SchemeFixData
bfix8	IoData.h	/^  BFixData bfix8;$/;"	m	struct:SchemeFixData
bfix9	IoData.h	/^  BFixData bfix9;$/;"	m	struct:SchemeFixData
bigNum	SubDomain.h	/^  double bigNum;$/;"	m	class:SubDomain
big_endian	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^static const bool big_endian=true;$/;"	m	namespace:PhysBAM
bij	MatVecProd.h	/^  DistSVec<double,dim> bij;$/;"	m	class:MatVecProdH2
binomialTerm	OneDimensionalSourceTerm.h	/^  int binomialTerm(int n, int k) {$/;"	f	class:OneDimensionalSourceTerm
binread	Timer.h	/^		binread, binwrite, levelSet, lsNodalWeightsAndGrad, lsFvTerm,$/;"	e	enum:Timer::TimerIndex
binwrite	Timer.h	/^		binread, binwrite, levelSet, lsNodalWeightsAndGrad, lsFvTerm,$/;"	e	enum:Timer::TimerIndex
bji	MatVecProd.h	/^  DistSVec<double,dim> bji;$/;"	m	class:MatVecProdH2
blLen	BlockAlloc.h	/^    int blLen;$/;"	m	class:BlockAlloc
blacsHandle_	DistLeastSquareSolver.h	/^  int blacsHandle_;$/;"	m	class:DistLeastSquareSolver
blksize	arpack++/include/ardfmat.h	/^  int      blksize;   \/\/ Size of each matrix block that is read at once.$/;"	m	class:ARdfMatrix
blmeshmotion	IoData.h	/^  BLMeshMotionData blmeshmotion;$/;"	m	struct:DefoMeshMotionData
block	BlockAlloc.h	/^    char *block;$/;"	m	class:BlockAlloc
block	arpack++/include/ardfmat.h	/^  int      block;     \/\/ Index of the matrix block that is to be read.$/;"	m	class:ARdfMatrix
blockSizeIs	DistLeastSquareSolver.C	/^DistLeastSquareSolver::blockSizeIs(int row, int col, int rhsRow, int rhsRank) {$/;"	f	class:DistLeastSquareSolver
blockSizeIs	DistLeastSquareSolver.C	/^DistLeastSquareSolver::blockSizeIs(int size) {$/;"	f	class:DistLeastSquareSolver
blur	Domain.C	/^void Domain::blur(DistSVec<double,dim> &U, DistSVec<double,dim> &U0)$/;"	f	class:Domain
blur	SubDomain.C	/^void SubDomain::blur(SVec<double,dim> &U,SVec<double,dim> &U0, Vec<double>& weight)$/;"	f	class:SubDomain
bmat	arpack++/include/arrseig.h	/^  char    bmat;       \/\/ Indicates if the problem is a standard ('I') or$/;"	m	class:ARrcStdEig
boltzmanns_constant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double boltzmanns_constant=1.380658e-23; \/\/ J\/K$/;"	m	namespace:PhysBAM
bool	arpack++/include/arch.h	/^  typedef int bool;$/;"	t
bool2Pat	Domain.h	/^  CommPattern<bool> *bool2Pat;$/;"	m	class:Domain
bool3Pat	Domain.h	/^  CommPattern<bool> *bool3Pat;$/;"	m	class:Domain
bool4Pat	Domain.h	/^  CommPattern<bool> *bool4Pat; \/\/KW(02\/2014): for FluidIdFS2$/;"	m	class:Domain
boundaryConditionsMap	GappyPreprocessing.h	/^  boost::unordered_map <int, std::string > boundaryConditionsMap;	\/\/ mapping between BC numbers in BcDef.h and Sower's identification$/;"	m	class:GappyPreprocessing
boundaryFluid	DistBcData.h	/^  enum BoundaryFluid { GAS=0, TAIT=1, JWL=2 } boundaryFluid;$/;"	m	class:DistBcData	typeref:enum:DistBcData::BoundaryFluid
boundaryState	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* boundaryState;$/;"	m	class:MultiGridOperator
boundaryStateHH	BcData.h	/^  Vec<double> *boundaryStateHH;$/;"	m	class:BcData
boundaryStateHH	DistBcData.h	/^  DistVec<double> *boundaryStateHH; $/;"	m	class:DistBcData
boundaryStateL	OneDimensionalSolver.h	/^    double boundaryStateL[5],boundaryStateR[5],outletState[5];$/;"	m	class:OneDimensional::Veval
boundaryStateR	OneDimensionalSolver.h	/^    double boundaryStateL[5],boundaryStateR[5],outletState[5];$/;"	m	class:OneDimensional::Veval
boundary_mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    T_BOUNDARY_MESH* boundary_mesh;$/;"	m	class:PhysBAM::TRIANGLE_MESH
boundary_nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    ARRAY<int>* boundary_nodes;$/;"	m	class:PhysBAM::TRIANGLE_MESH
boundingBox	KDTree.h	/^  double boundingBox[2][3];$/;"	m	class:KDTree
bounding_box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    RANGE<TV> bounding_box;$/;"	m	class:PhysBAM::RAY
bounds	SparseGridCore.C	/^void SparseGrid::bounds(const int nPointsSubGrid){$/;"	f	class:SparseGrid
box	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    BOX<TV> box; \/\/ box containing the voxelized implicit surface$/;"	m	class:PhysBAM::IMPLICIT_OBJECT
boxMax	IntersectorFRG/IntersectorFRG.h	/^    DistSVec<double,3> *boxMax, *boxMin; \/\/fluid node bounding boxes$/;"	m	class:DistIntersectorFRG
boxMax	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistSVec<double,3> *boxMax, *boxMin; \/\/fluid node bounding boxes$/;"	m	class:DistIntersectorPhysBAM
boxMin	IntersectorFRG/IntersectorFRG.h	/^    DistSVec<double,3> *boxMax, *boxMin; \/\/fluid node bounding boxes$/;"	m	class:DistIntersectorFRG
boxMin	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistSVec<double,3> *boxMax, *boxMin; \/\/fluid node bounding boxes$/;"	m	class:DistIntersectorPhysBAM
box_hierarchy	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    ARRAY<RANGE<TV> > box_hierarchy;$/;"	m	class:PhysBAM::BOX_HIERARCHY
box_radius	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    ARRAY<T> box_radius;$/;"	m	class:PhysBAM::BOX_HIERARCHY
boxes	DistNodalGrad.h	/^  double boxes[SchemeFixData::num * 2][2][3];$/;"	m	class:DistNodalGrad
boxes	IoData.h	/^  BFixData* boxes[num];$/;"	m	struct:SchemeFixData
breakloop1	ImplicitGappyTsDesc.C	/^bool ImplicitGappyTsDesc<dim>::breakloop1(const bool breakloop) {$/;"	f	class:ImplicitGappyTsDesc
breakloop1	ImplicitRomTsDesc.C	/^bool ImplicitRomTsDesc<dim>::breakloop1(const bool breakloop) {$/;"	f	class:ImplicitRomTsDesc
breakloop2	ImplicitGappyTsDesc.C	/^bool ImplicitGappyTsDesc<dim>::breakloop2(const bool breakloop) {$/;"	f	class:ImplicitGappyTsDesc
breakloop2	ImplicitRomTsDesc.C	/^bool ImplicitRomTsDesc<dim>::breakloop2(const bool breakloop) {$/;"	f	class:ImplicitRomTsDesc
broadcast	Communicator.C	/^void Communicator::broadcast(int n, Scalar *b, int root)$/;"	f	class:Communicator
bubbleRadius	IoData.h	/^  const char* bubbleRadius;$/;"	m	struct:TransientData
bubbleRadiusFile	OneDimensionalSolver.h	/^  char* bubbleRadiusFile;$/;"	m	class:OneDimensional
bubble_x0	OneDimensionalSolver.h	/^    double bubble_x0, bubble_y0,bubble_z0;$/;"	m	class:OneDimensional::Veval
bubble_y0	OneDimensionalSolver.h	/^    double bubble_x0, bubble_y0,bubble_z0;$/;"	m	class:OneDimensional::Veval
bubble_z0	OneDimensionalSolver.h	/^    double bubble_x0, bubble_y0,bubble_z0;$/;"	m	class:OneDimensional::Veval
buffer	StructExc.h	/^  double *buffer;$/;"	m	class:StructExc
bufferEnergy	IoData.h	/^  double bufferEnergy;$/;"	m	struct:NonlinearRomOnlineData
bufferResizePolicy	DistLeastSquareSolver.h	/^  BufferResizePolicy bufferResizePolicy() const { return bufferResizePolicy_; }$/;"	f	class:DistLeastSquareSolver
bufferResizePolicyIs	DistLeastSquareSolver.C	/^DistLeastSquareSolver::bufferResizePolicyIs(BufferResizePolicy newPolicy) {$/;"	f	class:DistLeastSquareSolver
bufferResizePolicy_	DistLeastSquareSolver.h	/^  BufferResizePolicy bufferResizePolicy_;$/;"	m	class:DistLeastSquareSolver
buffer_size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ID buffer_size;$/;"	m	class:PhysBAM::ARRAY
buffer_size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int buffer_size; \/\/ includes dead space$/;"	m	class:PhysBAM::ARRAY_COLLECTION
bufsize	StructExc.h	/^  int bufsize;$/;"	m	class:StructExc
buildConnectivity	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::buildConnectivity() {$/;"	f	class:DistIntersectorFRG
buildDeltaFreq	SubDomainCore.C	/^void SubDomain::buildDeltaFreq(double *deltaFreqCoarse,int numFreqCoarse, double *freqCoarse, int *midFreq){$/;"	f	class:SubDomain
buildPadeMatrix	SubDomainCore.C	/^void SubDomain::buildPadeMatrix(bcomp *data, int *stepParam, int nPoints, double *deltaFreq, bcomp *padeMat, int L, int M, int flag)$/;"	f	class:SubDomain
buildPadeRhs	SubDomainCore.C	/^void SubDomain::buildPadeRhs(bcomp *data, int *stepParam, int nPoints, bcomp *padeVec, int L, int M, int flag)$/;"	f	class:SubDomain
buildReducedModel	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::buildReducedModel() {$/;"	f	class:GappyPreprocessing
buildReducedModel	ReducedMeshShapeChanger.C	/^void ReducedMeshShapeChanger<dim>::buildReducedModel() {$/;"	f	class:ReducedMeshShapeChanger
buildRemainingMesh	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::buildRemainingMesh() {$/;"	f	class:GappyPreprocessing
buildScopeTopology	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::buildScopeTopology(int (*sElem)[3], int nsElem)$/;"	f	class:IntersectorFRG
buildSolidNormals	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::buildSolidNormals() {$/;"	f	class:DistIntersectorFRG
buildSolidNormals	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::buildSolidNormals() {$/;"	f	class:DistIntersectorPhysBAM
built_dVdU	PostOperator.h	/^  bool built_dVdU;$/;"	m	class:PostOperator
bulkViscosity	IoData.h	/^  double bulkViscosity;$/;"	m	struct:ViscosityModelData
bulkViscosity	ViscoFcn.h	/^  double bulkViscosity;$/;"	m	class:ConstantViscoFcn
burnable	IoData.h	/^  YesNo burnable;$/;"	m	struct:LiquidModelData
burnable	VarFcnTait.h	/^  bool burnable;$/;"	m	class:VarFcnTait
burnedEOS	IoData.h	/^  int unburnedEOS,burnedEOS;$/;"	m	struct:ProgrammedBurnData
c	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    T1_VIEW c;$/;"	m	class:PhysBAM::ARRAY_LEFT_MULTIPLE
c	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    T1_VIEW c;$/;"	m	class:PhysBAM::ARRAY_PLUS_SCALAR
c	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    COMPLEX<T> c;$/;"	m	class:PhysBAM::ROTATION
c	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T a,b,c; \/\/ coefficients$/;"	m	class:PhysBAM::QUADRATIC
c0	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T c3,c2,c1,c0; \/\/ coefficients $/;"	m	class:PhysBAM::CUBIC
c1	ImplicitRomTsDesc.h	/^  double c1;$/;"	m	class:ImplicitRomTsDesc
c1	IoData.h	/^  double c1;$/;"	m	struct:LineSearchData
c1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T c3,c2,c1,c0; \/\/ coefficients $/;"	m	class:PhysBAM::CUBIC
c2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T c3,c2,c1,c0; \/\/ coefficients $/;"	m	class:PhysBAM::CUBIC
c3	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T c3,c2,c1,c0; \/\/ coefficients $/;"	m	class:PhysBAM::CUBIC
cForFastDistComp	NonlinearRom.h	/^  double ***cForFastDistComp;$/;"	m	class:NonlinearRom
cGlobalLU_t	arpack++/include/arlspdef.h	/^} cGlobalLU_t;$/;"	t	typeref:struct:__anon37
cTraceOn	arpack++/include/debug.h	/^inline void cTraceOn(const ARint digit, const ARint getv0, const ARint aupd, $/;"	f
c_add	arpack++/include/arlcomp.h	94;"	d
c_bridge_dgssv_	arpack++/include/arlnames.h	131;"	d
c_bridge_dgssv_	arpack++/include/arlnames.h	202;"	d
c_eq	arpack++/include/arlcomp.h	115;"	d
c_mu	IoData.h	/^  double c_mu;$/;"	m	struct:KEModelData
c_mu	KEpsilonTerm.h	/^  double c_mu;$/;"	m	class:KEpsilonTerm
c_n	TimeState.h	/^    double c_np1, c_n, c_nm1, c_nm2;$/;"	m	struct:TimeState::TimeFDCoefs
c_nm1	TimeState.h	/^    double c_np1, c_n, c_nm1, c_nm2;$/;"	m	struct:TimeState::TimeFDCoefs
c_nm2	TimeState.h	/^    double c_np1, c_n, c_nm1, c_nm2;$/;"	m	struct:TimeState::TimeFDCoefs
c_np1	TimeState.h	/^    double c_np1, c_n, c_nm1, c_nm2;$/;"	m	struct:TimeState::TimeFDCoefs
c_s	IoData.h	/^  double c_s;$/;"	m	struct:SmagorinskyLESData
c_s_prime	IoData.h	/^  double c_s_prime;$/;"	m	struct:DynamicVMSData
c_s_prime	IoData.h	/^  double c_s_prime;$/;"	m	struct:VMSLESData
c_sub	arpack++/include/arlcomp.h	98;"	d
c_w	IoData.h	/^  double c_w;$/;"	m	struct:WaleLESData
cableLen	FSI/DynamicNodalTransfer.h	/^  double cableLen, xbeg;$/;"	m	class:EmbeddedStructure
calcResidual	NonlinearRomDatabaseConstruction.C	/^double NonlinearRomDatabaseConstruction<dim>::calcResidual(VecSet< DistSVec<double, dim> > &centers, VecSet< DistSVec<double, dim> > &centersOld) {$/;"	f	class:NonlinearRomDatabaseConstruction
calculateErrorEstiNorm	DistTimeState.C	/^void DistTimeState<dim>::calculateErrorEstiNorm(DistSVec<double,dim> &U, DistSVec<double,dim> &F)$/;"	f	class:DistTimeState
calculateSpatialResidual	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::calculateSpatialResidual(DistSVec<double,dim> &Q, DistSVec<double,dim> &spatialRes) {$/;"	f	class:ImplicitTsDesc
calculateSpatialResidual	MeshMotionSolver.h	/^  void calculateSpatialResidual(DistSVec<double, 3> &, DistSVec<double,3> &) {}$/;"	f	class:TetMeshMotionSolver
calculateSpatialResidual	TsDesc.h	/^  virtual void calculateSpatialResidual(DistSVec<double,dim> &, DistSVec<double,dim> &) {}$/;"	f	class:TsDesc
callSowerSplit	NonlinearRom.C	/^void NonlinearRom<dim>::callSowerSplit(std::string meshPath, std::string conPath, char* result) {$/;"	f	class:NonlinearRom
candidates	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ARRAY<ARRAY<int> > candidates;$/;"	m	struct:PhysBAM::SubDInterface
cart2sph_x	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::cart2sph_x$/;"	f	class:KirchhoffIntegrator
cart2sph_y	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::cart2sph_y$/;"	f	class:KirchhoffIntegrator
caupp	arpack++/include/caupp.h	/^inline void caupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,$/;"	f
caxpy_	arpack++/include/arlnames.h	108;"	d
caxpy_	arpack++/include/arlnames.h	179;"	d
cb1	DESTerm.h	/^  double cb1;$/;"	m	class:DESTerm
cb1	IoData.h	/^  double cb1;$/;"	m	struct:DESModelData
cb1	IoData.h	/^  double cb1;$/;"	m	struct:SAModelData
cb1	SpalartAllmarasTerm.h	/^  double cb1;$/;"	m	class:SATerm
cb2	DESTerm.h	/^  double cb2;$/;"	m	class:DESTerm
cb2	IoData.h	/^  double cb2;$/;"	m	struct:DESModelData
cb2	IoData.h	/^  double cb2;$/;"	m	struct:SAModelData
cb2	SpalartAllmarasTerm.h	/^  double cb2;$/;"	m	class:SATerm
cc_mult	arpack++/include/arlcomp.h	106;"	d
ccc	SpaceOperator.h	/^  int ccc;$/;"	m	class:SpaceOperator
ccopy_	arpack++/include/arlnames.h	105;"	d
ccopy_	arpack++/include/arlnames.h	176;"	d
ccwerrboundA	utils/Predicate.C	/^REAL ccwerrboundA, ccwerrboundB, ccwerrboundC;$/;"	v
ccwerrboundB	utils/Predicate.C	/^REAL ccwerrboundA, ccwerrboundB, ccwerrboundC;$/;"	v
ccwerrboundC	utils/Predicate.C	/^REAL ccwerrboundA, ccwerrboundB, ccwerrboundC;$/;"	v
cdes	DESTerm.h	/^  double cdes;$/;"	m	class:DESTerm
cdes	FemEquationTermDesc.h	/^  double cdes;$/;"	m	class:FemEquationTermDES
cdes	IoData.h	/^  double cdes;$/;"	m	struct:DESModelData
ceil	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^ceil(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
ceil	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^ceil(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
ceil	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^ceil(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
ceil	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^ceil(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
cellsPerMacroCell	MacroCell.h	/^  int *cellsPerMacroCell;$/;"	m	class:MacroCellSet
cen_x	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
cen_x	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
cen_x	IoData.h	/^  double cen_x, cen_y, cen_z, radius;$/;"	m	struct:SphereData
cen_x	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
cen_y	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
cen_y	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
cen_y	IoData.h	/^  double cen_x, cen_y, cen_z, radius;$/;"	m	struct:SphereData
cen_y	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
cen_z	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
cen_z	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
cen_z	IoData.h	/^  double cen_x, cen_y, cen_z, radius;$/;"	m	struct:SphereData
cen_z	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
centerComponentWiseSumsName	NonlinearRom.h	/^  char* centerComponentWiseSumsName; \/\/ for fast distance calcs when using either no updates or exact updates ()$/;"	m	class:NonlinearRom
centerNorms	NonlinearRom.h	/^  std::vector<std::vector<double> > centerNorms; \/\/ note: actually norm squared$/;"	m	class:NonlinearRom
centerNormsName	IoData.h	/^  const char *centerNormsName;$/;"	m	struct:NonlinearRomFilesData
centerNormsName	NonlinearRom.h	/^  char* centerNormsName;$/;"	m	class:NonlinearRom
centersName	IoData.h	/^  const char *centersName;$/;"	m	struct:NonlinearRomFilesData
centersName	NonlinearRom.h	/^  char* centersName;$/;"	m	class:NonlinearRom
cerr	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^log_null_class cerr;$/;"	m	namespace:PhysBAM::LOG_NULL	file:
cerr_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^cerr_Helper()$/;"	f	namespace:PhysBAM::LOG_REAL
cerr_buffer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^std::streambuf* cerr_buffer=0;$/;"	m	namespace:PhysBAM::LOG_REAL::__anon18	file:
cerr_initialized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^bool cerr_initialized=false;$/;"	m	namespace:PhysBAM::LOG_REAL::__anon18	file:
ceupp	arpack++/include/ceupp.h	/^inline void ceupp(bool rvec, char HowMny, arcomplex<double> d[],$/;"	f
ceupp	arpack++/include/ceupp.h	/^inline void ceupp(bool rvec, char HowMny, arcomplex<float> d[],$/;"	f
cf2force	RefVal.h	/^  double cf2force;$/;"	m	class:RefVal
cfix1	IoData.h	/^  CFixData cfix1;$/;"	m	struct:SchemeFixData
cfix10	IoData.h	/^  CFixData cfix10;$/;"	m	struct:SchemeFixData
cfix2	IoData.h	/^  CFixData cfix2;$/;"	m	struct:SchemeFixData
cfix3	IoData.h	/^  CFixData cfix3;$/;"	m	struct:SchemeFixData
cfix4	IoData.h	/^  CFixData cfix4;$/;"	m	struct:SchemeFixData
cfix5	IoData.h	/^  CFixData cfix5;$/;"	m	struct:SchemeFixData
cfix6	IoData.h	/^  CFixData cfix6;$/;"	m	struct:SchemeFixData
cfix7	IoData.h	/^  CFixData cfix7;$/;"	m	struct:SchemeFixData
cfix8	IoData.h	/^  CFixData cfix8;$/;"	m	struct:SchemeFixData
cfix9	IoData.h	/^  CFixData cfix9;$/;"	m	struct:SchemeFixData
cfl	IoData.h	/^  CFLData cfl;$/;"	m	struct:TsData
cfl	OneDimensionalSolver.h	/^  double cfl;$/;"	m	class:OneDimensional
cfl	TsParameters.h	/^  double cfl;$/;"	m	class:TsParameters
cfl0	IoData.h	/^  double cfl0;$/;"	m	struct:CFLData
cfl0	IoData.h	/^  double cfl0;$/;"	m	struct:TsData
cfl0	TsParameters.h	/^  double cfl0;$/;"	m	class:TsParameters
cflCoef1	IoData.h	/^  double cflCoef1;$/;"	m	struct:CFLData
cflCoef1	IoData.h	/^  double cflCoef1;$/;"	m	struct:TsData
cflCoef1	TsParameters.h	/^  double cflCoef1;$/;"	m	class:TsParameters
cflCoef2	IoData.h	/^  double cflCoef2;$/;"	m	struct:CFLData
cflCoef2	IoData.h	/^  double cflCoef2;$/;"	m	struct:TsData
cflCoef2	TsParameters.h	/^  double cflCoef2;$/;"	m	class:TsParameters
cflMax	IoData.h	/^  double cflMax;$/;"	m	struct:CFLData
cflMax	IoData.h	/^  double cflMax;$/;"	m	struct:TsData
cflMax	TsParameters.h	/^  double cflMax;$/;"	m	class:TsParameters
cflMin	IoData.h	/^  double cflMin;$/;"	m	struct:CFLData
cflMin	IoData.h	/^  double cflMin;$/;"	m	struct:TsData
cflMin	TsParameters.h	/^  double cflMin;$/;"	m	class:TsParameters
cfl_output	TsParameters.h	/^  FILE *cfl_output;$/;"	m	class:TsParameters
cfllaw	TsParameters.h	/^  int cfllaw;$/;"	m	class:TsParameters
cg0	CorotSolver.h	/^  double cg0[3];$/;"	m	class:CorotSolver
cg0	EmbeddedCorotSolver.h	/^  double cg0[3], cgN[3];$/;"	m	class:EmbeddedCorotSolver
cgN	CorotSolver.h	/^  double cgN[3];$/;"	m	class:CorotSolver
cgN	EmbeddedCorotSolver.h	/^  double cg0[3], cgN[3];$/;"	m	class:EmbeddedCorotSolver
cgemm_	arpack++/include/arlnames.h	111;"	d
cgemm_	arpack++/include/arlnames.h	182;"	d
cgemv_	arpack++/include/arlnames.h	109;"	d
cgemv_	arpack++/include/arlnames.h	180;"	d
cgerc_	arpack++/include/arlnames.h	113;"	d
cgerc_	arpack++/include/arlnames.h	184;"	d
changeSurfaceType	SubDomainCore.C	/^void SubDomain::changeSurfaceType(map<int,SurfaceData*>& surfaceMap, map<int,BoundaryData*>& bcMap)  {$/;"	f	class:SubDomain
char_2_double	AlternatingLeastSquare/als_util.cpp	/^void char_2_double(unsigned char *X, double *Y, int M, int N){$/;"	f
characteristicToPrimitiveVariations	VarFcn.h	/^  void characteristicToPrimitiveVariations(double n[3], double *V, double *dW, double *dV, int tag=0) { check(tag); varFcn[tag]->characteristicToPrimitiveVariations(n,V,dW,dV); }$/;"	f	class:VarFcn
characteristicToPrimitiveVariations	VarFcnBase.h	/^  virtual void characteristicToPrimitiveVariations(double n[3], double *V, double *dW, double *dV){$/;"	f	class:VarFcnBase
characteristicToPrimitiveVariations	VarFcnJwl.h	/^void VarFcnJwl::characteristicToPrimitiveVariations(double n[3], double *V, $/;"	f	class:VarFcnJwl
characteristicToPrimitiveVariations	VarFcnSGEuler.h	/^void VarFcnSGEuler::characteristicToPrimitiveVariations(double n[3], double *V, $/;"	f	class:VarFcnSGEuler
characteristicToPrimitiveVariations	VarFcnTait.h	/^void VarFcnTait::characteristicToPrimitiveVariations(double n[3], double *V, $/;"	f	class:VarFcnTait
check	ExplicitTsDesc.h	/^  LiquidModelData::YesNo check;$/;"	m	class:ExplicitTsDesc
check	FluxFcn.h	/^  void check(int tag=0) const{ $/;"	f	class:FluxFcn
check	IoData.h	/^  YesNo check;$/;"	m	struct:LiquidModelData
check	VarFcn.h	/^  void check(int tag) const {assert(0<=tag && tag<numPhases);} $/;"	f	class:VarFcn
checkAccuracy	SparseGridCore.C	/^bool SparseGrid::checkAccuracy(){$/;"	f	class:SparseGrid
checkBoundaryValues	IoDataCore.C	/^int IoData::checkBoundaryValues()$/;"	f	class:IoData
checkCFLBackwardsCompatibility	IoDataCore.C	/^int IoData::checkCFLBackwardsCompatibility(){$/;"	f	class:IoData
checkConsistency	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::checkConsistency() {$/;"	f	class:GappyPreprocessing
checkConvergence	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
checkEdge	IntersectorFRG/IntersectorFRG.C	/^ClosestTriangle::checkEdge(int trId, int ip1, int ip2, int p3, double trDist) {$/;"	f	class:ClosestTriangle
checkEdgeForTester	IntersectorFRG/IntersectorFRG.C	/^void ClosestTriangle::checkEdgeForTester(Vec3D xt, int trId, int ip1, int ip2, int p3, double trDist, int &nn1, int &nn2, $/;"	f	class:ClosestTriangle
checkExtrapolationValue	Domain.C	/^void Domain::checkExtrapolationValue(DistSVec<double,dim>&U, VarFcn* vf,$/;"	f	class:Domain
checkExtrapolationValue	InletNode.C	/^void InletNodeSet::checkExtrapolationValue(SVec<double,dim> &U, Connectivity* sharedInletNodes, int* nodeType, VarFcn* vf, BcData<dim>& bcData, GeoState& geoState)$/;"	f	class:InletNodeSet
checkExtrapolationValue	SubDomain.C	/^void SubDomain::checkExtrapolationValue(SVec<double,dim> &V, VarFcn *vf,$/;"	f	class:SubDomain
checkFaceAlreadyAdded	GappyPreprocessing.C	/^bool GappyPreprocessing<dim>::checkFaceAlreadyAdded(const int cpuNum, const int$/;"	f	class:GappyPreprocessing
checkFaceContributesToLift	GappyPreprocessing.C	/^bool GappyPreprocessing<dim>::checkFaceContributesToLift(FaceSet& faces, const int iFace, const int iSub, const int *locToGlobNodeMap ){$/;"	f	class:GappyPreprocessing
checkFaceInMesh	GappyPreprocessing.C	/^bool GappyPreprocessing<dim>::checkFaceInMesh(FaceSet& currentFaces, const int iFace, const int iSub, const int *locToGlobNodeMap){$/;"	f	class:GappyPreprocessing
checkFailSafe	Domain.C	/^void Domain::checkFailSafe(VarFcn* varFcn, DistSVec<double,dim>& U,$/;"	f	class:Domain
checkFailSafe	ImplicitEmbeddedRomTsDesc.h	/^    bool checkFailSafe(DistSVec<double, dim> &Q) {return super::checkFailSafe(Q); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
checkFailSafe	ImplicitEmbeddedTsDesc.C	/^int ImplicitEmbeddedTsDesc<dim>::checkFailSafe(DistSVec<double,dim>& U)$/;"	f	class:ImplicitEmbeddedTsDesc
checkFailSafe	ImplicitLevelSetTsDesc.C	/^int ImplicitLevelSetTsDesc<dim,dimLS>::checkFailSafe(DistSVec<double,dim>& U)$/;"	f	class:ImplicitLevelSetTsDesc
checkFailSafe	ImplicitMultiPhysicsTsDesc.C	/^int ImplicitMultiPhysicsTsDesc<dim,dimLS>::checkFailSafe(DistSVec<double,dim>& U)$/;"	f	class:ImplicitMultiPhysicsTsDesc
checkFailSafe	ImplicitRomTsDesc.C	/^int ImplicitRomTsDesc<dim>::checkFailSafe(DistSVec<double,dim>& U)$/;"	f	class:ImplicitRomTsDesc
checkFailSafe	ImplicitTsDesc.C	/^int ImplicitTsDesc<dim>::checkFailSafe(DistSVec<double,dim>& U)$/;"	f	class:ImplicitTsDesc
checkFailSafe	MeshMotionSolver.h	/^  int checkFailSafe(DistSVec<double,3>& X) { return 0; }$/;"	f	class:TetMeshMotionSolver
checkFailSafe	SubDomain.C	/^void SubDomain::checkFailSafe(VarFcn* varFcn, SVec<double,dim>& U,$/;"	f	class:SubDomain
checkFileNames	IoDataCore.C	/^int IoData::checkFileNames()$/;"	f	class:IoData
checkFinalRes	IoData.h	/^  enum CheckFinalRes {NO = 0, YES = 1} checkFinalRes;$/;"	m	struct:KspData	typeref:enum:KspData::CheckFinalRes
checkFinalRes	KspSolver.h	/^  bool checkFinalRes;$/;"	m	class:KspSolver
checkFluidRomStability	Modal.C	/^void ModalSolver<dim>::checkFluidRomStability(VecSet<Vec<double> > &romOperator, int nPodVecs)$/;"	f	class:ModalSolver
checkForLastIteration	ImplicitGappyTsDesc.C	/^bool ImplicitGappyTsDesc<dim>::checkForLastIteration(IoData &ioData, int it, double t, double dt, DistSVec<double,dim> &U)$/;"	f	class:ImplicitGappyTsDesc
checkForLastIteration	ImplicitPGTsDesc.C	/^bool ImplicitPGTsDesc<dim>::checkForLastIteration(IoData &ioData, int it, double t, double dt, DistSVec<double,dim> &U)$/;"	f	class:ImplicitPGTsDesc
checkForLastIteration	TsDesc.C	/^bool TsDesc<dim>::checkForLastIteration(IoData &ioData, int it, double t, double dt, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
checkForRapidlyChangingDensity	DistTimeState.h	/^  double checkForRapidlyChangingDensity;$/;"	m	class:DistTimeState
checkForRapidlyChangingPressure	DistTimeState.h	/^  double checkForRapidlyChangingPressure;$/;"	m	class:DistTimeState
checkForRapidlyChangingValues	DistTimeState.h	/^  bool checkForRapidlyChangingValues;$/;"	m	class:DistTimeState
checkGhostPoints	SubDomain.C	/^void SubDomain::checkGhostPoints(Vec<GhostPoint<dim>*> &ghostPoints, SVec<double,3> &X, $/;"	f	class:SubDomain
checkGradients	Domain.C	/^void Domain::checkGradients(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:Domain
checkGradientsSetUp	SubDomain.C	/^void SubDomain::checkGradientsSetUp(SVec<double,3> &X, SVec<double,dim> &V)$/;"	f	class:SubDomain
checkGradientsWrite	SubDomain.C	/^void SubDomain::checkGradientsWrite(SVec<double,3> &X, NodalGrad<dim> &ngrad)$/;"	f	class:SubDomain
checkIfFileExists	SubDomain.C	/^bool SubDomain::checkIfFileExists(const char *prefix)$/;"	f	class:SubDomain
checkInitialConditionScenario	NonlinearRom.C	/^void NonlinearRom<dim>::checkInitialConditionScenario() {$/;"	f	class:NonlinearRom
checkInletNodes	InletNodeCore.C	/^void InletNode::checkInletNodes(int i, int* locToGlobNodeMap)$/;"	f	class:InletNode
checkInletNodes	InletNodeCore.C	/^void InletNodeSet::checkInletNodes(int* locToGlobNodeMap)$/;"	f	class:InletNodeSet
checkInletNodes	SubDomainCore.C	/^void SubDomain::checkInletNodes()$/;"	f	class:SubDomain
checkInputValues	IoDataCore.C	/^int IoData::checkInputValues()$/;"	f	class:IoData
checkInputValuesAeroAcoustic	IoDataCore.C	/^int IoData::checkInputValuesAeroAcoustic(){$/;"	f	class:IoData
checkInputValuesAllEquationsOfState	IoDataCore.C	/^int IoData::checkInputValuesAllEquationsOfState(){$/;"	f	class:IoData
checkInputValuesAllInitialConditions	IoDataCore.C	/^int IoData::checkInputValuesAllInitialConditions(){$/;"	f	class:IoData
checkInputValuesDefaultOutlet	IoDataCore.C	/^void IoData::checkInputValuesDefaultOutlet()$/;"	f	class:IoData
checkInputValuesDimensional	IoDataCore.C	/^int IoData::checkInputValuesDimensional(map<int,SurfaceData*>& surfaceMap)$/;"	f	class:IoData
checkInputValuesEmbeddedFramework	IoDataCore.C	/^int IoData::checkInputValuesEmbeddedFramework() {$/;"	f	class:IoData
checkInputValuesEquationOfState	IoDataCore.C	/^int IoData::checkInputValuesEquationOfState(FluidModelData &fluidModel, int fluidModelID)$/;"	f	class:IoData
checkInputValuesEssentialBC	IoDataCore.C	/^int IoData::checkInputValuesEssentialBC()$/;"	f	class:IoData
checkInputValuesInitialConditions	IoDataCore.C	/^int IoData::checkInputValuesInitialConditions(InitialConditions &initialConditions,$/;"	f	class:IoData
checkInputValuesNonDimensional	IoDataCore.C	/^int IoData::checkInputValuesNonDimensional()$/;"	f	class:IoData
checkInputValuesNonlinearRomOnline	IoDataCore.C	/^int IoData::checkInputValuesNonlinearRomOnline() {$/;"	f	class:IoData
checkInputValuesNonlinearRomPostprocessing	IoDataCore.C	/^int IoData::checkInputValuesNonlinearRomPostprocessing() {$/;"	f	class:IoData
checkInputValuesNonlinearRomPreprocessing	IoDataCore.C	/^int IoData::checkInputValuesNonlinearRomPreprocessing() {$/;"	f	class:IoData
checkInputValuesProgrammedBurn	IoDataCore.C	/^int IoData::checkInputValuesProgrammedBurn() {$/;"	f	class:IoData
checkInputValuesSparseGrid	IoDataCore.C	/^int IoData::checkInputValuesSparseGrid(SparseGridData &sparseGrid){$/;"	f	class:IoData
checkInputValuesTurbulence	IoDataCore.C	/^void IoData::checkInputValuesTurbulence()$/;"	f	class:IoData
checkLSConsistency	FluidSelector.C	/^void FluidSelector::checkLSConsistency(DistSVec<double,dim> &Phi)$/;"	f	class:FluidSelector
checkLocalRomStatus	ImplicitRomPostproTsDesc.C	/^void ImplicitRomPostproTsDesc<dim>::checkLocalRomStatus(DistSVec<double, dim> &U, const int totalTimeSteps)  {$/;"	f	class:ImplicitRomPostproTsDesc
checkLocalRomStatus	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::checkLocalRomStatus(DistSVec<double, dim> &U, const int totalTimeSteps)  {$/;"	f	class:ImplicitRomTsDesc
checkLocalRomStatus	MeshMotionSolver.h	/^  void checkLocalRomStatus(DistSVec<double, 3> &, const int) {}$/;"	f	class:TetMeshMotionSolver
checkLocalRomStatus	TsDesc.h	/^  virtual void checkLocalRomStatus(DistSVec<double, dim> &, const int) {}$/;"	f	class:TsDesc
checkMVP	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::checkMVP(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &dx, DistSVec<double, dim> &orig){$/;"	f	class:ImplicitEmbeddedRomTsDesc
checkMatVecProd	Domain.C	/^void Domain::checkMatVecProd(DistSVec<double,dim> &prod,$/;"	f	class:Domain
checkMatVecProd	SubDomain.C	/^void SubDomain::checkMatVecProd(SVec<double,dim> &prod, const char *msg)$/;"	f	class:SubDomain
checkNodePhaseChange	Domain.C	/^void Domain::checkNodePhaseChange(DistSVec<double,dimLS> &PhiProduct)$/;"	f	class:Domain
checkNodePhaseChange	SubDomain.C	/^void SubDomain::checkNodePhaseChange(SVec<double,dimLS> &PhiProduct)$/;"	f	class:SubDomain
checkNormalTetrahedra	SubDomainCore.C	/^void SubDomain::checkNormalTetrahedra(ExtrapolationNodeData (*&xpoldata)[2])$/;"	f	class:SubDomain
checkPiercePoint	SubDomainCore.C	/^int checkPiercePoint(Vec3D& a, Vec3D& b, Vec3D& c, Vec3D& d, Vec3D& e, bool adaptive)$/;"	f
checkPiercePointInTriangle	SubDomainCore.C	/^int checkPiercePointInTriangle(double vol1, double vol2, double vol3)$/;"	f
checkPressure	VarFcn.h	/^  double checkPressure(double *V, int tag=0) const{check(tag); return varFcn[tag]->checkPressure(V); }$/;"	f	class:VarFcn
checkPressure	VarFcnBase.h	/^  virtual double checkPressure(double *V) const{$/;"	f	class:VarFcnBase
checkPressure	VarFcnJwl.h	/^  double checkPressure(double *V) const{$/;"	f	class:VarFcnJwl
checkPressure	VarFcnSGEuler.h	/^  double checkPressure(double *V) const { $/;"	f	class:VarFcnSGEuler
checkPressure	VarFcnSGKE.h	/^  double checkPressure(double *V) const { $/;"	f	class:VarFcnSGKE
checkPressure	VarFcnSGSA.h	/^  double checkPressure(double *V) const { $/;"	f	class:VarFcnSGSA
checkPressure	VarFcnTait.h	/^  double checkPressure(double *V) const{ return getPressure(V); }$/;"	f	class:VarFcnTait
checkProgrammedBurnLocal	IoDataCore.C	/^ int IoData::checkProgrammedBurnLocal(ProgrammedBurnData& programmedBurn,$/;"	f	class:IoData
checkRHS	SubDomain.C	/^void SubDomain::checkRHS(Scalar (*rhs)[dim])$/;"	f	class:SubDomain
checkROBType	Modal.C	/^void ModalSolver<dim>::checkROBType(VecSet<DistSVec<double, dim> > &podVecs, int nPodVecs) {$/;"	f	class:ModalSolver
checkReconstructedValues	EdgeCore.C	/^int EdgeSet::checkReconstructedValues(int i, int j, double *Vi, double *Vj, VarFcn *vf, $/;"	f	class:EdgeSet
checkReconstructedValues	VarFcn.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe, int tag=0) const{check(tag);$/;"	f	class:VarFcn
checkReconstructedValues	VarFcnBase.h	/^  virtual bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnBase
checkReconstructedValues	VarFcnJwl.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnJwl
checkReconstructedValues	VarFcnSGEuler.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnSGEuler
checkReconstructedValues	VarFcnSGKE.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnSGKE
checkReconstructedValues	VarFcnSGSA.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnSGSA
checkReconstructedValues	VarFcnTait.h	/^  bool checkReconstructedValues(double *V, int nodeNum, int otherNodeNum, int phi, int otherPhi, int failsafe) const{$/;"	f	class:VarFcnTait
checkSolution	Domain.C	/^int Domain::checkSolution(VarFcn *varFcn, DistSVec<double,dim> &U, DistLevelSetStructure *distLSS)$/;"	f	class:Domain
checkSolution	Domain.C	/^int Domain::checkSolution(VarFcn *varFcn, DistSVec<double,dim> &U, DistVec<int> &fluidId, DistLevelSetStructure *distLSS)$/;"	f	class:Domain
checkSolution	Domain.C	/^int Domain::checkSolution(VarFcn *varFcn, DistVec<double> &ctrlVol,$/;"	f	class:Domain
checkSolution	EmbeddedTsDesc.C	/^int EmbeddedTsDesc<dim>::checkSolution(DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
checkSolution	ImplicitEmbeddedRomTsDesc.h	/^    int checkSolution(DistSVec<double, dim> &Q) {return super::checkSolution(Q); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
checkSolution	LevelSetTsDesc.C	/^int LevelSetTsDesc<dim,dimLS>::checkSolution(DistSVec<double,dim> &U)$/;"	f	class:LevelSetTsDesc
checkSolution	MeshMotionSolver.h	/^  int checkSolution(DistSVec<double,3> &X) { return 0; }$/;"	f	class:TetMeshMotionSolver
checkSolution	MultiPhysicsTsDesc.C	/^int MultiPhysicsTsDesc<dim,dimLS>::checkSolution(DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
checkSolution	SubDomain.C	/^int SubDomain::checkSolution(VarFcn *varFcn, SVec<double,dim> &U, LevelSetStructure *LSS)$/;"	f	class:SubDomain
checkSolution	SubDomain.C	/^int SubDomain::checkSolution(VarFcn *varFcn, SVec<double,dim> &U, Vec<int> &fluidId, LevelSetStructure *LSS)$/;"	f	class:SubDomain
checkSolution	SubDomain.C	/^int SubDomain::checkSolution(VarFcn *varFcn, Vec<double> &ctrlVol, SVec<double,dim> &U,$/;"	f	class:SubDomain
checkSolution	TsDesc.C	/^int TsDesc<dim>::checkSolution(DistSVec<double,dim> &U)$/;"	f	class:TsDesc
checkSolutionInNewton	ImplicitRomTsDesc.h	/^  bool checkSolutionInNewton;$/;"	m	class:ImplicitRomTsDesc
checkSolverValues	IoDataCore.C	/^int IoData::checkSolverValues(map<int,SurfaceData*>& surfaceMap)$/;"	f	class:IoData
checkTriangle	IntersectorFRG/IntersectorFRG.C	/^ClosestTriangle::checkTriangle(int trId) {$/;"	f	class:ClosestTriangle
checkTriangulatedSurface	IntersectorFRG/IntersectorFRG.C	/^bool DistIntersectorFRG::checkTriangulatedSurface()$/;"	f	class:DistIntersectorFRG
checkTriangulatedSurface	IntersectorPhysBAM/IntersectorPhysBAM.C	/^bool DistIntersectorPhysBAM::checkTriangulatedSurface()$/;"	f	class:DistIntersectorPhysBAM
checkTrueLevelSetUpdate	LevelSet.C	/^void LevelSet<dimLS>::checkTrueLevelSetUpdate(DistSVec<double,dimLS> &dPhi)$/;"	f	class:LevelSet
checkUniformInitialCondition	NonlinearRom.C	/^void NonlinearRom<dim>::checkUniformInitialCondition(DistSVec<double, dim> &ic) {$/;"	f	class:NonlinearRom
checkVec	PostOperator.C	/^void PostOperator<dim>::checkVec(DistSVec<double,3>& V)  {$/;"	f	class:PostOperator
checkVec	SubDomainCore.C	/^void SubDomain::checkVec(SVec<double,3> &V)$/;"	f	class:SubDomain
checkVertex	IntersectorFRG/IntersectorFRG.C	/^void ClosestTriangle::checkVertex(int ip1, int trId, double trDist) {$/;"	f	class:ClosestTriangle
checkdensity	IoData.h	/^  int checkdensity;$/;"	m	struct:TsData
checklargevelocity	TsParameters.h	/^  int checklargevelocity;$/;"	m	class:TsParameters
checklinsolve	IoData.h	/^  int checklinsolve;$/;"	m	struct:TsData
checklinsolve	TsParameters.h	/^  int checklinsolve;$/;"	m	class:TsParameters
checkpclipping	TsParameters.h	/^  int checkpclipping;$/;"	m	class:TsParameters
checkpressure	IoData.h	/^  int checkpressure;$/;"	m	struct:TsData
checkrhoclipping	TsParameters.h	/^  int checkrhoclipping;$/;"	m	class:TsParameters
checkriemann	TsParameters.h	/^  int checkriemann;$/;"	m	class:TsParameters
checksol	IoData.h	/^  int checksol;$/;"	m	struct:TsData
checksol	TsParameters.h	/^  int checksol;$/;"	m	class:TsParameters
checkvelocity	IoData.h	/^  int checkvelocity;$/;"	m	struct:TsData
chemv_	arpack++/include/arlnames.h	114;"	d
chemv_	arpack++/include/arlnames.h	185;"	d
cher2_	arpack++/include/arlnames.h	115;"	d
cher2_	arpack++/include/arlnames.h	186;"	d
child1	RTree.h	/^    Node* child1,*child2;$/;"	m	struct:RTree::Node
child2	RTree.h	/^    Node* child1,*child2;$/;"	m	struct:RTree::Node
children	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    ARRAY<VECTOR<int,2> > children;$/;"	m	class:PhysBAM::BOX_HIERARCHY
children	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    ARRAY<LOG_ENTRY*> children;$/;"	m	class:PhysBAM::LOG_REAL::LOG_SCOPE
choice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^inline typename IF<i==1,T1&,T2&>::TYPE choice(T1& a,T2& b)$/;"	f	namespace:PhysBAM
choice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^inline typename IF<i==1,T1&,const T2&>::TYPE choice(T1& a,const T2& b)$/;"	f	namespace:PhysBAM
choice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^inline typename IF<i==1,T1&,typename IF<i==2,T2&,T3&>::TYPE>::TYPE choice(T1& a,T2& b,T3& c)$/;"	f	namespace:PhysBAM
choice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^inline typename IF<i==1,const T1&,T2&>::TYPE choice(const T1& a,T2& b)$/;"	f	namespace:PhysBAM
choice	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^inline typename IF<i==1,const T1&,const T2&>::TYPE choice(const T1& a,const T2& b)$/;"	f	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<1,T1,T2,T3> {static T1& helper(T1& a,T2& b,T3& c){return a;}};$/;"	s	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<2,T1,T2,T3> {static T2& helper(T1& a,T2& b,T3& c){return b;}};$/;"	s	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<3,T1,T2,T3> {static T3& helper(T1& a,T2& b,T3& c){return c;}};$/;"	s	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2> struct choice_helper<1,T1,T2,void> {static T1& helper(T1& a,T2& b){return a;}};$/;"	s	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2> struct choice_helper<2,T1,T2,void> {static T2& helper(T1& a,T2& b){return b;}};$/;"	s	namespace:PhysBAM
choice_helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T> struct choice_helper<0,T,void,void>$/;"	s	namespace:PhysBAM
chooseExtrapolation	InletNodeCore.C	/^void InletNode::chooseExtrapolation(int dim, double u, int* tet, int* mask, double* V1, double* V2, double* V){$/;"	f	class:InletNode
cin	MeshMotionHandler.h	/^  double cin;$/;"	m	class:RigidMeshMotionHandler
cjDensity	IoData.h	/^  double cjDensity;$/;"	m	struct:ProgrammedBurnData
cjDetonationVelocity	IoData.h	/^  double cjDetonationVelocity;$/;"	m	struct:ProgrammedBurnData
cjEnergy	IoData.h	/^  double cjEnergy;$/;"	m	struct:ProgrammedBurnData
cjPressure	IoData.h	/^  double cjPressure;$/;"	m	struct:ProgrammedBurnData
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	/^inline T clamp(const T x,const T xmin,const T xmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> clamp(const MATRIX<T,1>& x,const MATRIX<T,1>& xmin,const MATRIX<T,1>& xmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> clamp(const SYMMETRIC_MATRIX<T,2>& x,const SYMMETRIC_MATRIX<T,2>& xmin,const SYMMETRIC_MATRIX<T,2>& xmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> clamp(const SYMMETRIC_MATRIX<T,3>& x,const SYMMETRIC_MATRIX<T,3>& xmin,const SYMMETRIC_MATRIX<T,3>& xmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp(const VECTOR<T,d>& v,const T& min,const T& max)$/;"	f	class:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp(const VECTOR<T,d>& v,const VECTOR<T,d>& vmin,const VECTOR<T,d>& vmax)$/;"	f	class:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp(const VECTOR<T,1>& v,T min,T max)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp(const VECTOR<T,1>& v,const VECTOR<T,1>& vmin,const VECTOR<T,1>& vmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp(const VECTOR<T,2>& v,T min,T max)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp(const VECTOR<T,2>& v,const VECTOR<T,2>& vmin,const VECTOR<T,2>& vmax)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp(const VECTOR<T,3>& v,T min,T max)$/;"	f	namespace:PhysBAM
clamp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp(const VECTOR<T,3>& v,const VECTOR<T,3>& vmin,const VECTOR<T,3>& vmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	/^inline T clamp_max(const T x,const T xmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> clamp_max(const MATRIX<T,1>& x,const MATRIX<T,1>& xmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> clamp_max(const SYMMETRIC_MATRIX<T,2>& x,const SYMMETRIC_MATRIX<T,2>& xmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> clamp_max(const SYMMETRIC_MATRIX<T,3>& x,const SYMMETRIC_MATRIX<T,3>& xmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp_max(const VECTOR<T,d>& v,const T& max)$/;"	f	class:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp_max(const VECTOR<T,d>& v,const VECTOR<T,d>& vmax)$/;"	f	class:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp_max(const VECTOR<T,1>& v,const T& max)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp_max(const VECTOR<T,1>& v,const VECTOR<T,1>& vmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp_max(const VECTOR<T,2>& v,const T& max)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp_max(const VECTOR<T,2>& v,const VECTOR<T,2>& vmax)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp_max(const VECTOR<T,3>& v,const T& max)$/;"	f	namespace:PhysBAM
clamp_max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp_max(const VECTOR<T,3>& v,const VECTOR<T,3>& vmax)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	/^inline T clamp_min(const T x,const T xmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> clamp_min(const MATRIX<T,1>& x,const MATRIX<T,1>& xmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> clamp_min(const SYMMETRIC_MATRIX<T,2>& x,const SYMMETRIC_MATRIX<T,2>& xmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> clamp_min(const SYMMETRIC_MATRIX<T,3>& x,const SYMMETRIC_MATRIX<T,3>& xmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp_min(const VECTOR<T,d>& v,const T& min)$/;"	f	class:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^clamp_min(const VECTOR<T,d>& v,const VECTOR<T,d>& vmin)$/;"	f	class:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp_min(const VECTOR<T,1>& v,const T& min)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^clamp_min(const VECTOR<T,1>& v,const VECTOR<T,1>& vmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp_min(const VECTOR<T,2>& v,const T& min)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^clamp_min(const VECTOR<T,2>& v,const VECTOR<T,2>& vmin)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp_min(const VECTOR<T,3>& v,const T& min)$/;"	f	namespace:PhysBAM
clamp_min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^clamp_min(const VECTOR<T,3>& v,const VECTOR<T,3>& vmin)$/;"	f	namespace:PhysBAM
cleanProbesFile	TsOutput.C	/^void TsOutput<dim>::cleanProbesFile() {$/;"	f	class:TsOutput
cleanTempFiles	GappyPreprocessing.h	/^  bool cleanTempFiles;$/;"	m	class:GappyPreprocessing
clearAuxilliary	MvpMatrix.h	/^  void clearAuxilliary(AuxilliaryRows& A) {$/;"	f	class:MvpMat
clearError	ErrorHandler.h	/^  void clearError(int type=ALL){$/;"	f	struct:ErrorHandler
clearForceVector	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::clearForceVector()$/;"	f	class:EmbeddedStructure
clearGhost	GenMatrix.h	/^  virtual void clearGhost() { }$/;"	f	class:GenMat
clearGhost	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::clearGhost()$/;"	f	class:MatVecProdH1
clearGhost	MvpMatrix.h	/^  void clearGhost() { $/;"	f	class:MvpMat
clip	IoData.h	/^  ClippingData clip;$/;"	m	struct:DynamicLESData
clip	IoData.h	/^  ClippingData clip;$/;"	m	struct:DynamicVMSData
clipSolution	Domain.C	/^int Domain::clipSolution(TsData::Clipping ctype, BcsWallData::Integration wtype,$/;"	f	class:Domain
clipSolution	SubDomain.C	/^int SubDomain::clipSolution(TsData::Clipping ctype, BcsWallData::Integration wtype,$/;"	f	class:SubDomain
clippingType	TsDesc.h	/^  TsData::Clipping clippingType;$/;"	m	class:TsDesc
closeAsciiFiles	TsOutput.C	/^void TsOutput<dim>::closeAsciiFiles()$/;"	f	class:TsOutput
closeCommunication	CommunicatorMPI.C	/^void closeCommunication()$/;"	f
closed_polygon	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POLYGON.h	/^    bool closed_polygon; \/\/ (true) closed with first and last vertex connected, (false) open - one less side$/;"	m	class:PhysBAM::POLYGON
closest	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<ClosestPoint> *closest;$/;"	m	class:DistIntersectorPhysBAM
closest	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<ClosestPoint> &closest;$/;"	m	class:IntersectorPhysBAM
closestCenter	NonlinearRom.C	/^void NonlinearRom<dim>::closestCenter(DistSVec<double, dim> &vec, int *index1) {$/;"	f	class:NonlinearRom
closestCenterFast	NonlinearRom.C	/^void NonlinearRom<dim>::closestCenterFast(int *index1) {$/;"	f	class:NonlinearRom
closestCenterFull	NonlinearRom.C	/^void NonlinearRom<dim>::closestCenterFull(DistSVec<double, dim> &vec, int *index1, int *index2, double *dist1, double *dist2) {$/;"	f	class:NonlinearRom
closestPointInRange	SparseGridCore.C	/^void SparseGrid::closestPointInRange(double *coord){$/;"	f	class:SparseGrid
clusSubNum	SubDomain.h	/^  int clusSubNum;$/;"	m	class:SubDomain
clus_bconds	GeoSource.h	/^  BCondSet *clus_bconds;$/;"	m	class:GeoSource
clustUsageFile	NonlinearRom.h	/^  FILE* clustUsageFile;$/;"	m	class:NonlinearRom
clusterCenters	NonlinearRom.h	/^  VecSet< DistSVec<double, dim> >* clusterCenters; \/\/ average of all snapshots in a cluster $/;"	m	class:NonlinearRom
clusterFilesSeparately	IoData.h	/^  enum ClusterFilesSeparately {CLUSTER_FILES_SEPARATELY_FALSE = 0, CLUSTER_FILES_SEPARATELY_TRUE = 1} clusterFilesSeparately;$/;"	m	struct:ClusteringData	typeref:enum:ClusteringData::ClusterFilesSeparately
clusterIndex	NonlinearRom.h	/^  int* clusterIndex; \/\/ stores original cluster association for each snapshot (before any overlap is introduced)$/;"	m	class:NonlinearRom
clusterKrylovCount	NonlinearRom.h	/^  int* clusterKrylovCount;  \/\/ counts number of krylov vectors stored in each cluster$/;"	m	class:NonlinearRom
clusterName	IoData.h	/^  const char *clusterName;$/;"	m	struct:NonlinearRomDirectoriesData
clusterName	NonlinearRom.h	/^  const char* clusterName;$/;"	m	class:NonlinearRom
clusterNeighbors	NonlinearRom.h	/^  int** clusterNeighbors;  \/\/ one vector per cluster, lists neighboring clusters$/;"	m	class:NonlinearRom
clusterNeighborsCount	NonlinearRom.h	/^  int* clusterNeighborsCount; \/\/ stores number of neighbors for each cluster$/;"	m	class:NonlinearRom
clusterNewtonCount	NonlinearRom.h	/^  int* clusterNewtonCount;  \/\/ counts number of residuals\/jacActions stored in each cluster$/;"	m	class:NonlinearRom
clusterSnapshotMap	NonlinearRom.h	/^  int** clusterSnapshotMap;  \/\/ one vector per cluster, lists snapshots to include in the cluster (including overlapping snapshots) $/;"	m	class:NonlinearRom
clusterSwitch	ImplicitRomTsDesc.h	/^  bool clusterSwitch;$/;"	m	class:ImplicitRomTsDesc
clusterUsage	IoData.h	/^  const char *clusterUsage;$/;"	m	struct:ROMOutputData
clustering	IoData.h	/^  ClusteringData clustering;$/;"	m	struct:ROBConstructionData
clustering	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
clusteringAlgorithm	IoData.h	/^  enum ClusteringAlgorithm {K_MEANS_WITHOUT_BOUNDS = 0, K_MEANS_WITH_BOUNDS = 1} clusteringAlgorithm;$/;"	m	struct:ClusteringData	typeref:enum:ClusteringData::ClusteringAlgorithm
cm2moment	RefVal.h	/^  double cm2moment;$/;"	m	class:RefVal
cmach	IoData.h	/^  double cmach;$/;"	m	struct:PreconditionData
cmdCom	MeshMotionHandler.h	/^  virtual void cmdCom(bool *) {}$/;"	f	class:MeshMotionHandler
cmdCom	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::cmdCom(bool *lastIt)$/;"	f	class:AeroMeshMotionHandler
cmdCom	TsDesc.C	/^void TsDesc<dim>::cmdCom(bool *lastIt)$/;"	f	class:TsDesc
cmdFileName	IoData.h	/^  char *cmdFileName;$/;"	m	class:IoData
cmdFilePtr	IoData.h	/^  FILE *cmdFilePtr;$/;"	m	class:IoData
cntl	arpack++/include/arunsmat.h	/^  ARTYPE  cntl[10];$/;"	m	class:ARumNonSymMatrix
cntl	arpack++/include/arusmat.h	/^  ARTYPE  cntl[10];$/;"	m	class:ARumSymMatrix
coarseMvps	MultiGridKspSolver.h	/^  MultiGridMatVecProd<Scalar2,neq>** coarseMvps;$/;"	m	class:MultiGridKspSolver
coarseNodeTopology	MultiGridLevel.h	/^    DistVec<Topology>* coarseNodeTopology;$/;"	m	class:MultiGridLevel
coarsePrecs	MultiGridKspSolver.h	/^  MultiGridRASPrec<Scalar2,neq>** coarsePrecs;$/;"	m	class:MultiGridKspSolver
coarseSolvers	MultiGridKspSolver.h	/^            MultiGridRASPrec<Scalar2,neq>, Communicator>** coarseSolvers;                         $/;"	m	class:MultiGridKspSolver
coarseTopologyNormal	MultiGridLevel.h	/^    DistVec<Vec3D>* coarseTopologyNormal;$/;"	m	class:MultiGridLevel
coarsen4to1	MultiGridKernel.h	/^  bool coarsen4to1;$/;"	m	class:MultiGridKernel
coarseningRatio	IoData.h	/^  enum CoarseningRatio { TWOTOONE = 0, FOURTOONE = 1} coarseningRatio;$/;"	m	struct:MultiGridData	typeref:enum:MultiGridData::CoarseningRatio
code	AgglomeratedFace.h	/^  int code;$/;"	m	class:AgglomeratedFace
code	ArpackUtil.h	/^ArpackError::ErrorCode ArpackError::code = NO_ERRORS;$/;"	m	class:ArpackError
code	Face.h	/^  int code; \/\/boundary condition code$/;"	m	class:Face
code	MultiGridLevel.C	/^  int code;$/;"	m	struct:agg_face	file:
code	arpack++/include/arerror.h	/^  static ErrorCode code;$/;"	m	class:ArpackError
coeff	DynamicLESTerm.h	/^  double coeff;$/;"	m	class:DynamicLESTerm
coeff	DynamicVMSTerm.h	/^  double coeff;$/;"	m	class:DynamicVMSTerm
coeff	SmagorinskyLESTerm.h	/^  double coeff;$/;"	m	class:SmagorinskyLESTerm
coeff	VMSLESTerm.h	/^  double coeff;$/;"	m	class:VMSLESTerm
coeff	WaleLESTerm.h	/^  double coeff;$/;"	m	class:WaleLESTerm
col	GenMatrix.h	/^    int row,col;$/;"	m	struct:GenMat::AuxilliaryIterator
colBlockSize_	DistLeastSquareSolver.h	/^  int rowBlockSize_, colBlockSize_;$/;"	m	class:DistLeastSquareSolver
colCpus	DistLeastSquareSolver.h	/^  int colCpus() const { return colCpus_; }$/;"	f	class:DistLeastSquareSolver
colCpus_	DistLeastSquareSolver.h	/^  int rowCpus_, colCpus_;$/;"	m	class:DistLeastSquareSolver
colHostCpu	DistLeastSquareSolver.C	/^DistLeastSquareSolver::colHostCpu(int globalColIdx) const {$/;"	f	class:DistLeastSquareSolver
col_to_sup	arpack++/include/arlsupm.h	/^  int *col_to_sup;   \/* col_to_sup[j] is the supernode number to which column $/;"	m	struct:__anon48
colbeg	arpack++/include/arlsupm.h	/^    int *colbeg;  \/* colbeg[j] points to the beginning of column j in nzval[] $/;"	m	struct:__anon49
colend	arpack++/include/arlsupm.h	/^    int *colend;  \/* colend[j] points to one past the last element of column$/;"	m	struct:__anon49
colind	RectangularSparseMatrix.h	/^  int *colind() { return ja.v; }$/;"	f	class:RectangularSparseMat
colind	SparseMatrix.h	/^  int *colind() { return ja.v; }$/;"	f	class:SparseMat
colind	arpack++/include/arlsupm.h	/^    int  *colind; \/* pointer to array of column indices of the nonzeros *\/$/;"	m	struct:__anon47
collectPointsInRadius	KDTree.h	/^  void collectPointsInRadius(double x0[3],double radius,  $/;"	f	class:KDTree
collectPointsInRadius	KDTree.h	/^  void collectPointsInRadius(double x0[3],double radius,$/;"	f	class:KDTree
colorPattern	IntersectorPhysBAM/Mpi_Utilities.C	/^static CommPattern<pair<int,int> >* colorPattern=0;$/;"	m	namespace:PHYSBAM_MPI_UTILITIES	file:
colptr	arpack++/include/arlsupm.h	/^    int  *colptr; \/* pointer to array of beginning of columns in nzval[] $/;"	m	struct:__anon46
column	ImplicitGappyTsDesc.h	/^  double *jactmp, *column;$/;"	m	class:ImplicitGappyTsDesc
columnSumsV	NonlinearRom.h	/^  std::vector<double>* columnSumsV;$/;"	m	class:NonlinearRom
com	Communicator.h	/^    Communicator &com;$/;"	m	class:Communication::Window
com	CorotSolver.h	/^  Communicator *com;$/;"	m	class:CorotSolver
com	DistBcData.h	/^  Communicator *com;$/;"	m	class:DistBcData
com	DistDynamicVMSTerm.h	/^  Communicator      *com;$/;"	m	class:DistDynamicVMSTerm
com	DistGeoState.h	/^  Communicator *com;$/;"	m	class:DistGeoState
com	DistInfo.h	/^  Communicator *com;$/;"	m	struct:DistInfo
com	DistMatrix.h	/^  Communicator *com;$/;"	m	class:DistMat
com	Domain.h	/^  Communicator *com;$/;"	m	class:Domain
com	EmbeddedCorotSolver.h	/^  Communicator *com;$/;"	m	class:EmbeddedCorotSolver
com	ErrorHandler.h	/^  Communicator *com;$/;"	m	struct:ErrorHandler
com	FSI/DynamicNodalTransfer.h	/^	Communicator &com;$/;"	m	class:DynamicNodalTransfer
com	FSI/DynamicNodalTransfer.h	/^  Communicator &com;$/;"	m	class:EmbeddedStructure
com	GappyPreprocessing.h	/^	Communicator *com;$/;"	m	class:GappyPreprocessing
com	HeatTransferHandler.h	/^  Communicator* com;$/;"	m	class:HeatTransferHandler
com	IntersectorFRG/IntersectorFRG.h	/^    Communicator *com;$/;"	m	class:DistIntersectorFRG
com	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Communicator *com;$/;"	m	class:DistIntersectorPhysBAM
com	IoData.h	/^  Communicator *com;$/;"	m	class:IoData
com	KspBinaryOutput.h	/^  Communicator* com; $/;"	m	class:KspBinaryOutput
com	LevelSet.h	/^  Communicator *com;$/;"	m	class:LevelSet
com	LevelSet/MultiGridLevelSetStructure.h	/^  Communicator *com;$/;"	m	class:DistMultiGridLevelSetStructure
com	MatVecProd.h	/^  Communicator *com;$/;"	m	class:MatVecProdFD
com	MatVecProd.h	/^  Communicator *com;$/;"	m	class:MatVecProdFDMultiPhase
com	MatVecProd.h	/^  Communicator *com;$/;"	m	class:MatVecProdLS
com	MatVecProd.h	/^  Communicator *com;$/;"	m	class:MatVecProd_dRdX
com	MeshMotionHandler.h	/^  Communicator *com;$/;"	m	class:MeshMotionHandler
com	MeshMotionSolver.h	/^  Communicator *com;$/;"	m	class:TetMeshMotionSolver
com	Modal.h	/^    Communicator *com;$/;"	m	class:ModalSolver
com	NonlinearRom.h	/^  Communicator* com; $/;"	m	class:NonlinearRom
com	NonlinearRomOffline.h	/^    Communicator *com;$/;"	m	class:NonlinearRomOfflineSolver
com	ParallelRom.h	/^	Communicator *com; $/;"	m	class:ParallelRom
com	PostOperator.h	/^  Communicator *com;$/;"	m	class:PostOperator
com	SpaceOperator.h	/^  Communicator *com;$/;"	m	class:SpaceOperator
com	SparseGridGeneratorDesc.h	/^  Communicator *com;$/;"	m	class:SparseGridGeneratorDesc
com	StructExc.h	/^  Communicator *com;$/;"	m	class:StructExc
com	Timer.h	/^  Communicator *com;$/;"	m	class:Timer
com	TsDesc.h	/^  Communicator *com;$/;"	m	class:TsDesc
com	TsOutput.h	/^  Communicator *com;$/;"	m	class:TsOutput
comm	AlternatingLeastSquare/als_lapack.h	/^    MPI_Comm comm;$/;"	m	class:AlternatingLeastSquare
comm	Communicator.h	/^  MPI_Comm comm;$/;"	m	class:Communicator
comm	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
commonPart	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::commonPart(DistSVec<double,dim> &U)$/;"	f	class:ExplicitEmbeddedTsDesc
commonPart	ImplicitEmbeddedTsDesc.C	/^int ImplicitEmbeddedTsDesc<dim>::commonPart(DistSVec<double,dim> &U)$/;"	f	class:ImplicitEmbeddedTsDesc
commonPart	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::commonPart(DistSVec<double,dim> &U)$/;"	f	class:ImplicitMultiPhysicsTsDesc
communicateAll	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::communicateAll() {$/;"	f	class:GappyPreprocessing
communicateBCFaces	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::communicateBCFaces(){$/;"	f	class:GappyPreprocessing
communicateMesh	Domain.C	/^void Domain::communicateMesh(std::vector <Scalar> * nodeOrEle, int arraySize,$/;"	f	class:Domain
communicator	Communicator.h	/^  Communicator *communicator;$/;"	m	class:CommPattern
communicator	DistLeastSquareSolver.h	/^  const Communicator * communicator() const { return communicator_; }$/;"	f	class:DistLeastSquareSolver
communicator_	DistLeastSquareSolver.h	/^  Communicator * communicator_;$/;"	m	class:DistLeastSquareSolver
comp3d	IoData.h	/^  enum Compatible3D {OFF_COMPATIBLE3D = 0, ON_COMPATIBLE3D = 1} comp3d;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::Compatible3D
compNodalGrad	SpaceOperator.h	/^  DistNodalGrad<dim, bcomp> *compNodalGrad;$/;"	m	class:SpaceOperator
compStruct	Connectivity.h	/^  compStruct() { xcomp = 0; order = 0; renum = 0; }$/;"	f	struct:compStruct
compStruct	Connectivity.h	/^struct compStruct {$/;"	s
compVecPat	DistMatrix.h	/^  CommPattern<bcomp> *compVecPat;$/;"	m	class:DistMat
compVecPat	Domain.h	/^  CommPattern<bcomp> *compVecPat;$/;"	m	class:Domain
compare	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
compareSVDMethods	IoData.h	/^  enum CompareSVDMethods {COMPARE_SVD_FALSE = 0, COMPARE_SVD_TRUE = 1} compareSVDMethods;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::CompareSVDMethods
comparison	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    T_COMPARE comparison;$/;"	m	struct:PhysBAM::INDIRECT_COMPARE
completeEmbeddedALEMeshMotionDofType	SubDomainCore.C	/^SubDomain::completeEmbeddedALEMeshMotionDofType(int* DofType, CommPattern<int> &ntP)$/;"	f	class:SubDomain
completeFaceBelongsToSurface	SubDomainCore.C	/^void SubDomain::completeFaceBelongsToSurface(Vec<int> &ndToSurfFlag, Vec<double> &nodeTemp, map<int,SurfaceData*>& surfaceMap, CommPattern<int> &cpat) {$/;"	f	class:SubDomain
completeJac	FemEquationTerm.h	/^  bool completeJac;$/;"	m	class:FemEquationTerm
completeMeshMotionDofType	SubDomainCore.C	/^SubDomain::completeMeshMotionDofType(int* DofType, CommPattern<int> &ntP)$/;"	f	class:SubDomain
completeNodeFaceType	SubDomainCore.C	/^int* SubDomain::completeNodeFaceType(CommPattern<int> &ntP)$/;"	f	class:SubDomain
completeNodeType	SubDomainCore.C	/^int* SubDomain::completeNodeType(int* priority, CommPattern<int> &ntP)$/;"	f	class:SubDomain
completeOffWallNode	SubDomainCore.C	/^int* SubDomain::completeOffWallNode(CommPattern<int> &ntP)$/;"	f	class:SubDomain
completeRotateSurfaceOwnership	SubDomainCore.C	/^void SubDomain::completeRotateSurfaceOwnership(CommPattern<int>&cpat)  {$/;"	f	class:SubDomain
componentwiseScalingVec	ImplicitRomTsDesc.h	/^  DistSVec<double, dim>* componentwiseScalingVec; \/\/ Intended to fix the scaling of the residual.  Gives energy interpretation to all equations.$/;"	m	class:ImplicitRomTsDesc
compress	utils/Predicate.C	/^int compress(int elen, REAL *e, REAL *h)  \/* e and h may be the same. *\/$/;"	f
compute	CurvatureDetection.C	/^void CurvatureDetection::compute(double threshold, DistSVec<double,3>& X, DistVec<bool>& t)$/;"	f	class:CurvatureDetection
compute	DistDynamicLESTerm.C	/^void DistDynamicLESTerm<dim>::compute(DistVec<double> &ctrlVol, $/;"	f	class:DistDynamicLESTerm
compute	DistDynamicVMSTerm.C	/^void DistDynamicVMSTerm<dim>::compute(FluxFcn** fluxFcn, $/;"	f	class:DistDynamicVMSTerm
compute	DistEdgeGrad.C	/^void DistEdgeGrad<dim>::compute(int config, DistSVec<double,3> &X)$/;"	f	class:DistEdgeGrad
compute	DistExtrapolation.C	/^void DistExtrapolation<dim>::compute(int config, DistVec<Vec3D> &norm, DistSVec<double,3> &X)$/;"	f	class:DistExtrapolation
compute	DistGeoState.C	/^void DistGeoState::compute(TimeData &timeData, DistSVec<double,3> &Xsdot, $/;"	f	class:DistGeoState
compute	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::compute(int config, DistSVec<double,3> &X,$/;"	f	class:DistNodalGrad
compute	DistVMSLESTerm.C	/^void DistVMSLESTerm<dim>::compute(int config, DistVec<double> &ctrlVol,$/;"	f	class:DistVMSLESTerm
compute	DynamicLESTerm.C	/^void DynamicLESTerm::compute(double tetVol, double dp1dxj[4][3], double *V[4], $/;"	f	class:DynamicLESTerm
compute	DynamicVMSTerm.C	/^void DynamicVMSTerm::compute(double Cs[4], double Pt[4], double tetVol, double dp1dxj[4][3], double *VBar[4],$/;"	f	class:DynamicVMSTerm
compute	EdgeGalerkin.C	/^void EdgeGalerkin::compute(int config, RefVal *refVal, VarFcn *varFcn, ViscoFcn *viscoFcn, $/;"	f	class:EdgeGalerkin
compute	EdgeGrad.C	/^void EdgeGrad<dim>::compute(int l, int i, int j, ElemSet& elems, $/;"	f	class:EdgeGrad
compute	FluxFcn.h	/^  void compute(double length, double irey, double *normal, double normalVel, double *VL, double *VR, double *flux, int tag=0, bool useLimiter = true){$/;"	f	class:FluxFcn
compute	FluxFcnBase.h	/^  virtual void compute(double, double, double *, double, double *, double *, double *, bool) {}$/;"	f	class:FluxFcnBase
compute	FluxFcnBase.h	/^  virtual void compute(double, double, double *, double, double *, double *, double *, bool){} $/;"	f	class:FluxFcnFD
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlApprJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlApprJacRoeEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlExactJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlExactJacRoeEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlFDJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlFDJacRoeEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlGhidagliaEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlGhidagliaEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlInflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlInflowEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlInternalInflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlInternalInflowEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlInternalOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlInternalOutflowEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlOutflowEuler3D
compute	FluxFcnDescJwl.C	/^void FluxFcnJwlWallEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlWallEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLEEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLEEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLEKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLEKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLESA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLESA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateInflowKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateInflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateOutflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateOutflowKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateOutflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLCEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLCEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLCKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLCKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLCSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLCSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLEEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLEEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLEKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLEKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacHLLESA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacHLLESA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacRoeKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGFDJacRoeSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGGhidagliaEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGGhidagliaEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGGhidagliaKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGGhidagliaKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGGhidagliaSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGGhidagliaSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGInflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalInflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalInflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalOutflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowInflowKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowInflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowOutflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowOutflowKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowOutflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGModifiedGhidagliaEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGModifiedGhidagliaEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGOutflowEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGOutflowKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGOutflowKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGOutflowSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGOutflowSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnSGPorousWallEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGPorousWallKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGPorousWallSA3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGVanLeerEuler3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGVanLeerEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGWallEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnSGWallEuler3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGWallKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallKE3D
compute	FluxFcnDescSG.C	/^void FluxFcnSGWallSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallSA3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGDirectStateInflowKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGDirectStateInflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGDirectStateOutflowKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGDirectStateOutflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGGhidagliaKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGGhidagliaSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGInternalInflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGInternalOutflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGMassFlowInflowKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGMassFlowInflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGMassFlowOutflowKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGMassFlowOutflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGOutflowKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGOutflowSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGPorousWallKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGPorousWallSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGRoeKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGRoeSAturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGWallKEturb3D
compute	FluxFcnDescSG.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnSGWallSAturb3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitApprJacRoeEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitApprJacRoeKE3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitApprJacRoeSA3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitExactJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitExactJacRoeEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitFDJacRoeEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitFDJacRoeEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitGhidagliaEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitGhidagliaEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitGhidagliaKE3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitGhidagliaKE3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitGhidagliaSA3D::compute(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitGhidagliaSA3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitInflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitInflowEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitInternalInflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitInternalInflowEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitInternalOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitInternalOutflowEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitModifiedGhidagliaEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitModifiedGhidagliaEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitOutflowEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitOutflowEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitWallEuler3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitWallEuler3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitWallKE3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitWallKE3D
compute	FluxFcnDescTait.C	/^void FluxFcnTaitWallSA3D::compute(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitWallSA3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitGhidagliaKEturb3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitGhidagliaSAturb3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitRoeKEturb3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitRoeSAturb3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitWallKEturb3D
compute	FluxFcnDescTait.h	/^  void compute(double, double, double *n, double nv, double *vl, double *vr, double *f, bool) {}$/;"	f	class:FluxFcnTaitWallSAturb3D
compute	KspConvCriterion.C	/^double KspConvCriterion::compute(int nlit, int nlmaxits, double fnorm)$/;"	f	class:KspConvCriterion
compute	MacroCell.C	/^void MacroCellSet::compute(bool doInitialTasks,$/;"	f	class:MacroCellSet
compute	OneDimensionalSolver.C	/^  void compute(double* U, double* f,int i) {$/;"	f	class:EulerSource
compute	OneDimensionalSolver.C	/^  void compute(double* U, double* f,int i) {$/;"	f	class:LevelSetSource
compute	OneDimensionalSourceTerm.h	/^    void compute(FluxF& f, SVec<double,dim>& V, SVec<double,dim>& F, SVec<double,1>& X, SVec<double,1>& Y, Vec<int>& fluidId) {$/;"	f	class:OneDimensionalSourceTerm
compute	RecFcn.h	/^void RecFcn::compute(Scalar* pi, Scalar* ddpij, Scalar* pj, Scalar* ddpji,$/;"	f	class:RecFcn
compute	RecFcn.h	/^void RecFcn::compute(double *dx, SVec<Scalar1,dim> &p,$/;"	f	class:RecFcn
compute	RecFcn.h	/^void RecFcn::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcn
compute	RecFcnDesc.h	/^void RecFcnConstant<5>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
compute	RecFcnDesc.h	/^void RecFcnConstant<6>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
compute	RecFcnDesc.h	/^void RecFcnConstant<7>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
compute	RecFcnDesc.h	/^void RecFcnConstant<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
compute	RecFcnDesc.h	/^void RecFcnLinear<5>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinear
compute	RecFcnDesc.h	/^void RecFcnLinear<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinear
compute	RecFcnDesc.h	/^void RecFcnLinearConstant<6>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearConstant
compute	RecFcnDesc.h	/^void RecFcnLinearConstant<7>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearConstant
compute	RecFcnDesc.h	/^void RecFcnLinearConstant<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearConstant
compute	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<6>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearVanAlbada
compute	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<7>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearVanAlbada
compute	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearVanAlbada
compute	RecFcnDesc.h	/^void RecFcnVanAlbada<5>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
compute	RecFcnDesc.h	/^void RecFcnVanAlbada<6>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
compute	RecFcnDesc.h	/^void RecFcnVanAlbada<7>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
compute	RecFcnDesc.h	/^void RecFcnVanAlbada<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
compute	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<6>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbadaConstant
compute	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<7>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbadaConstant
compute	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<dim>::compute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbadaConstant
compute	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::compute(double tetVol, double dp1dxj[4][3],$/;"	f	class:SmagorinskyLESTerm
compute	ThermalCondFcn.h	/^  double compute(double Tadim) { return thermal_conductivity_coefficient; }$/;"	f	class:ConstantThermalCondFcn
compute	ThermalCondFcn.h	/^  double compute(double Tadim)$/;"	f	class:ConstantPrandtlThermalCondFcn
compute	VMSLESTerm.C	/^void VMSLESTerm::compute(double tetVol, $/;"	f	class:VMSLESTerm
compute	WaleLESTerm.C	/^void WaleLESTerm::compute(double tetVol, double dp1dxj[4][3],$/;"	f	class:WaleLESTerm
computeAJ	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::computeAJ(int it, DistSVec<double, dim> &Q)  {$/;"	f	class:FluidRomShapeOptimizationHandler
computeAJ	ImplicitGappyTsDesc.C	/^void ImplicitGappyTsDesc<dim>::computeAJ(int it, DistSVec<double, dim> &Q, bool applyWeighting, DistSVec<double, dim> *R)  {$/;"	f	class:ImplicitGappyTsDesc
computeAJ	ImplicitRomPostproTsDesc.C	/^void ImplicitRomPostproTsDesc<dim>::computeAJ(int it, DistSVec<double, dim> &Q, bool applyWeighting,  DistSVec<double, dim> *R) {$/;"	f	class:ImplicitRomPostproTsDesc
computeAJ	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::computeAJ(int it, DistSVec<double, dim> &Q, bool applyWeighting, DistSVec<double, dim> *R)  {$/;"	f	class:ImplicitRomTsDesc
computeAlpha	HigherOrderFSI.C	/^double HigherOrderFSI::computeAlpha(int nodeId, const double* currentV, const double* neighborV) $/;"	f	class:HigherOrderFSI
computeAlpha	HigherOrderMultiFluid.C	/^computeAlpha(int nodeId,const double* currentV, $/;"	f	class:HigherOrderMultiFluid
computeApproxMetricNonlinearNNLS	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeApproxMetricNonlinearNNLS(int iCluster) {$/;"	f	class:GappyPreprocessing
computeApproximatedMetricLowRankFactor	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeApproximatedMetricLowRankFactor() {$/;"	f	class:GappyPreprocessing
computeBCFaces	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeBCFaces(bool liftContribution) {$/;"	f	class:GappyPreprocessing
computeBCsJacobianWallValues	Domain.C	/^void Domain::computeBCsJacobianWallValues(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeBCsJacobianWallValues	Face.C	/^void FaceSet::computeBCsJacobianWallValues(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceSet
computeBCsJacobianWallValues	Face.h	/^  void computeBCsJacobianWallValues(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, Vec<double> &d2wall, $/;"	f	class:Face
computeBCsJacobianWallValues	Face.h	/^  void computeBCsJacobianWallValues(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, Vec<double> &d2wall, $/;"	f	class:FaceDummy
computeBCsJacobianWallValues	Face.h	/^  void computeBCsJacobianWallValues(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, Vec<double> &d2wall, $/;"	f	class:FaceWrapper_dim
computeBCsJacobianWallValues	FaceTria.C	/^void FaceTria::computeBCsJacobianWallValues(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, Vec<double> &d2wall, $/;"	f	class:FaceTria
computeBCsJacobianWallValues	FemEquationTermDesc.C	/^void FemEquationTermSA::computeBCsJacobianWallValues(int code, Vec3D &n, double d2w[3], double *Vwall, double *dVwall, double *V[3])$/;"	f	class:FemEquationTermSA
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermDES
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermDESmean
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermDESturb
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermKE
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermKEmean
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermKEturb
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermNS
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermSAmean
computeBCsJacobianWallValues	FemEquationTermDesc.h	/^  void computeBCsJacobianWallValues$/;"	f	class:FemEquationTermSAturb
computeBCsJacobianWallValues	SubDomain.C	/^void SubDomain::computeBCsJacobianWallValues(FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeBCsJacobianWallValues	WallFcn.C	/^void WallFcn::computeBCsJacobianWallValues(int code, Vec3D &normal, double d2wall[3],$/;"	f	class:WallFcn
computeBalancedWeightVec	VarFcn.h	/^DistSVec<double,dim>* VarFcn::computeBalancedWeightVec(IoData &iod, DistSVec<double,dim> &U, DistSVec<double,dim> *F) {$/;"	f	class:VarFcn
computeBar	DistTimeState.C	/^void DistTimeState<dim>::computeBar(bool doInitialTasks, DistMacroCellSet *macroCells,$/;"	f	class:DistTimeState
computeBarTerm	Domain.C	/^void Domain::computeBarTerm(DistMacroCellSet *macroCells, bool doInitialTasks, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeBarValues	MacroCell.C	/^void MacroCell::computeBarValues(SVec<double,dim> &V, $/;"	f	class:MacroCell
computeBarthFcn	RecFcn.h	/^double RecFcn::computeBarthFcn(double vmax, double vmin, double v,$/;"	f	class:RecFcn
computeBarycentricCoordinates	ElemTetCore.C	/^void ElemTet::computeBarycentricCoordinates(SVec<double,3>&X, const Vec3D& loc, double bary[3]) {$/;"	f	class:ElemTet
computeBij	SubDomainCore.C	/^void SubDomain::computeBij(double Bij[3][3], double r_s_p[6], double sqrt2S2,$/;"	f	class:SubDomain
computeBoundingBox	ElemCore.C	/^void Elem::computeBoundingBox(SVec<double,3>& X, double* bb) {$/;"	f	class:Elem
computeCG	CorotSolver.C	/^void CorotSolver::computeCG(DistSVec<double,3> &X, double cg[3])$/;"	f	class:CorotSolver
computeCG	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeCG(double *Xs, double cg[3])$/;"	f	class:EmbeddedCorotSolver
computeCP	PostOperator.C	/^void PostOperator<dim>::computeCP(DistSVec<double,3>& X, DistSVec<double,dim>& U, Vec3D &cp)  {$/;"	f	class:PostOperator
computeCVBasedForceLoad	Domain.C	/^void Domain::computeCVBasedForceLoad(int forceApp, int orderOfAccuracy, DistGeoState& geoState,$/;"	f	class:Domain
computeCVBasedForceLoad	SubDomain.C	/^void SubDomain::computeCVBasedForceLoad(int forceApp, int orderOfAccuracy, GeoState& geoState,$/;"	f	class:SubDomain
computeCflNumber	TsParameters.C	/^void TsParameters::computeCflNumber(int its, double res, double angle)$/;"	f	class:TsParameters
computeChapmanJouguetState	ProgrammedBurnCore.C	/^void computeChapmanJouguetState(double p_0,double rho_0,double e_0,$/;"	f	namespace:ProgrammedBurn_CJ
computeChapmanJouguetStateJWL	ProgrammedBurnCore.C	/^void ProgrammedBurn::computeChapmanJouguetStateJWL(double A1,double A2,double R1,double R2,double omega, \/\/ JWL parameters$/;"	f	class:ProgrammedBurn
computeChapmanJouguetStatePG	ProgrammedBurnCore.C	/^void ProgrammedBurn::computeChapmanJouguetStatePG(double gamma, \/\/ PG parameters$/;"	f	class:ProgrammedBurn
computeCharacteristicEdgeLength	DomainCore.C	/^void Domain::computeCharacteristicEdgeLength(DistSVec<double,3> &X, double& minLength, double& aveLength, double& maxLength, int& numInsideEdges, const double xmin, const double xmax, const double ymin, const double ymax, const double zmin, const double zmax)$/;"	f	class:Domain
computeCharacteristicEdgeLength	EdgeCore.C	/^void EdgeSet::computeCharacteristicEdgeLength(SVec<double,3> &X, double &minLength, double &aveLength, double &maxLength, int &numInsideEdges, const double xmin, const double xmax, const double ymin, const double ymax, const double zmin, const double zmax)$/;"	f	class:EdgeSet
computeCharacteristicEdgeLength	SubDomainCore.C	/^void SubDomain::computeCharacteristicEdgeLength(SVec<double,3>&X, double& minLength, double& aveLength, double& maxLength, int& numInsideEdges, const double xmin, const double xmax, const double ymin, const double ymax, const double zmin, const double zmax)$/;"	f	class:SubDomain
computeClassicalMultiDimensionalScaling	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::computeClassicalMultiDimensionalScaling()  {$/;"	f	class:NonlinearRomDatabaseConstruction
computeClusterSuffix	BinFileHandler.h	/^char *computeClusterSuffix(int num, int maxNum)$/;"	f
computeCoefficients	DistTimeState.C	/^void DistTimeState<dim>::computeCoefficients(double dt_glob)$/;"	f	class:DistTimeState
computeCoefficients	TimeData.C	/^void TimeData::computeCoefficients(DistVec<double> &dt, double dt_glob)$/;"	f	class:TimeData
computeConnectedEdges	EdgeCore.C	/^void EdgeSet::computeConnectedEdges(const std::vector<int> &locSampleNodes) $/;"	f	class:EdgeSet
computeConnectedElems	ElemCore.C	/^void ElemSet::computeConnectedElems(const std::vector<int> &locSampleNodes) $/;"	f	class:ElemSet
computeConnectedFaces	FaceCore.C	/^void FaceSet::computeConnectedFaces(const std::vector<int> &locSampleNodes) $/;"	f	class:FaceSet
computeConnectedNodes	DomainCore.C	/^void Domain::computeConnectedNodes(const std::vector<std::vector<int> > &locSampleNodes_,$/;"	f	class:Domain
computeConnectedTopology	DomainCore.C	/^void Domain::computeConnectedTopology(const std::vector<std::vector<int> > & locSampleNodes) {$/;"	f	class:Domain
computeConnectedTopology	SubDomainCore.C	/^void SubDomain::computeConnectedTopology(const std::vector<int> &locSampleNodes_, const std::vector<int> &globalNeighborNodes) $/;"	f	class:SubDomain
computeConservativeToPrimitiveDerivativeOperators	VarFcn.h	/^void VarFcn::computeConservativeToPrimitiveDerivativeOperators(DistSVec<double,dim> &U,$/;"	f	class:VarFcn
computeConservativeToPrimitiveDerivativeOperators	VarFcn.h	/^void VarFcn::computeConservativeToPrimitiveDerivativeOperators(SVec<double,dim> &U, SVec<double,dim> &V, $/;"	f	class:VarFcn
computeConservativeToPrimitiveDerivativeOperators	VarFcnBase.h	/^  virtual void computeConservativeToPrimitiveDerivativeOperators(double*, double*,$/;"	f	class:VarFcnBase
computeConservativeToPrimitiveDerivativeOperators	VarFcnSGEuler.h	/^void VarFcnSGEuler::computeConservativeToPrimitiveDerivativeOperators(double *U, double *V, double dVdU[5][5], double dVdPstiff[5])$/;"	f	class:VarFcnSGEuler
computeControlVolumes	DomainCore.C	/^int Domain::computeControlVolumes(double lscale, DistSVec<double,3> &X, DistVec<double> &ctrlVol)$/;"	f	class:Domain
computeControlVolumes	ElemTetCore.C	/^double ElemTet::computeControlVolumes(SVec<double,3> &X, Vec<double> &ctrlVol)$/;"	f	class:ElemTet
computeControlVolumes	SubDomainCore.C	/^int SubDomain::computeControlVolumes(int numInvElem, double lscale,$/;"	f	class:SubDomain
computeConvergenceInformation	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::computeConvergenceInformation(IoData &ioData, const char* file, DistSVec<double,dim>& U) {$/;"	f	class:EmbeddedTsDesc
computeConvergenceInformation	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::computeConvergenceInformation(IoData &ioData, const char* file, DistSVec<double,dim>& U) {$/;"	f	class:LevelSetTsDesc
computeConvergenceInformation	TsDesc.C	/^void TsDesc<dim>::computeConvergenceInformation(IoData &ioData, const char* file, DistSVec<double,dim>& U) {$/;"	f	class:TsDesc
computeCorrelationMatrixEVD	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeCorrelationMatrixEVD(std::vector<std::vector<double> >* corrMat) {$/;"	f	class:GappyPreprocessing
computeCs	DistDynamicVMSTerm.C	/^void DistDynamicVMSTerm<dim>::computeCs(FluxFcn** fluxFcn,$/;"	f	class:DistDynamicVMSTerm
computeCsDeltaSq	SubDomain.C	/^void SubDomain::computeCsDeltaSq(SVec<double,dim> &R,$/;"	f	class:SubDomain
computeCsValue	DistDynamicLESTerm.C	/^void DistDynamicLESTerm<dim>::computeCsValue(DistVec<double> &ctrlVol,$/;"	f	class:DistDynamicLESTerm
computeCsValues	SubDomain.C	/^void SubDomain::computeCsValues(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test,$/;"	f	class:SubDomain
computeDVMS	DistMacroCell.C	/^void DistMacroCellSet::computeDVMS(bool doInitialTasks,$/;"	f	class:DistMacroCellSet
computeDampingRatios	Modal.C	/^void ModalSolver<dim>::computeDampingRatios()$/;"	f	class:ModalSolver
computeDcDe	ProgrammedBurnCore.C	/^	double computeDcDe(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computeDcDe	ProgrammedBurnCore.C	/^	double computeDcDe(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computeDcDrho	ProgrammedBurnCore.C	/^	double computeDcDrho(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computeDcDrho	ProgrammedBurnCore.C	/^	double computeDcDrho(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computeDelOverDel	MacroCellCore.C	/^void MacroCell::computeDelOverDel(SVec<double,5> &Volume, int scd1, int scd2, double &rsum)$/;"	f	class:MacroCell
computeDelOverDel	MacroCellCore.C	/^void MacroCellSet::computeDelOverDel(SVec<double,5> &Volume, int scd1, int scd2, double &rsum)$/;"	f	class:MacroCellSet
computeDelRatios	DistMacroCellCore.C	/^void DistMacroCellSet::computeDelRatios(DistVec<double> &ctrlVol, int scopeDepth, double *rmin, double *rmax, $/;"	f	class:DistMacroCellSet
computeDelRatios	DomainCore.C	/^void Domain::computeDelRatios(DistMacroCellSet *macroCells, DistVec<double> &ctrlVol, int scopeDepth,$/;"	f	class:Domain
computeDelRatios	MacroCellCore.C	/^void MacroCell::computeDelRatios(Vec<double> &ctrlVol, double &rmax, double &rmin, double &rsum, int &sumcells, $/;"	f	class:MacroCell
computeDelRatios	MacroCellCore.C	/^void MacroCellSet::computeDelRatios(Vec<double> &ctrlVol, double &rmin, double &rmax, double &rsum, int &sumcells, $/;"	f	class:MacroCellSet
computeDelta	DynamicLESTerm.C	/^void DynamicLESTerm::computeDelta(double tetVol, SVec<double,3> &X, int nodeNum[4], double &delta)$/;"	f	class:DynamicLESTerm
computeDeltaNodeRot	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeDeltaNodeRot(double RR[3][3], DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:EmbeddedCorotSolver
computeDeltaPlus	WallFcnCore.C	/^double WallFcn::computeDeltaPlus(Vec3D &normal, double d2wall[3], double *Vwall, double *V[3])$/;"	f	class:WallFcn
computeDerivative	DistDynamicVMSTerm.C	/^void DistDynamicVMSTerm<dim>::computeDerivative(FluxFcn** fluxFcn, $/;"	f	class:DistDynamicVMSTerm
computeDerivative	DistEdgeGrad.C	/^void DistEdgeGrad<dim>::computeDerivative(int config, DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:DistEdgeGrad
computeDerivative	DistExtrapolation.C	/^void DistExtrapolation<dim>::computeDerivative(int config, DistVec<Vec3D> &norm, DistSVec<double,3> &X)$/;"	f	class:DistExtrapolation
computeDerivative	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivative(dRdXoperators<dim> *dRdXop, DistSVec<double,3> &dX, $/;"	f	class:DistNodalGrad
computeDerivative	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivative(int configSA, DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:DistNodalGrad
computeDerivative	DistVMSLESTerm.C	/^void DistVMSLESTerm<dim>::computeDerivative(int config, DistVec<double> &ctrlVol,$/;"	f	class:DistVMSLESTerm
computeDerivative	EdgeGrad.C	/^void EdgeGrad<dim>::computeDerivative(int l, int i, int j, ElemSet& elems,$/;"	f	class:EdgeGrad
computeDerivative	FluxFcn.h	/^  void computeDerivative$/;"	f	class:FluxFcn
computeDerivative	FluxFcnBase.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnBase
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeEuler3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeKE3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGApprJacRoeKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeSA3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGApprJacRoeSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowKE3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowKE3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeEuler3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeKE3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGExactJacRoeKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeSA3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGExactJacRoeSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeEuler3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeKE3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGFDJacRoeKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGFDJacRoeSA3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGFDJacRoeSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGInflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGInflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGInternalInflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGInternalInflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGInternalOutflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowKE3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowKE3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGOutflowEuler3D::computeDerivative$/;"	f	class:FluxFcnSGOutflowEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGOutflowKE3D::computeDerivative$/;"	f	class:FluxFcnSGOutflowKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGOutflowSA3D::computeDerivative$/;"	f	class:FluxFcnSGOutflowSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallEuler3D::computeDerivative$/;"	f	class:FluxFcnSGPorousWallEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallKE3D::computeDerivative$/;"	f	class:FluxFcnSGPorousWallKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallSA3D::computeDerivative$/;"	f	class:FluxFcnSGPorousWallSA3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGVanLeerEuler3D::computeDerivative(double irey, double dIrey, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnSGVanLeerEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGWallEuler3D::computeDerivative$/;"	f	class:FluxFcnSGWallEuler3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGWallKE3D::computeDerivative$/;"	f	class:FluxFcnSGWallKE3D
computeDerivative	FluxFcnDescSG.C	/^void FluxFcnSGWallSA3D::computeDerivative$/;"	f	class:FluxFcnSGWallSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGApprJacRoeKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGApprJacRoeSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateInflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGDirectStateOutflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGExactJacRoeKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGExactJacRoeSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGFDJacRoeKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGFDJacRoeSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGInflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGInternalInflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGInternalInflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGInternalOutflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowInflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGMassFlowOutflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGOutflowEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGOutflowKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGOutflowSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGPorousWallEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGPorousWallKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGPorousWallSA3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGVanLeerEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGWallEuler3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGWallKE3D
computeDerivative	FluxFcnDescSG.h	/^  virtual void computeDerivative$/;"	f	class:FluxFcnSGWallSA3D
computeDerivative	RecFcn.h	/^void RecFcn::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcn
computeDerivative	RecFcnDesc.h	/^void RecFcnConstant<5>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnConstant<6>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnConstant<7>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnConstant<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnLinear<5>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinear
computeDerivative	RecFcnDesc.h	/^void RecFcnLinear<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinear
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearConstant<6>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearConstant<7>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearConstant<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<6>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<7>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<5>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<6>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<7>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<6>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbadaConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<7>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbadaConstant
computeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<dim>::computeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbadaConstant
computeDerivative	ThermalCondFcn.h	/^  double computeDerivative(double Tadim, double dTadim, double dMach) { return 0.0; }$/;"	f	class:ConstantThermalCondFcn
computeDerivative	ThermalCondFcn.h	/^  double computeDerivative(double Tadim, double dTadim, double dMach)$/;"	f	class:ConstantPrandtlThermalCondFcn
computeDerivativeOfBarthFcn	RecFcn.h	/^double RecFcn::computeDerivativeOfBarthFcn(double vmax, double dvmax, double vmin, double dvmin, double v, double dv,$/;"	f	class:RecFcn
computeDerivativeOfControlVolumes	DomainCore.C	/^int Domain::computeDerivativeOfControlVolumes(RectangularSparseMat<double,3,1> **dCtrlVoldX, $/;"	f	class:Domain
computeDerivativeOfControlVolumes	DomainCore.C	/^int Domain::computeDerivativeOfControlVolumes(double lscale, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &dCtrlVol)$/;"	f	class:Domain
computeDerivativeOfControlVolumes	ElemTetCore.C	/^double ElemTet::computeDerivativeOfControlVolumes(SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &dCtrlVol)$/;"	f	class:ElemTet
computeDerivativeOfControlVolumes	SubDomainCore.C	/^int SubDomain::computeDerivativeOfControlVolumes(RectangularSparseMat<double,3,1> &dCtrlVoldX,$/;"	f	class:SubDomain
computeDerivativeOfControlVolumes	SubDomainCore.C	/^int SubDomain::computeDerivativeOfControlVolumes(int numInvElem, double lscale,$/;"	f	class:SubDomain
computeDerivativeOfDerivativeVanAlbadaFcn	RecFcn.h	/^double RecFcn::computeDerivativeOfDerivativeVanAlbadaFcn(double eps, double a, double da, double b, double db)$/;"	f	class:RecFcn
computeDerivativeOfEdgeNormals	ElemTetCore.C	/^void ElemTet::computeDerivativeOfEdgeNormals(SVec<double,3> &X, SVec<double,3> &dX, Vec<Vec3D> &edgeNorm,$/;"	f	class:ElemTet
computeDerivativeOfExponentials	VarFcn.h	/^  double computeDerivativeOfExponentials(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeDerivativeOfExponentials(density); }$/;"	f	class:VarFcn
computeDerivativeOfExponentials	VarFcnBase.h	/^  virtual double computeDerivativeOfExponentials(const double density) const{$/;"	f	class:VarFcnBase
computeDerivativeOfExponentials	VarFcnJwl.h	/^  double computeDerivativeOfExponentials(const double density) const{$/;"	f	class:VarFcnJwl
computeDerivativeOfExponentials2	VarFcn.h	/^  double computeDerivativeOfExponentials2(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeDerivativeOfExponentials2(density); }$/;"	f	class:VarFcn
computeDerivativeOfExponentials2	VarFcnBase.h	/^  virtual double computeDerivativeOfExponentials2(const double density) const{$/;"	f	class:VarFcnBase
computeDerivativeOfExponentials2	VarFcnJwl.h	/^  double computeDerivativeOfExponentials2(const double density) const{$/;"	f	class:VarFcnJwl
computeDerivativeOfFaceGalerkinTerm	Elem.h	/^  void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,$/;"	f	class:Elem
computeDerivativeOfFaceGalerkinTerm	Elem.h	/^  void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,$/;"	f	class:ElemDummy
computeDerivativeOfFaceGalerkinTerm	Elem.h	/^  void computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,$/;"	f	class:ElemWrapper_dim
computeDerivativeOfFaceGalerkinTerm	ElemTet.C	/^void ElemTet::computeDerivativeOfFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, Vec3D &dn,$/;"	f	class:ElemTet
computeDerivativeOfFaceGradient	EdgeGrad.C	/^void EdgeGrad<dim>::computeDerivativeOfFaceGradient(ElemSet& elems, V6NodeData& data, double rij[3], double drij[3],$/;"	f	class:EdgeGrad
computeDerivativeOfFaceValues	WallFcnCore.C	/^void WallFcn::computeDerivativeOfFaceValues(double d2wall[3], double *Vwall, double *dVwall, double *V[3], double *dV[3],$/;"	f	class:WallFcn
computeDerivativeOfFiniteVolumeTerm	Domain.C	/^void Domain::computeDerivativeOfFiniteVolumeTerm(DistVec<double> &ctrlVol, DistVec<double> &dCtrlVol,$/;"	f	class:Domain
computeDerivativeOfFiniteVolumeTerm	Domain.C	/^void Domain::computeDerivativeOfFiniteVolumeTerm(FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:Domain
computeDerivativeOfFiniteVolumeTerm	Domain.C	/^void Domain::computeDerivativeOfFiniteVolumeTerm(dRdXoperators<dim> &dRdXop, $/;"	f	class:Domain
computeDerivativeOfFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeDerivativeOfFiniteVolumeTerm($/;"	f	class:EdgeSet
computeDerivativeOfFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeDerivativeOfFiniteVolumeTerm(FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:EdgeSet
computeDerivativeOfFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeDerivativeOfFiniteVolumeTerm(Vec<double> &irey, Vec<double> &dIrey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:EdgeSet
computeDerivativeOfFiniteVolumeTerm	Face.C	/^void Face::computeDerivativeOfFiniteVolumeTerm(FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeDerivativeOfFiniteVolumeTerm	Face.C	/^void FaceSet::computeDerivativeOfFiniteVolumeTerm($/;"	f	class:FaceSet
computeDerivativeOfFiniteVolumeTerm	Face.C	/^void FaceSet::computeDerivativeOfFiniteVolumeTerm(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:FaceSet
computeDerivativeOfFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfFiniteVolumeTerm($/;"	f	class:SubDomain
computeDerivativeOfFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfFiniteVolumeTerm(FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:SubDomain
computeDerivativeOfFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfFiniteVolumeTerm(Vec<double> &irey, Vec<double> &dIrey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:SubDomain
computeDerivativeOfForce	FaceTria.C	/^void FaceTria::computeDerivativeOfForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &d2wall,$/;"	f	class:FaceTria
computeDerivativeOfForce	PostFcn.C	/^void PostFcnEuler::computeDerivativeOfForce(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],$/;"	f	class:PostFcnEuler
computeDerivativeOfForce	PostFcn.C	/^void PostFcnNS::computeDerivativeOfForce(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],$/;"	f	class:PostFcnNS
computeDerivativeOfForce	WallFcnCore.C	/^Vec3D WallFcn::computeDerivativeOfForce(Vec3D &normal, Vec3D &dNormal, double d2wall[3], double *Vwall, double *dVwall, double *V[3], double *dV[3], double dMach)$/;"	f	class:WallFcn
computeDerivativeOfForce2	PostFcn.C	/^void PostFcnEuler::computeDerivativeOfForce2(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],$/;"	f	class:PostFcnEuler
computeDerivativeOfForceAndMoment	Face.h	/^  void computeDerivativeOfForceAndMoment(ElemSet &elems, PostFcn *postFcn,$/;"	f	class:Face
computeDerivativeOfForceAndMoment	Face.h	/^  void computeDerivativeOfForceAndMoment(ElemSet &elems, PostFcn *postFcn,$/;"	f	class:FaceDummy
computeDerivativeOfForceAndMoment	Face.h	/^  void computeDerivativeOfForceAndMoment(ElemSet &elems, PostFcn *postFcn,$/;"	f	class:FaceWrapper_dim
computeDerivativeOfForceAndMoment	FaceTria.C	/^void FaceTria::computeDerivativeOfForceAndMoment(ElemSet &elems, PostFcn *postFcn,$/;"	f	class:FaceTria
computeDerivativeOfForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfForceAndMoment(Vec3D &x0, DistSVec<double,3> &X, $/;"	f	class:PostOperator
computeDerivativeOfForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfForceAndMoment(Vec3D &x0, DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:PostOperator
computeDerivativeOfForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfForceAndMoment(dRdXoperators<dim> *dRdXop, DistSVec<double,3> &dX,$/;"	f	class:PostOperator
computeDerivativeOfForceAndMoment	SubDomain.C	/^void SubDomain::computeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,$/;"	f	class:SubDomain
computeDerivativeOfForceAndMoment	SubDomain.C	/^void SubDomain::computeDerivativeOfForceAndMoment(map<int,int> & surfOutMap, PostFcn *postFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeDerivativeOfForceTransmitted	FaceTria.C	/^void FaceTria::computeDerivativeOfForceTransmitted(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &d2wall,$/;"	f	class:FaceTria
computeDerivativeOfForceTransmitted	PostFcn.C	/^void PostFcnEuler::computeDerivativeOfForceTransmitted(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],$/;"	f	class:PostFcnEuler
computeDerivativeOfForceTransmitted	PostFcn.C	/^void PostFcnNS::computeDerivativeOfForceTransmitted(double dp1dxj[4][3], double ddp1dxj[4][3], double *Xface[3], double *dXface[3],$/;"	f	class:PostFcnNS
computeDerivativeOfFrictionTemperature	WallFcnCore.C	/^double WallFcn::computeDerivativeOfFrictionTemperature(double utau, double dutau, double delta, double rho, double drho,$/;"	f	class:WallFcn
computeDerivativeOfFrictionVelocity	WallFcnCore.C	/^double WallFcn::computeDerivativeOfFrictionVelocity(Vec3D &t, Vec3D &dt, double delta, double rho, double drho, Vec3D &u, Vec3D &du, double mu, double dmu, double dMach)$/;"	f	class:WallFcn
computeDerivativeOfGalerkinTerm	Domain.C	/^void Domain::computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeDerivativeOfGalerkinTerm	Domain.C	/^void Domain::computeDerivativeOfGalerkinTerm(dRdXoperators<dim> &dRdXop, FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeDerivativeOfGalerkinTerm	Elem.C	/^void ElemSet::computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, GeoState &geoState,$/;"	f	class:ElemSet
computeDerivativeOfGalerkinTerm	Elem.h	/^  void computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:Elem
computeDerivativeOfGalerkinTerm	Elem.h	/^  void computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:ElemDummy
computeDerivativeOfGalerkinTerm	Elem.h	/^  void computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:ElemWrapper_dim
computeDerivativeOfGalerkinTerm	ElemTet.C	/^void ElemTet::computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:ElemTet
computeDerivativeOfGalerkinTerm	Face.C	/^void FaceSet::computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:FaceSet
computeDerivativeOfGalerkinTerm	Face.h	/^  void computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:Face
computeDerivativeOfGalerkinTerm	Face.h	/^  void computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceDummy
computeDerivativeOfGalerkinTerm	Face.h	/^  void computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceWrapper_dim
computeDerivativeOfGalerkinTerm	FaceTria.C	/^void FaceTria::computeDerivativeOfGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceTria
computeDerivativeOfGalerkinTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfGalerkinTerm(FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeDerivativeOfGalerkinTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *dViscousFluxdX,$/;"	f	class:SubDomain
computeDerivativeOfGradP	SpaceOperator.C	/^void SpaceOperator<dim>::computeDerivativeOfGradP$/;"	f	class:SpaceOperator
computeDerivativeOfGradientP1Function	ElemTetCore.C	/^double ElemTet::computeDerivativeOfGradientP1Function(SVec<double,3> &nodes, SVec<double,3> &dNodes, double dNGrad[4][3])$/;"	f	class:ElemTet
computeDerivativeOfGradientP1Function2	ElemTetCore.C	/^double ElemTet::computeDerivativeOfGradientP1Function2(SVec<double,3> &nodes, SVec<double,3> &dNodes, double dNGrad[4][3], double dX[4][3])$/;"	f	class:ElemTet
computeDerivativeOfGradientsGalerkin	Domain.C	/^void Domain::computeDerivativeOfGradientsGalerkin(DistVec<double> &ctrlVol, DistVec<double> &dCtrlVol,$/;"	f	class:Domain
computeDerivativeOfGradientsGalerkin	SubDomain.C	/^void SubDomain::computeDerivativeOfGradientsGalerkin(Vec<double> &ctrlVol, Vec<double> &dCtrlVol,$/;"	f	class:SubDomain
computeDerivativeOfGradientsLeastSquares	Domain.C	/^void Domain::computeDerivativeOfGradientsLeastSquares(DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:Domain
computeDerivativeOfGradientsLeastSquares	Domain.C	/^void Domain::computeDerivativeOfGradientsLeastSquares(dRdXoperators<dim> &dRdXop, DistSVec<double,3> &dX,$/;"	f	class:Domain
computeDerivativeOfGradientsLeastSquares	SubDomain.C	/^void SubDomain::computeDerivativeOfGradientsLeastSquares($/;"	f	class:SubDomain
computeDerivativeOfHeatFluxVector	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfHeatFluxVector(double kappa, double dkappa, double dTdxj[3], double ddTdxj[3], double dqj[3])$/;"	f	class:NavierStokesTerm
computeDerivativeOfHeatPower	PostFcn.C	/^double PostFcnEuler::computeDerivativeOfHeatPower(double dp1dxj[4][3], double ddp1dxj[4][3], Vec3D& n, Vec3D& dn, double d2w[3], $/;"	f	class:PostFcnEuler
computeDerivativeOfHeatPower	PostFcn.C	/^double PostFcnNS::computeDerivativeOfHeatPower(double dp1dxj[4][3], double ddp1dxj[4][3], Vec3D& n, Vec3D& dn, double d2w[3], $/;"	f	class:PostFcnNS
computeDerivativeOfHeatPower	WallFcnCore.C	/^double WallFcn::computeDerivativeOfHeatPower(Vec3D &normal, Vec3D &dNormal, double d2wall[3], double *Vwall, double *dVwall, double *V[3], double *dV[3], double dMach)$/;"	f	class:WallFcn
computeDerivativeOfInvReynolds	Domain.C	/^void Domain::computeDerivativeOfInvReynolds(FemEquationTerm *fet, VarFcn *varFcn, DistGeoState &geoState,$/;"	f	class:Domain
computeDerivativeOfLimiter	RecFcnDesc.h	/^void RecFcnBarth<5>::computeDerivativeOfLimiter(double *Vimax, double *dVimax, double *Vimin, double *dVimin, double *Vi, double *dVi,$/;"	f	class:RecFcnBarth
computeDerivativeOfLimiter	RecFcnDesc.h	/^void RecFcnBarth<dim>::computeDerivativeOfLimiter(double *Vimax, double *dVimax, double *Vimin, double *dVimin, double *Vi, double *dVi,$/;"	f	class:RecFcnBarth
computeDerivativeOfLimiter	RecFcnDesc.h	/^void RecFcnVenkat<5>::computeDerivativeOfLimiter(double *Vimax, double *dVimax, double *Vimin, double *dVimin, double *Vi, double *dVi,$/;"	f	class:RecFcnVenkat
computeDerivativeOfLimiter	RecFcnDesc.h	/^void RecFcnVenkat<dim>::computeDerivativeOfLimiter(double *Vimax, double *dVimax, double *Vimin, double *dVimin, double *Vi, double *dVi,$/;"	f	class:RecFcnVenkat
computeDerivativeOfLocalWeightsLeastSquares	SubDomain.C	/^void computeDerivativeOfLocalWeightsLeastSquares(double dx[3], double ddx[3], double *R, double *dR, double *W, double *dW)$/;"	f
computeDerivativeOfMachNumber	VarFcn.h	/^  double computeDerivativeOfMachNumber(double *V, double *dV, double dMach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfMachNumber(V,dV,dMach); }$/;"	f	class:VarFcn
computeDerivativeOfMachNumber	VarFcnBase.h	/^  virtual double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const { return 0.0; }$/;"	f	class:VarFcnBase
computeDerivativeOfMachNumber	VarFcnSGEuler.h	/^  double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const $/;"	f	class:VarFcnSGEuler
computeDerivativeOfMachNumber	VarFcnSGKE.h	/^  double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const $/;"	f	class:VarFcnSGKE
computeDerivativeOfMachNumber	VarFcnSGSA.h	/^  double computeDerivativeOfMachNumber(double *V, double *dV, double dMach) const $/;"	f	class:VarFcnSGSA
computeDerivativeOfMinMaxStencilValues	SubDomain.C	/^void SubDomain::computeDerivativeOfMinMaxStencilValues(SVec<double,dim> &V, SVec<double,dim> &dV, SVec<double,dim> &Vmin, SVec<double,dim> &dVmin,$/;"	f	class:SubDomain
computeDerivativeOfMultiDimLimiter	Domain.C	/^void Domain::computeDerivativeOfMultiDimLimiter(RecFcnLtdMultiDim<dim> *recFcn, DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:Domain
computeDerivativeOfMultiDimLimiter	SubDomain.C	/^void SubDomain::computeDerivativeOfMultiDimLimiter(RecLimiter *recFcn, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:SubDomain
computeDerivativeOfNodalForce	Face.h	/^  void computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:Face
computeDerivativeOfNodalForce	Face.h	/^  void computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceDummy
computeDerivativeOfNodalForce	Face.h	/^  void computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceWrapper_dim
computeDerivativeOfNodalForce	FaceTria.C	/^void FaceTria::computeDerivativeOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:FaceTria
computeDerivativeOfNodalForce	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfNodalForce(DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:PostOperator
computeDerivativeOfNodalForce	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfNodalForce(RectangularSparseMat<double,3,3> **dForcedX,$/;"	f	class:PostOperator
computeDerivativeOfNodalForce	SubDomain.C	/^void SubDomain::computeDerivativeOfNodalForce(PostFcn *postFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeDerivativeOfNodalForce	SubDomain.C	/^void SubDomain::computeDerivativeOfNodalForce(RectangularSparseMat<double,3,3> *dForcedX,$/;"	f	class:SubDomain
computeDerivativeOfNodalHeatPower	Face.h	/^  void computeDerivativeOfNodalHeatPower(ElemSet& elems, PostFcn* postFcn, SVec<double,3>& X, $/;"	f	class:FaceWrapper_dim
computeDerivativeOfNodalHeatPower	Face.h	/^  void computeDerivativeOfNodalHeatPower(ElemSet& elems, PostFcn* postFcn, SVec<double,3>& X, SVec<double,3>& dX, $/;"	f	class:Face
computeDerivativeOfNodalHeatPower	Face.h	/^  void computeDerivativeOfNodalHeatPower(ElemSet& elems, PostFcn* postFcn, SVec<double,3>& X, SVec<double,3>& dX, $/;"	f	class:FaceDummy
computeDerivativeOfNodalHeatPower	FaceTria.C	/^void FaceTria::computeDerivativeOfNodalHeatPower(ElemSet& elems, PostFcn* postFcn, SVec<double,3>& X, SVec<double,3>& dX, $/;"	f	class:FaceTria
computeDerivativeOfNodalHeatPower	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfNodalHeatPower(DistSVec<double,3>& X, DistSVec<double,3>& dX, DistSVec<double,dim>& U, DistSVec<double,dim>& dU, double dS[3], DistVec<double>& dP)$/;"	f	class:PostOperator
computeDerivativeOfNodalHeatPower	SubDomain.C	/^void SubDomain::computeDerivativeOfNodalHeatPower(PostFcn* postFcn, BcData<dim>& bcData,$/;"	f	class:SubDomain
computeDerivativeOfNodeBcValue	Face.C	/^void Face::computeDerivativeOfNodeBcValue(SVec<double,3> &X, SVec<double,3> &dX, double *Uface, double *dUface, SVec<double,dim2> &dUnode)$/;"	f	class:Face
computeDerivativeOfNodeBcValue	SubDomain.C	/^void SubDomain::computeDerivativeOfNodeBcValue(SVec<double,3> &X, SVec<double,3> &dX, SVec<double,dim1> &Uface, SVec<double,dim1> &dUface,$/;"	f	class:SubDomain
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcn::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *X, double *dX, double *V, double *dV, double phi)$/;"	f	class:PostFcn
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcnDES::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *V, double *dV, double *X, double *dX, double phi)$/;"	f	class:PostFcnDES
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcnEuler::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *V, double *dV, double *X, double *dX, double phi)$/;"	f	class:PostFcnEuler
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcnKE::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *V, double *dV, double *X, double *dX, double phi)$/;"	f	class:PostFcnKE
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcnNS::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *V, double *dV, double *X, double *dX, double phi)$/;"	f	class:PostFcnNS
computeDerivativeOfNodeScalarQuantity	PostFcn.C	/^double PostFcnSA::computeDerivativeOfNodeScalarQuantity(ScalarDerivativeType type, double dS[3], double *V, double *dV, double *X, double *dX, double phi)$/;"	f	class:PostFcnSA
computeDerivativeOfNodeScalarQuantity	SubDomain.C	/^SubDomain::computeDerivativeOfNodeScalarQuantity(PostFcn::ScalarDerivativeType type, PostFcn *postFcn, double dS[3], SVec<double,dim> &V, SVec<double,dim> &dV, SVec<double,3> &X, SVec<double,3> &dX, Vec<double> &dQ)$/;"	f	class:SubDomain
computeDerivativeOfNodeValue	DistBcData.C	/^void DistBcDataKE<dim>::computeDerivativeOfNodeValue(DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:DistBcDataKE
computeDerivativeOfNodeValue	DistBcData.C	/^void DistBcDataSA<dim>::computeDerivativeOfNodeValue(DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:DistBcDataSA
computeDerivativeOfNodeValue	DistBcData.h	/^  virtual void computeDerivativeOfNodeValue(DistSVec<double,3> &, DistSVec<double,3> &) {}$/;"	f	class:DistBcData
computeDerivativeOfNormal	FaceTriaCore.C	/^void FaceTria::computeDerivativeOfNormal(SVec<double,3> &X, SVec<double,3> &dX, Vec3D &faceNorm,$/;"	f	class:FaceTria
computeDerivativeOfNormals	DomainCore.C	/^void Domain::computeDerivativeOfNormals(DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:Domain
computeDerivativeOfNormals	DomainCore.C	/^void Domain::computeDerivativeOfNormals(RectangularSparseMat<double,3,3> **dEdgeNormdX,$/;"	f	class:Domain
computeDerivativeOfNormals	SubDomainCore.C	/^void SubDomain::computeDerivativeOfNormals(RectangularSparseMat<double,3,3> &dEdgeNormdX,$/;"	f	class:SubDomain
computeDerivativeOfNormals	SubDomainCore.C	/^void SubDomain::computeDerivativeOfNormals(SVec<double,3> &X, SVec<double,3> &dX,$/;"	f	class:SubDomain
computeDerivativeOfResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeDerivativeOfResidual$/;"	f	class:SpaceOperator
computeDerivativeOfResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeDerivativeOfResidual(DistSVec<double,3> &X,$/;"	f	class:SpaceOperator
computeDerivativeOfScalarQuantity	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfScalarQuantity(PostFcn::ScalarDerivativeType type, double dS[3], $/;"	f	class:PostOperator
computeDerivativeOfSecondTurbulentViscosity	DESTerm.h	/^double DESTerm::computeDerivativeOfSecondTurbulentViscosity(double lambdal, double dlambdal,$/;"	f	class:DESTerm
computeDerivativeOfSecondTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeDerivativeOfSecondTurbulentViscosity(double lambdal, double dlambdal,$/;"	f	class:KEpsilonTerm
computeDerivativeOfSecondTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeDerivativeOfSecondTurbulentViscosity(double lambdal, double dlambdal,$/;"	f	class:SATerm
computeDerivativeOfSmagorinskyLESTerm	Domain.C	/^void Domain::computeDerivativeOfSmagorinskyLESTerm(SmagorinskyLESTerm *smag, DistSVec<double,3> &X,$/;"	f	class:Domain
computeDerivativeOfSoundSpeed	VarFcn.h	/^  double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfSoundSpeed(V,dV,dMach); }$/;"	f	class:VarFcn
computeDerivativeOfSoundSpeed	VarFcnBase.h	/^  virtual double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach) const { return 0.0; }$/;"	f	class:VarFcnBase
computeDerivativeOfSoundSpeed	VarFcnSGEuler.h	/^  double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach) const {$/;"	f	class:VarFcnSGEuler
computeDerivativeOfSoundSpeed	VarFcnSGKE.h	/^  double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach) const {$/;"	f	class:VarFcnSGKE
computeDerivativeOfSoundSpeed	VarFcnSGSA.h	/^  double computeDerivativeOfSoundSpeed(double *V, double *dV, double dMach) const {$/;"	f	class:VarFcnSGSA
computeDerivativeOfStressTensor	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfStressTensor(double mu, double dmu, double lambda, double dlambda, double dudxj[3][3], double ddudxj[3][3], double dtij[3][3])$/;"	f	class:NavierStokesTerm
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeDerivativeOfSurfaceTerm(double dp1dxj[4][3], double ddp1dxj[4][3], int code, Vec3D &n, Vec3D &dn, double d2w[4], double *Vwall, double *dVwall, double *V[4], double *dV[4], double dMach, double *dR)$/;"	f	class:FemEquationTermDES
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeDerivativeOfSurfaceTerm(int code, Vec3D &n, Vec3D &dn, double d2w[3],$/;"	f	class:FemEquationTermDES
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermKE::computeDerivativeOfSurfaceTerm(int code, Vec3D &n, Vec3D &dn, double d2w[3],$/;"	f	class:FemEquationTermKE
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeDerivativeOfSurfaceTerm(double dp1dxj[4][3], double ddp1dxj[4][3], int code,$/;"	f	class:FemEquationTermNS
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeDerivativeOfSurfaceTerm(int code, Vec3D &n, Vec3D &dn, double d2w[3],$/;"	f	class:FemEquationTermNS
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeDerivativeOfSurfaceTerm(double dp1dxj[4][3], double ddp1dxj[4][3], int code,$/;"	f	class:FemEquationTermSA
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeDerivativeOfSurfaceTerm(int code, Vec3D &n, Vec3D &dn, double d2w[3],$/;"	f	class:FemEquationTermSA
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermDESmean
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermDESturb
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermKE
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermKEmean
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermKEturb
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermSAmean
computeDerivativeOfSurfaceTerm	FemEquationTermDesc.h	/^  void computeDerivativeOfSurfaceTerm$/;"	f	class:FemEquationTermSAturb
computeDerivativeOfSurfaceTerm	WallFcnCore.C	/^void WallFcn::computeDerivativeOfSurfaceTerm(int code, Vec3D &normal, Vec3D &dNormal, double d2wall[3],$/;"	f	class:WallFcn
computeDerivativeOfSurfaceTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfSurfaceTermNS(double dp1dxj[4][3], double ddp1dxj[4][3], Vec3D &n, Vec3D &dn,$/;"	f	class:NavierStokesTerm
computeDerivativeOfTangentVector	WallFcnCore.C	/^Vec3D WallFcn::computeDerivativeOfTangentVector(Vec3D &n, Vec3D &dn, Vec3D &u, Vec3D &du)$/;"	f	class:WallFcn
computeDerivativeOfTemperature	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfTemperature(double *V, double *dV, double &dT)$/;"	f	class:NavierStokesTerm
computeDerivativeOfTemperature	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfTemperature(double *V[4], double *dV[4], double dT[4], double &dTcg)$/;"	f	class:NavierStokesTerm
computeDerivativeOfTemperature	VarFcn.h	/^  double computeDerivativeOfTemperature(double *V, double *dV, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfTemperature(V,dV); }$/;"	f	class:VarFcn
computeDerivativeOfTemperature	VarFcnBase.h	/^  virtual double computeDerivativeOfTemperature(double *V, double *dV) const { return 0.0; }$/;"	f	class:VarFcnBase
computeDerivativeOfTemperature	VarFcnSGEuler.h	/^  double computeDerivativeOfTemperature(double *V, double *dV) const {$/;"	f	class:VarFcnSGEuler
computeDerivativeOfTemperature	VarFcnSGKE.h	/^  double computeDerivativeOfTemperature(double *V, double *dV) const $/;"	f	class:VarFcnSGKE
computeDerivativeOfTemperature	VarFcnSGSA.h	/^  double computeDerivativeOfTemperature(double *V, double *dV) const {$/;"	f	class:VarFcnSGSA
computeDerivativeOfTemperatureGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfTemperatureGradient(double dp1dxj[4][3], double ddp1dxj[4][3], double T[4], double dT[4],$/;"	f	class:NavierStokesTerm
computeDerivativeOfTimeStep	Edge.C	/^void EdgeSet::computeDerivativeOfTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState,$/;"	f	class:EdgeSet
computeDerivativeOfTimeStep	Face.C	/^void Face::computeDerivativeOfTimeStep(FemEquationTerm *fet, VarFcn *varFcn, Vec<Vec3D>  &normals, Vec<Vec3D>  &dNormals, Vec<double> normalVel, Vec<double> dNormalVel,$/;"	f	class:Face
computeDerivativeOfTimeStep	Face.C	/^void FaceSet::computeDerivativeOfTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState, $/;"	f	class:FaceSet
computeDerivativeOfTimeStep	SubDomain.C	/^void SubDomain::computeDerivativeOfTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState,$/;"	f	class:SubDomain
computeDerivativeOfTotalPressure	VarFcn.h	/^  double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dmach, int tag=0) { check(tag); return varFcn[tag]->computeDerivativeOfTotalPressure(machr,dmachr,V,dV,dmach); }$/;"	f	class:VarFcn
computeDerivativeOfTotalPressure	VarFcnBase.h	/^  virtual double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dmach) const { return 0.0; }$/;"	f	class:VarFcnBase
computeDerivativeOfTotalPressure	VarFcnSGEuler.h	/^  double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dMach) const {$/;"	f	class:VarFcnSGEuler
computeDerivativeOfTotalPressure	VarFcnSGKE.h	/^  double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dMach) const {$/;"	f	class:VarFcnSGKE
computeDerivativeOfTotalPressure	VarFcnSGSA.h	/^  double computeDerivativeOfTotalPressure(double machr, double dmachr, double* V, double* dV, double dMach) const {$/;"	f	class:VarFcnSGSA
computeDerivativeOfTurbulentViscosity	DESTerm.h	/^double DESTerm::computeDerivativeOfTurbulentViscosity(double *V, double *dV, double mul, double dmul)$/;"	f	class:DESTerm
computeDerivativeOfTurbulentViscosity	DESTerm.h	/^double DESTerm::computeDerivativeOfTurbulentViscosity(double *V[4], double *dV[4], double mul, double dmul, double &mutilde, double &dmutilde)$/;"	f	class:DESTerm
computeDerivativeOfTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeDerivativeOfTurbulentViscosity(double *V, double *dV, double dMach)$/;"	f	class:KEpsilonTerm
computeDerivativeOfTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeDerivativeOfTurbulentViscosity(double *V[4], double *dV[4], double &drhok, double &drhoeps, double dMach)$/;"	f	class:KEpsilonTerm
computeDerivativeOfTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeDerivativeOfTurbulentViscosity(double *V, double *dV, double mul, double dmul)$/;"	f	class:SATerm
computeDerivativeOfTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeDerivativeOfTurbulentViscosity(double *V[4], double *dV[4], double mul, double dmul, double &dmutilde)$/;"	f	class:SATerm
computeDerivativeOfTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeDerivativeOfTurbulentViscosity(double *V[4], double mul, double dmul, double dmutilde)$/;"	f	class:SATerm
computeDerivativeOfUpwindGradient	EdgeGrad.C	/^void EdgeGrad<dim>::computeDerivativeOfUpwindGradient(Elem& elem, double rij[3], double drij[3], SVec<double,3>& X, SVec<double,3>& dX,$/;"	f	class:EdgeGrad
computeDerivativeOfVanAlbadaFcn	RecFcn.h	/^double RecFcn::computeDerivativeOfVanAlbadaFcn(double eps, double a, double da, double b, double db)$/;"	f	class:RecFcn
computeDerivativeOfVectorQuantity	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOfVectorQuantity(PostFcn::VectorDerivativeType type, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,dim> &U, DistSVec<double,dim> &dU, DistSVec<double,3> &dQ)$/;"	f	class:PostOperator
computeDerivativeOfVelocity	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfVelocity(double *dV[4], double du[4][3], double ducg[3])$/;"	f	class:NavierStokesTerm
computeDerivativeOfVelocityGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfVelocityGradient(double dp1dxj[4][3], double ddp1dxj[4][3], double u[4][3], double du[4][3], double ddudxj[3][3])$/;"	f	class:NavierStokesTerm
computeDerivativeOfVenkatFcn	RecFcn.h	/^double RecFcn::computeDerivativeOfVenkatFcn(double vmax, double dvmax, double vmin, double dvmin, double v, double dv,$/;"	f	class:RecFcn
computeDerivativeOfViscousForce	PostFcn.C	/^Vec3D PostFcnNS::computeDerivativeOfViscousForce(double dp1dxj[4][3], double ddp1dxj[4][3], Vec3D& n, Vec3D& dn, double d2w[3],$/;"	f	class:PostFcnNS
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermDES::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermDES
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermDESmean::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermDESmean
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermKE::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermKE
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermKEmean::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermKEmean
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermNS::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermNS
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermSA::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermSA
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermSAmean::computeDerivativeOfViscousTimeStep(double X[3], double dX[3], double *V, double *dV, double dMach)$/;"	f	class:FemEquationTermSAmean
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.h	/^  double computeDerivativeOfViscousTimeStep$/;"	f	class:FemEquationTermDESturb
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.h	/^  double computeDerivativeOfViscousTimeStep$/;"	f	class:FemEquationTermKEturb
computeDerivativeOfViscousTimeStep	FemEquationTermDesc.h	/^  double computeDerivativeOfViscousTimeStep$/;"	f	class:FemEquationTermSAturb
computeDerivativeOfVolume	ElemTetCore.C	/^double ElemTet::computeDerivativeOfVolume(SVec<double,3> &X, SVec<double,3> &dX )$/;"	f	class:ElemTet
computeDerivativeOfVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermDES::computeDerivativeOfVolumeTerm(double dp1dxj[4][3], double ddp1dxj[4][3], double d2w[4],$/;"	f	class:FemEquationTermDES
computeDerivativeOfVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermKE::computeDerivativeOfVolumeTerm(double dp1dxj[4][3], double ddp1dxj[4][3], double d2w[4],$/;"	f	class:FemEquationTermKE
computeDerivativeOfVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermNS::computeDerivativeOfVolumeTerm(double dp1dxj[4][3], double ddp1dxj[4][3], double d2w[4],$/;"	f	class:FemEquationTermNS
computeDerivativeOfVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermSA::computeDerivativeOfVolumeTerm(double dp1dxj[4][3], double ddp1dxj[4][3], double d2w[4],$/;"	f	class:FemEquationTermSA
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermDESmean
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermDESturb
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermKEmean
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermKEturb
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermSAmean
computeDerivativeOfVolumeTerm	FemEquationTermDesc.h	/^  bool computeDerivativeOfVolumeTerm$/;"	f	class:FemEquationTermSAturb
computeDerivativeOfVolumeTerm	VolumicForceTerm.h	/^  void computeDerivativeOfVolumeTerm(double ctrlVol, double dCtrlVol, double *V, double *dV, double *dFlux){$/;"	f	class:VolumicForceTerm
computeDerivativeOfVolumeTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOfVolumeTermNS(double mu, double dmu, double lambda, double dlambda, double kappa, double dkappa, double u[3], double du[3],$/;"	f	class:NavierStokesTerm
computeDerivativeOfVolumicForceTerm	Domain.C	/^void Domain::computeDerivativeOfVolumicForceTerm(VolumicForceTerm *volForce, DistVec<double> &ctrlVol, DistVec<double> &dCtrlVol,$/;"	f	class:Domain
computeDerivativeOfVolumicForceTerm	SubDomain.C	/^void SubDomain::computeDerivativeOfVolumicForceTerm(VolumicForceTerm *volForce, Vec<double> &ctrlVol, Vec<double> &dCtrlVol,$/;"	f	class:SubDomain
computeDerivativeOfWallValues	WallFcn.h	/^  virtual void computeDerivativeOfWallValues(double utau, double dutau, double delta, double rho, double drho,$/;"	f	class:WallFcn
computeDerivativeOfWallValues	WallFcnCore.C	/^void WallFcnKE::computeDerivativeOfWallValues(double utau, double dutau, double delta, double rho, double drho,$/;"	f	class:WallFcnKE
computeDerivativeOfWallValues	WallFcnCore.C	/^void WallFcnSA::computeDerivativeOfWallValues(double utau, double dutau, double delta, double rho, double drho,$/;"	f	class:WallFcnSA
computeDerivativeOfWeights	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivativeOfWeights(DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:DistNodalGrad
computeDerivativeOfWeights	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivativeOfWeights(dRdXoperators<dim> &dRdXop, DistSVec<double,3> &dX, DistSVec<double,6> &dR2)$/;"	f	class:DistNodalGrad
computeDerivativeOfWeightsGalerkin	DomainCore.C	/^void Domain::computeDerivativeOfWeightsGalerkin(DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,3> &dwii,$/;"	f	class:Domain
computeDerivativeOfWeightsGalerkin	ElemTetCore.C	/^void ElemTet::computeDerivativeOfWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &dX, SVec<double,3> &dwii,$/;"	f	class:ElemTet
computeDerivativeOfWeightsGalerkin	SubDomainCore.C	/^void SubDomain::computeDerivativeOfWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &dX, SVec<double,3> &dwii, SVec<double,3> &dwij, SVec<double,3> &dwji)$/;"	f	class:SubDomain
computeDerivativeOfWeightsLeastSquares	DomainCore.C	/^void Domain::computeDerivativeOfWeightsLeastSquares(DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,6> &dR)$/;"	f	class:Domain
computeDerivativeOfWeightsLeastSquares	DomainCore.C	/^void Domain::computeDerivativeOfWeightsLeastSquares(RectangularSparseMat<double,3,6> **dRdX, $/;"	f	class:Domain
computeDerivativeOfWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeDerivativeOfWeightsLeastSquaresEdgePart(RectangularSparseMat<double,3,6> &dRdX, SVec<double,3> &dX, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeDerivativeOfWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeDerivativeOfWeightsLeastSquaresEdgePart(SVec<double,3> &X, SVec<double,3> &dX, SVec<double,6> &R, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeDerivativeOfWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeDerivativeOfWeightsLeastSquaresNodePart(RectangularSparseMat<double,6,6> &dRdR, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeDerivativeOfWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeDerivativeOfWeightsLeastSquaresNodePart(SVec<double,6> &R, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeDerivativeOfWeightsOperators	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivativeOfWeightsOperators(DistSVec<double,3> &X, dRdXoperators<dim> &dRdXop)$/;"	f	class:DistNodalGrad
computeDerivativeOperatorOfGradP	Domain.C	/^void Domain::computeDerivativeOperatorOfGradP(RectangularSparseMat<double,dim,3> **dGradPdddx,$/;"	f	class:Domain
computeDerivativeOperatorOfGradP	SubDomain.C	/^void SubDomain::computeDerivativeOperatorOfGradP(RectangularSparseMat<double,dim,3> &dGradPdddx,$/;"	f	class:SubDomain
computeDerivativeOperatorOfGradientP1Function	ElemTetCore.C	/^void ElemTet::computeDerivativeOperatorOfGradientP1Function(SVec<double,3> &nodes, double ddOmegadNodes[4][3], double dNGraddNodes[4][3][4][3], int nodeNumTet[4])$/;"	f	class:ElemTet
computeDerivativeOperators	DistGeoState.C	/^void DistGeoState::computeDerivativeOperators(DistSVec<double,3> &X, $/;"	f	class:DistGeoState
computeDerivativeOperators	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeDerivativeOperators(DistSVec<double,3> &X, DistVec<double> &ctrlVol, $/;"	f	class:DistNodalGrad
computeDerivativeOperators	FluxFcn.h	/^  void computeDerivativeOperators(double ire, double dIre, double *n, double nv, double *v, double *ub,$/;"	f	class:FluxFcn
computeDerivativeOperators	FluxFcnBase.h	/^  virtual void computeDerivativeOperators(double *n, double nv, double *v, $/;"	f	class:FluxFcnBase
computeDerivativeOperators	FluxFcnDescSG.C	/^void FluxFcnSGInflowEuler3D::computeDerivativeOperators$/;"	f	class:FluxFcnSGInflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.C	/^void FluxFcnSGOutflowEuler3D::computeDerivativeOperators$/;"	f	class:FluxFcnSGOutflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.C	/^void FluxFcnSGWallEuler3D::computeDerivativeOperators$/;"	f	class:FluxFcnSGWallEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators$/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators$/;"	f	class:FluxFcnSGInternalInflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators$/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators(double *n, double nv, double *v,$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators(double *n, double nv, double *v,$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators(double *n, double nv, double *v,$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
computeDerivativeOperators	FluxFcnDescSG.h	/^  virtual void computeDerivativeOperators(double *n, double nv, double *v,$/;"	f	class:FluxFcnSGVanLeerEuler3D
computeDerivativeOperators	RecFcn.h	/^  void computeDerivativeOperators(double*, double*, double*, double*,$/;"	f	class:RecFcn
computeDerivativeOperators	RecFcnDesc.h	/^  void computeDerivativeOperators(double*, double*, double*, double*, double*, double*, double*, double*, double*, double*) {}$/;"	f	class:RecFcnConstant
computeDerivativeOperators	RecFcnDesc.h	/^  void computeDerivativeOperators(double*, double*, double*, double*, double*, double*, double*, double*, double*, double*) {}$/;"	f	class:RecFcnLinear
computeDerivativeOperators	RecFcnDesc.h	/^  void computeDerivativeOperators(double*, double*, double*, double*, double*, double*, double*, double*, double*, double*) {}$/;"	f	class:RecFcnLinearConstant
computeDerivativeOperators	RecFcnDesc.h	/^  void computeDerivativeOperators(double*, double*, double*, double*, double*, double*, double*, double*, double*, double*) {}$/;"	f	class:RecFcnLinearVanAlbada
computeDerivativeOperators	RecFcnDesc.h	/^  void computeDerivativeOperators(double*, double*, double*, double*, double*, double*, double*, double*, double*, double*) {}$/;"	f	class:RecFcnVanAlbadaConstant
computeDerivativeOperators	RecFcnDesc.h	/^void RecFcnVanAlbada<dim>::computeDerivativeOperators(double* Vi, double* ddVij, double* Vj, double* ddVji, $/;"	f	class:RecFcnVanAlbada
computeDerivativeOperators	SpaceOperator.C	/^void SpaceOperator<dim>::computeDerivativeOperators$/;"	f	class:SpaceOperator
computeDerivativeOperators	ThermalCondFcn.h	/^  void computeDerivativeOperators(double Tadim, double &dkappadTadim, double &dkappadMach)$/;"	f	class:ConstantPrandtlThermalCondFcn
computeDerivativeOperators	ThermalCondFcn.h	/^  void computeDerivativeOperators(double Tadim, double &dkappadTaim, double &dkappadMach) { dkappadTaim=0.0; dkappadMach=0.0;}$/;"	f	class:ConstantThermalCondFcn
computeDerivativeOperatorsOfControlVolumes	DomainCore.C	/^int Domain::computeDerivativeOperatorsOfControlVolumes(double lscale, DistSVec<double,3> &X, RectangularSparseMat<double,3,1> **dCtrlVoldX)$/;"	f	class:Domain
computeDerivativeOperatorsOfControlVolumes	ElemTetCore.C	/^void ElemTet::computeDerivativeOperatorsOfControlVolumes(SVec<double,3> &X, RectangularSparseMat<double,3,1> &dCtrlVoldX)$/;"	f	class:ElemTet
computeDerivativeOperatorsOfControlVolumes	SubDomainCore.C	/^int SubDomain::computeDerivativeOperatorsOfControlVolumes(SVec<double,3> &X, RectangularSparseMat<double,3,1> &dCtrlVoldX)$/;"	f	class:SubDomain
computeDerivativeOperatorsOfEdgeNormals	ElemTetCore.C	/^void ElemTet::computeDerivativeOperatorsOfEdgeNormals(SVec<double,3> &X, RectangularSparseMat<double,3,3> &dEdgeNormdX)$/;"	f	class:ElemTet
computeDerivativeOperatorsOfFiniteVolumeTerm	Domain.C	/^void Domain::computeDerivativeOperatorsOfFiniteVolumeTerm(DistVec<double>& irey, DistVec<double>& dIrey,$/;"	f	class:Domain
computeDerivativeOperatorsOfFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeDerivativeOperatorsOfFiniteVolumeTerm(Vec<double> &irey, Vec<double> &dIrey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:EdgeSet
computeDerivativeOperatorsOfFiniteVolumeTerm	Face.C	/^void Face::computeDerivativeOperatorsOfFiniteVolumeTerm(int faceNum, FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeDerivativeOperatorsOfFiniteVolumeTerm	Face.C	/^void FaceSet::computeDerivativeOperatorsOfFiniteVolumeTerm($/;"	f	class:FaceSet
computeDerivativeOperatorsOfFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeDerivativeOperatorsOfFiniteVolumeTerm(Vec<double> &irey, Vec<double> &dIrey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:SubDomain
computeDerivativeOperatorsOfForce	FaceTria.C	/^  void FaceTria::computeDerivativeOperatorsOfForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double *pin, double* gradP[3], int hydro,$/;"	f	class:FaceTria
computeDerivativeOperatorsOfForce	PostFcn.C	/^void PostFcnEuler::computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,$/;"	f	class:PostFcnEuler
computeDerivativeOperatorsOfForce	PostFcn.C	/^void PostFcnNS::computeDerivativeOperatorsOfForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,$/;"	f	class:PostFcnNS
computeDerivativeOperatorsOfForceAndMoment	Face.h	/^  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:Face
computeDerivativeOperatorsOfForceAndMoment	Face.h	/^  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceDummy
computeDerivativeOperatorsOfForceAndMoment	Face.h	/^  void computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceWrapper_dim
computeDerivativeOperatorsOfForceAndMoment	FaceTria.C	/^    void FaceTria::computeDerivativeOperatorsOfForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceTria
computeDerivativeOperatorsOfForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOperatorsOfForceAndMoment(dRdXoperators<dim> &dRdXop,$/;"	f	class:PostOperator
computeDerivativeOperatorsOfForceAndMoment	SubDomain.C	/^void SubDomain::computeDerivativeOperatorsOfForceAndMoment(map<int,int> & surfOutMap, PostFcn *postFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeDerivativeOperatorsOfForceTransmitted	FaceTria.C	/^void FaceTria::computeDerivativeOperatorsOfForceTransmitted(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V,$/;"	f	class:FaceTria
computeDerivativeOperatorsOfForceTransmitted	PostFcn.C	/^void PostFcnEuler::computeDerivativeOperatorsOfForceTransmitted(double dp1dxj[4][3],$/;"	f	class:PostFcnEuler
computeDerivativeOperatorsOfForceTransmitted	PostFcn.C	/^void PostFcnNS::computeDerivativeOperatorsOfForceTransmitted(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double *Vface[3], double *Vtet[4], double *pin,$/;"	f	class:PostFcnNS
computeDerivativeOperatorsOfGalerkinTerm	Domain.C	/^void Domain::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeDerivativeOperatorsOfGalerkinTerm	Elem.C	/^void ElemSet::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, GeoState &geoState,$/;"	f	class:ElemSet
computeDerivativeOperatorsOfGalerkinTerm	Elem.h	/^  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,$/;"	f	class:Elem
computeDerivativeOperatorsOfGalerkinTerm	Elem.h	/^  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeDerivativeOperatorsOfGalerkinTerm	Elem.h	/^  void computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeDerivativeOperatorsOfGalerkinTerm	ElemTet.C	/^void ElemTet::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, \/\/SVec<double,3> &dX,$/;"	f	class:ElemTet
computeDerivativeOperatorsOfGalerkinTerm	SubDomain.C	/^void SubDomain::computeDerivativeOperatorsOfGalerkinTerm(FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeDerivativeOperatorsOfGradientsLeastSquares	Domain.C	/^void Domain::computeDerivativeOperatorsOfGradientsLeastSquares(DistSVec<double,3> &X, DistSVec<double,6> &R, DistSVec<Scalar,dim> &var, $/;"	f	class:Domain
computeDerivativeOperatorsOfGradientsLeastSquares	SubDomain.C	/^void SubDomain::computeDerivativeOperatorsOfGradientsLeastSquares(SVec<double,3> &X, SVec<double,6> &R, SVec<Scalar,dim> &var, $/;"	f	class:SubDomain
computeDerivativeOperatorsOfHeatFluxVector	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfHeatFluxVector(double kappa, double dTdxj[3], double dqjddTdxj[3][3], double dqjdkappa[3])$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfNodalForce	Face.h	/^  void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double *gradP[3],$/;"	f	class:Face
computeDerivativeOperatorsOfNodalForce	Face.h	/^  void computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, double Pin, double* gradP[3],$/;"	f	class:FaceWrapper_dim
computeDerivativeOperatorsOfNodalForce	Face.h	/^  void computeDerivativeOperatorsOfNodalForce(ElemSet *elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceDummy
computeDerivativeOperatorsOfNodalForce	FaceTria.C	/^void FaceTria::computeDerivativeOperatorsOfNodalForce(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceTria
computeDerivativeOperatorsOfNodalForce	PostOperator.C	/^void PostOperator<dim>::computeDerivativeOperatorsOfNodalForce(DistSVec<double,3> &X, DistSVec<double,dim> &U, $/;"	f	class:PostOperator
computeDerivativeOperatorsOfNodalForce	SubDomain.C	/^void SubDomain::computeDerivativeOperatorsOfNodalForce(PostFcn *postFcn, SVec<double,3> &X, SVec<double,dim> &V, Vec<double> &Pin,$/;"	f	class:SubDomain
computeDerivativeOperatorsOfNormal	FaceTriaCore.C	/^void FaceTria::computeDerivativeOperatorsOfNormal(int faceNum, SVec<double,3> &X, RectangularSparseMat<double,3,3> &dFaceNormdX)$/;"	f	class:FaceTria
computeDerivativeOperatorsOfNormals	DomainCore.C	/^void Domain::computeDerivativeOperatorsOfNormals(DistSVec<double,3> &X, $/;"	f	class:Domain
computeDerivativeOperatorsOfNormals	SubDomainCore.C	/^void SubDomain::computeDerivativeOperatorsOfNormals(SVec<double,3> &X, $/;"	f	class:SubDomain
computeDerivativeOperatorsOfStressTensor	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfStressTensor(double mu, double lambda, double dudxj[3][3],$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfTemperature	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfTemperature(double *V[4], double dTdV[4][5], double dTcgdV[4])$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfTemperature	VarFcn.h	/^  void computeDerivativeOperatorsOfTemperature(double *V, double *dTdV, int tag=0) { check(tag); varFcn[tag]->computeDerivativeOperatorsOfTemperature(V,dTdV); }$/;"	f	class:VarFcn
computeDerivativeOperatorsOfTemperature	VarFcnBase.h	/^  virtual void computeDerivativeOperatorsOfTemperature(double *V, double dTdV[5]) const {$/;"	f	class:VarFcnBase
computeDerivativeOperatorsOfTemperature	VarFcnSGEuler.h	/^  void computeDerivativeOperatorsOfTemperature(double *V, double dTdV[5]) const {$/;"	f	class:VarFcnSGEuler
computeDerivativeOperatorsOfTemperature2	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfTemperature2(double *V[4], double dTdV[4][4][5], double dTcgdV[4][5])$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfTemperatureGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfTemperatureGradient(double dp1dxj[4][3], double T[4],$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfVanAlbadaFcn	RecFcn.h	/^void RecFcn::computeDerivativeOperatorsOfVanAlbadaFcn(double eps, double a, double b, double &dda, double &ddb)$/;"	f	class:RecFcn
computeDerivativeOperatorsOfVelocity	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfVelocity(double dudV[4][3][4][4], double ducgdV[3][4][4])$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfVelocityGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfVelocityGradient(double dp1dxj[4][3], double u[4][3],$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfViscousForce	PostFcn.C	/^void PostFcnNS::computeDerivativeOperatorsOfViscousForce(double dp1dxj[4][3], Vec3D& n, double* Vtet[4],$/;"	f	class:PostFcnNS
computeDerivativeOperatorsOfVolume	ElemTetCore.C	/^void ElemTet::computeDerivativeOperatorsOfVolume(SVec<double,3> &X, $/;"	f	class:ElemTet
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeDerivativeOperatorsOfVolumeTerm(double dp1dxj[4][3], double *V[4],$/;"	f	class:FemEquationTermNS
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^   void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermDES
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC WTF is this code style?$/;"	f	class:FemEquationTermKE
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermDESmean
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermDESturb
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermKEmean
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermKEturb
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermSA
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermSAmean
computeDerivativeOperatorsOfVolumeTerm	FemEquationTermDesc.h	/^  void computeDerivativeOperatorsOfVolumeTerm \/\/ YC$/;"	f	class:FemEquationTermSAturb
computeDerivativeOperatorsOfVolumeTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeDerivativeOperatorsOfVolumeTermNS(double mu, double lambda, double kappa, double u[3],$/;"	f	class:NavierStokesTerm
computeDerivativeOperatorsOfWeightsGalerkin	DomainCore.C	/^void Domain::computeDerivativeOperatorsOfWeightsGalerkin(DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,3> &dwii,$/;"	f	class:Domain
computeDerivativeOperatorsOfWeightsLeastSquares	DomainCore.C	/^void Domain::computeDerivativeOperatorsOfWeightsLeastSquares(DistSVec<double,3> &X, RectangularSparseMat<double,3,6> **dRdX, RectangularSparseMat<double,6,6> **dRdR)$/;"	f	class:Domain
computeDerivativeTransposeOfGradientP1Function	ElemTetCore.C	/^void ElemTet::computeDerivativeTransposeOfGradientP1Function(SVec<double,3> &nodes, double vol, double NGrad[4][3], double dNGrad[4][3], SVec<double,3> &dNodes)$/;"	f	class:ElemTet
computeDerivativeTransposeOfWeightsGalerkin	DomainCore.C	/^void Domain::computeDerivativeTransposeOfWeightsGalerkin(DistSVec<double,3> &X, DistSVec<double,3> &dX, DistSVec<double,3> &dwii,$/;"	f	class:Domain
computeDerivativeTransposeOfWeightsGalerkin	ElemTetCore.C	/^void ElemTet::computeDerivativeTransposeOfWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &dwii, SVec<double,3> &dwij, $/;"	f	class:ElemTet
computeDerivativeTransposeOfWeightsGalerkin	SubDomainCore.C	/^void SubDomain::computeDerivativeTransposeOfWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &dwii, SVec<double,3> &dwij, SVec<double,3> &dwji, SVec<double,3> &dX)$/;"	f	class:SubDomain
computeDerivativeTransposeOfWeightsLeastSquares	DomainCore.C	/^void Domain::computeDerivativeTransposeOfWeightsLeastSquares(DistSVec<double,3> &X, DistSVec<double,6> &dR, DistSVec<double,3> &dX)$/;"	f	class:Domain
computeDerivativeTransposeOfWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeDerivativeTransposeOfWeightsLeastSquaresEdgePart(SVec<double,3> &X, SVec<double,6> &dR, SVec<double,6> &R, SVec<double,3> &dX)$/;"	f	class:SubDomain
computeDerivativeTransposeOfWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeDerivativeTransposeOfWeightsLeastSquaresNodePart(SVec<double,6> &R, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeDerivativeVanAlbadaFcn	RecFcn.h	/^double RecFcn::computeDerivativeVanAlbadaFcn(double eps, double a, double b)$/;"	f	class:RecFcn
computeDerivatives	DistGeoState.C	/^void DistGeoState::computeDerivatives(DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:DistGeoState
computeDerivatives	DistGeoState.C	/^void DistGeoState::computeDerivatives(RectangularSparseMat<double,3,3> **dEdgeNormdX,$/;"	f	class:DistGeoState
computeDifference	InletNode.C	/^void InletNode::computeDifference(VarFcn* vf, SVec<double, dim> &V, SVec<double,dim> &rhs)$/;"	f	class:InletNode
computeDisplacement	SubDomainCore.C	/^void SubDomain::computeDisplacement(SVec<double,3> &X, SVec<double,3> &dX)$/;"	f	class:SubDomain
computeDisplacement	SubDomainCore.C	/^void SubDomain::computeDisplacement(SVec<double,3> &X, double* dX,int node)$/;"	f	class:SubDomain
computeDistanceCloseNodes	Domain.C	/^void Domain::computeDistanceCloseNodes(int lsdim, DistVec<int> &Tag, DistSVec<double,3> &X,$/;"	f	class:Domain
computeDistanceCloseNodes	Elem.C	/^void ElemSet::computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemSet
computeDistanceCloseNodes	Elem.h	/^  void computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:Elem
computeDistanceCloseNodes	Elem.h	/^  void computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeDistanceCloseNodes	Elem.h	/^  void computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeDistanceCloseNodes	ElemTet.C	/^void ElemTet::computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemTet
computeDistanceCloseNodes	SubDomain.C	/^void SubDomain::computeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:SubDomain
computeDistanceLevelNodes	Domain.C	/^void Domain::computeDistanceLevelNodes(int lsdim, DistVec<int> &Tag, int level,$/;"	f	class:Domain
computeDistanceLevelNodes	Elem.C	/^void ElemSet::computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:ElemSet
computeDistanceLevelNodes	Elem.h	/^  void computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:Elem
computeDistanceLevelNodes	Elem.h	/^  void computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:ElemDummy
computeDistanceLevelNodes	Elem.h	/^  void computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:ElemWrapper_dim
computeDistanceLevelNodes	ElemTet.C	/^void ElemTet::computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:ElemTet
computeDistanceLevelNodes	SubDomain.C	/^double SubDomain::computeDistanceLevelNodes(int lsdim, Vec<int> &Tag, int level,$/;"	f	class:SubDomain
computeDistancePlusPhi	ElemTet.C	/^double ElemTet::computeDistancePlusPhi(int i, SVec<double,3> &X, SVec<double,dim> &Psi)$/;"	f	class:ElemTet
computeDistancePlusPhiToEdge	ElemTetCore.C	/^bool ElemTet::computeDistancePlusPhiToEdge(double phi0, double phi1,$/;"	f	class:ElemTet
computeDistancePlusPhiToEdges	ElemTetCore.C	/^bool ElemTet::computeDistancePlusPhiToEdges(double phi[3], Vec3D Y0,$/;"	f	class:ElemTet
computeDistancePlusPhiToOppFace	ElemTetCore.C	/^bool ElemTet::computeDistancePlusPhiToOppFace(double phi[3], Vec3D Y0,$/;"	f	class:ElemTet
computeDistancePlusPhiToVertices	ElemTetCore.C	/^bool ElemTet::computeDistancePlusPhiToVertices(double phi[3], Vec3D Y0,$/;"	f	class:ElemTet
computeDistanceToAll	ElemTetCore.C	/^int ElemTet::computeDistanceToAll(double phi[3], Vec3D Y0, Vec3D Y1, Vec3D Y2, double &psi)$/;"	f	class:ElemTet
computeDistanceToInterface	ElemTet.C	/^void ElemTet::computeDistanceToInterface(int type, SVec<double,3> &X, int reorder[4],$/;"	f	class:ElemTet
computeDistanceToWall	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::computeDistanceToWall(IoData &ioData)$/;"	f	class:EmbeddedTsDesc
computeDistanceToWall	TsDesc.C	/^void TsDesc<dim>::computeDistanceToWall(IoData &ioData)$/;"	f	class:TsDesc
computeDpDe	ProgrammedBurnCore.C	/^	double computeDpDe(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computeDpDe	ProgrammedBurnCore.C	/^	double computeDpDe(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computeDpDrho	ProgrammedBurnCore.C	/^	double computeDpDrho(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computeDpDrho	ProgrammedBurnCore.C	/^	double computeDpDrho(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computeDuDTwf	HigherOrderFSI.C	/^bool HigherOrderFSI::computeDuDTwf(double *V1, VarFcn *vf, double d2w, $/;"	f	class:HigherOrderFSI
computeDualTimeFDCoefs	TimeState.C	/^void TimeState<dim>::computeDualTimeFDCoefs(GeoState &geoState, TimeFDCoefs &coefs, Vec<double> &ctrlVol, int i) { $/;"	f	class:TimeState
computeDynamicLESTerm	Domain.C	/^void Domain::computeDynamicLESTerm(DynamicLESTerm *dles, DistSVec<double,2> &Cs,$/;"	f	class:Domain
computeDynamicLESTerm	Elem.C	/^void ElemSet::computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:ElemSet
computeDynamicLESTerm	Elem.h	/^  void computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:Elem
computeDynamicLESTerm	Elem.h	/^  void computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:ElemDummy
computeDynamicLESTerm	Elem.h	/^  void computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:ElemWrapper_dim
computeDynamicLESTerm	ElemTet.C	/^void ElemTet::computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs,$/;"	f	class:ElemTet
computeDynamicLESTerm	SubDomain.C	/^void SubDomain::computeDynamicLESTerm(DynamicLESTerm *dles, SVec<double,2> &Cs,$/;"	f	class:SubDomain
computeDynamicLESTerm_e	Elem.h	/^  void computeDynamicLESTerm_e(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:Elem
computeDynamicLESTerm_e	Elem.h	/^  void computeDynamicLESTerm_e(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:ElemDummy
computeDynamicLESTerm_e	Elem.h	/^  void computeDynamicLESTerm_e(DynamicLESTerm *dles, SVec<double,2> &Cs, $/;"	f	class:ElemWrapper_dim
computeDynamicLESTerm_e	ElemTet.C	/^void ElemTet::computeDynamicLESTerm_e(DynamicLESTerm *dles, SVec<double,2> &Cs,$/;"	f	class:ElemTet
computeDynamicVMSTerm	Domain.C	/^void Domain::computeDynamicVMSTerm(DynamicVMSTerm *dvmst, DistMacroCellSet *macroCells,$/;"	f	class:Domain
computeDynamicVMSTerm	Elem.C	/^void ElemSet::computeDynamicVMSTerm(DynamicVMSTerm *dvmst,$/;"	f	class:ElemSet
computeDynamicVMSTerm	Elem.h	/^  void computeDynamicVMSTerm(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:Elem
computeDynamicVMSTerm	Elem.h	/^  void computeDynamicVMSTerm(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:ElemDummy
computeDynamicVMSTerm	Elem.h	/^  void computeDynamicVMSTerm(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:ElemWrapper_dim
computeDynamicVMSTerm	ElemTet.C	/^void ElemTet::computeDynamicVMSTerm(DynamicVMSTerm *dvmst,$/;"	f	class:ElemTet
computeDynamicVMSTerm_Step1	SubDomain.C	/^void SubDomain::computeDynamicVMSTerm_Step1(DynamicVMSTerm *dvmst,$/;"	f	class:SubDomain
computeDynamicVMSTerm_Step2	SubDomain.C	/^void SubDomain::computeDynamicVMSTerm_Step2(MacroCellSet **macroCells,$/;"	f	class:SubDomain
computeEMBNodeScalarQuantity	SubDomain.C	/^void SubDomain::computeEMBNodeScalarQuantity(SVec<double,3> &X, SVec<double,dim> &V, $/;"	f	class:SubDomain
computeEMBNodeScalarQuantity_step1	SubDomain.C	/^void SubDomain::computeEMBNodeScalarQuantity_step1(SVec<double,3> &X, SVec<double,dim> &V,$/;"	f	class:SubDomain
computeEMBNodeScalarQuantity_step2	SubDomain.C	/^void SubDomain::computeEMBNodeScalarQuantity_step2(SVec<double,3> &X, SVec<double,dim> &V, $/;"	f	class:SubDomain
computeEMBScalarQuantity	PostOperator.C	/^void PostOperator<dim>::computeEMBScalarQuantity(DistSVec<double,3>& X,$/;"	f	class:PostOperator
computeEddyViscosity	DynamicLESTerm.C	/^double DynamicLESTerm::computeEddyViscosity(double rho, double Delta,$/;"	f	class:DynamicLESTerm
computeEddyViscosity	DynamicVMSTerm.C	/^double DynamicVMSTerm::computeEddyViscosity(double rhoBar, double duidxj[3][3])$/;"	f	class:DynamicVMSTerm
computeEddyViscosity	SmagorinskyLESTerm.C	/^double SmagorinskyLESTerm::computeEddyViscosity(double rho, double Delta,$/;"	f	class:SmagorinskyLESTerm
computeEddyViscosity	VMSLESTerm.C	/^double VMSLESTerm::computeEddyViscosity(double rhoBar, double Delta,$/;"	f	class:VMSLESTerm
computeEddyViscosity	WaleLESTerm.C	/^double WaleLESTerm::computeEddyViscosity(double rho, double Delta, double duidxj[3][3])$/;"	f	class:WaleLESTerm
computeEdgeCrossing	LevelSet/MultiGridLevelSetStructure.C	/^computeEdgeCrossing(SVec<double,3>& nodeNormals) {$/;"	f	class:MultiGridLevelSetStructure
computeEdgeDihedralAngle	SubDomainCore.C	/^void SubDomain::computeEdgeDihedralAngle(double threshold, SVec<double,6>& normals,$/;"	f	class:SubDomain
computeEdgeNormals	FaceCore.C	/^void Face::computeEdgeNormals(SVec<double,3>& X, int* l2gl, SVec<double,6>& normals)$/;"	f	class:Face
computeEdgeNormalsConfig	ElemTetCore.C	/^void ElemTet::computeEdgeNormalsConfig(SVec<double,3> &Xconfig, SVec<double,3> &Xdot,$/;"	f	class:ElemTet
computeEdgeNormalsEZGCL1	ElemTetCore.C	/^void ElemTet::computeEdgeNormalsEZGCL1(double oodt, SVec<double,3> &Xn, SVec<double,3> &Xnp1, $/;"	f	class:ElemTet
computeEdgeNormalsGCL1	ElemTetCore.C	/^void ElemTet::computeEdgeNormalsGCL1(SVec<double,3> &Xn, SVec<double,3> &Xnp1, $/;"	f	class:ElemTet
computeEdgeWeightsGalerkin	ElemTetCore.C	/^void ElemTet::computeEdgeWeightsGalerkin(SVec<double,3> &X, SVec<double,9> &M)$/;"	f	class:ElemTet
computeEdgeWeightsGalerkin	SubDomainCore.C	/^void SubDomain::computeEdgeWeightsGalerkin(SVec<double,3> &X, Vec<double> &A, SVec<double,9> &M)$/;"	f	class:SubDomain
computeEigenvectorsAndResidual	Modal.C	/^void ModalSolver<dim>::computeEigenvectorsAndResidual(double sReal, double sImag, int iEV, $/;"	f	class:ModalSolver
computeEmbSurfBasedForceLoad	Domain.C	/^void Domain::computeEmbSurfBasedForceLoad(IoData &iod, int forceApp, int orderOfAccuracy, $/;"	f	class:Domain
computeEmbSurfBasedForceLoad	SubDomain.C	/^void SubDomain::computeEmbSurfBasedForceLoad(IoData &iod, int forceApp, int order, $/;"	f	class:SubDomain
computeEmbSurfBasedForceLoad_e	SubDomain.C	/^void SubDomain::computeEmbSurfBasedForceLoad_e(IoData &iod, int forceApp, int order, $/;"	f	class:SubDomain
computeEnergy	DynamicLESTerm.C	/^void DynamicLESTerm::computeEnergy(double *V[4], double en[4])$/;"	f	class:DynamicLESTerm
computeEnergy	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::computeEnergy(double *V[4], double en[4])$/;"	f	class:SmagorinskyLESTerm
computeEnergy	WaleLESTerm.C	/^void WaleLESTerm::computeEnergy(double *V[4], double en[4])$/;"	f	class:WaleLESTerm
computeEnergyGradient	DynamicLESTerm.C	/^void DynamicLESTerm::computeEnergyGradient(double dp1dxj[4][3],$/;"	f	class:DynamicLESTerm
computeEnergyGradient	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::computeEnergyGradient(double dp1dxj[4][3],$/;"	f	class:SmagorinskyLESTerm
computeEnergyGradient	WaleLESTerm.C	/^void WaleLESTerm::computeEnergyGradient(double dp1dxj[4][3],$/;"	f	class:WaleLESTerm
computeEnergyWeightVec	VarFcn.h	/^DistSVec<double,dim>* VarFcn::computeEnergyWeightVec(IoData &iod, DistSVec<double,dim> &U) {$/;"	f	class:VarFcn
computeEntropy	VarFcn.h	/^  double computeEntropy(const double density, const double pressure, int tag=0) const{check(tag); return varFcn[tag]->computeEntropy(density,pressure); }$/;"	f	class:VarFcn
computeEntropy	VarFcnBase.h	/^  virtual double computeEntropy(const double density, const double pressure) const{$/;"	f	class:VarFcnBase
computeEntropy	VarFcnJwl.h	/^  double computeEntropy(const double density, const double pressure) const{$/;"	f	class:VarFcnJwl
computeEntropy	VarFcnSGEuler.h	/^  double computeEntropy(double density, double pressure) const {$/;"	f	class:VarFcnSGEuler
computeEntropy	VarFcnSGKE.h	/^  double computeEntropy(double density, double pressure) const {$/;"	f	class:VarFcnSGKE
computeEntropy	VarFcnSGSA.h	/^  double computeEntropy(double density, double pressure) const {$/;"	f	class:VarFcnSGSA
computeEpsilon	MatVecProd.C	/^double MatVecProdFD<dim, neq>::computeEpsilon(DistSVec<double,neq> &U, DistSVec<double,neq> &p)$/;"	f	class:MatVecProdFD
computeEpsilon	MatVecProd.C	/^double MatVecProdFDMultiPhase<dim, dimLS>::computeEpsilon(DistSVec<double,dim> &U, DistSVec<double,dim> &p)$/;"	f	class:MatVecProdFDMultiPhase
computeEpsilon	MatVecProd.C	/^double MatVecProdLS<dim, dimLS>::computeEpsilon(DistSVec<double,dimLS> &U, DistSVec<double,dimLS> &p)$/;"	f	class:MatVecProdLS
computeEpsilonEisenstadt	KspConvCriterion.C	/^double KspConvCriterion::computeEpsilonEisenstadt(double fnorm)$/;"	f	class:KspConvCriterion
computeEulerFluxes	OneDimensionalSolver.C	/^void OneDimensional::computeEulerFluxes(SVec<double,5>& y){$/;"	f	class:OneDimensional
computeExactErrors	ReinitializeDistanceToWall.C	/^void ReinitializeDistanceToWall<dimLS>::computeExactErrors(DistLevelSetStructure& LSS,DistSVec<double,3>& X,DistGeoState& distGeoState)$/;"	f	class:ReinitializeDistanceToWall
computeExponentials	VarFcn.h	/^  double computeExponentials(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeExponentials(density); }$/;"	f	class:VarFcn
computeExponentials	VarFcnBase.h	/^  virtual double computeExponentials(const double density) const{$/;"	f	class:VarFcnBase
computeExponentials	VarFcnJwl.h	/^  double computeExponentials(const double density) const{$/;"	f	class:VarFcnJwl
computeExponentials2	VarFcn.h	/^  double computeExponentials2(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeExponentials2(density); }$/;"	f	class:VarFcn
computeExponentials2	VarFcnBase.h	/^  virtual double computeExponentials2(const double density) const{$/;"	f	class:VarFcnBase
computeExponentials2	VarFcnJwl.h	/^  double computeExponentials2(const double density) const{$/;"	f	class:VarFcnJwl
computeExtended	RecFcn.h	/^void RecFcn::computeExtended(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcn
computeExtended	RecFcnDesc.h	/^void RecFcnExtendedVanAlbada<dim>::computeExtended(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnExtendedVanAlbada
computeFDerivs	Face.h	/^  void computeFDerivs(ElemSet &elems, VarFcn *varFcn, SVec<double,3> &X, $/;"	f	class:FaceDummy
computeFDerivs	Face.h	/^  void computeFDerivs(ElemSet &elems, VarFcn *varFcn, SVec<double,3> &X, $/;"	f	class:FaceWrapper_dim
computeFDerivs	Face.h	/^  void computeFDerivs(ElemSet &elems,$/;"	f	class:Face
computeFDerivs	FaceTria.C	/^void FaceTria::computeFDerivs(ElemSet &elems,$/;"	f	class:FaceTria
computeFSIRiemannJacobian	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::computeFSIRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:ExactRiemannSolver
computeFSIRiemannSolution	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::computeFSIRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:ExactRiemannSolver
computeFSIRiemannSolution	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::computeFSIRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:ExactRiemannSolver
computeFSIRiemannderivative	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::computeFSIRiemannderivative(double *Vi, double *Vstar,$/;"	f	class:ExactRiemannSolver
computeFaceBcValue	Face.C	/^void Face::computeFaceBcValue(SVec<double,dim> &Unode, double *Uface)$/;"	f	class:Face
computeFaceBcValue	SubDomain.C	/^void SubDomain::computeFaceBcValue(SVec<double,dim> &Unode, SVec<double,dim> &Uface)$/;"	f	class:SubDomain
computeFaceEdgeNormals	SubDomainCore.C	/^void SubDomain::computeFaceEdgeNormals(SVec<double,3>& X, SVec<double,6>& normals)$/;"	f	class:SubDomain
computeFaceGalerkinTerm	Elem.h	/^  void computeFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, $/;"	f	class:Elem
computeFaceGalerkinTerm	Elem.h	/^  void computeFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, $/;"	f	class:ElemDummy
computeFaceGalerkinTerm	Elem.h	/^  void computeFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, $/;"	f	class:ElemWrapper_dim
computeFaceGalerkinTerm	ElemTet.C	/^void ElemTet::computeFaceGalerkinTerm(FemEquationTerm *fet, int face[3], int code, Vec3D &n, $/;"	f	class:ElemTet
computeFaceGradient	EdgeGrad.C	/^void EdgeGrad<dim>::computeFaceGradient(ElemSet& elems, V6NodeData& data, double rij[3],$/;"	f	class:EdgeGrad
computeFaceInterpolation	Extrapolation.C	/^void Extrapolation<dim>::computeFaceInterpolation(int i, bool &master, int node, ElemSet &elems, $/;"	f	class:Extrapolation
computeFaceJacobianGalerkinTerm	Elem.h	/^  void computeFaceJacobianGalerkinTerm(FemEquationTerm *fet, int face[3], int code, $/;"	f	class:Elem
computeFaceJacobianGalerkinTerm	Elem.h	/^  void computeFaceJacobianGalerkinTerm(FemEquationTerm *fet, int face[3], int code, $/;"	f	class:ElemDummy
computeFaceJacobianGalerkinTerm	Elem.h	/^  void computeFaceJacobianGalerkinTerm(FemEquationTerm *fet, int face[3], int code, $/;"	f	class:ElemWrapper_Scalar_dim_neq
computeFaceJacobianGalerkinTerm	ElemTet.C	/^void ElemTet::computeFaceJacobianGalerkinTerm(FemEquationTerm *fet, int face[3], int code, $/;"	f	class:ElemTet
computeFaceNormals	DomainCore.C	/^void Domain::computeFaceNormals(DistSVec<double,3> &X, DistVec<Vec3D> &faceNorm)$/;"	f	class:Domain
computeFaceNormals	SubDomainCore.C	/^void SubDomain::computeFaceNormals(SVec<double,3> &X, Vec<Vec3D> &faceNorm)$/;"	f	class:SubDomain
computeFaceScalarQuantity	PostFcn.C	/^double PostFcn::computeFaceScalarQuantity(ScalarType type, double dp1dxj[4][3], $/;"	f	class:PostFcn
computeFaceScalarQuantity	PostFcn.C	/^double PostFcnNS::computeFaceScalarQuantity(ScalarType type, double dp1dxj[4][3], $/;"	f	class:PostFcnNS
computeFaceScalarQuantity	SubDomain.C	/^void SubDomain::computeFaceScalarQuantity(PostFcn::ScalarType type, PostFcn *postFcn,$/;"	f	class:SubDomain
computeFaceValues	WallFcnCore.C	/^void WallFcn::computeFaceValues(double d2wall[3], double *Vwall, double *V[3],$/;"	f	class:WallFcn
computeFilterWidth	DynamicLESTerm.C	/^double DynamicLESTerm::computeFilterWidth(double tetVol, SVec<double,3> &X, int nodeNum[4])$/;"	f	class:DynamicLESTerm
computeFilterWidth	DynamicVMSTerm.C	/^double DynamicVMSTerm::computeFilterWidth(double tetVol, SVec<double,3> &X, int nodeNum[4])$/;"	f	class:DynamicVMSTerm
computeFilterWidth	SmagorinskyLESTerm.C	/^double SmagorinskyLESTerm::computeFilterWidth(double tetVol, SVec<double,3> &X, int nodeNum[4])$/;"	f	class:SmagorinskyLESTerm
computeFilterWidth	SubDomainCore.C	/^void SubDomain::computeFilterWidth(SVec<double,3> &X, Vec<double> &Delta)$/;"	f	class:SubDomain
computeFilterWidth	VMSLESTerm.C	/^double VMSLESTerm::computeFilterWidth(double tetVol, SVec<double,3> &X, int nodeNum[4])$/;"	f	class:VMSLESTerm
computeFilterWidth	WaleLESTerm.C	/^double WaleLESTerm::computeFilterWidth(double tetVol, SVec<double,3> &X, int nodeNum[4])$/;"	f	class:WaleLESTerm
computeFiniteVolumeBarTerm	Domain.C	/^void Domain::computeFiniteVolumeBarTerm(DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeFiniteVolumeBar_Step1	SubDomain.C	/^int SubDomain::computeFiniteVolumeBar_Step1(Vec<double> &irey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:SubDomain
computeFiniteVolumeBar_Step2	SubDomain.C	/^void SubDomain::computeFiniteVolumeBar_Step2(MacroCellSet **macroCells,$/;"	f	class:SubDomain
computeFiniteVolumeTerm	AgglomeratedFace.C	/^computeFiniteVolumeTerm(FluxFcn **fluxFcn, $/;"	f	class:AgglomeratedFaceSet
computeFiniteVolumeTerm	AgglomeratedFace.C	/^void AgglomeratedFace::computeFiniteVolumeTerm(FluxFcn **fluxFcn, $/;"	f	class:AgglomeratedFace
computeFiniteVolumeTerm	AgglomeratedFace.C	/^void AgglomeratedFaceSet::computeFiniteVolumeTerm(FluxFcn **fluxFcn, $/;"	f	class:AgglomeratedFaceSet
computeFiniteVolumeTerm	Domain.C	/^void Domain::computeFiniteVolumeTerm(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:Domain
computeFiniteVolumeTerm	Domain.C	/^void Domain::computeFiniteVolumeTerm(DistVec<double> &ctrlVol, $/;"	f	class:Domain
computeFiniteVolumeTerm	Domain.C	/^void Domain::computeFiniteVolumeTerm(DistVec<double> &ctrlVol, DistVec<double>& irey,$/;"	f	class:Domain
computeFiniteVolumeTerm	Domain.C	/^void Domain::computeFiniteVolumeTerm(DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeFiniteVolumeTerm	Edge.C	/^int EdgeSet::computeFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann, int* locToGlobNodeMap,$/;"	f	class:EdgeSet
computeFiniteVolumeTerm	Edge.C	/^int EdgeSet::computeFiniteVolumeTerm(int* locToGlobNodeMap, Vec<double> &irey, FluxFcn** fluxFcn,$/;"	f	class:EdgeSet
computeFiniteVolumeTerm	Face.C	/^void Face::computeFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann,$/;"	f	class:Face
computeFiniteVolumeTerm	Face.C	/^void Face::computeFiniteVolumeTerm(FluxFcn **fluxFcn, Vec<Vec3D> &normals, $/;"	f	class:Face
computeFiniteVolumeTerm	Face.C	/^void Face::computeFiniteVolumeTerm(FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeFiniteVolumeTerm	Face.C	/^void FaceSet::computeFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann, $/;"	f	class:FaceSet
computeFiniteVolumeTerm	Face.C	/^void FaceSet::computeFiniteVolumeTerm(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:FaceSet
computeFiniteVolumeTerm	SubDomain.C	/^int SubDomain::computeFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann, $/;"	f	class:SubDomain
computeFiniteVolumeTerm	SubDomain.C	/^int SubDomain::computeFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann,$/;"	f	class:SubDomain
computeFiniteVolumeTerm	SubDomain.C	/^int SubDomain::computeFiniteVolumeTerm(Vec<double> &irey, FluxFcn** fluxFcn, RecFcn* recFcn,$/;"	f	class:SubDomain
computeFiniteVolumeTermLS	Domain.C	/^void Domain::computeFiniteVolumeTermLS(FluxFcn** fluxFcn, RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:Domain
computeFiniteVolumeTermLS	Edge.C	/^void EdgeSet::computeFiniteVolumeTermLS(FluxFcn** fluxFcn, RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:EdgeSet
computeFiniteVolumeTermLS	Face.C	/^void Face::computeFiniteVolumeTermLS(FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeFiniteVolumeTermLS	Face.C	/^void FaceSet::computeFiniteVolumeTermLS(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:FaceSet
computeFiniteVolumeTermLS	SubDomain.C	/^void SubDomain::computeFiniteVolumeTermLS(FluxFcn** fluxFcn, RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:SubDomain
computeFiniteVolumeTermRestrict	Edge.C	/^int EdgeSet::computeFiniteVolumeTermRestrict(int* locToGlobNodeMap, Vec<double>$/;"	f	class:EdgeSet
computeFirstLayerNodeStatus	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::computeFirstLayerNodeStatus(Vec<int> tId, Vec<double> dist)$/;"	f	class:IntersectorFRG
computeFofU	VarFcnBase.h	/^  virtual void computeFofU(double n[3], double *U, double *F) {}$/;"	f	class:VarFcnBase
computeFofU	VarFcnSGEuler.h	/^void VarFcnSGEuler::computeFofU(double n[3], double *U, double *F)$/;"	f	class:VarFcnSGEuler
computeFofV	VarFcnBase.h	/^  virtual void computeFofV(double n[3], double *V, double *F) {}$/;"	f	class:VarFcnBase
computeFofV	VarFcnSGEuler.h	/^void VarFcnSGEuler::computeFofV(double n[3], double *V, double *F)$/;"	f	class:VarFcnSGEuler
computeForce	FaceTria.C	/^void FaceTria::computeForce(ElemSet &elems,$/;"	f	class:FaceTria
computeForce	FaceTria.C	/^void FaceTria::computeForce(ExactRiemannSolver<dim>& riemann, $/;"	f	class:FaceTria
computeForce	PostFcn.C	/^void PostFcnEuler::computeForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3],$/;"	f	class:PostFcnEuler
computeForce	PostFcn.C	/^void PostFcnNS::computeForce(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3], $/;"	f	class:PostFcnNS
computeForce	WallFcnCore.C	/^Vec3D WallFcn::computeForce(Vec3D &normal, double d2wall[3], double *Vwall, double *V[3])$/;"	f	class:WallFcn
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, $/;"	f	class:Face
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, $/;"	f	class:FaceDummy
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ElemSet &elems,$/;"	f	class:FaceWrapper_dim
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ExactRiemannSolver<dim> &riemann,$/;"	f	class:FaceWrapper_dim
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ExactRiemannSolver<dim>& riemann, $/;"	f	class:Face
computeForceAndMoment	Face.h	/^  void computeForceAndMoment(ExactRiemannSolver<dim>& riemann,$/;"	f	class:FaceDummy
computeForceAndMoment	FaceTria.C	/^void FaceTria::computeForceAndMoment(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X, $/;"	f	class:FaceTria
computeForceAndMoment	FaceTria.C	/^void FaceTria::computeForceAndMoment(ExactRiemannSolver<dim>& riemann,$/;"	f	class:FaceTria
computeForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeForceAndMoment(DistExactRiemannSolver<dim> &riemann,$/;"	f	class:PostOperator
computeForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeForceAndMoment(Vec3D &x0, DistSVec<double,3> &X, $/;"	f	class:PostOperator
computeForceAndMoment	SubDomain.C	/^void SubDomain::computeForceAndMoment(ExactRiemannSolver<dim> &riemann, VarFcn *varFcn, $/;"	f	class:SubDomain
computeForceAndMoment	SubDomain.C	/^void SubDomain::computeForceAndMoment(map<int,int> & surfOutMap, PostFcn *postFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeForceCoefficients	Face.h	/^  void computeForceCoefficients(PostFcn *postFcn, Vec3D &x0, ElemSet &elems, $/;"	f	class:Face
computeForceCoefficients	Face.h	/^  void computeForceCoefficients(PostFcn *postFcn, Vec3D &x0, ElemSet &elems, $/;"	f	class:FaceDummy
computeForceCoefficients	Face.h	/^  void computeForceCoefficients(PostFcn *postFcn, Vec3D &x0, ElemSet &elems, $/;"	f	class:FaceWrapper_dim
computeForceCoefficients	FaceTria.C	/^void FaceTria::computeForceCoefficients(PostFcn *postFcn, Vec3D &x0, ElemSet &elems,$/;"	f	class:FaceTria
computeForceCoefficients	PostOperator.C	/^void PostOperator<dim>::computeForceCoefficients(Vec3D &x0, DistSVec<double,3> &X,$/;"	f	class:PostOperator
computeForceCoefficients	SubDomain.C	/^void SubDomain::computeForceCoefficients(PostFcn *postFcn, Vec3D &x0, GeoState &geoState,$/;"	f	class:SubDomain
computeForceDerivs	Domain.C	/^void Domain::computeForceDerivs(VarFcn *varFcn, DistSVec<double,3> &X, DistSVec<double,dim> &V,$/;"	f	class:Domain
computeForceDerivs	Face.h	/^  void computeForceDerivs(ElemSet &elems, VarFcn *varFcn, SVec<double,3> &X, $/;"	f	class:Face
computeForceDerivs	Face.h	/^  void computeForceDerivs(ElemSet &elems, VarFcn *varFcn, SVec<double,3> &X, $/;"	f	class:FaceDummy
computeForceDerivs	Face.h	/^  void computeForceDerivs(ElemSet &elems, VarFcn *varFcn, SVec<double,3> &X, $/;"	f	class:FaceWrapper_dim
computeForceDerivs	FaceTria.C	/^void FaceTria::computeForceDerivs(ElemSet &elems, VarFcn *varFcn, $/;"	f	class:FaceTria
computeForceDerivs	PostOperator.C	/^void PostOperator<dim>::computeForceDerivs(DistSVec<double,3> &X, DistSVec<double, dim> &U,$/;"	f	class:PostOperator
computeForceDerivs	SubDomain.C	/^void SubDomain::computeForceDerivs(VarFcn *varFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
computeForceEmbedded	PostFcn.C	/^void PostFcnEuler::computeForceEmbedded(int orderOfAccuracy, double dp1dxj[4][3], $/;"	f	class:PostFcnEuler
computeForceEmbedded	PostFcn.C	/^void PostFcnNS::computeForceEmbedded(int orderOfAccuracy,double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3], $/;"	f	class:PostFcnNS
computeForceLoad	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::computeForceLoad(DistSVec<double,dim> *Wij, DistSVec<double,dim> *Wji)$/;"	f	class:EmbeddedTsDesc
computeForceLoad	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::computeForceLoad(DistSVec<double,dim> *Wij, DistSVec<double,dim> *Wji)$/;"	f	class:MultiPhysicsTsDesc
computeForceLoad	SpaceOperator.C	/^void SpaceOperator<dim>::computeForceLoad(int forceApp, int orderOfAccuracy, DistSVec<double,3> &X, $/;"	f	class:SpaceOperator
computeForceTransmitted	FaceTria.C	/^void FaceTria::computeForceTransmitted(ElemSet &elems, PostFcn *postFcn, SVec<double,3> &X,$/;"	f	class:FaceTria
computeForceTransmitted	PostFcn.C	/^void PostFcnEuler::computeForceTransmitted(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3],$/;"	f	class:PostFcnEuler
computeForceTransmitted	PostFcn.C	/^void PostFcnNS::computeForceTransmitted(double dp1dxj[4][3], double *Xface[3], Vec3D &n, double d2w[3],$/;"	f	class:PostFcnNS
computeForces	IoData.h	/^  enum ComputeForces {FALSE = 0, TRUE = 1 } computeForces;$/;"	m	struct:SurfaceData	typeref:enum:SurfaceData::ComputeForces
computeForwardEuler	ExplicitTsDesc.C	/^void ExplicitTsDesc<dim>::computeForwardEuler(DistSVec<double,dim>& U)$/;"	f	class:ExplicitTsDesc
computeFrho	VarFcn.h	/^  double computeFrho(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeFrho(density); }$/;"	f	class:VarFcn
computeFrho	VarFcn.h	/^  double computeFrho(double *V, int tag=0) const{ check(tag); return varFcn[tag]->computeFrho(V); }$/;"	f	class:VarFcn
computeFrho	VarFcnBase.h	/^  virtual double computeFrho(const double density) const{$/;"	f	class:VarFcnBase
computeFrho	VarFcnBase.h	/^  virtual double computeFrho(double *V) const{$/;"	f	class:VarFcnBase
computeFrho	VarFcnJwl.h	/^  double computeFrho(const double rho) const{$/;"	f	class:VarFcnJwl
computeFrho	VarFcnJwl.h	/^  double computeFrho(double *V) const{$/;"	f	class:VarFcnJwl
computeFrhop	VarFcn.h	/^  double computeFrhop(const double density, int tag=0) const{ check(tag); return varFcn[tag]->computeFrhop(density); }$/;"	f	class:VarFcn
computeFrhop	VarFcn.h	/^  double computeFrhop(double *V, int tag=0) const{ check(tag); return varFcn[tag]->computeFrhop(V); }$/;"	f	class:VarFcn
computeFrhop	VarFcnBase.h	/^  virtual double computeFrhop(const double density) const{$/;"	f	class:VarFcnBase
computeFrhop	VarFcnBase.h	/^  virtual double computeFrhop(double *V) const{$/;"	f	class:VarFcnBase
computeFrhop	VarFcnJwl.h	/^  double computeFrhop(const double rho) const{$/;"	f	class:VarFcnJwl
computeFrhop	VarFcnJwl.h	/^  double computeFrhop(double *V) const{$/;"	f	class:VarFcnJwl
computeFrictionTemperature	WallFcnCore.C	/^double WallFcn::computeFrictionTemperature(double utau, double delta, double rho, $/;"	f	class:WallFcn
computeFrictionVelocity	WallFcnCore.C	/^double WallFcn::computeFrictionVelocity(double ut, double delta, double rho, double mu)$/;"	f	class:WallFcn
computeFullResidual	ImplicitGappyTsDesc.C	/^void ImplicitGappyTsDesc<dim>::computeFullResidual(int it, DistSVec<double, dim> &Q, bool applyWeighting,  DistSVec<double, dim> *R, bool includeHomotopy)$/;"	f	class:ImplicitGappyTsDesc
computeFullResidual	ImplicitRomPostproTsDesc.C	/^void ImplicitRomPostproTsDesc<dim>::computeFullResidual(int it, DistSVec<double, dim> &Q, bool applyWeighting,  DistSVec<double, dim> *R, bool includeHomotopy) {$/;"	f	class:ImplicitRomPostproTsDesc
computeFullResidual	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::computeFullResidual(int it, DistSVec<double, dim> &Q, bool applyWeighting,  DistSVec<double, dim> *R, bool includeHomotopy)$/;"	f	class:ImplicitRomTsDesc
computeFunction	ImplicitEmbeddedRomTsDesc.h	/^    void computeFunction(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &F) { super::computeFunction(it, Q, F); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
computeFunction	ImplicitEmbeddedTsDesc.C	/^void ImplicitEmbeddedTsDesc<dim>::computeFunction(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitEmbeddedTsDesc
computeFunction	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::computeFunction(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitLevelSetTsDesc
computeFunction	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::computeFunction(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitMultiPhysicsTsDesc
computeFunction	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::computeFunction(int it, DistSVec<double,dim> &Q, $/;"	f	class:ImplicitTsDesc
computeFunction	MeshMotionSolver.C	/^void TetMeshMotionSolver::computeFunction(int it, DistSVec<double,3> &X, $/;"	f	class:TetMeshMotionSolver
computeFunctionLS	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::computeFunctionLS(int it,$/;"	f	class:ImplicitLevelSetTsDesc
computeFunctionLS	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::computeFunctionLS(int it,$/;"	f	class:ImplicitMultiPhysicsTsDesc
computeGAM	Modal.C	/^void ModalSolver<dim>::computeGAM(double sReal, double sImag, VecSet<Vec<bcomp> > &compGAM)$/;"	f	class:ModalSolver
computeGalerkinBarTerm	Domain.C	/^void Domain::computeGalerkinBarTerm(bool doInitialTasks,$/;"	f	class:Domain
computeGalerkinBar_Step1	SubDomain.C	/^void SubDomain::computeGalerkinBar_Step1(FemEquationTerm *fet,$/;"	f	class:SubDomain
computeGalerkinBar_Step2	SubDomain.C	/^void SubDomain::computeGalerkinBar_Step2(MacroCellSet **macroCells,$/;"	f	class:SubDomain
computeGalerkinTerm	Domain.C	/^void Domain::computeGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeGalerkinTerm	Elem.C	/^void ElemSet::computeGalerkinTerm(FemEquationTerm *fet, GeoState &geoState, $/;"	f	class:ElemSet
computeGalerkinTerm	Elem.h	/^  void computeGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:Elem
computeGalerkinTerm	Elem.h	/^  void computeGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemDummy
computeGalerkinTerm	Elem.h	/^  void computeGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemWrapper_dim
computeGalerkinTerm	ElemTet.C	/^void ElemTet::computeGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemTet
computeGalerkinTerm	Face.C	/^void FaceSet::computeGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceSet
computeGalerkinTerm	Face.h	/^  void computeGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:Face
computeGalerkinTerm	Face.h	/^  void computeGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:FaceDummy
computeGalerkinTerm	Face.h	/^  void computeGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:FaceWrapper_dim
computeGalerkinTerm	FaceTria.C	/^void FaceTria::computeGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceTria
computeGalerkinTerm	SubDomain.C	/^void SubDomain::computeGalerkinTerm(FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeGalerkinTermRestrict	Elem.C	/^void ElemSet::computeGalerkinTermRestrict(FemEquationTerm *fet, GeoState &geoState, $/;"	f	class:ElemSet
computeGalerkinTerm_e	Elem.h	/^	  void computeGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X,$/;"	f	class:Elem
computeGalerkinTerm_e	Elem.h	/^  void computeGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemDummy
computeGalerkinTerm_e	Elem.h	/^  void computeGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemWrapper_dim
computeGalerkinTerm_e	ElemTet.C	/^void ElemTet::computeGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemTet
computeGappyRes	IoData.h	/^  enum ComputeGappyRes {NO_GAPPYRES = 0, YES_GAPPYRES  = 1} computeGappyRes;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::ComputeGappyRes
computeGappyResidualNorm	ImplicitGappyTsDesc.C	/^double ImplicitGappyTsDesc<dim>::computeGappyResidualNorm(DistSVec<double,dim>& Q)$/;"	f	class:ImplicitGappyTsDesc
computeGasDerivRarefaction2x2	ImplicitRiemann.C	/^void ImplicitRiemann::computeGasDerivRarefaction2x2(double gamma,double p,double pref,$/;"	f	class:ImplicitRiemann
computeGasDerivShock2x2	ImplicitRiemann.C	/^void ImplicitRiemann::computeGasDerivShock2x2(double gamma,double p,$/;"	f	class:ImplicitRiemann
computeGasGasJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeGasGasJacobian(double Pstar, double gammai, double Pci, double Pi,double rhoi,$/;"	f	class:ImplicitRiemann
computeGasJwlJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeGasJwlJacobian(VarFcn* vf, int fluidi, int fluidj,$/;"	f	class:ImplicitRiemann
computeGasTaitJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeGasTaitJacobian(double Pstar, double gammai, double Pci, double Pi,double rhoi,$/;"	f	class:ImplicitRiemann
computeGenAeroForceMat	Modal.C	/^void ModalSolver<dim>::computeGenAeroForceMat()$/;"	f	class:ModalSolver
computeGlobalConnectedEdges	EdgeCore.C	/^void EdgeSet::computeGlobalConnectedEdges(const std::vector<int> &globalNeighborNodes, const int *locToGlobNodeMap) $/;"	f	class:EdgeSet
computeGradP	SpaceOperator.C	/^void SpaceOperator<dim>::computeGradP(DistSVec<double,3> &X, DistVec<double> &ctrlVol, $/;"	f	class:SpaceOperator
computeGradPermittivityTensor	FemEquationTerm.h	/^  void computeGradPermittivityTensor(double alpha[3], double ucg[3], double R[9] ,double *B)$/;"	f	class:FemEquationTerm
computeGradientLeastSquares	Domain.C	/^void Domain::computeGradientLeastSquares(DistSVec<double,3> &X,$/;"	f	class:Domain
computeGradientLeastSquares	SubDomain.C	/^void SubDomain::computeGradientLeastSquares(SVec<double,3> &X,$/;"	f	class:SubDomain
computeGradientP1Function	ElemTetCore.C	/^double ElemTet::computeGradientP1Function(SVec<double,3> &nodes, double nGrad[4][3], double *m)$/;"	f	class:ElemTet
computeGradientP1Function	ElemTetCore.C	/^double ElemTet::computeGradientP1Function(Vec3D &A, Vec3D &B, Vec3D &C, Vec3D &D, $/;"	f	class:ElemTet
computeGradientsGalerkin	Domain.C	/^void Domain::computeGradientsGalerkin(DistVec<double> &ctrlVol, DistSVec<double,3> &wii,$/;"	f	class:Domain
computeGradientsGalerkin	SubDomain.C	/^void SubDomain::computeGradientsGalerkin(Vec<double> &ctrlVol, $/;"	f	class:SubDomain
computeGradientsGalerkinT	Domain.C	/^void Domain::computeGradientsGalerkinT(DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeGradientsGalerkinT	SubDomain.C	/^void SubDomain::computeGradientsGalerkinT(Vec<double> &ctrlVol,$/;"	f	class:SubDomain
computeGradientsLeastSquares	Domain.C	/^void Domain::computeGradientsLeastSquares(DistSVec<double,3> &X,$/;"	f	class:Domain
computeGradientsLeastSquares	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::computeGradientsLeastSquares(DistSVec<Scalar,dim>& V) {$/;"	f	class:MultiGridOperator
computeGradientsLeastSquares	SubDomain.C	/^void SubDomain::computeGradientsLeastSquares(SVec<double,3> &X, SVec<double,6> &R,$/;"	f	class:SubDomain
computeGradientsLeastSquares	SubDomain.C	/^void SubDomain::computeGradientsLeastSquares(SVec<double,3> &X,$/;"	f	class:SubDomain
computeGradientsTransposeNew	SubDomain.C	/^void SubDomain::computeGradientsTransposeNew(SVec<double,3> &X,$/;"	f	class:SubDomain
computeGreenGaussGradient	MultiGridLevel.C	/^computeGreenGaussGradient(DistSVec<Scalar2,dim>& V,$/;"	f	class:MultiGridLevel
computeH1	Domain.C	/^void Domain::computeH1(FluxFcn **fluxFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeH1	SpaceOperator.C	/^void SpaceOperator<dim>::computeH1(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeH1	SubDomain.C	/^void SubDomain::computeH1(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeH2	Domain.C	/^void Domain::computeH2(FluxFcn **fluxFcn, RecFcn *recFcn,$/;"	f	class:Domain
computeH2	SpaceOperator.C	/^void SpaceOperator<dim>::computeH2(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeH2	SubDomain.C	/^void SubDomain::computeH2(FluxFcn **fluxFcn, RecFcn *recFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeH2transpose	Domain.C	/^void Domain::computeH2transpose(FluxFcn **fluxFcn, RecFcn *recFcn,$/;"	f	class:Domain
computeH2transpose	SpaceOperator.C	/^void SpaceOperator<dim>::computeH2transpose(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeH2transpose	SubDomain.C	/^void SubDomain::computeH2transpose(FluxFcn **fluxFcn, RecFcn *recFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeHHBoundaryTermJacobian	Face.C	/^void Face::computeHHBoundaryTermJacobian(int faceid,FluxFcn **fluxFcn, SVec<double,dim> &U,$/;"	f	class:Face
computeHHBoundaryTermJacobian	Face.C	/^void FaceSet::computeHHBoundaryTermJacobian(FluxFcn **fluxFcn, BcData<dim> &bcData,SVec<double,dim> &U,$/;"	f	class:FaceSet
computeHHBoundaryTermResidual	Domain.C	/^void Domain::computeHHBoundaryTermResidual(DistBcData<dim> &bcData,DistSVec<double,dim> &U,DistVec<double>& res,$/;"	f	class:Domain
computeHHBoundaryTermResidual	Face.C	/^void Face::computeHHBoundaryTermResidual(SVec<double,dim> &U,double* Ub,double& UbHH, double& res, VarFcn* vf) {$/;"	f	class:Face
computeHHBoundaryTermResidual	Face.C	/^void FaceSet::computeHHBoundaryTermResidual(BcData<dim> &bcData,SVec<double,dim> &V, Vec<double> &res,VarFcn* vf) {$/;"	f	class:FaceSet
computeHHBoundaryTermResidual	SubDomain.C	/^void SubDomain::computeHHBoundaryTermResidual(BcData<dim> &bcData,SVec<double,dim> &U,Vec<double>& res, VarFcn* vf) {$/;"	f	class:SubDomain
computeHeatFluxRelatedValues	PostFcn.C	/^double PostFcnEuler::computeHeatFluxRelatedValues(double dp1dxj[4][3], Vec3D& n, double d2w[3],$/;"	f	class:PostFcnEuler
computeHeatFluxRelatedValues	PostFcn.C	/^double PostFcnNS::computeHeatFluxRelatedValues(double dp1dxj[4][3], Vec3D& n, double d2w[3],$/;"	f	class:PostFcnNS
computeHeatFluxVector	NavierStokesTerm.h	/^void NavierStokesTerm::computeHeatFluxVector(double kappa, double dTdxj[3], double qj[3])$/;"	f	class:NavierStokesTerm
computeHeatFluxes	Face.h	/^  double computeHeatFluxes(ElemSet &elems,$/;"	f	class:Face
computeHeatFluxes	Face.h	/^  double computeHeatFluxes(ElemSet &elems,$/;"	f	class:FaceWrapper_dim
computeHeatFluxes	FaceTria.C	/^double FaceTria::computeHeatFluxes(ElemSet& elems,$/;"	f	class:FaceTria
computeHeatFluxes	IoData.h	/^  enum ComputeHeatPower {FALSE_HF = 0, TRUE_HF = 1 } computeHeatFluxes;$/;"	m	struct:SurfaceData	typeref:enum:SurfaceData::ComputeHeatPower
computeHeatFluxes	PostOperator.C	/^void PostOperator<dim>::computeHeatFluxes(DistSVec<double,3>& X, $/;"	f	class:PostOperator
computeHeatFluxes	SubDomain.C	/^void SubDomain::computeHeatFluxes(map<int,int> & surfOutMapHF, PostFcn* postFcn, BcData<dim>& bcData,$/;"	f	class:SubDomain
computeHeatPower	PostFcn.C	/^double PostFcnEuler::computeHeatPower(double dp1dxj[4][3], Vec3D& n, double d2w[3], $/;"	f	class:PostFcnEuler
computeHeatPower	PostFcn.C	/^double PostFcnNS::computeHeatPower(double dp1dxj[4][3], Vec3D& n, double d2w[3], $/;"	f	class:PostFcnNS
computeHeatPower	WallFcnCore.C	/^double WallFcn::computeHeatPower(Vec3D &normal, double d2wall[3], double *Vwall, double *V[3])$/;"	f	class:WallFcn
computeInfNodeRot	CorotSolver.C	/^void CorotSolver::computeInfNodeRot(double RR[3][3], DistSVec<double,3> &X, $/;"	f	class:CorotSolver
computeInitialState	DistTimeState.C	/^void DistTimeState<dim>::computeInitialState(InitialConditions &ic,$/;"	f	class:DistTimeState
computeInletNormals	DomainCore.C	/^void Domain::computeInletNormals(DistVec<Vec3D>& inletNodeNorm, DistVec<Vec3D>& faceNorm, DistVec<int>& numFaceNeighb)$/;"	f	class:Domain
computeIntegralTerm	OneDimensionalSourceTerm.h	/^  double computeIntegralTerm(double r1, double r0,double ri, int n,int i) {$/;"	f	class:OneDimensionalSourceTerm
computeInterfaceQuantities	ImplicitRiemann.C	/^void computeInterfaceQuantities(const double outi[], const double outj[], $/;"	f
computeInterfaceQuantities2x2	ImplicitRiemann.C	/^void ImplicitRiemann::computeInterfaceQuantities2x2(double outi[6], double outj[6],$/;"	f	class:ImplicitRiemann
computeInterfaceWork	Face.h	/^  double computeInterfaceWork(ElemSet &elems, PostFcn* postFcn, $/;"	f	class:Face
computeInterfaceWork	Face.h	/^  double computeInterfaceWork(ElemSet &elems, PostFcn* postFcn, $/;"	f	class:FaceDummy
computeInterfaceWork	Face.h	/^  double computeInterfaceWork(ElemSet &elems, PostFcn* postFcn, $/;"	f	class:FaceWrapper_dim
computeInterfaceWork	FaceTria.C	/^double FaceTria::computeInterfaceWork(ElemSet& elems, PostFcn* postFcn, $/;"	f	class:FaceTria
computeInterfaceWork	MeshMotionHandler.C	/^void MeshMotionHandler::computeInterfaceWork(double dt, PostOperator<dim>* postOp, $/;"	f	class:MeshMotionHandler
computeInterfaceWork	PostFcn.C	/^double PostFcnEuler::computeInterfaceWork(double dp1dxj[4][3], Vec3D& n, double ndot, $/;"	f	class:PostFcnEuler
computeInterfaceWork	PostFcn.C	/^double PostFcnNS::computeInterfaceWork(double dp1dxj[4][3], Vec3D& n, double ndot, $/;"	f	class:PostFcnNS
computeInterfaceWork	PostOperator.C	/^double PostOperator<dim>::computeInterfaceWork(DistSVec<double,3>& X, $/;"	f	class:PostOperator
computeInterfaceWork	SubDomain.C	/^double SubDomain::computeInterfaceWork(PostFcn* postFcn, BcData<dim>& bcData,$/;"	f	class:SubDomain
computeInterfaceWork	WallFcnCore.C	/^double WallFcn::computeInterfaceWork(Vec3D& normal, double d2wall[3], double* Vwall, double* V[3])$/;"	f	class:WallFcn
computeInviscidResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeInviscidResidual(DistSVec<double,3> &X, DistVec<double> &ctrlVol, DistSVec<double,dim> &U, DistSVec<double,dim> &R, DistTimeState<dim> *timeState, bool compatF3D)$/;"	f	class:SpaceOperator
computeIsentropicPressure	VarFcn.h	/^  double computeIsentropicPressure(const double entropy, const double density, int tag=0) const{check(tag); return varFcn[tag]->computeIsentropicPressure(entropy,density); }$/;"	f	class:VarFcn
computeIsentropicPressure	VarFcnBase.h	/^  virtual double computeIsentropicPressure(const double entropy, const double density) const{$/;"	f	class:VarFcnBase
computeIsentropicPressure	VarFcnJwl.h	/^  double computeIsentropicPressure(const double entropy, const double density) const{$/;"	f	class:VarFcnJwl
computeIsentropicPressure	VarFcnSGEuler.h	/^  double computeIsentropicPressure(double entropy, double density) const {$/;"	f	class:VarFcnSGEuler
computeIsentropicPressure	VarFcnSGKE.h	/^  double computeIsentropicPressure(double entropy, double density) const {$/;"	f	class:VarFcnSGKE
computeIsentropicPressure	VarFcnSGSA.h	/^  double computeIsentropicPressure(double entropy, double density) const {$/;"	f	class:VarFcnSGSA
computeJacobian	FluxFcn.h	/^  void computeJacobian(double length, double irey, double *normal, double normalVel, double *VL, double *VR, double *jacL, int tag=0, bool useLimiter = true){$/;"	f	class:FluxFcn
computeJacobian	FluxFcnBase.h	/^  virtual void computeJacobian(double, double, double *, double, double *, double *, double *, bool) {}$/;"	f	class:FluxFcnBase
computeJacobian	FluxFcnBase.h	/^void FluxFcnFD<dim>::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnFD
computeJacobian	FluxFcnDescJwl.C	/^void FluxFcnJwlInternalInflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlInternalInflowEuler3D
computeJacobian	FluxFcnDescJwl.C	/^void FluxFcnJwlInternalOutflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlInternalOutflowEuler3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateInflowKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateInflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateInflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateOutflowKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGDirectStateOutflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGDirectStateOutflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGGhidagliaKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGGhidagliaKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGGhidagliaSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGGhidagliaSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalInflowEuler3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowSA3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalInflowSA3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalInflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalInflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowSA3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalOutflowSA3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGInternalOutflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGInternalOutflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowInflowKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowInflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowInflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowOutflowKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGMassFlowOutflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGMassFlowOutflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGOutflowKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGOutflowKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGOutflowSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGOutflowSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGPorousWallKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGPorousWallSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGPorousWallSAturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGWallEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallEuler3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGWallKE3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallKE3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGWallKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallKEturb3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGWallSA3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallSA3D
computeJacobian	FluxFcnDescSG.C	/^void FluxFcnSGWallSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGWallSAturb3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitGhidagliaKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitGhidagliaKEturb3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitGhidagliaSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitGhidagliaSAturb3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitInternalInflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitInternalInflowEuler3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitInternalOutflowEuler3D::computeJacobian(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitInternalOutflowEuler3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitWallKEturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitWallKEturb3D
computeJacobian	FluxFcnDescTait.C	/^void FluxFcnTaitWallSAturb3D::computeJacobian(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitWallSAturb3D
computeJacobian	ImplicitCoupledTsDesc.C	/^void ImplicitCoupledTsDesc<dim>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitCoupledTsDesc
computeJacobian	ImplicitEmbeddedCoupledTsDesc.C	/^void ImplicitEmbeddedCoupledTsDesc<dim>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitEmbeddedCoupledTsDesc
computeJacobian	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::computeJacobian(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &F) {$/;"	f	class:ImplicitEmbeddedRomTsDesc
computeJacobian	ImplicitEmbeddedSegTsDesc.C	/^void ImplicitEmbeddedSegTsDesc<dim,neq1,neq2>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitEmbeddedSegTsDesc
computeJacobian	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitLevelSetTsDesc
computeJacobian	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitMultiPhysicsTsDesc
computeJacobian	ImplicitSegTsDesc.C	/^void ImplicitSegTsDesc<dim,neq1,neq2>::computeJacobian(int it, DistSVec<double,dim> &Q,$/;"	f	class:ImplicitSegTsDesc
computeJacobian	MeshMotionSolver.C	/^void TetMeshMotionSolver::computeJacobian(int it, DistSVec<double,3> &X, $/;"	f	class:TetMeshMotionSolver
computeJacobian	MultiGridOperator.C	/^computeJacobian(DistSVec<Scalar2,dim>& U, DistSVec<Scalar2,dim>& V,$/;"	f	class:MultiGridOperator
computeJacobian	MultiGridSpaceOperator.C	/^computeJacobian(int lvl, MultiGridDistSVec<Scalar,dim>& U,$/;"	f	class:MultiGridSpaceOperator
computeJacobian	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeJacobian(DistExactRiemannSolver<dim>* riemann,$/;"	f	class:MultiPhaseSpaceOperator
computeJacobian	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeJacobian(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MultiPhaseSpaceOperator
computeJacobian	SpaceOperator.C	/^void SpaceOperator<dim>::computeJacobian(DistExactRiemannSolver<dim> *riemann, DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeJacobian	SpaceOperator.C	/^void SpaceOperator<dim>::computeJacobian(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeJacobianEmbedded	MultiGridOperator.C	/^computeJacobianEmbedded(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:MultiGridOperator
computeJacobianEmbedded	MultiGridSpaceOperator.C	/^computeJacobianEmbedded(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:MultiGridSpaceOperator
computeJacobianFarfield	FluxFcn.h	/^  void computeJacobianFarfield(double length, double irey, double *normal, double normalVel, double * VL, double * Ub, double * jac,$/;"	f	class:FluxFcn
computeJacobianFarfield	FluxFcnBase.h	/^  virtual void computeJacobianFarfield(double length, double irey, double *normal, double normalVel, double * VL, double * Ub, double *jac, bool useLimiter = true) {$/;"	f	class:FluxFcnBase
computeJacobianFarfield	FluxFcnDescSG.C	/^void FluxFcnSGModifiedGhidagliaEuler3D::computeJacobianFarfield(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnSGModifiedGhidagliaEuler3D
computeJacobianFarfield	FluxFcnDescTait.C	/^void FluxFcnTaitModifiedGhidagliaEuler3D::computeJacobianFarfield(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitModifiedGhidagliaEuler3D
computeJacobianFiniteVolumeTerm	AgglomeratedFace.C	/^computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn,$/;"	f	class:AgglomeratedFaceSet
computeJacobianFiniteVolumeTerm	AgglomeratedFace.C	/^void AgglomeratedFace::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, $/;"	f	class:AgglomeratedFace
computeJacobianFiniteVolumeTerm	AgglomeratedFace.C	/^void AgglomeratedFaceSet::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn,$/;"	f	class:AgglomeratedFaceSet
computeJacobianFiniteVolumeTerm	Domain.C	/^void Domain::computeJacobianFiniteVolumeTerm(DistExactRiemannSolver<dim> &riemann,$/;"	f	class:Domain
computeJacobianFiniteVolumeTerm	Domain.C	/^void Domain::computeJacobianFiniteVolumeTerm(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:Domain
computeJacobianFiniteVolumeTerm	Domain.C	/^void Domain::computeJacobianFiniteVolumeTerm(DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeJacobianFiniteVolumeTerm	Domain.C	/^void Domain::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeJacobianFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeJacobianFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann,$/;"	f	class:EdgeSet
computeJacobianFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeJacobianFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann,int* locToGlobNodeMap,$/;"	f	class:EdgeSet
computeJacobianFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, GeoState &geoState,$/;"	f	class:EdgeSet
computeJacobianFiniteVolumeTerm	Face.C	/^void Face::computeJacobianFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann, FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeJacobianFiniteVolumeTerm	Face.C	/^void Face::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, Vec<Vec3D> &normals, $/;"	f	class:Face
computeJacobianFiniteVolumeTerm	Face.C	/^void Face::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, Vec<Vec3D> &normals,$/;"	f	class:Face
computeJacobianFiniteVolumeTerm	Face.C	/^void FaceSet::computeJacobianFiniteVolumeTerm(ExactRiemannSolver<dim> &riemann,$/;"	f	class:FaceSet
computeJacobianFiniteVolumeTerm	Face.C	/^void FaceSet::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:FaceSet
computeJacobianFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeJacobianFiniteVolumeTerm(ExactRiemannSolver<dim>& riemann,$/;"	f	class:SubDomain
computeJacobianFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeJacobianFiniteVolumeTerm(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeJacobianFiniteVolumeTermHH	SubDomain.C	/^void SubDomain::computeJacobianFiniteVolumeTermHH(FluxFcn **fluxFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeJacobianFiniteVolumeTermLS	Domain.C	/^void Domain::computeJacobianFiniteVolumeTermLS(RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:Domain
computeJacobianFiniteVolumeTermLS	Edge.C	/^void EdgeSet::computeJacobianFiniteVolumeTermLS(RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:EdgeSet
computeJacobianFiniteVolumeTermLS	Face.C	/^void Face::computeJacobianFiniteVolumeTermLS(Vec<Vec3D> &normals,$/;"	f	class:Face
computeJacobianFiniteVolumeTermLS	Face.C	/^void FaceSet::computeJacobianFiniteVolumeTermLS(GeoState &geoState, SVec<double,dim> &V,$/;"	f	class:FaceSet
computeJacobianFiniteVolumeTermLS	SubDomain.C	/^void SubDomain::computeJacobianFiniteVolumeTermLS(RecFcn* recFcn, RecFcn* recFcnLS,$/;"	f	class:SubDomain
computeJacobianGalerkinTerm	Domain.C	/^void Domain::computeJacobianGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeJacobianGalerkinTerm	Elem.C	/^void ElemSet::computeJacobianGalerkinTerm(FemEquationTerm *fet, GeoState &geoState, $/;"	f	class:ElemSet
computeJacobianGalerkinTerm	Elem.h	/^  void computeJacobianGalerkinTerm(FemEquationTerm *, SVec<double,3> &, $/;"	f	class:ElemDummy
computeJacobianGalerkinTerm	Elem.h	/^  void computeJacobianGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:Elem
computeJacobianGalerkinTerm	Elem.h	/^  void computeJacobianGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemWrapper_Scalar_dim_neq
computeJacobianGalerkinTerm	ElemTet.C	/^void ElemTet::computeJacobianGalerkinTerm(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemTet
computeJacobianGalerkinTerm	Face.C	/^void FaceSet::computeJacobianGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceSet
computeJacobianGalerkinTerm	Face.h	/^  void computeJacobianGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:Face
computeJacobianGalerkinTerm	Face.h	/^  void computeJacobianGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceDummy
computeJacobianGalerkinTerm	Face.h	/^  void computeJacobianGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceWrapper_Scalar_dim_neq
computeJacobianGalerkinTerm	FaceTria.C	/^void FaceTria::computeJacobianGalerkinTerm(ElemSet &elems, FemEquationTerm *fet, $/;"	f	class:FaceTria
computeJacobianGalerkinTerm	SubDomain.C	/^void SubDomain::computeJacobianGalerkinTerm(FemEquationTerm *fet, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeJacobianGalerkinTerm_e	Elem.h	/^  void computeJacobianGalerkinTerm_e(FemEquationTerm *, SVec<double,3> &, $/;"	f	class:ElemDummy
computeJacobianGalerkinTerm_e	Elem.h	/^  void computeJacobianGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:Elem
computeJacobianGalerkinTerm_e	Elem.h	/^  void computeJacobianGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemWrapper_Scalar_dim_neq
computeJacobianGalerkinTerm_e	ElemTet.C	/^void ElemTet::computeJacobianGalerkinTerm_e(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemTet
computeJacobianLS	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::computeJacobianLS(int it,$/;"	f	class:ImplicitLevelSetTsDesc
computeJacobianLS	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::computeJacobianLS(int it,$/;"	f	class:ImplicitMultiPhysicsTsDesc
computeJacobianLS	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeJacobianLS(DistSVec<double,3> &X,DistSVec<double,dim> &V, DistVec<double> &ctrlVol,$/;"	f	class:MultiPhaseSpaceOperator
computeJacobianRight	FluxFcnBase.h	/^  virtual void computeJacobianRight(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnBase
computeJacobianRight	FluxFcnBase.h	/^void FluxFcnFD<dim>::computeJacobianRight(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnFD
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeJacobianSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermDES
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermDES
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDESmean::computeJacobianSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermDESmean
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDESmean::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermDESmean
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermKE::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermKE
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermKEmean::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermKEmean
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeJacobianSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermNS
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermNS
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeJacobianSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermSA
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermSA
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSAmean::computeJacobianSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermSAmean
computeJacobianSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSAmean::computeJacobianSurfaceTerm(int code, Vec3D &n, $/;"	f	class:FemEquationTermSAmean
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermDESturb
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKE
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKEmean
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKEturb
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermSAturb
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermDESturb
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermKEturb
computeJacobianSurfaceTerm	FemEquationTermDesc.h	/^  void computeJacobianSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermSAturb
computeJacobianSurfaceTerm	WallFcn.C	/^void WallFcn::computeJacobianSurfaceTerm(int code, Vec3D &normal, double d2wall[3],$/;"	f	class:WallFcn
computeJacobianSurfaceTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeJacobianSurfaceTermNS(double dp1dxj[4][3], Vec3D &n, $/;"	f	class:NavierStokesTerm
computeJacobianThinLayerViscousFiniteVolumeTerm	AgglomeratedFace.C	/^computeJacobianThinLayerViscousFiniteVolumeTerm(class FemEquationTerm* fet,$/;"	f	class:AgglomeratedFace
computeJacobianThinLayerViscousFiniteVolumeTerm	AgglomeratedFace.C	/^computeJacobianThinLayerViscousFiniteVolumeTerm(class FemEquationTerm* fet,$/;"	f	class:AgglomeratedFaceSet
computeJacobianThinLayerViscousFiniteVolumeTerm	Edge.C	/^int EdgeSet::computeJacobianThinLayerViscousFiniteVolumeTerm(int* locToGlobNodeMap,$/;"	f	class:EdgeSet
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermDES::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermDES
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermDESmean::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermDESmean
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermDESturb::computeJacobianVolumeTerm(double dp1dxj[4][3], $/;"	f	class:FemEquationTermDESturb
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermKE::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermKE
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermKEmean::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermKEmean
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermKEturb::computeJacobianVolumeTerm(double dp1dxj[4][3], $/;"	f	class:FemEquationTermKEturb
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermNS::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermNS
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermSA::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermSA
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermSAmean::computeJacobianVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermSAmean
computeJacobianVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermSAturb::computeJacobianVolumeTerm(double dp1dxj[4][3], $/;"	f	class:FemEquationTermSAturb
computeJacobianVolumeTerm	VolumicForceTerm.h	/^  void computeJacobianVolumeTerm(int dim, double ctrlVol, $/;"	f	class:VolumicForceTerm
computeJacobianVolumeTermDES	DESTerm.h	/^void DESTerm::computeJacobianVolumeTermDES(double dp1dxj[4][3], double d2w[4], $/;"	f	class:DESTerm
computeJacobianVolumeTermKE	KEpsilonTerm.h	/^void KEpsilonTerm::computeJacobianVolumeTermKE(double dp1dxj[4][3], double mul,$/;"	f	class:KEpsilonTerm
computeJacobianVolumeTermNS	NavierStokesTerm.h	/^computeJacobianVolumeTermNS(double dp1dxj[4][3], double mu, double dmu[4][5], double lambda, double dlambda[4][5], double kappa, double dkappa[4][5], $/;"	f	class:NavierStokesTerm
computeJacobianVolumeTermNS	NavierStokesTerm.h	/^computeJacobianVolumeTermNS(double dp1dxj[4][3], double mu, double dmu[4][6], double lambda, double dlambda[4][6], double kappa, double dkappa[4][6], $/;"	f	class:NavierStokesTerm
computeJacobianVolumeTermNS	NavierStokesTerm.h	/^computeJacobianVolumeTermNS(double dp1dxj[4][3], double mu, double lambda, double kappa, $/;"	f	class:NavierStokesTerm
computeJacobianVolumeTermPorousCore	FemEquationTerm.h	/^  bool computeJacobianVolumeTermPorousCore(double tetVol,$/;"	f	class:FemEquationTerm
computeJacobianVolumeTermSA	SpalartAllmarasTerm.h	/^void SATerm::computeJacobianVolumeTermSA(double dp1dxj[4][3], double d2w[4], $/;"	f	class:SATerm
computeJacobianVolumicForceTerm	Domain.C	/^void Domain::computeJacobianVolumicForceTerm(VolumicForceTerm *volForce,$/;"	f	class:Domain
computeJacobianVolumicForceTerm	SubDomain.C	/^void SubDomain::computeJacobianVolumicForceTerm(VolumicForceTerm *volForce,$/;"	f	class:SubDomain
computeJacobians	FluxFcn.h	/^  void computeJacobians(double length, double irey, double *normal, double normalVel, double *VL, double *VR, double *jacL, double *jacR, int tag=0, bool useLimiter = true){$/;"	f	class:FluxFcn
computeJacobians	FluxFcnBase.h	/^  virtual void computeJacobians(double, double, double *, double, double *, double *, double *, double *, bool) {}$/;"	f	class:FluxFcnBase
computeJacobians	FluxFcnBase.h	/^void FluxFcnFD<dim>::computeJacobians(double length, double irey, double *normal, double normalVel, double *VL,$/;"	f	class:FluxFcnFD
computeJacobians	FluxFcnDescJwl.C	/^void FluxFcnJwlApprJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlApprJacRoeEuler3D
computeJacobians	FluxFcnDescJwl.C	/^void FluxFcnJwlExactJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnJwlExactJacRoeEuler3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCEuler3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCKE3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCKE3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLCSA3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLCSA3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLEEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLEEuler3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLEKE3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLEKE3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacHLLESA3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacHLLESA3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeKE3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeKE3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGApprJacRoeSA3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGApprJacRoeSA3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeKE3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeKE3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeSA3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGExactJacRoeSA3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGRoeKEturb3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGRoeKEturb3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGRoeSAturb3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGRoeSAturb3D
computeJacobians	FluxFcnDescSG.C	/^void FluxFcnSGVanLeerEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnSGVanLeerEuler3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitApprJacRoeEuler3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeKE3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitApprJacRoeKE3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitApprJacRoeSA3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitApprJacRoeSA3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitExactJacRoeEuler3D::computeJacobians(double length, double irey, double *normal, double normalVel, $/;"	f	class:FluxFcnTaitExactJacRoeEuler3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitRoeKEturb3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitRoeKEturb3D
computeJacobians	FluxFcnDescTait.C	/^void FluxFcnTaitRoeSAturb3D::computeJacobians(double length, double irey, double *normal, double normalVel,$/;"	f	class:FluxFcnTaitRoeSAturb3D
computeJwlDerivRarefaction	ImplicitRiemann.C	/^void ImplicitRiemann::computeJwlDerivRarefaction(VarFcn* vf_, int fluidId,double omega,$/;"	f	class:ImplicitRiemann
computeJwlDerivShock	ImplicitRiemann.C	/^void ImplicitRiemann::computeJwlDerivShock(double omega,$/;"	f	class:ImplicitRiemann
computeJwlIntegral2	ImplicitRiemann.C	/^double ImplicitRiemann::computeJwlIntegral2(VarFcn* vf_, int fluidId, double omega,$/;"	f	class:ImplicitRiemann
computeJwlIntegralKernel2	ImplicitRiemann.C	/^  double computeJwlIntegralKernel2(double rho, const JwlInfo& J) {$/;"	f	struct:JwlKernel2
computeJwlJwlJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeJwlJwlJacobian(VarFcn* vf, int fluidi, int fluidj,$/;"	f	class:ImplicitRiemann
computeL1Error	Domain.C	/^void Domain::computeL1Error(DistSVec<double,dim>& U, DistSVec<double,dim>& Uexact, $/;"	f	class:Domain
computeL1Error	SubDomain.C	/^void SubDomain::computeL1Error(bool* nodeFlag,SVec<double,dim>& U, SVec<double,dim>& Uexact, Vec<double>& vol,double error[dim], LevelSetStructure* LSS) {$/;"	f	class:SubDomain
computeL2Error	Domain.C	/^void Domain::computeL2Error(DistSVec<double,dim>& U, DistSVec<double,dim>& Uexact, $/;"	f	class:Domain
computeL2Error	SubDomain.C	/^void SubDomain::computeL2Error(bool* nodeFlag,SVec<double,dim>& U, SVec<double,dim>& Uexact, Vec<double>& vol,double error[dim], LevelSetStructure* LSS) {$/;"	f	class:SubDomain
computeLInfError	Domain.C	/^void Domain::computeLInfError(DistSVec<double,dim>& U, DistSVec<double,dim>& Uexact, double error[dim],DistLevelSetStructure* distLSS) {$/;"	f	class:Domain
computeLInfError	SubDomain.C	/^void SubDomain::computeLInfError(bool* nodeFlag,SVec<double,dim>& U, SVec<double,dim>& Uexact, double error[dim], LevelSetStructure* LSS) {$/;"	f	class:SubDomain
computeLU	BlockTridiagonalMatrix.C	/^computeLU(const BlockTridiagonalMatrix& B) {$/;"	f	class:BlockTridiagonalMatrix
computeLU	BlockTridiagonalMatrix.C	/^void BlockTridiagonalMatrix<Scalar,dim>::computeLU() {$/;"	f	class:BlockTridiagonalMatrix
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermDES::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermDES
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermDESmean::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermDESmean
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermKE::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermKE
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermKEmean::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermKEmean
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermSA::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermSA
computeLaminarTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermSAmean::computeLaminarTransportCoefficients($/;"	f	class:FemEquationTermSAmean
computeLevelSetFluxes	OneDimensionalSolver.C	/^void OneDimensional::computeLevelSetFluxes(SVec<double,1>& y){$/;"	f	class:OneDimensional
computeLi	SubDomainCore.C	/^void SubDomain::computeLi(double Li[3], double r_e, double r_e_plus_p, double r_u[3], double vc[5])$/;"	f	class:SubDomain
computeLij	SubDomainCore.C	/^void SubDomain::computeLij(double Lij[3][3], double r_u[3], double r_u_u[6], double vc[5])$/;"	f	class:SubDomain
computeLimiter	RecFcnDesc.h	/^void RecFcnBarth<5>::computeLimiter(double *Vimax, double *Vimin, double *Vi, $/;"	f	class:RecFcnBarth
computeLimiter	RecFcnDesc.h	/^void RecFcnBarth<dim>::computeLimiter(double *Vimax, double *Vimin, double *Vi, $/;"	f	class:RecFcnBarth
computeLimiter	RecFcnDesc.h	/^void RecFcnVenkat<5>::computeLimiter(double *Vimax, double *Vimin, double *Vi, $/;"	f	class:RecFcnVenkat
computeLimiter	RecFcnDesc.h	/^void RecFcnVenkat<dim>::computeLimiter(double *Vimax, double *Vimin, double *Vi, $/;"	f	class:RecFcnVenkat
computeLocalAvg	SubDomainCore.C	/^void SubDomain::computeLocalAvg(SVec<double,3> &X, SVec<double,2> &Q, SVec<double,2> &W)$/;"	f	class:SubDomain
computeLocalAvg	SubDomainCore.C	/^void SubDomain::computeLocalAvg(SVec<double,3> &X, Vec<double> &Q, Vec<double> &W)$/;"	f	class:SubDomain
computeLocalWeightsLeastSquares	SubDomain.C	/^void computeLocalWeightsLeastSquares(double dx[3], double *R, double *W)$/;"	f
computeLocalWeightsLeastSquaresForEmbeddedStruct	SubDomain.C	/^void computeLocalWeightsLeastSquaresForEmbeddedStruct(double dx[3], double *R, double *W)$/;"	f
computeLongestEdge	ElemCore.C	/^double Elem::computeLongestEdge(SVec<double,3> &X)$/;"	f	class:Elem
computeMBarAndM	Elem.C	/^void ElemSet::computeMBarAndM(DynamicVMSTerm *dvmst,$/;"	f	class:ElemSet
computeMBarAndM	Elem.h	/^  void computeMBarAndM(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:Elem
computeMBarAndM	Elem.h	/^  void computeMBarAndM(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:ElemDummy
computeMBarAndM	Elem.h	/^  void computeMBarAndM(DynamicVMSTerm *dvmst, SVec<double,dim> **VBar,$/;"	f	class:ElemWrapper_dim
computeMBarAndM	ElemTet.C	/^void ElemTet::computeMBarAndM(DynamicVMSTerm *dvmst,$/;"	f	class:ElemTet
computeMBarAndM_Step1	SubDomain.C	/^void SubDomain::computeMBarAndM_Step1(DynamicVMSTerm *dvmst,$/;"	f	class:SubDomain
computeMBarAndM_Step2	SubDomain.C	/^void SubDomain::computeMBarAndM_Step2(MacroCellSet **macroCells,$/;"	f	class:SubDomain
computeMDS	IoData.h	/^  enum ComputeMDS {COMPUTE_MDS_FALSE = 0, COMPUTE_MDS_TRUE = 1} computeMDS;$/;"	m	struct:ClusteringData	typeref:enum:ClusteringData::ComputeMDS
computeMachNumber	VarFcn.h	/^  double computeMachNumber(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->computeMachNumber(V); }$/;"	f	class:VarFcn
computeMachNumber	VarFcnBase.h	/^  virtual double computeMachNumber(double *V)  const{ return getVelocityNorm(V)\/computeSoundSpeed(V); }$/;"	f	class:VarFcnBase
computeMaskedSnapshots	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeMaskedSnapshots(const char* type, int iCluster) {$/;"	f	class:GappyPreprocessing
computeMatVecProd	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::computeMatVecProd(DistMat<Scalar2,dim>& mat,$/;"	f	class:MultiGridLevel
computeMatVecProdH1	SubDomain.C	/^ void SubDomain::computeMatVecProdH1(bool *nodeFlag, GenMat<Scalar,dim> &A,$/;"	f	class:SubDomain
computeMatVecProdH1FarFieldHH	Face.C	/^void  FaceSet::computeMatVecProdH1FarFieldHH(GenMat<Scalar,dim> &A, SVec<double,dim> &p_u,$/;"	f	class:FaceSet
computeMatVecProdH1FarFieldHH	Face.C	/^void Face::computeMatVecProdH1FarFieldHH(int faceid,GenMat<Scalar,dim> &A, SVec<double,dim> &p_u,$/;"	f	class:Face
computeMatVecProdH1FarFieldHH	SubDomain.C	/^ computeMatVecProdH1FarFieldHH(bool *nodeFlag, GenMat<Scalar,dim> &A, SVec<double,dim> &p_u,$/;"	f	class:SubDomain
computeMatVecProdH1transpose	SubDomain.C	/^void SubDomain::computeMatVecProdH1transpose(bool *nodeFlag, GenMat<Scalar,dim> &A,$/;"	f	class:SubDomain
computeMatVecProdH2	Domain.C	/^void Domain::computeMatVecProdH2(FluxFcn **fluxFcn, RecFcn *recFcn, DistGeoState &geoState,$/;"	f	class:Domain
computeMatVecProdH2	Domain.C	/^void Domain::computeMatVecProdH2(RecFcn *recFcn, DistSVec<double,3> &X,$/;"	f	class:Domain
computeMatVecProdH2	SubDomain.C	/^ void SubDomain::computeMatVecProdH2(FluxFcn **fluxFcn, RecFcn *recFcn, GeoState &geoState,$/;"	f	class:SubDomain
computeMatVecProdH2	SubDomain.C	/^ void SubDomain::computeMatVecProdH2(RecFcn *recFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMatVecProdH2T	Domain.C	/^void Domain::computeMatVecProdH2T(RecFcn *recFcn, DistSVec<double,3> &X,$/;"	f	class:Domain
computeMatVecProdH2T	SubDomain.C	/^void SubDomain::computeMatVecProdH2T(RecFcn *recFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMatVecProdH2Tb	Domain.C	/^void Domain::computeMatVecProdH2Tb(RecFcn *recFcn, DistSVec<double,3> &X,$/;"	f	class:Domain
computeMatVecProdH2Tb	SubDomain.C	/^void SubDomain::computeMatVecProdH2Tb(RecFcn *recFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMatVecProdH2transposeNew	Domain.C	/^void Domain::computeMatVecProdH2transposeNew(IoData& iod, DistSVec<double,3> &X,$/;"	f	class:Domain
computeMatVecProdH2transposeNew	SubDomain.C	/^void SubDomain::computeMatVecProdH2transposeNew(IoData& iod, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMaterialMassEnergy	Domain.C	/^void Domain::computeMaterialMassEnergy(double *Mass, double *Energy, int size, DistSVec<double,dim> &U, DistVec<double> &A, DistVec<int> *fluidId)$/;"	f	class:Domain
computeMaterialVolumes	DomainCore.C	/^void Domain::computeMaterialVolumes(double *Vol, int size, DistVec<double> &A, DistVec<int> *fluidId)$/;"	f	class:Domain
computeMaxTimeStep	OneDimensionalSolver.C	/^double OneDimensional::computeMaxTimeStep(){$/;"	f	class:OneDimensional
computeMeanDXForSlidingPlane	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeMeanDXForSlidingPlane(DistSVec<double,3> &dX, double meandX[3])$/;"	f	class:EmbeddedCorotSolver
computeMeshMetrics	TsDesc.C	/^void TsDesc<dim>::computeMeshMetrics(int it)$/;"	f	class:TsDesc
computeMinMaxStencilValues	SubDomain.C	/^void SubDomain::computeMinMaxStencilValues(SVec<double,dim> &V, SVec<double,dim> &Vmin,$/;"	f	class:SubDomain
computeModalDisp	Modal.C	/^void ModalSolver<dim>::computeModalDisp(double sdt, DistSVec<double, 3> &xPos, DistSVec<double, dim> &delW, double *delU, double *delY, Vec<double> &refModalF, int timeIt) {$/;"	f	class:ModalSolver
computeModalDisp	Modal.C	/^void ModalSolver<dim>::computeModalDisp(double sdt, Vec<double> &delWRom, double *delU, double *delY, Vec<double> &refModalF, VecSet<Vec<double> > &PtimesPhi, int nPodVecs, int timeIt) {$/;"	f	class:ModalSolver
computeMultiDimLimiter	Domain.C	/^void Domain::computeMultiDimLimiter(DistSVec<double,3> &X,$/;"	f	class:Domain
computeMultiDimLimiter	Domain.C	/^void Domain::computeMultiDimLimiter(RecFcnLtdMultiDim<dim> *recFcn, DistSVec<double,3> &X,$/;"	f	class:Domain
computeMultiDimLimiter	Domain.h	/^  void computeMultiDimLimiter(RecFcnLtdMultiDim<dim> *, DistSVec<double,3> &,$/;"	f	class:Domain
computeMultiDimLimiter	SubDomain.C	/^void SubDomain::computeMultiDimLimiter(RecLimiter *recFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMutOMu	DistDynamicLESTerm.C	/^void DistDynamicLESTerm<dim>::computeMutOMu(DistVec<double> &ctrlVol, $/;"	f	class:DistDynamicLESTerm
computeMutOMu	DistDynamicVMSTerm.C	/^void DistDynamicVMSTerm<dim>::computeMutOMu(DistVec<double> &ctrlVol,$/;"	f	class:DistDynamicVMSTerm
computeMutOMu	DistVMSLESTerm.C	/^void DistVMSLESTerm<dim>::computeMutOMu(DistVec<double> &ctrlVol,$/;"	f	class:DistVMSLESTerm
computeMutOMu	DynamicLESTerm.C	/^double DynamicLESTerm::computeMutOMu(double tetVol, double dp1dxj[4][3], double *V[4], $/;"	f	class:DynamicLESTerm
computeMutOMu	DynamicVMSTerm.C	/^double DynamicVMSTerm::computeMutOMu(double tetVol, double dp1dxj[4][3], double *VBar[4],$/;"	f	class:DynamicVMSTerm
computeMutOMu	SmagorinskyLESTerm.C	/^double SmagorinskyLESTerm::computeMutOMu(double tetVol, double dp1dxj[4][3],$/;"	f	class:SmagorinskyLESTerm
computeMutOMu	VMSLESTerm.C	/^double VMSLESTerm::computeMutOMu(double tetVol, $/;"	f	class:VMSLESTerm
computeMutOMu	WaleLESTerm.C	/^double WaleLESTerm::computeMutOMu(double tetVol, double dp1dxj[4][3],$/;"	f	class:WaleLESTerm
computeMutOMuDynamicLES	Domain.C	/^void Domain::computeMutOMuDynamicLES(DynamicLESTerm *dles, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeMutOMuDynamicLES	SubDomain.C	/^void SubDomain::computeMutOMuDynamicLES(DynamicLESTerm *dles, SVec<double,2> &Cs,$/;"	f	class:SubDomain
computeMutOMuDynamicVMS	Domain.C	/^void Domain::computeMutOMuDynamicVMS(DynamicVMSTerm *dvms, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeMutOMuDynamicVMS	SubDomain.C	/^void SubDomain::computeMutOMuDynamicVMS(DynamicVMSTerm *dvmst, SVec<double,dim> &VBar, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMutOMuSmag	Domain.C	/^void Domain::computeMutOMuSmag(SmagorinskyLESTerm *smag, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeMutOMuSmag	SubDomain.C	/^void SubDomain::computeMutOMuSmag(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMutOMuVMS	Domain.C	/^void Domain::computeMutOMuVMS(VMSLESTerm *vms, DistMacroCellSet *macroCells, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeMutOMuVMS	SubDomain.C	/^void SubDomain::computeMutOMuVMS(VMSLESTerm *vmst, SVec<double,dim> &VBar, SVec<double,3> &X,$/;"	f	class:SubDomain
computeMutOMuWale	Domain.C	/^void Domain::computeMutOMuWale(WaleLESTerm *wale, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeMutOMuWale	SubDomain.C	/^void SubDomain::computeMutOMuWale(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:SubDomain
computeNearestNode	ProgrammedBurnCore.C	/^void ProgrammedBurn::computeNearestNode(const double x0n[3], double x0[3], int& x0subdom, int& x0id) {$/;"	f	class:ProgrammedBurn
computeNodalForce	Face.h	/^  void computeNodalForce(ElemSet &elems,$/;"	f	class:Face
computeNodalForce	Face.h	/^  void computeNodalForce(ElemSet &elems,$/;"	f	class:FaceDummy
computeNodalForce	Face.h	/^  void computeNodalForce(ElemSet &elems,$/;"	f	class:FaceWrapper_dim
computeNodalForce	FaceTria.C	/^void FaceTria::computeNodalForce(ElemSet &elems,$/;"	f	class:FaceTria
computeNodalForce	PostOperator.C	/^void PostOperator<dim>::computeNodalForce(DistSVec<double,3> &X, DistSVec<double,dim> &U, $/;"	f	class:PostOperator
computeNodalForce	SubDomain.C	/^void SubDomain::computeNodalForce(PostFcn *postFcn, BcData<dim> &bcData,$/;"	f	class:SubDomain
computeNodalGrad	SpaceOperator.C	/^void SpaceOperator<dim>::computeNodalGrad(DistSVec<double,3> &X, DistVec<double> &ctrlVol, $/;"	f	class:SpaceOperator
computeNodalHeatFluxRelatedValues	Face.h	/^  void computeNodalHeatFluxRelatedValues(ElemSet &elems, PostFcn* postFcn, SVec<double,3>& X, $/;"	f	class:FaceWrapper_dim
computeNodalHeatFluxRelatedValues	Face.h	/^  void computeNodalHeatFluxRelatedValues(ElemSet &elems, PostFcn* postFcn, SVec<double,3>& X,$/;"	f	class:Face
computeNodalHeatFluxRelatedValues	Face.h	/^  void computeNodalHeatFluxRelatedValues(ElemSet &elems, PostFcn* postFcn, SVec<double,3>& X,$/;"	f	class:FaceDummy
computeNodalHeatFluxRelatedValues	FaceTria.C	/^void FaceTria::computeNodalHeatFluxRelatedValues(ElemSet& elems,$/;"	f	class:FaceTria
computeNodalHeatFluxRelatedValues	PostOperator.C	/^void PostOperator<dim>::computeNodalHeatFluxRelatedValues(DistSVec<double,3>& X, DistSVec<double,dim>& U,$/;"	f	class:PostOperator
computeNodalHeatFluxRelatedValues	SubDomain.C	/^void SubDomain::computeNodalHeatFluxRelatedValues(PostFcn* postFcn, BcData<dim>& bcData,$/;"	f	class:SubDomain
computeNodalHeatFluxes	Face.h	/^  double computeNodalHeatFluxes(ElemSet &elems,$/;"	f	class:FaceDummy
computeNodalHeatPower	Face.h	/^  void computeNodalHeatPower(ElemSet &elems,$/;"	f	class:Face
computeNodalHeatPower	Face.h	/^  void computeNodalHeatPower(ElemSet &elems,$/;"	f	class:FaceDummy
computeNodalHeatPower	Face.h	/^  void computeNodalHeatPower(ElemSet &elems,$/;"	f	class:FaceWrapper_dim
computeNodalHeatPower	FaceTria.C	/^void FaceTria::computeNodalHeatPower(ElemSet& elems,$/;"	f	class:FaceTria
computeNodalHeatPower	PostOperator.C	/^void PostOperator<dim>::computeNodalHeatPower(DistSVec<double,3>& X, DistSVec<double,dim>& U, $/;"	f	class:PostOperator
computeNodalHeatPower	SubDomain.C	/^void SubDomain::computeNodalHeatPower(PostFcn* postFcn, BcData<dim>& bcData,$/;"	f	class:SubDomain
computeNodeBCsWallValues	Face.C	/^void Face::computeNodeBCsWallValues(SVec<double,3> &X, SVec<double,1> &dNormSA, double *dUfaceSA, SVec<double,dim> &dUnodeSA)$/;"	f	class:Face
computeNodeBCsWallValues	SubDomain.C	/^void SubDomain::computeNodeBCsWallValues(SVec<double,3> &X, SVec<double,1> &dNormSA, SVec<double,dim> &dUfaceSA, SVec<double,dim> &dUnodeSA)$/;"	f	class:SubDomain
computeNodeBcValue	Face.C	/^void Face::computeNodeBcValue(SVec<double,3> &X, double *Uface, SVec<double,dim2> &Unode)$/;"	f	class:Face
computeNodeBcValue	SubDomain.C	/^void SubDomain::computeNodeBcValue(SVec<double,3> &X, SVec<double,dim1> &Uface,$/;"	f	class:SubDomain
computeNodeError	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeNodeError(bool *locMasterFlag, int locNodeNum, double &nodeError) {$/;"	f	class:GappyPreprocessing
computeNodeNormalClasses	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::computeNodeNormalClasses() {$/;"	f	class:MultiGridLevel
computeNodeRot	CorotSolver.C	/^void CorotSolver::computeNodeRot(double dRot[3][3], DistSVec<double,3> &X, $/;"	f	class:CorotSolver
computeNodeRot	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeNodeRot(double RR[3][3], DistSVec<double,3> &X, $/;"	f	class:EmbeddedCorotSolver
computeNodeScalarQuantity	PostFcn.C	/^double PostFcn::computeNodeScalarQuantity(ScalarType type, double *V, double *X, int fluidId,double* phi)$/;"	f	class:PostFcn
computeNodeScalarQuantity	PostFcn.C	/^double PostFcnDES::computeNodeScalarQuantity(ScalarType type, double *V, double *X,int fluidId,double* phi)$/;"	f	class:PostFcnDES
computeNodeScalarQuantity	PostFcn.C	/^double PostFcnEuler::computeNodeScalarQuantity(ScalarType type, double *V, double *X, int fluidId,double* phi)$/;"	f	class:PostFcnEuler
computeNodeScalarQuantity	PostFcn.C	/^double PostFcnKE::computeNodeScalarQuantity(ScalarType type, double *V, double *X, int fluidId,double* phi)$/;"	f	class:PostFcnKE
computeNodeScalarQuantity	PostFcn.C	/^double PostFcnSA::computeNodeScalarQuantity(ScalarType type, double *V, double *X,  int fluidId,double* phi)$/;"	f	class:PostFcnSA
computeNodeScalarQuantity	SubDomain.C	/^inline double SubDomain::computeNodeScalarQuantity(PostFcn::ScalarType type, PostFcn *postFcn,$/;"	f	class:SubDomain
computeNodeScalarQuantity	SubDomain.C	/^inline void SubDomain::computeNodeScalarQuantity(PostFcn::ScalarType type, PostFcn *postFcn,$/;"	f	class:SubDomain
computeNodeScalarQuantity	SubDomain.C	/^void SubDomain::computeNodeScalarQuantity(PostFcn::ScalarType type, PostFcn *postFcn,$/;"	f	class:SubDomain
computeNodeValue	DistBcData.C	/^void DistBcDataKE<dim>::computeNodeValue(DistSVec<double,3> &X)$/;"	f	class:DistBcDataKE
computeNodeValue	DistBcData.C	/^void DistBcDataSA<dim>::computeNodeValue(DistSVec<double,3> &X)$/;"	f	class:DistBcDataSA
computeNodeValue	DistBcData.h	/^  virtual void computeNodeValue(DistSVec<double,3> &) {}$/;"	f	class:DistBcData
computeNodeWallValues	DistBcData.C	/^void DistBcDataSA<dim>::computeNodeWallValues(DistSVec<double,3> &X)$/;"	f	class:DistBcDataSA
computeNodeWallValues	DistBcData.h	/^  virtual void computeNodeWallValues(DistSVec<double,3> &) {}$/;"	f	class:DistBcData
computeNodeWallValues	DistBcData.h	/^  void computeNodeWallValues(DistSVec<double,3> &x) {}$/;"	f	class:DistBcDataKE
computeNonlinearEigenResidual	Modal.C	/^void ModalSolver<dim>::computeNonlinearEigenResidual(double sReal, double sImag, $/;"	f	class:ModalSolver
computeNonlinearEigenResidualNormalized	Modal.C	/^void ModalSolver<dim>::computeNonlinearEigenResidualNormalized(double sReal, double sImag, $/;"	f	class:ModalSolver
computeNormDerivWallFcn	FemEquationTermDesc.C	/^double FemEquationTermDES::computeNormDerivWallFcn(double rho, double T, double Du1, $/;"	f	class:FemEquationTermDES
computeNormDerivWallFcn	FemEquationTermDesc.C	/^double FemEquationTermKE::computeNormDerivWallFcn(double rho, double T, double Du1, $/;"	f	class:FemEquationTermKE
computeNormDerivWallFcn	FemEquationTermDesc.C	/^double FemEquationTermNS::computeNormDerivWallFcn(double rho, double T, double Du1, $/;"	f	class:FemEquationTermNS
computeNormDerivWallFcn	FemEquationTermDesc.C	/^double FemEquationTermSA::computeNormDerivWallFcn(double rho, double T, double Du1, $/;"	f	class:FemEquationTermSA
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermDESmean
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermDESturb
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermKEmean
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermKEturb
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermSAmean
computeNormDerivWallFcn	FemEquationTermDesc.h	/^  double computeNormDerivWallFcn(double rho, double T, double Du1, double DT1,$/;"	f	class:FemEquationTermSAturb
computeNormal	FaceTriaCore.C	/^void FaceTria::computeNormal(SVec<double,3> &X, Vec3D &faceNorm)$/;"	f	class:FaceTria
computeNormal	FaceTriaCore.C	/^void FaceTria::computeNormal(SVec<double,3> &X, Vec<Vec3D> &faceNorm)$/;"	f	class:FaceTria
computeNormalAndDerivative	FaceTriaCore.C	/^void FaceTria::computeNormalAndDerivative(SVec<double,3> &X, SVec<double,3> &dX, Vec3D &faceNorm, Vec3D &dFaceNorm)$/;"	f	class:FaceTria
computeNormalConfig	FaceTriaCore.C	/^void FaceTria::computeNormalConfig(SVec<double,3> &Xconfig, SVec<double,3> &Xdot,$/;"	f	class:FaceTria
computeNormalEZGCL1	FaceTriaCore.C	/^void FaceTria::computeNormalEZGCL1(double oodt, SVec<double,3> &Xn, SVec<double,3> &Xnp1, $/;"	f	class:FaceTria
computeNormalGCL1	FaceTriaCore.C	/^void FaceTria::computeNormalGCL1(SVec<double,3> &Xn, SVec<double,3> &Xnp1, $/;"	f	class:FaceTria
computeNormalsConfig	DomainCore.C	/^void Domain::computeNormalsConfig(DistSVec<double,3> &Xconfig, DistSVec<double,3> &Xdot,$/;"	f	class:Domain
computeNormalsConfig	SubDomainCore.C	/^void SubDomain::computeNormalsConfig(SVec<double,3> &Xconfig, SVec<double,3> &Xdot,$/;"	f	class:SubDomain
computeNormalsEZGCL1	DomainCore.C	/^void Domain::computeNormalsEZGCL1(double oodt, DistSVec<double,3>& Xn, DistSVec<double,3>& Xnp1,$/;"	f	class:Domain
computeNormalsEZGCL1	SubDomainCore.C	/^void SubDomain::computeNormalsEZGCL1(double oodt, SVec<double,3>& Xn, SVec<double,3>& Xnp1,$/;"	f	class:SubDomain
computeNormalsEZGCL2	DomainCore.C	/^void Domain::computeNormalsEZGCL2(TimeData& data, DistVec<double>& edgeNormVel,$/;"	f	class:Domain
computeNormalsEZGCL3	DomainCore.C	/^void Domain::computeNormalsEZGCL3(TimeData& data, DistVec<double>& edgeNormVel,$/;"	f	class:Domain
computeNormalsGCL1	DomainCore.C	/^void Domain::computeNormalsGCL1(DistSVec<double,3> &Xn, DistSVec<double,3> &Xnp1,$/;"	f	class:Domain
computeNormalsGCL1	SubDomainCore.C	/^void SubDomain::computeNormalsGCL1(SVec<double,3> &Xn, SVec<double,3> &Xnp1,$/;"	f	class:SubDomain
computeNormalsGCL2	DomainCore.C	/^void Domain::computeNormalsGCL2(TimeData &data, DistVec<Vec3D> &edgeNorm,$/;"	f	class:Domain
computeNumGlobNode	DomainCore.C	/^void Domain::computeNumGlobNode() {$/;"	f	class:Domain
computeNumberOfDigits	BinFileHandler.h	/^int computeNumberOfDigits(int num)$/;"	f
computeOIBEI	Modal.C	/^void ModalSolver<dim>::computeOIBEI(double sReal, double sImag, int iEV)$/;"	f	class:ModalSolver
computeOffWallNode	DomainCore.C	/^void Domain::computeOffWallNode(DistLevelSetStructure *distLSS)$/;"	f	class:Domain
computeOffWallNode	SubDomainCore.C	/^void SubDomain::computeOffWallNode(LevelSetStructure *LSS, CommPattern<int> &ntP)$/;"	f	class:SubDomain
computeOnlyGalerkinTerm	Domain.C	/^void Domain::computeOnlyGalerkinTerm(FemEquationTerm *fet, DistBcData<dim> &bcData,$/;"	f	class:Domain
computeP1Avg	Elem.h	/^  void computeP1Avg(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:Elem
computeP1Avg	Elem.h	/^  void computeP1Avg(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemDummy
computeP1Avg	Elem.h	/^  void computeP1Avg(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemWrapper_dim
computeP1Avg	ElemTet.C	/^void ElemTet::computeP1Avg(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemTet
computeP1Avg_e	Elem.h	/^  void computeP1Avg_e(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:Elem
computeP1Avg_e	Elem.h	/^  void computeP1Avg_e(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemDummy
computeP1Avg_e	Elem.h	/^  void computeP1Avg_e(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemWrapper_dim
computeP1Avg_e	ElemTet.C	/^void ElemTet::computeP1Avg_e(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test, SVec<double,6> &Sij_Test, $/;"	f	class:ElemTet
computePGResidualNorm	ImplicitPGTsDesc.C	/^double ImplicitPGTsDesc<dim>::computePGResidualNorm(DistSVec<double,dim>& Q)$/;"	f	class:ImplicitPGTsDesc
computePOD	IoData.h	/^  enum ComputePOD {COMPUTE_POD_FALSE = 0, COMPUTE_POD_TRUE = 1} computePOD;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::ComputePOD
computePermittivityTensor	FemEquationTerm.h	/^  void computePermittivityTensor(double alpha[3], double beta[3], double ucg[3], double R[9], double *K)$/;"	f	class:FemEquationTerm
computePodTPod	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computePodTPod() {$/;"	f	class:GappyPreprocessing
computePointWiseSourceTerm	Domain.C	/^void Domain::computePointWiseSourceTerm(DistGeoState &geoState, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computePorousTurbulentViscosity	FemEquationTerm.h	/^  double computePorousTurbulentViscosity($/;"	f	class:FemEquationTerm
computePositionVector	EmbeddedTsDesc.C	/^double EmbeddedTsDesc<dim>::computePositionVector(bool *lastIt, int it, double t, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
computePositionVector	TsDesc.C	/^double TsDesc<dim>::computePositionVector(bool *lastIt, int it, double t, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
computePostOpDVMS	SpaceOperator.C	/^void SpaceOperator<dim>::computePostOpDVMS(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computePrdtPhiCtrlVolRatio	Domain.C	/^void Domain::computePrdtPhiCtrlVolRatio(DistSVec<double,dimLS> &ratioTimesPhi, DistSVec<double,dimLS> &Phi, DistVec<double> &ctrlVol, DistGeoState &geoState) {$/;"	f	class:Domain
computePrdtPhiCtrlVolRatio	SubDomain.C	/^void SubDomain::computePrdtPhiCtrlVolRatio(SVec<double,dimLS> &ratioTimesPhi,$/;"	f	class:SubDomain
computePrdtWCtrlVolRatio	Domain.C	/^void Domain::computePrdtWCtrlVolRatio(DistSVec<double,dim> &ratioTimesU, DistSVec<double,dim> &U, DistVec<double> &ctrlVol, DistGeoState &geoState) {$/;"	f	class:Domain
computePrdtWCtrlVolRatio	SubDomain.C	/^void SubDomain::computePrdtWCtrlVolRatio(SVec<double,dim> &ratioTimesU, SVec<double,dim> &U, Vec<double> &ctrlVol, GeoState &geoState)$/;"	f	class:SubDomain
computePressure	ProgrammedBurnCore.C	/^	double computePressure(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computePressure	ProgrammedBurnCore.C	/^	double computePressure(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computePressureCoefficient	VarFcn.h	/^  double computePressureCoefficient(double *V, double pinfty, double mach, bool dimFlag, int tag=0) const{ check(tag); return varFcn[tag]->computePressureCoefficient(V,pinfty,mach,dimFlag); }$/;"	f	class:VarFcn
computePressureCoefficient	VarFcnBase.h	/^  virtual double computePressureCoefficient(double *V, double pinfty, $/;"	f	class:VarFcnBase
computePressureCoefficient	VarFcnSGEuler.h	/^  double computePressureCoefficient(double *V, double pinfty, double mach, bool dimFlag) const {$/;"	f	class:VarFcnSGEuler
computePressureCoefficient	VarFcnSGKE.h	/^  double computePressureCoefficient(double *V, double pinfty, double mach, bool dimFlag) const {$/;"	f	class:VarFcnSGKE
computePressureCoefficient	VarFcnSGSA.h	/^  double computePressureCoefficient(double *V, double pinfty, double mach, bool dimFlag) const {$/;"	f	class:VarFcnSGSA
computePressureCoefficient	VarFcnTait.h	/^  double computePressureCoefficient(double *V, double pinfty, double mach, bool dimFlag) const {$/;"	f	class:VarFcnTait
computePressureSensor	Domain.C	/^void Domain::computePressureSensor(double threshold, DistSVec<double,3>& X,$/;"	f	class:Domain
computePressureSensor	Domain.h	/^  void computePressureSensor(double, DistSVec<double,3>&,$/;"	f	class:Domain
computePressureSensor	SubDomain.C	/^void SubDomain::computePressureSensor(SVec<double,3>& X, SVec<double,dim>& V,$/;"	f	class:SubDomain
computePseudoInverse	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computePseudoInverse() {$/;"	f	class:GappyPreprocessing
computePseudoInverse	SurfMeshGen.h	/^	void computePseudoInverse() { ;}$/;"	f	class:SurfMeshGen
computePseudoInverseMaskedSnapshots	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computePseudoInverseMaskedSnapshots(const char* type, int iCluster) {$/;"	f	class:GappyPreprocessing
computePseudoInverseTranspose	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computePseudoInverseTranspose() {$/;"	f	class:GappyPreprocessing
computeQuantities	ImplicitRiemann.C	/^static void computeQuantities(double jaci[], double jacj[], double* dWidWi, double* dWidWj,$/;"	f	file:
computeREigenvector	Modal.C	/^void ModalSolver<dim>::computeREigenvector(double sReal, double sImag, int iEV,$/;"	f	class:ModalSolver
computeRKFourthOrder	ExplicitTsDesc.C	/^void ExplicitTsDesc<dim>::computeRKFourthOrder(DistSVec<double,dim>& U)$/;"	f	class:ExplicitTsDesc
computeRKSecondOrder	ExplicitTsDesc.C	/^void ExplicitTsDesc<dim>::computeRKSecondOrder(DistSVec<double,dim>& U)$/;"	f	class:ExplicitTsDesc
computeRKUpdate	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::computeRKUpdate(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitEmbeddedTsDesc
computeRKUpdate	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::computeRKUpdate(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitLevelSetTsDesc
computeRKUpdate	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::computeRKUpdate(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitMultiPhysicsTsDesc
computeRKUpdate	ExplicitTsDesc.C	/^void ExplicitTsDesc<dim>::computeRKUpdate(DistSVec<double,dim>& U,$/;"	f	class:ExplicitTsDesc
computeRKUpdateHH	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::computeRKUpdateHH(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitEmbeddedTsDesc
computeRKUpdateHH	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::computeRKUpdateHH(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitLevelSetTsDesc
computeRKUpdateHH	ExplicitMultiPhysicsTsDesc.C	/^computeRKUpdateHH(DistSVec<double,dim>& Ulocal,$/;"	f	class:ExplicitMultiPhysicsTsDesc
computeRKUpdateLS	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::computeRKUpdateLS(DistSVec<double,dimLS> &Philocal,$/;"	f	class:ExplicitLevelSetTsDesc
computeRKUpdateLS	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::computeRKUpdateLS(DistSVec<double,dimLS> &Philocal,$/;"	f	class:ExplicitMultiPhysicsTsDesc
computeRealFluidResidual	Domain.C	/^double Domain::computeRealFluidResidual(DistSVec<double, dim> &F, DistSVec<double,dim> &Freal,$/;"	f	class:Domain
computeRealFluidResidual	SpaceOperator.C	/^double SpaceOperator<dim>::computeRealFluidResidual(DistSVec<double, dim> &F, DistSVec<double,dim> &Freal,$/;"	f	class:SpaceOperator
computeRealFluidResidual	SubDomain.C	/^void SubDomain::computeRealFluidResidual(SVec<double, dim> &F, SVec<double,dim> &Freal, LevelSetStructure &lss)$/;"	f	class:SubDomain
computeRecSurfBasedForceLoad	Domain.C	/^void Domain::computeRecSurfBasedForceLoad(int forceApp, int orderOfAccuracy, DistSVec<double,3> &X, $/;"	f	class:Domain
computeRecSurfBasedForceLoad	SubDomain.C	/^void SubDomain::computeRecSurfBasedForceLoad(int forceApp, int order, SVec<double,3> &X,$/;"	f	class:SubDomain
computeRedHessianSums	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::computeRedHessianSums(int it, DistSVec<double, dim> &Q)  {$/;"	f	class:ImplicitRomTsDesc
computeRelativeEnergy	Modal.C	/^void ModalSolver<dim>::computeRelativeEnergy(FILE *sValsFile, const Vec<double> &sVals, const int nPod){$/;"	f	class:ModalSolver
computeResidual	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::computeResidual(DistSVec<Scalar2,dim>& V,$/;"	f	class:MultiGridOperator
computeResidual	MultiGridPrec.C	/^computeResidual(int lvl, MultiGridDistSVec<double,dim>& b,$/;"	f	class:MultiGridPrec
computeResidual	MultiGridSpaceOperator.C	/^computeResidual(int level, MultiGridDistSVec<Scalar,dim>& U,$/;"	f	class:MultiGridSpaceOperator
computeResidual	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeResidual(DistSVec<double,3> &X, DistVec<double> &ctrlVol, DistSVec<double,dim> &U, $/;"	f	class:MultiPhaseSpaceOperator
computeResidual	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeResidual(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MultiPhaseSpaceOperator
computeResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeResidual(DistExactRiemannSolver<dim> *riemann,$/;"	f	class:SpaceOperator
computeResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeResidual(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeResidualDenominator	Modal.C	/^double ModalSolver<dim>::computeResidualDenominator(double sReal, double sImag, $/;"	f	class:ModalSolver
computeResidualEmbedded	MultiGridOperator.C	/^computeResidualEmbedded(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:MultiGridOperator
computeResidualEmbedded	MultiGridSpaceOperator.C	/^computeResidualEmbedded(DistExactRiemannSolver<dim>& riemann,$/;"	f	class:MultiGridSpaceOperator
computeResidualLS	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::computeResidualLS(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MultiPhaseSpaceOperator
computeResidualNorm	EmbeddedTsDesc.C	/^double EmbeddedTsDesc<dim>::computeResidualNorm(DistSVec<double,dim>& U)$/;"	f	class:EmbeddedTsDesc
computeResidualNorm	MultiPhysicsTsDesc.C	/^double MultiPhysicsTsDesc<dim,dimLS>::computeResidualNorm(DistSVec<double,dim>& U)$/;"	f	class:MultiPhysicsTsDesc
computeResidualNorm	TsDesc.C	/^double TsDesc<dim>::computeResidualNorm(DistSVec<double,dim>& U)$/;"	f	class:TsDesc
computeResidualRestrict	SpaceOperator.C	/^void SpaceOperator<dim>::computeResidualRestrict(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeRestrictedQuantities	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::computeRestrictedQuantities(const DistGeoState& refinedGeoState)$/;"	f	class:MultiGridLevel
computeRhoEnergy	VarFcn.h	/^  double computeRhoEnergy(double *V, int tag=0)   const{check(tag); return varFcn[tag]->computeRhoEnergy(V); }$/;"	f	class:VarFcn
computeRhoEnergy	VarFcnBase.h	/^  virtual double computeRhoEnergy(double *V)   const{$/;"	f	class:VarFcnBase
computeRhoEnergy	VarFcnJwl.h	/^  double computeRhoEnergy(double *V)   const{$/;"	f	class:VarFcnJwl
computeRhoEnergy	VarFcnSGEuler.h	/^  double computeRhoEnergy(double *V) const {$/;"	f	class:VarFcnSGEuler
computeRhoEnergy	VarFcnSGKE.h	/^  double computeRhoEnergy(double *V) const {$/;"	f	class:VarFcnSGKE
computeRhoEnergy	VarFcnSGSA.h	/^  double computeRhoEnergy(double *V) const {$/;"	f	class:VarFcnSGSA
computeRhoEnergy	VarFcnTait.h	/^  double computeRhoEnergy(double *V)   const{$/;"	f	class:VarFcnTait
computeRhoEpsilon	VarFcn.h	/^  double computeRhoEpsilon(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->computeRhoEpsilon(V); }$/;"	f	class:VarFcn
computeRhoEpsilon	VarFcnBase.h	/^  virtual double computeRhoEpsilon(double *V)  const{ \/\/this function computes the internal energy (=rho*e-0.5*rho*u^2)$/;"	f	class:VarFcnBase
computeRhoEpsilon	VarFcnJwl.h	/^  double computeRhoEpsilon(double *V)  const{ $/;"	f	class:VarFcnJwl
computeRhoEpsilon	VarFcnSGEuler.h	/^  double computeRhoEpsilon(double *V) const { $/;"	f	class:VarFcnSGEuler
computeRhoEpsilon	VarFcnSGKE.h	/^  double computeRhoEpsilon(double *V) const { $/;"	f	class:VarFcnSGKE
computeRhoEpsilon	VarFcnSGSA.h	/^  double computeRhoEpsilon(double *V) const { $/;"	f	class:VarFcnSGSA
computeRhoEpsilon	VarFcnTait.h	/^  double computeRhoEpsilon(double *V)  const{$/;"	f	class:VarFcnTait
computeRiemannJacobian	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:ExactRiemannSolver
computeRiemannJacobian	LocalRiemann.h	/^  virtual void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemann
computeRiemannJacobian	LocalRiemann.h	/^  virtual void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemann
computeRiemannJacobian	LocalRiemann.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannLowMach
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannFluidStructure
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpGasGas
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpGasJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpJWLJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpTaitTait
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar, $/;"	f	class:LocalRiemannGfmpTaitTait
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasGas
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpJWLJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasGas
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasTait
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparJWLJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^  void computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparTaitTait
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::computeRiemannJacobian(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannFluidStructure
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasGas::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasGas
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasJWL::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasTait::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasTait
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparJWLJWL::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparJWLJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitJWL::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparTaitJWL
computeRiemannJacobian	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitTait::computeRiemannJacobian(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparTaitTait
computeRiemannSolution	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:ExactRiemannSolver
computeRiemannSolution	LocalRiemann.h	/^  int computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannLowMach
computeRiemannSolution	LocalRiemann.h	/^  virtual int computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemann
computeRiemannSolution	LocalRiemann.h	/^  virtual int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemann
computeRiemannSolution	LocalRiemann.h	/^  virtual void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemann
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannFluidStructure
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar, $/;"	f	class:LocalRiemannGfmpTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasTait
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  int computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar, $/;"	f	class:LocalRiemannGfmpTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmpJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparGasTait
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^  void computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannGfmparTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannFluidStructure<dim>::computeRiemannSolution(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannFluidStructure
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmpGasGas::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmpGasJWL::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmpJWLJWL::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmpTaitTait::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmpTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparGasGas::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasGas
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparGasJWL::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasJWL
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparGasTait::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparGasTait
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparJWLJWL::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparJWLJWL
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparTaitJWL::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparTaitJWL
computeRiemannSolution	LocalRiemannDesc.h	/^int LocalRiemannGfmparTaitTait::computeRiemannSolution(double *Vi, double *Vj,$/;"	f	class:LocalRiemannGfmparTaitTait
computeRiemannSolution	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::computeRiemannSolution(int tag, double *Vi, double *Vstar,$/;"	f	class:LocalRiemannFluidStructure
computeRiemannWeightsForEmbeddedStruct	Domain.C	/^void Domain::computeRiemannWeightsForEmbeddedStruct(DistSVec<double,3> &X, DistSVec<double,dim> &V,$/;"	f	class:Domain
computeRiemannWeightsForEmbeddedStruct	SubDomain.C	/^void SubDomain::computeRiemannWeightsForEmbeddedStruct(SVec<double,dim> &V, SVec<double,dim> &Wstarij,$/;"	f	class:SubDomain
computeRiemannderivative	LocalRiemann.h	/^  virtual void computeRiemannderivative(double *Vi, double *Vstar, $/;"	f	class:LocalRiemann
computeRiemannderivative	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::computeRiemannderivative(double *Vi, double *Vstar,$/;"	f	class:LocalRiemannFluidStructure
computeRotGradAndJac	CorotSolver.C	/^void CorotSolver::computeRotGradAndJac(DistSVec<double,3> &X, double RR[3][3], $/;"	f	class:CorotSolver
computeRotGradAndJac	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeRotGradAndJac(double *Xs, double RR[3][3], $/;"	f	class:EmbeddedCorotSolver
computeRotMat	CorotSolver.C	/^void CorotSolver::computeRotMat(double *angle, double mat[3][3])$/;"	f	class:CorotSolver
computeRotMat	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::computeRotMat(double *angle, double mat[3][3])$/;"	f	class:EmbeddedCorotSolver
computeRotationAngle	MeshMotionHandlerCore.C	/^double RigidRollMeshMotionHandler::computeRotationAngle(double time)$/;"	f	class:RigidRollMeshMotionHandler
computeScalarQuantity	Face.h	/^  void computeScalarQuantity(PostFcn::ScalarType type, ElemSet &elems, PostFcn *postFcn, $/;"	f	class:Face
computeScalarQuantity	Face.h	/^  void computeScalarQuantity(PostFcn::ScalarType type, ElemSet &elems, PostFcn *postFcn, $/;"	f	class:FaceDummy
computeScalarQuantity	Face.h	/^  void computeScalarQuantity(PostFcn::ScalarType type, ElemSet &elems, PostFcn *postFcn, $/;"	f	class:FaceWrapper_dim
computeScalarQuantity	FaceTria.C	/^void FaceTria::computeScalarQuantity(PostFcn::ScalarType stype, ElemSet& elems,$/;"	f	class:FaceTria
computeScalarQuantity	PostOperator.C	/^void PostOperator<dim>::computeScalarQuantity(PostFcn::ScalarType type,$/;"	f	class:PostOperator
computeScalingVec	VarFcn.h	/^DistSVec<double,dim>* VarFcn::computeScalingVec(IoData &iod, DistSVec<double,dim> &U, DistSVec<double,dim> *F) {$/;"	f	class:VarFcn
computeSecondPorousTurbulentViscosity	FemEquationTerm.h	/^  double computeSecondPorousTurbulentViscosity(double lambdal, double mul, double mut)$/;"	f	class:FemEquationTerm
computeSecondTurbulentViscosity	DESTerm.h	/^double DESTerm::computeSecondTurbulentViscosity(double lambdal, double mul, double mut)$/;"	f	class:DESTerm
computeSecondTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeSecondTurbulentViscosity(double lambdal, double mul, double mut)$/;"	f	class:KEpsilonTerm
computeSecondTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeSecondTurbulentViscosity(double lambdal, double mul, double mut)$/;"	f	class:SATerm
computeSlopes	OneDimensionalSolver.C	/^void OneDimensional::computeSlopes(SVec<double,neq>& VV, SVec<double,neq>& slopes,$/;"	f	class:OneDimensional
computeSmagorinskyLESTerm	Domain.C	/^void Domain::computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, DistSVec<double,3> &X,$/;"	f	class:Domain
computeSmagorinskyLESTerm	Elem.C	/^void ElemSet::computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemSet
computeSmagorinskyLESTerm	Elem.h	/^  void computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:Elem
computeSmagorinskyLESTerm	Elem.h	/^  void computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeSmagorinskyLESTerm	Elem.h	/^  void computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeSmagorinskyLESTerm	ElemTet.C	/^void ElemTet::computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemTet
computeSmagorinskyLESTerm	SubDomain.C	/^void SubDomain::computeSmagorinskyLESTerm(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:SubDomain
computeSmagorinskyLESTerm_e	Elem.h	/^  void computeSmagorinskyLESTerm_e(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:Elem
computeSmagorinskyLESTerm_e	Elem.h	/^  void computeSmagorinskyLESTerm_e(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeSmagorinskyLESTerm_e	Elem.h	/^  void computeSmagorinskyLESTerm_e(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeSmagorinskyLESTerm_e	ElemTet.C	/^void ElemTet::computeSmagorinskyLESTerm_e(SmagorinskyLESTerm *smag, SVec<double,3> &X,$/;"	f	class:ElemTet
computeSmallEnergyGradient	DynamicVMSTerm.C	/^void DynamicVMSTerm::computeSmallEnergyGradient(double dp1dxj[4][3],$/;"	f	class:DynamicVMSTerm
computeSmallEnergyGradient	VMSLESTerm.C	/^void VMSLESTerm::computeSmallEnergyGradient(double dp1dxj[4][3],$/;"	f	class:VMSLESTerm
computeSmoothedSensor	SubDomainCore.C	/^void SubDomain::computeSmoothedSensor(SVec<double,3>& X, Vec<double>& sigma,$/;"	f	class:SubDomain
computeSoundSpeed	ProgrammedBurnCore.C	/^	double computeSoundSpeed(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::IdealGasEOS
computeSoundSpeed	ProgrammedBurnCore.C	/^	double computeSoundSpeed(double rho,double e) const {$/;"	f	class:ProgrammedBurn_CJ::JWLEOS
computeSoundSpeed	VarFcn.h	/^  double computeSoundSpeed(const double density, const double entropy, int tag=0) const{check(tag); return varFcn[tag]->computeSoundSpeed(density,entropy); }$/;"	f	class:VarFcn
computeSoundSpeed	VarFcn.h	/^  double computeSoundSpeed(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->computeSoundSpeed(V); }$/;"	f	class:VarFcn
computeSoundSpeed	VarFcnBase.h	/^  virtual double computeSoundSpeed(const double density, const double entropy) const{$/;"	f	class:VarFcnBase
computeSoundSpeed	VarFcnBase.h	/^  virtual double computeSoundSpeed(double *V)  const{ $/;"	f	class:VarFcnBase
computeSoundSpeed	VarFcnJwl.h	/^  double computeSoundSpeed(const double density, const double entropy) const{$/;"	f	class:VarFcnJwl
computeSoundSpeed	VarFcnJwl.h	/^  double computeSoundSpeed(double *V)  const{ $/;"	f	class:VarFcnJwl
computeSoundSpeed	VarFcnSGEuler.h	/^  double computeSoundSpeed(double *V) const {$/;"	f	class:VarFcnSGEuler
computeSoundSpeed	VarFcnSGEuler.h	/^  double computeSoundSpeed(double density, double entropy) const {$/;"	f	class:VarFcnSGEuler
computeSoundSpeed	VarFcnSGKE.h	/^  double computeSoundSpeed(double *V) const { $/;"	f	class:VarFcnSGKE
computeSoundSpeed	VarFcnSGKE.h	/^  double computeSoundSpeed(double density, double entropy) const {$/;"	f	class:VarFcnSGKE
computeSoundSpeed	VarFcnSGSA.h	/^  double computeSoundSpeed(double *V) const { $/;"	f	class:VarFcnSGSA
computeSoundSpeed	VarFcnSGSA.h	/^  double computeSoundSpeed(double density, double entropy) const {$/;"	f	class:VarFcnSGSA
computeSoundSpeed	VarFcnTait.h	/^  double computeSoundSpeed(const double density, const double entropy) const{$/;"	f	class:VarFcnTait
computeSoundSpeed	VarFcnTait.h	/^  double computeSoundSpeed(double *V)  const{ $/;"	f	class:VarFcnTait
computeSourceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeSourceTerm(double dudxj[3][3],double dnudx[3],$/;"	f	class:FemEquationTermSA
computeStiffAndForce	Domain.C	/^void Domain::computeStiffAndForce(DefoMeshMotionData::Element type, DistSVec<double,3>& X,$/;"	f	class:Domain
computeStiffAndForce	ElemTetCore.C	/^void ElemTet::computeStiffAndForce(double *force, double *Kspace,$/;"	f	class:ElemTet
computeStiffAndForce	SubDomain.C	/^void SubDomain::computeStiffAndForce(DefoMeshMotionData::Element typeElement,$/;"	f	class:SubDomain
computeStiffAndForceBallVertex	ElemTetCore.C	/^void ElemTet::computeStiffAndForceBallVertex(double *force, double *Kspace,$/;"	f	class:ElemTet
computeStiffAndForceLIN	ElemTetCore.C	/^void ElemTet::computeStiffAndForceLIN(double *Kspace,$/;"	f	class:ElemTet
computeStiffBallVertex	ElemTetCore.C	/^void ElemTet::computeStiffBallVertex(double *Kspace, SVec<double,3> &X, SVec<double,3> &X0, double expansionStiffCoef)$/;"	f	class:ElemTet
computeStiffTorsionSpring	ElemTetCore.C	/^void ElemTet::computeStiffTorsionSpring(double *Kspace, SVec<double,3> &X, double expansionStiffCoef)$/;"	f	class:ElemTet
computeStiffnessMatrix	MeshMotionSolver.C	/^void TetMeshMotionSolver::computeStiffnessMatrix(DistSVec<double,3> &X)$/;"	f	class:TetMeshMotionSolver
computeStiffnessMatrix	MeshMotionSolver.h	/^  virtual void computeStiffnessMatrix(DistSVec<double,3> &) {}$/;"	f	class:MeshMotionSolver
computeStressTensor	DynamicLESTerm.C	/^void DynamicLESTerm::computeStressTensor(double mu, double dudxj[3][3],$/;"	f	class:DynamicLESTerm
computeStressTensor	DynamicVMSTerm.C	/^void DynamicVMSTerm::computeStressTensor(double mu, double dudxj[3][3],$/;"	f	class:DynamicVMSTerm
computeStressTensor	NavierStokesTerm.h	/^void NavierStokesTerm::computeStressTensor(double mu, double lambda, double dudxj[3][3], double tij[3][3])$/;"	f	class:NavierStokesTerm
computeStressTensor	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::computeStressTensor(double mu, double dudxj[3][3],$/;"	f	class:SmagorinskyLESTerm
computeStressTensor	VMSLESTerm.C	/^void VMSLESTerm::computeStressTensor(double mu, double dudxj[3][3],$/;"	f	class:VMSLESTerm
computeStressTensor	WaleLESTerm.C	/^void WaleLESTerm::computeStressTensor(double mu, double dudxj[3][3],$/;"	f	class:WaleLESTerm
computeSubGradAndJac	CorotSolver.C	/^double CorotSolver::computeSubGradAndJac(SVec<double,3> &subNd, double RR[3][3], $/;"	f	class:CorotSolver
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermDES
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermDES::computeSurfaceTerm(int code, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermDES
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermKE::computeSurfaceTerm(int code, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermKE
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermNS
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermNS::computeSurfaceTerm(int code, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermNS
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeSurfaceTerm(double dp1dxj[4][3], int code,$/;"	f	class:FemEquationTermSA
computeSurfaceTerm	FemEquationTermDesc.C	/^void FemEquationTermSA::computeSurfaceTerm(int code, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermSA
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermDESmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermDESturb
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKE
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKEmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermKEturb
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermSAmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(double dp1dxj[4][3], int c, Vec3D &n, double d2w[4], $/;"	f	class:FemEquationTermSAturb
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermDESmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermDESturb
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermKEmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermKEturb
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermSAmean
computeSurfaceTerm	FemEquationTermDesc.h	/^  void computeSurfaceTerm(int c, Vec3D &n, double d2w[3], $/;"	f	class:FemEquationTermSAturb
computeSurfaceTerm	WallFcnCore.C	/^void WallFcn::computeSurfaceTerm(int code, Vec3D &normal, double d2wall[3],$/;"	f	class:WallFcn
computeSurfaceTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeSurfaceTermNS(double dp1dxj[4][3], Vec3D &n, $/;"	f	class:NavierStokesTerm
computeSwept	LevelSet/LevelSetStructure.h	/^    void computeSwept(Vec<int> &swept){$/;"	f	class:LevelSetStructure
computeSweptNodes	IntersectorPhysBAM/IntersectorPhysBAM.C	/^int IntersectorPhysBAM::computeSweptNodes(SVec<double,3>& X, Vec<bool>& tId,Communicator& com,const double dt)$/;"	f	class:IntersectorPhysBAM
computeSweptNodes	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^computeSweptNodes(const int subD,const ARRAY<TV>& node_positions,const ARRAY<TV>& node_positions_initial,ARRAY<bool>& swept_node,const T dt) const$/;"	f	class:PhysBAMInterface
computeT	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeT(int config, DistSVec<double,3> &X,$/;"	f	class:DistNodalGrad
computeT	RecFcn.h	/^void RecFcn::computeT(double *dx, Scalar *pi, Scalar *pj,$/;"	f	class:RecFcn
computeTaitDerivRarefaction2x2	ImplicitRiemann.C	/^void ImplicitRiemann::computeTaitDerivRarefaction2x2(double alpha,double beta,double pinf,double p,$/;"	f	class:ImplicitRiemann
computeTaitDerivShock2x2	ImplicitRiemann.C	/^void ImplicitRiemann::computeTaitDerivShock2x2(double alpha,double beta,double pinf,double p,$/;"	f	class:ImplicitRiemann
computeTaitJwlJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeTaitJwlJacobian(VarFcn* vf, int fluidi, int fluidj,$/;"	f	class:ImplicitRiemann
computeTaitTaitJacobian	ImplicitRiemann.C	/^void ImplicitRiemann::computeTaitTaitJacobian(double Pstar, double alphai, double betai,double Pinfi,double Pi,double rhoi,$/;"	f	class:ImplicitRiemann
computeTangentVector	WallFcnCore.C	/^Vec3D WallFcn::computeTangentVector(Vec3D &n, Vec3D &u)$/;"	f	class:WallFcn
computeTb	RecFcn.h	/^void RecFcn::computeTb(SVec<Scalar,dim> &p,$/;"	f	class:RecFcn
computeTemperature	NavierStokesTerm.h	/^void NavierStokesTerm::computeTemperature(double *V, double &T)$/;"	f	class:NavierStokesTerm
computeTemperature	NavierStokesTerm.h	/^void NavierStokesTerm::computeTemperature(double *V[4], double T[4], double &Tcg)$/;"	f	class:NavierStokesTerm
computeTemperature	VarFcn.h	/^  double computeTemperature(double *V, int tag=0) const{check(tag); return varFcn[tag]->computeTemperature(V); }$/;"	f	class:VarFcn
computeTemperature	VarFcn.h	/^void VarFcn::computeTemperature(DistSVec<double,dim> &V, DistVec<double> &T, DistVec<int> *tag)$/;"	f	class:VarFcn
computeTemperature	VarFcn.h	/^void VarFcn::computeTemperature(SVec<double,dim> &V, Vec<double> &T, Vec<int> *tag)$/;"	f	class:VarFcn
computeTemperature	VarFcnBase.h	/^  virtual double computeTemperature(double *V) const{$/;"	f	class:VarFcnBase
computeTemperature	VarFcnJwl.h	/^  double computeTemperature(double *V) const{$/;"	f	class:VarFcnJwl
computeTemperature	VarFcnSGEuler.h	/^  double computeTemperature(double *V) const {$/;"	f	class:VarFcnSGEuler
computeTemperature	VarFcnSGKE.h	/^  double computeTemperature(double *V) const {$/;"	f	class:VarFcnSGKE
computeTemperature	VarFcnSGSA.h	/^  double computeTemperature(double *V) const {$/;"	f	class:VarFcnSGSA
computeTemperature	VarFcnTait.h	/^  double computeTemperature(double *V) const{ return V[4]; }$/;"	f	class:VarFcnTait
computeTemperatureGradient	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeTemperatureGradient(int config, DistSVec<double,3> &X,$/;"	f	class:DistNodalGrad
computeTemperatureGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeTemperatureGradient(double dp1dxj[4][3], double T[4],$/;"	f	class:NavierStokesTerm
computeTemperatureGradient	VarFcn.h	/^  void computeTemperatureGradient(double *V,double* Tg, int tag=0) const{check(tag); varFcn[tag]->computeTemperatureGradient(V,Tg); }$/;"	f	class:VarFcn
computeTemperatureGradient	VarFcnBase.h	/^  virtual void computeTemperatureGradient(double *V,double* Tg) const{$/;"	f	class:VarFcnBase
computeTemperatureGradient	VarFcnSGEuler.h	/^  void computeTemperatureGradient(double *V,double* Tg) const {$/;"	f	class:VarFcnSGEuler
computeTemperatureGradient	VarFcnSGSA.h	/^  void computeTemperatureGradient(double *V,double* Tg) const {$/;"	f	class:VarFcnSGSA
computeTemperatureHessian	VarFcn.h	/^  void computeTemperatureHessian(double *V,double& Trr, double& Trp, $/;"	f	class:VarFcn
computeTemperatureHessian	VarFcnBase.h	/^  virtual void computeTemperatureHessian(double *V,double& Trr, double& Trp, $/;"	f	class:VarFcnBase
computeTemperatureHessian	VarFcnSGEuler.h	/^  void computeTemperatureHessian(double *V,double& Trr, double& Trp, $/;"	f	class:VarFcnSGEuler
computeTestFilterAvgs	Elem.C	/^void ElemSet::computeTestFilterAvgs(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test,$/;"	f	class:ElemSet
computeTestFilterAvgs	SubDomain.C	/^void SubDomain::computeTestFilterAvgs(SVec<double,dim> &VCap, SVec<double,16> &Mom_Test,$/;"	f	class:SubDomain
computeTestFilterValues	Domain.C	/^void Domain::computeTestFilterValues(DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeTetsConnectedToNode	DomainCore.C	/^void Domain::computeTetsConnectedToNode(DistVec<int> &Ni)$/;"	f	class:Domain
computeTetsConnectedToNode	SubDomainCore.C	/^void SubDomain::computeTetsConnectedToNode(Vec<int> &Ni)$/;"	f	class:SubDomain
computeThinLayerViscousFiniteVolumeTerm	AgglomeratedFace.C	/^computeThinLayerViscousFiniteVolumeTerm(class FemEquationTerm* fet,$/;"	f	class:AgglomeratedFace
computeThinLayerViscousFiniteVolumeTerm	AgglomeratedFace.C	/^computeThinLayerViscousFiniteVolumeTerm(class FemEquationTerm* ns,$/;"	f	class:AgglomeratedFaceSet
computeThinLayerViscousFiniteVolumeTerm	Edge.C	/^int EdgeSet::computeThinLayerViscousFiniteVolumeTerm(int* locToGlobNodeMap,$/;"	f	class:EdgeSet
computeTimeFDCoefs	TimeState.C	/^void TimeState<dim>::computeTimeFDCoefs(GeoState &geoState, TimeFDCoefs &coefs, Vec<double> &ctrlVol, int i) $/;"	f	class:TimeState
computeTimeFDCoefsSpecialBDF	TimeState.C	/^void TimeState<dim>::computeTimeFDCoefsSpecialBDF(GeoState &geoState, TimeFDCoefs &coefs, Vec<double> &ctrlVol, int i) $/;"	f	class:TimeState
computeTimeStep	AgglomeratedFace.C	/^void AgglomeratedFace::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn,$/;"	f	class:AgglomeratedFace
computeTimeStep	AgglomeratedFace.C	/^void AgglomeratedFaceSet::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn,$/;"	f	class:AgglomeratedFaceSet
computeTimeStep	DistTimeState.C	/^double DistTimeState<dim>::computeTimeStep(double cfl, double dualtimecfl, double* dtLeft, int* numSubCycles,$/;"	f	class:DistTimeState
computeTimeStep	DistTimeState.C	/^double DistTimeState<dim>::computeTimeStep(int it, double* dtLeft, int* numSubCycles)$/;"	f	class:DistTimeState
computeTimeStep	Domain.C	/^void Domain::computeTimeStep(double cfl, double dualtimecfl, double viscous, FemEquationTerm *fet, VarFcn *varFcn, $/;"	f	class:Domain
computeTimeStep	Domain.C	/^void Domain::computeTimeStep(double cfl, double dualtimecfl, double viscous, FemEquationTerm *fet, VarFcn *varFcn, DistGeoState &geoState,$/;"	f	class:Domain
computeTimeStep	Edge.C	/^void EdgeSet::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState,$/;"	f	class:EdgeSet
computeTimeStep	Edge.C	/^void EdgeSet::computeTimeStep(VarFcn *varFcn, GeoState &geoState,$/;"	f	class:EdgeSet
computeTimeStep	Elem.C	/^void ElemSet::computeTimeStep(FemEquationTerm *fet, SVec<double,3> &X, $/;"	f	class:ElemSet
computeTimeStep	EmbeddedTsDesc.C	/^double EmbeddedTsDesc<dim>::computeTimeStep(int it, double *dtLeft,$/;"	f	class:EmbeddedTsDesc
computeTimeStep	EmbeddedTsDesc.h	/^  double computeTimeStep(int a, double * b, DistSVec<double,dim> & c){ return computeTimeStep(a,b,c,-2.0);}$/;"	f	class:EmbeddedTsDesc
computeTimeStep	Face.C	/^ void Face::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn, $/;"	f	class:Face
computeTimeStep	Face.C	/^void Face::computeTimeStep(VarFcn *varFcn, Vec<Vec3D> &normals, Vec<double> &normalVel,$/;"	f	class:Face
computeTimeStep	Face.C	/^void FaceSet::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState, $/;"	f	class:FaceSet
computeTimeStep	Face.C	/^void FaceSet::computeTimeStep(VarFcn *varFcn, GeoState &geoState, $/;"	f	class:FaceSet
computeTimeStep	ImplicitRomPostproTsDesc.C	/^double ImplicitRomPostproTsDesc<dim>::computeTimeStep(int it, double *dtLeft, DistSVec<double,dim> &U, double angle)$/;"	f	class:ImplicitRomPostproTsDesc
computeTimeStep	LevelSetTsDesc.C	/^double LevelSetTsDesc<dim,dimLS>::computeTimeStep(int it, double *dtLeft,$/;"	f	class:LevelSetTsDesc
computeTimeStep	LevelSetTsDesc.h	/^  double computeTimeStep(int a, double * b, DistSVec<double,dim> & c){ return computeTimeStep(a,b,c,-2.0);}$/;"	f	class:LevelSetTsDesc
computeTimeStep	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::computeTimeStep(double cfl, VarFcn *varFcn,$/;"	f	class:MultiGridOperator
computeTimeStep	MultiGridSpaceOperator.C	/^computeTimeStep(int level, double cfl, $/;"	f	class:MultiGridSpaceOperator
computeTimeStep	MultiPhysicsTsDesc.C	/^double MultiPhysicsTsDesc<dim,dimLS>::computeTimeStep(int it, double *dtLeft,$/;"	f	class:MultiPhysicsTsDesc
computeTimeStep	MultiPhysicsTsDesc.h	/^  double computeTimeStep(int a, double *b, DistSVec<double,dim> &c){ return computeTimeStep(a,b,c,-2.0);}$/;"	f	class:MultiPhysicsTsDesc
computeTimeStep	SubDomain.C	/^void SubDomain::computeTimeStep(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState,$/;"	f	class:SubDomain
computeTimeStep	TsDesc.C	/^double TsDesc<dim>::computeTimeStep(int it, double *dtLeft, DistSVec<double,dim> &U, double angle)$/;"	f	class:TsDesc
computeTimeStep	TsDesc.h	/^  virtual double computeTimeStep(int a, double *b, DistSVec<double,dim> &c){ return computeTimeStep(a,b,c,-2); }$/;"	f	class:TsDesc
computeTimeStep2	Edge.C	/^void EdgeSet::computeTimeStep2(FemEquationTerm *fet, VarFcn *varFcn, GeoState &geoState,$/;"	f	class:EdgeSet
computeTimeStepFailSafe	DistTimeState.C	/^double DistTimeState<dim>::computeTimeStepFailSafe(double* dtLeft, int* numSubCycles)$/;"	f	class:DistTimeState
computeTotalPressure	VarFcn.h	/^  double computeTotalPressure(double machr, double *V, int tag=0) const{check(tag); return varFcn[tag]->computeTotalPressure(machr,V); }$/;"	f	class:VarFcn
computeTotalPressure	VarFcnBase.h	/^  virtual double computeTotalPressure(double machr, double* V) const{$/;"	f	class:VarFcnBase
computeTotalPressure	VarFcnSGEuler.h	/^  double computeTotalPressure(double machr, double* V) const {$/;"	f	class:VarFcnSGEuler
computeTotalPressure	VarFcnSGKE.h	/^  double computeTotalPressure(double machr, double* V) const {$/;"	f	class:VarFcnSGKE
computeTotalPressure	VarFcnSGSA.h	/^  double computeTotalPressure(double machr, double* V) const {$/;"	f	class:VarFcnSGSA
computeTotalPressure	VarFcnTait.h	/^  double computeTotalPressure(double machr, double* V) const {$/;"	f	class:VarFcnTait
computeTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermNS::computeTransportCoefficients($/;"	f	class:FemEquationTermNS
computeTransportCoefficientsPublic	FemEquationTermDesc.C	/^void FemEquationTermNS::computeTransportCoefficientsPublic($/;"	f	class:FemEquationTermNS
computeTransposeDerivative	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeTransposeDerivative(dRdXoperators<dim> *dRdXop,  $/;"	f	class:DistNodalGrad
computeTransposeDerivativeOfControlVolumes	DomainCore.C	/^int Domain::computeTransposeDerivativeOfControlVolumes(RectangularSparseMat<double,3,1> **dCtrlVoldX, $/;"	f	class:Domain
computeTransposeDerivativeOfControlVolumes	SubDomainCore.C	/^int SubDomain::computeTransposeDerivativeOfControlVolumes(RectangularSparseMat<double,3,1> &dCtrlVoldX,$/;"	f	class:SubDomain
computeTransposeDerivativeOfFiniteVolumeTerm	Domain.C	/^void Domain::computeTransposeDerivativeOfFiniteVolumeTerm(dRdXoperators<dim> &dRdXop, $/;"	f	class:Domain
computeTransposeDerivativeOfFiniteVolumeTerm	Edge.C	/^void EdgeSet::computeTransposeDerivativeOfFiniteVolumeTerm($/;"	f	class:EdgeSet
computeTransposeDerivativeOfFiniteVolumeTerm	Face.C	/^void FaceSet::computeTransposeDerivativeOfFiniteVolumeTerm(RectangularSparseMat<double,3,dim> *dFluxdFaceNormal,$/;"	f	class:FaceSet
computeTransposeDerivativeOfFiniteVolumeTerm	SubDomain.C	/^void SubDomain::computeTransposeDerivativeOfFiniteVolumeTerm($/;"	f	class:SubDomain
computeTransposeDerivativeOfForceAndMoment	PostOperator.C	/^void PostOperator<dim>::computeTransposeDerivativeOfForceAndMoment(dRdXoperators<dim> *dRdXop, SVec<double,3> &dFi,$/;"	f	class:PostOperator
computeTransposeDerivativeOfForceAndMoment	SubDomain.C	/^void SubDomain::computeTransposeDerivativeOfForceAndMoment(RectangularSparseMat<double,3,3> *dFidGradP,$/;"	f	class:SubDomain
computeTransposeDerivativeOfGalerkinTerm	Domain.C	/^void Domain::computeTransposeDerivativeOfGalerkinTerm(dRdXoperators<dim> &dRdXop, DistSVec<double,dim> &dR, DistSVec<double,3> &dX)$/;"	f	class:Domain
computeTransposeDerivativeOfGalerkinTerm	SubDomain.C	/^void SubDomain::computeTransposeDerivativeOfGalerkinTerm(RectangularSparseMat<double,3,dim> *dViscousFluxdX,$/;"	f	class:SubDomain
computeTransposeDerivativeOfGradP	SpaceOperator.C	/^void SpaceOperator<dim>::computeTransposeDerivativeOfGradP$/;"	f	class:SpaceOperator
computeTransposeDerivativeOfGradientsLeastSquares	Domain.C	/^void Domain::computeTransposeDerivativeOfGradientsLeastSquares(dRdXoperators<dim> &dRdXop, $/;"	f	class:Domain
computeTransposeDerivativeOfGradientsLeastSquares	SubDomain.C	/^void SubDomain::computeTransposeDerivativeOfGradientsLeastSquares($/;"	f	class:SubDomain
computeTransposeDerivativeOfNodalForce	PostOperator.C	/^void PostOperator<dim>::computeTransposeDerivativeOfNodalForce(RectangularSparseMat<double,3,3> **dForcedX,$/;"	f	class:PostOperator
computeTransposeDerivativeOfNodalForce	SubDomain.C	/^void SubDomain::computeTransposeDerivativeOfNodalForce(RectangularSparseMat<double,3,3> *dForcedX,$/;"	f	class:SubDomain
computeTransposeDerivativeOfNormals	DomainCore.C	/^void Domain::computeTransposeDerivativeOfNormals(RectangularSparseMat<double,3,3> **dEdgeNormdX,$/;"	f	class:Domain
computeTransposeDerivativeOfNormals	SubDomainCore.C	/^void SubDomain::computeTransposeDerivativeOfNormals(RectangularSparseMat<double,3,3> &dEdgeNormdX,$/;"	f	class:SubDomain
computeTransposeDerivativeOfResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeTransposeDerivativeOfResidual(dRdXoperators<dim> *dRdXop,$/;"	f	class:SpaceOperator
computeTransposeDerivativeOfWeights	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeTransposeDerivativeOfWeights(dRdXoperators<dim> &dRdXop, DistSVec<double,6> &dR2, DistSVec<double,3> &dX)$/;"	f	class:DistNodalGrad
computeTransposeDerivativeOfWeightsLeastSquares	DomainCore.C	/^void Domain::computeTransposeDerivativeOfWeightsLeastSquares( $/;"	f	class:Domain
computeTransposeDerivativeOfWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeTransposeDerivativeOfWeightsLeastSquaresEdgePart(RectangularSparseMat<double,3,6> &dRdX, SVec<double,6> &dR, SVec<double,3> &dX)$/;"	f	class:SubDomain
computeTransposeDerivativeOfWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeTransposeDerivativeOfWeightsLeastSquaresNodePart(RectangularSparseMat<double,6,6> &dRdR, SVec<double,6> &dR)$/;"	f	class:SubDomain
computeTransposeDerivatives	DistGeoState.C	/^void DistGeoState::computeTransposeDerivatives(RectangularSparseMat<double,3,3> **dEdgeNormdX,$/;"	f	class:DistGeoState
computeTurbulentJacobian	MultiGridSpaceOperator.C	/^computeTurbulentJacobian(int lvl, MultiGridDistSVec<Scalar,dim>& U,$/;"	f	class:MultiGridSpaceOperator
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermDES::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermDES
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermDESmean::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermDESmean
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermKE::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermKE
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermKEmean::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermKEmean
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermSA::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermSA
computeTurbulentTransportCoefficients	FemEquationTermDesc.C	/^void FemEquationTermSAmean::computeTurbulentTransportCoefficients($/;"	f	class:FemEquationTermSAmean
computeTurbulentViscosity	DESTerm.h	/^double DESTerm::computeTurbulentViscosity(double *V, double mul)$/;"	f	class:DESTerm
computeTurbulentViscosity	DESTerm.h	/^double DESTerm::computeTurbulentViscosity(double *V[4], double mul, double &mutilde)$/;"	f	class:DESTerm
computeTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeTurbulentViscosity(double *V)$/;"	f	class:KEpsilonTerm
computeTurbulentViscosity	KEpsilonTerm.h	/^double KEpsilonTerm::computeTurbulentViscosity(double *V[4], double &rhok, double &rhoeps)$/;"	f	class:KEpsilonTerm
computeTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeTurbulentViscosity(double *V, double mul)$/;"	f	class:SATerm
computeTurbulentViscosity	SpalartAllmarasTerm.h	/^double SATerm::computeTurbulentViscosity(double *V[4], double mul, double &mutilde)$/;"	f	class:SATerm
computeU2	VarFcn.h	/^  double computeU2(double *V) const{ return V[1]*V[1]+V[2]*V[2]+V[3]*V[3]; }$/;"	f	class:VarFcn
computeUpwindGradient	EdgeGrad.C	/^void EdgeGrad<dim>::computeUpwindGradient(Elem& elem, double rij[3], SVec<double,3>& X, SVec<double,dim>& V,$/;"	f	class:EdgeGrad
computeUpwindGradient	EdgeGrad.C	/^void EdgeGrad<dim>::computeUpwindGradient(Elem& elem, double rij[3], SVec<double,3>& X,$/;"	f	class:EdgeGrad
computeVBar	DistMacroCell.C	/^void DistMacroCellSet::computeVBar(bool doInitialTasks, $/;"	f	class:DistMacroCellSet
computeVBar	Domain.C	/^void Domain::computeVBar(DistMacroCellSet *macroCells, bool doInitialTasks, DistGeoState &geoState,$/;"	f	class:Domain
computeVBar	MacroCell.C	/^void MacroCell::computeVBar(SVec<double,dim> &V,$/;"	f	class:MacroCell
computeVBar	MacroCell.C	/^void MacroCellSet::computeVBar(bool doInitialTasks,$/;"	f	class:MacroCellSet
computeVMS	DistMacroCell.C	/^void DistMacroCellSet::computeVMS(bool doInitialTasks,$/;"	f	class:DistMacroCellSet
computeVMSLESTerm	Domain.C	/^void Domain::computeVMSLESTerm(VMSLESTerm *vmst, DistMacroCellSet *macroCells,$/;"	f	class:Domain
computeVMSLESTerm	Elem.C	/^void ElemSet::computeVMSLESTerm(VMSLESTerm *vmst,$/;"	f	class:ElemSet
computeVMSLESTerm	Elem.h	/^  void computeVMSLESTerm(VMSLESTerm *vmst, SVec<double,dim> &VBar,$/;"	f	class:Elem
computeVMSLESTerm	Elem.h	/^  void computeVMSLESTerm(VMSLESTerm *vmst, SVec<double,dim> &VBar,$/;"	f	class:ElemDummy
computeVMSLESTerm	Elem.h	/^  void computeVMSLESTerm(VMSLESTerm *vmst, SVec<double,dim> &VBar,$/;"	f	class:ElemWrapper_dim
computeVMSLESTerm	ElemTet.C	/^void ElemTet::computeVMSLESTerm(VMSLESTerm *vmst,$/;"	f	class:ElemTet
computeVMSLES_Step1	SubDomain.C	/^void SubDomain::computeVMSLES_Step1(VMSLESTerm *vmst,$/;"	f	class:SubDomain
computeVMSLES_Step2	SubDomain.C	/^void SubDomain::computeVMSLES_Step2(SVec<double,1> &volRatio,$/;"	f	class:SubDomain
computeVanAlbadaFcn	RecFcn.h	/^double RecFcn::computeVanAlbadaFcn(double eps, double a, double b)$/;"	f	class:RecFcn
computeVectorQuantity	PostOperator.C	/^void PostOperator<dim>::computeVectorQuantity(PostFcn::VectorType type, $/;"	f	class:PostOperator
computeVectorQuantity	PostOperator.C	/^void PostOperator<dim>::computeVectorQuantity(PostFcn::VectorType type,$/;"	f	class:PostOperator
computeVelocities	DomainCore.C	/^void Domain::computeVelocities(DGCLData::Velocities typeVel, TimeData &timeData,$/;"	f	class:Domain
computeVelocities	TimeData.C	/^void TimeData::computeVelocities(DGCLData::Velocities typeVelocities, $/;"	f	class:TimeData
computeVelocity	DynamicLESTerm.C	/^void DynamicLESTerm::computeVelocity(double *V[4], double u[4][3],$/;"	f	class:DynamicLESTerm
computeVelocity	NavierStokesTerm.h	/^void NavierStokesTerm::computeVelocity(double *V[4], double u[4][3], double ucg[3])$/;"	f	class:NavierStokesTerm
computeVelocity	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::computeVelocity(double *V[4], double u[4][3],$/;"	f	class:SmagorinskyLESTerm
computeVelocity	WaleLESTerm.C	/^void WaleLESTerm::computeVelocity(double *V[4], double u[4][3],$/;"	f	class:WaleLESTerm
computeVelocityGradient	DynamicLESTerm.C	/^void DynamicLESTerm::computeVelocityGradient(double dp1dxj[4][3],$/;"	f	class:DynamicLESTerm
computeVelocityGradient	DynamicVMSTerm.C	/^void DynamicVMSTerm::computeVelocityGradient(double dp1dxj[4][3],$/;"	f	class:DynamicVMSTerm
computeVelocityGradient	NavierStokesTerm.h	/^void NavierStokesTerm::computeVelocityGradient(double dp1dxj[4][3], double u[4][3],$/;"	f	class:NavierStokesTerm
computeVelocityGradient	SmagorinskyLESTerm.C	/^void SmagorinskyLESTerm::computeVelocityGradient(double dp1dxj[4][3],$/;"	f	class:SmagorinskyLESTerm
computeVelocityGradient	VMSLESTerm.C	/^void VMSLESTerm::computeVelocityGradient(double dp1dxj[4][3],$/;"	f	class:VMSLESTerm
computeVelocityGradient	WaleLESTerm.C	/^void WaleLESTerm::computeVelocityGradient(double dp1dxj[4][3],$/;"	f	class:WaleLESTerm
computeVenkatFcn	RecFcn.h	/^double RecFcn::computeVenkatFcn(double vmax, double vmin, double v,$/;"	f	class:RecFcn
computeViscousFiniteVolumeTerm	Edge.C	/^computeViscousFiniteVolumeTerm(int* locToGlobNodeMap,$/;"	f	class:EdgeSet
computeViscousForce	PostFcn.C	/^Vec3D PostFcnNS::computeViscousForce(double dp1dxj[4][3], Vec3D& n, double d2w[3], $/;"	f	class:PostFcnNS
computeViscousForce	PostFcn.h	/^  virtual Vec3D computeViscousForce(double [4][3], Vec3D&, double [3], double*, double* [3], double* [4])$/;"	f	class:PostFcn
computeViscousForce	PostFcn.h	/^  virtual Vec3D computeViscousForce(double [4][3], Vec3D&, double [3], double*, double* [3], double* [4])$/;"	f	class:PostFcnEuler
computeViscousForceCVBoundary	PostFcn.C	/^Vec3D PostFcnNS::computeViscousForceCVBoundary(Vec3D& n,  double* Vi, double dudxj[3][3])$/;"	f	class:PostFcnNS
computeViscousForceCVBoundary	PostFcn.h	/^  virtual Vec3D computeViscousForceCVBoundary(Vec3D& n,  double* Vi, double dudxj[3][3])$/;"	f	class:PostFcn
computeViscousForceCVBoundary	PostFcn.h	/^  virtual Vec3D computeViscousForceCVBoundary(Vec3D& n,  double* Vi, double dudxj[3][3])$/;"	f	class:PostFcnEuler
computeViscousJacobian	SpaceOperator.C	/^void SpaceOperator<dim>::computeViscousJacobian(DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
computeViscousResidual	SpaceOperator.C	/^void SpaceOperator<dim>::computeViscousResidual(DistSVec<double,3> &X, DistVec<double> &ctrlVol, DistSVec<double,dim> &U, DistSVec<double,dim> &R, DistTimeState<dim> *timeState, bool compatF3D)$/;"	f	class:SpaceOperator
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermDES::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermDES
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermDESmean::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermDESmean
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermKE::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermKE
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermKEmean::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermKEmean
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermNS::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermNS
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermSA::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermSA
computeViscousTimeStep	FemEquationTermDesc.C	/^double FemEquationTermSAmean::computeViscousTimeStep(double X[3], double *V)$/;"	f	class:FemEquationTermSAmean
computeViscousTimeStep	FemEquationTermDesc.h	/^  double computeViscousTimeStep(double *, double *){$/;"	f	class:FemEquationTermDESturb
computeViscousTimeStep	FemEquationTermDesc.h	/^  double computeViscousTimeStep(double *, double *){$/;"	f	class:FemEquationTermKEturb
computeViscousTimeStep	FemEquationTermDesc.h	/^  double computeViscousTimeStep(double *, double *){$/;"	f	class:FemEquationTermSAturb
computeVolume	ElemTetCore.C	/^double ElemTet::computeVolume(SVec<double,3> &X)$/;"	f	class:ElemTet
computeVolume	FaceCore.C	/^double Face::computeVolume(Vec3D &xa_n, Vec3D &xb_n, Vec3D &xc_n, $/;"	f	class:Face
computeVolume	MacroCellCore.C	/^double MacroCell::computeVolume(Vec<double> &ctrlVol)$/;"	f	class:MacroCell
computeVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermDES::computeVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermDES
computeVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermKE::computeVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermKE
computeVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermNS::computeVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermNS
computeVolumeTerm	FemEquationTermDesc.C	/^bool FemEquationTermSA::computeVolumeTerm(double dp1dxj[4][3], double d2w[4], $/;"	f	class:FemEquationTermSA
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermDESmean
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermDESturb
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermKEmean
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermKEturb
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermSAmean
computeVolumeTerm	FemEquationTermDesc.h	/^  bool computeVolumeTerm(double dp1dxj[4][3], double d2w[4], double *v[4],$/;"	f	class:FemEquationTermSAturb
computeVolumeTerm	VolumicForceTerm.h	/^  void computeVolumeTerm(double ctrlVol, double *V, double *flux){$/;"	f	class:VolumicForceTerm
computeVolumeTermNS	NavierStokesTerm.h	/^void NavierStokesTerm::computeVolumeTermNS(double mu, double lambda, double kappa, double u[3], $/;"	f	class:NavierStokesTerm
computeVolumeTermPorousCore	FemEquationTerm.h	/^  bool computeVolumeTermPorousCore(double tetVol,$/;"	f	class:FemEquationTerm
computeVolumicForceTerm	Domain.C	/^void Domain::computeVolumicForceTerm(VolumicForceTerm *volForce, DistVec<double> &ctrlVol,$/;"	f	class:Domain
computeVolumicForceTerm	SubDomain.C	/^void SubDomain::computeVolumicForceTerm(VolumicForceTerm *volForce, Vec<double> &ctrlVol,$/;"	f	class:SubDomain
computeWaleLESTerm	Domain.C	/^void Domain::computeWaleLESTerm(WaleLESTerm *wale, DistSVec<double,3> &X,$/;"	f	class:Domain
computeWaleLESTerm	Elem.C	/^void ElemSet::computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemSet
computeWaleLESTerm	Elem.h	/^   void computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:Elem
computeWaleLESTerm	Elem.h	/^  void computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeWaleLESTerm	Elem.h	/^  void computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeWaleLESTerm	ElemTet.C	/^void ElemTet::computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemTet
computeWaleLESTerm	SubDomain.C	/^void SubDomain::computeWaleLESTerm(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:SubDomain
computeWaleLESTerm_e	Elem.h	/^		void computeWaleLESTerm_e(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:Elem
computeWaleLESTerm_e	Elem.h	/^  void computeWaleLESTerm_e(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemDummy
computeWaleLESTerm_e	Elem.h	/^  void computeWaleLESTerm_e(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
computeWaleLESTerm_e	ElemTet.C	/^void ElemTet::computeWaleLESTerm_e(WaleLESTerm *wale, SVec<double,3> &X,$/;"	f	class:ElemTet
computeWallValues	WallFcn.h	/^  virtual void computeWallValues(double utau, double delta, double rho,$/;"	f	class:WallFcn
computeWallValues	WallFcnCore.C	/^void WallFcnKE::computeWallValues(double utau, double delta, double rho, $/;"	f	class:WallFcnKE
computeWallValues	WallFcnCore.C	/^void WallFcnSA::computeWallValues(double utau, double delta, double rho, $/;"	f	class:WallFcnSA
computeWallVersors	HigherOrderFSI.C	/^void HigherOrderFSI::computeWallVersors(double *V1, Vec3D &nWall, VarFcn *vf,$/;"	f	class:HigherOrderFSI
computeWeights	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::computeWeights(DistSVec<double,3> &X)$/;"	f	class:DistNodalGrad
computeWeightsForEmbeddedStruct	Domain.C	/^void Domain::computeWeightsForEmbeddedStruct(DistSVec<double,3> &X, DistSVec<double,dim> &V, $/;"	f	class:Domain
computeWeightsForEmbeddedStruct	Domain.C	/^void Domain::computeWeightsForEmbeddedStruct(DistSVec<double,3> &X, DistSVec<double,dim> &V,$/;"	f	class:Domain
computeWeightsForEmbeddedStruct	SubDomain.C	/^void SubDomain::computeWeightsForEmbeddedStruct(SVec<double,dim> &V, SVec<double,dim> &VWeights,$/;"	f	class:SubDomain
computeWeightsForFluidFluid	Domain.C	/^void Domain::computeWeightsForFluidFluid(DistSVec<double,3> &X, DistSVec<double,dim> &V, $/;"	f	class:Domain
computeWeightsForFluidFluid	SubDomain.C	/^void SubDomain::computeWeightsForFluidFluid(SVec<double,dim> &V, SVec<double,dim> &VWeights,$/;"	f	class:SubDomain
computeWeightsGalerkin	DomainCore.C	/^void Domain::computeWeightsGalerkin(DistSVec<double,3> &X, DistSVec<double,3> &wii,$/;"	f	class:Domain
computeWeightsGalerkin	DomainCore.C	/^void Domain::computeWeightsGalerkin(DistSVec<double,3> &X, const DistVec<int> &fluidId,$/;"	f	class:Domain
computeWeightsGalerkin	ElemTetCore.C	/^void ElemTet::computeWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &wii,$/;"	f	class:ElemTet
computeWeightsGalerkin	SubDomainCore.C	/^void SubDomain::computeWeightsGalerkin(SVec<double,3> &X, SVec<double,3> &wii,$/;"	f	class:SubDomain
computeWeightsGalerkin	SubDomainCore.C	/^void SubDomain::computeWeightsGalerkin(SVec<double,3> &X, const Vec<int> &fluidId,$/;"	f	class:SubDomain
computeWeightsLeastSquares	DomainCore.C	/^void Domain::computeWeightsLeastSquares(DistSVec<double,3> &X, DistSVec<double,6> &R)$/;"	f	class:Domain
computeWeightsLeastSquares	DomainCore.C	/^void Domain::computeWeightsLeastSquares(DistSVec<double,3> &X, const DistVec<int> &fluidId,$/;"	f	class:Domain
computeWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresEdgePart(SVec<double,3> &X, SVec<double,6> &R)$/;"	f	class:SubDomain
computeWeightsLeastSquaresEdgePart	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresEdgePart(SVec<double,3> &X, const Vec<int> &fluidId,$/;"	f	class:SubDomain
computeWeightsLeastSquaresEdgePartForEmbeddedStruct	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresEdgePartForEmbeddedStruct(LevelSetStructure &LSS, $/;"	f	class:SubDomain
computeWeightsLeastSquaresEdgePartForFF	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresEdgePartForFF(LevelSetStructure *LSS, $/;"	f	class:SubDomain
computeWeightsLeastSquaresForEmbeddedStruct	Domain.C	/^void Domain::computeWeightsLeastSquaresForEmbeddedStruct(DistSVec<double,3> &X, DistSVec<double,dim> &V, $/;"	f	class:Domain
computeWeightsLeastSquaresForEmbeddedStruct	SubDomain.C	/^void SubDomain::computeWeightsLeastSquaresForEmbeddedStruct(SVec<double,3> &X, SVec<double,10> &R, SVec<double,dim> &V, $/;"	f	class:SubDomain
computeWeightsLeastSquaresForFluidFluid	Domain.C	/^void Domain::computeWeightsLeastSquaresForFluidFluid($/;"	f	class:Domain
computeWeightsLeastSquaresForFluidFluid	SubDomain.C	/^void SubDomain::computeWeightsLeastSquaresForFluidFluid($/;"	f	class:SubDomain
computeWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresNodePart(SVec<double,6> &R)$/;"	f	class:SubDomain
computeWeightsLeastSquaresNodePart	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresNodePart(SVec<int,1> &count, SVec<double,6> &R)$/;"	f	class:SubDomain
computeWeightsLeastSquaresNodePartForEmbeddedStruct	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresNodePartForEmbeddedStruct(SVec<int,1> &count, SVec<double,10> &R) $/;"	f	class:SubDomain
computeWeightsLeastSquaresNodePartForFF	SubDomainCore.C	/^void SubDomain::computeWeightsLeastSquaresNodePartForFF(SVec<int,1> &count, SVec<double,10> &R) {$/;"	f	class:SubDomain
computeWtMachNumber	VarFcn.h	/^  double computeWtMachNumber(double *V, int tag=0) {$/;"	f	class:VarFcn
computeWtU2	VarFcn.h	/^  double computeWtU2(double *V) const{ $/;"	f	class:VarFcn
computeXP	SubDomain.C	/^void SubDomain::computeXP(PostFcn *postFcn, SVec<double,dim> &V, SVec<double,3> &X, Vec<double> &Q, int dir)$/;"	f	class:SubDomain
computeXYZ	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::computeXYZ(int iSub, int iLocNode, double *xyz) {$/;"	f	class:GappyPreprocessing
computeZeroExtrapolation	InletNode.C	/^void InletNode::computeZeroExtrapolation(VarFcn* vf, bool flag, Vec3D& normal,$/;"	f	class:InletNode
computeZi	SubDomainCore.C	/^void SubDomain::computeZi(double Zi[3], double sq_rat_delta, double sqrt2S2, double dtdxj[3],$/;"	f	class:SubDomain
compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR	FluxFcn.h	/^  void compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR(double *n, double nv, double *vl, double *vr,$/;"	f	class:FluxFcn
compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR	FluxFcnBase.h	/^  virtual void compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR(double *n, double nv, double *vl, double *vr,$/;"	f	class:FluxFcnBase
compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR	FluxFcnDescSG.C	/^void FluxFcnSGExactJacRoeEuler3D::compute_dFluxdNormal_dFluxdNormalVel_dFluxdVL_dFluxdVR(double *normal, double normalVel, double *VL, double *VR, $/;"	f	class:FluxFcnSGExactJacRoeEuler3D
compute_dRdR	SubDomainCore.C	/^void SubDomain::compute_dRdR(SVec<double,6> &R, RectangularSparseMat<double,6,6> &dRdR)$/;"	f	class:SubDomain
compute_dRdX	SubDomainCore.C	/^void SubDomain::compute_dRdX(SVec<double,3> &X, RectangularSparseMat<double,3,6> &dRdX)$/;"	f	class:SubDomain
compute_dWdXAnddWdR	SubDomain.C	/^void compute_dWdXAnddWdR(int pm, double dx[3], double *R, double *W, double dWdX[][6], double dWdR[][6])$/;"	f
compute_dndX	FaceTriaCore.C	/^void FaceTria::compute_dndX(SVec<double,3> &X, double dFaceNormdX[3][3][3]) $/;"	f	class:FaceTria
compute_lambda	ViscoFcn.h	/^  double compute_lambda(double T, double mu) { return bulkViscosity - twothird*mu; }$/;"	f	class:ConstantViscoFcn
compute_lambda	ViscoFcn.h	/^  double compute_lambda(double Tadim, double mu) { return -twothird*mu; }$/;"	f	class:SutherlandViscoFcn
compute_lambda	ViscoFcn.h	/^  double compute_lambda(double Tadim, double mu) { return -twothird*mu;}$/;"	f	class:PrandtlViscoFcn
compute_lambdaDerivative	ViscoFcn.h	/^  double compute_lambdaDerivative(double mu, double dmu, double dMach) { $/;"	f	class:ConstantViscoFcn
compute_lambdaDerivative	ViscoFcn.h	/^  double compute_lambdaDerivative(double mu, double dmu, double dMach) { $/;"	f	class:PrandtlViscoFcn
compute_lambdaDerivative	ViscoFcn.h	/^  double compute_lambdaDerivative(double mu, double dmu, double dMach) { $/;"	f	class:SutherlandViscoFcn
compute_lambdaDerivativeOperators	ViscoFcn.h	/^  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) { \/\/YC$/;"	f	class:ConstantViscoFcn
compute_lambdaDerivativeOperators	ViscoFcn.h	/^  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) {\/\/YC$/;"	f	class:PrandtlViscoFcn
compute_lambdaDerivativeOperators	ViscoFcn.h	/^  void compute_lambdaDerivativeOperators(double &dlambdadmu, double &dlambdadMach) {\/\/YC$/;"	f	class:SutherlandViscoFcn
compute_mu	ViscoFcn.h	/^  double compute_mu(double T) { return 1.0; }$/;"	f	class:ConstantViscoFcn
compute_mu	ViscoFcn.h	/^  double compute_mu(double Tadim) { return alpha * Tadim; }$/;"	f	class:PrandtlViscoFcn
compute_mu	ViscoFcn.h	/^  double compute_mu(double Tadim)$/;"	f	class:SutherlandViscoFcn
compute_muDerivative	ViscoFcn.h	/^  double compute_muDerivative(double T, double dT, double dMach) { return 0.0; }$/;"	f	class:ConstantViscoFcn
compute_muDerivative	ViscoFcn.h	/^  double compute_muDerivative(double Tadim, double dTadim, double dMach)$/;"	f	class:PrandtlViscoFcn
compute_muDerivative	ViscoFcn.h	/^  double compute_muDerivative(double Tadim, double dTadim, double dMach)$/;"	f	class:SutherlandViscoFcn
compute_muDerivativeOperators	ViscoFcn.h	/^  void compute_muDerivativeOperators(double T, double &dmudT, double &dmudMach) { dmudT = 0.0; dmudMach = 0.0; }$/;"	f	class:ConstantViscoFcn
compute_muDerivativeOperators	ViscoFcn.h	/^  void compute_muDerivativeOperators(double Tadim, double &dmudTadim, double &dmudMach) \/\/YC$/;"	f	class:PrandtlViscoFcn
compute_muDerivativeOperators	ViscoFcn.h	/^  void compute_muDerivativeOperators(double Tadim, double &dmudTadim, double &dmudMach) \/\/YC$/;"	f	class:SutherlandViscoFcn
computedFdU	VarFcnBase.h	/^  virtual void computedFdU(double n[3], double *V, double *dFdU) {}$/;"	f	class:VarFcnBase
computedFdU	VarFcnSGEuler.h	/^void VarFcnSGEuler::computedFdU(double n[3], double *V, double *dFdU)$/;"	f	class:VarFcnSGEuler
computedFdV	VarFcnBase.h	/^  virtual void computedFdV(double n[3], double *V, double *dFdV) {}$/;"	f	class:VarFcnBase
computedFdV	VarFcnSGEuler.h	/^void VarFcnSGEuler::computedFdV(double n[3], double *V, double *dFdV)$/;"	f	class:VarFcnSGEuler
computedPdV	VarFcn.h	/^  void computedPdV(double *dPdV, int tag=0)  const{ check(tag); varFcn[tag]->computedPdV(dPdV); }$/;"	f	class:VarFcn
computedPdV	VarFcnBase.h	/^  virtual void computedPdV(double *dPdV)  const{ $/;"	f	class:VarFcnBase
computedPdV	VarFcnSGEuler.h	/^  void computedPdV(double *dPdV)              const { $/;"	f	class:VarFcnSGEuler
computedUdV	VarFcnJwl.h	/^void VarFcnJwl::computedUdV(double *V, double *dUdV) {$/;"	f	class:VarFcnJwl
computedUdV	VarFcnSGEuler.h	/^void VarFcnSGEuler::computedUdV(double *V, double *dUdV)$/;"	f	class:VarFcnSGEuler
computedUdV	VarFcnSGKE.h	/^void VarFcnSGKE::computedUdV(double *V, double *dUdV)$/;"	f	class:VarFcnSGKE
computedUdV	VarFcnSGSA.h	/^void VarFcnSGSA::computedUdV(double *V, double *dUdV)$/;"	f	class:VarFcnSGSA
computedUdV	VarFcnTait.h	/^void VarFcnTait::computedUdV(double *V, double *dUdV) {$/;"	f	class:VarFcnTait
computedUdV	VarFcnTaitKE.h	/^void VarFcnTaitKE::computedUdV(double *V, double *dUdV) {$/;"	f	class:VarFcnTaitKE
computedUdV	VarFcnTaitSA.h	/^void VarFcnTaitSA::computedUdV(double *V, double *dUdV) {$/;"	f	class:VarFcnTaitSA
computedVdU	VarFcnJwl.h	/^void VarFcnJwl::computedVdU(double *V, double *dVdU) {$/;"	f	class:VarFcnJwl
computedVdU	VarFcnSGEuler.h	/^void VarFcnSGEuler::computedVdU(double *V, double *dVdU)$/;"	f	class:VarFcnSGEuler
computedVdU	VarFcnSGKE.h	/^void VarFcnSGKE::computedVdU(double *V, double *dVdU)$/;"	f	class:VarFcnSGKE
computedVdU	VarFcnSGSA.h	/^void VarFcnSGSA::computedVdU(double *V, double *dVdU)$/;"	f	class:VarFcnSGSA
computedVdU	VarFcnTait.h	/^void VarFcnTait::computedVdU(double *V, double *dVdU) {$/;"	f	class:VarFcnTait
computedVdU	VarFcnTaitKE.h	/^void VarFcnTaitKE::computedVdU(double *V, double *dVdU) {$/;"	f	class:VarFcnTaitKE
computedVdU	VarFcnTaitSA.h	/^void VarFcnTaitSA::computedVdU(double *V, double *dVdU) {$/;"	f	class:VarFcnTaitSA
computedWBar_dt	Domain.C	/^void Domain::computedWBar_dt(DistSVec<double, dim> &dWBardt, DistSVec<double, dim> &Sigma,$/;"	f	class:Domain
computedWBar_dt	SubDomain.C	/^void SubDomain::computedWBar_dt(MacroCellSet **macroCells,$/;"	f	class:SubDomain
computed_lazy_box_intersection_acceleration_data	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    bool computed_lazy_box_intersection_acceleration_data;$/;"	m	class:PhysBAM::RAY
computederivativeEmbSurfBasedForceLoad	Domain.C	/^void Domain::computederivativeEmbSurfBasedForceLoad(IoData &iod, int forceApp, int orderOfAccuracy, DistSVec<double,3> &X, $/;"	f	class:Domain
computederivativeEmbSurfBasedForceLoad	SubDomain.C	/^void SubDomain::computederivativeEmbSurfBasedForceLoad(IoData &iod, int forceApp, int order, SVec<double,3> &X,$/;"	f	class:SubDomain
computederivativeOfForceLoad	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::computederivativeOfForceLoad(DistSVec<double,dim> *Wij, $/;"	f	class:EmbeddedTsDesc
computederivativeOfForceLoad	SpaceOperator.C	/^void SpaceOperator<dim>::computederivativeOfForceLoad(int forceApp, int orderOfAccuracy, DistSVec<double,3> &X, $/;"	f	class:SpaceOperator
computedudT	WallFcnCore.C	/^double WallFcn::computedudT(double rho, double T, double du, double dT, $/;"	f	class:WallFcn
conName	GeoSource.h	/^  char *conName;$/;"	m	class:GeoSource
conductivity	IoData.h	/^  double conductivity;$/;"	m	struct:ThermalCondModelData
cones	DistNodalGrad.h	/^  double cones[SchemeFixData::num * 2][2][4];$/;"	m	class:DistNodalGrad
cones	IoData.h	/^  CFixData* cones[num];$/;"	m	struct:SchemeFixData
config	GeoData.h	/^  int config;$/;"	m	class:GeoData
configSA	GeoData.h	/^  int configSA;$/;"	m	class:GeoData
conjugate	DistVector.h	/^DistSVec<Scalar,dim>::conjugate()$/;"	f	class:DistSVec
conjugate	DistVector.h	/^DistVec<Scalar>::conjugate(const DistVec<Scalar> &v2)$/;"	f	class:DistVec
connName	IoData.h	/^  const char *connName;$/;"	m	struct:NonlinearRomFilesData
connName	NonlinearRom.h	/^  char* connName;$/;"	m	class:NonlinearRom
connections	IntersectorPhysBAM/FloodFill.h	/^std::set<pair<pair<GLOBAL_SUBD_ID,int>,pair<GLOBAL_SUBD_ID,int> > > connections;$/;"	m	class:FloodFill
connectivity	IoData.h	/^  const char *connectivity;$/;"	m	struct:InputData
connectivity	MultiGridLevel.h	/^    Connectivity ** connectivity;$/;"	m	class:MultiGridLevel
conservation	IoData.h	/^  const char *conservation;$/;"	m	struct:TransientData
conservation	TsOutput.h	/^  char *conservation;$/;"	m	class:TsOutput
conservativeToPrimitive	LevelSet.C	/^void LevelSet<dimLS>::conservativeToPrimitive(DistSVec<double,dimLS> &Cons, DistSVec<double,dimLS> &Prim, $/;"	f	class:LevelSet
conservativeToPrimitive	SpaceOperator.h	/^  void conservativeToPrimitive(DistSVec<double,dim> &U, $/;"	f	class:SpaceOperator
conservativeToPrimitive	SpaceOperator.h	/^  void conservativeToPrimitive(DistSVec<double,dim> &U, DistVec<int>* fid = 0) $/;"	f	class:SpaceOperator
conservativeToPrimitive	VarFcn.h	/^  void conservativeToPrimitive(double *U, double *V, int tag=0) { check(tag); varFcn[tag]->conservativeToPrimitive(U,V); }$/;"	f	class:VarFcn
conservativeToPrimitive	VarFcn.h	/^void VarFcn::conservativeToPrimitive(DistSVec<double,dim> &U, DistSVec<double,dim> &V, $/;"	f	class:VarFcn
conservativeToPrimitive	VarFcn.h	/^void VarFcn::conservativeToPrimitive(DistSVec<double,dim> &U, DistSVec<double,dim> &V, DistVec<int> *tag)$/;"	f	class:VarFcn
conservativeToPrimitive	VarFcn.h	/^void VarFcn::conservativeToPrimitive(SVec<double,dim> &U, SVec<double,dim> &V, Vec<int> *tag)$/;"	f	class:VarFcn
conservativeToPrimitive	VarFcnJwl.h	/^void VarFcnJwl::conservativeToPrimitive(double *U, double *V){$/;"	f	class:VarFcnJwl
conservativeToPrimitive	VarFcnSGEuler.h	/^void VarFcnSGEuler::conservativeToPrimitive(double *U, double *V)$/;"	f	class:VarFcnSGEuler
conservativeToPrimitive	VarFcnSGKE.h	/^void VarFcnSGKE::conservativeToPrimitive(double *U, double *V)$/;"	f	class:VarFcnSGKE
conservativeToPrimitive	VarFcnSGSA.h	/^void VarFcnSGSA::conservativeToPrimitive(double *U, double *V)$/;"	f	class:VarFcnSGSA
conservativeToPrimitive	VarFcnTait.h	/^void VarFcnTait::conservativeToPrimitive(double *U, double *V){$/;"	f	class:VarFcnTait
conservativeToPrimitive	VarFcnTaitKE.h	/^void VarFcnTaitKE::conservativeToPrimitive(double *U, double *V){$/;"	f	class:VarFcnTaitKE
conservativeToPrimitive	VarFcnTaitSA.h	/^void VarFcnTaitSA::conservativeToPrimitive(double *U, double *V){$/;"	f	class:VarFcnTaitSA
conservativeToPrimitiveDerivative	VarFcn.h	/^  void conservativeToPrimitiveDerivative(double *U, double *dU, double *V, double *dV, int tag=0) { check(tag); varFcn[tag]->conservativeToPrimitiveDerivative(U,dU,V,dV); }$/;"	f	class:VarFcn
conservativeToPrimitiveDerivative	VarFcn.h	/^void VarFcn::conservativeToPrimitiveDerivative(DistSVec<double,dim> &U, DistSVec<double,dim> &dU, DistSVec<double,dim> &V, DistSVec<double,dim> &dV, DistVec<int> *tag)$/;"	f	class:VarFcn
conservativeToPrimitiveDerivative	VarFcn.h	/^void VarFcn::conservativeToPrimitiveDerivative(RectangularSparseMat<double,dim,dim> **dVdU, RectangularSparseMat<double,1,dim> **dVdPstiff,$/;"	f	class:VarFcn
conservativeToPrimitiveDerivative	VarFcn.h	/^void VarFcn::conservativeToPrimitiveDerivative(SVec<double,dim> &U, SVec<double,dim> &dU, SVec<double,dim> &V, SVec<double,dim> &dV, Vec<int> *tag)$/;"	f	class:VarFcn
conservativeToPrimitiveDerivative	VarFcnBase.h	/^  virtual void conservativeToPrimitiveDerivative(double *U, double *dU, double *V, double *dV) {$/;"	f	class:VarFcnBase
conservativeToPrimitiveDerivative	VarFcnSGEuler.h	/^void VarFcnSGEuler::conservativeToPrimitiveDerivative(double *U, double *dU, double *V, double *dV)$/;"	f	class:VarFcnSGEuler
conservativeToPrimitiveDerivative	VarFcnSGKE.h	/^void VarFcnSGKE::conservativeToPrimitiveDerivative(double *U, double *dU, double *V, double *dV)$/;"	f	class:VarFcnSGKE
conservativeToPrimitiveDerivative	VarFcnSGSA.h	/^void VarFcnSGSA::conservativeToPrimitiveDerivative(double *U, double *dU, double *V, double *dV)$/;"	f	class:VarFcnSGSA
conservativeToPrimitiveTransposeDerivative	VarFcn.h	/^void VarFcn::conservativeToPrimitiveTransposeDerivative(RectangularSparseMat<double,dim,dim> **dVdU, RectangularSparseMat<double,1,dim> **dVdPstiff,$/;"	f	class:VarFcn
conservativeToPrimitiveVerification	VarFcn.h	/^  int  conservativeToPrimitiveVerification(int glob, double *U, double *V, int tag=0) { check(tag); return varFcn[tag]->conservativeToPrimitiveVerification(glob,U,V); }$/;"	f	class:VarFcn
conservativeToPrimitiveVerification	VarFcnBase.h	/^  virtual int  conservativeToPrimitiveVerification(int glob, double *U, double *V){$/;"	f	class:VarFcnBase
const_iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef const T* const_iterator; \/\/ for stl$/;"	t	class:PhysBAM::ARRAY_BASE
constant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    T constant;$/;"	m	class:PhysBAM::CONSTANT_ARRAY
constant	RecFcn.h	/^void RecFcn::constant(double Vi, double Vj, double& Vij, double& Vji)$/;"	f	class:RecFcn
constantDerivative	RecFcn.h	/^void RecFcn::constantDerivative(double dVi, double dVj, double& dVij, double& dVji)$/;"	f	class:RecFcn
constrained	TriangulatedInterface.h	/^  int *constrained;$/;"	m	class:TriangulatedInterface
construct	KDTree.h	/^  KDTreeNode* construct(Vec<ScalarGlob>& Xlocal,int depth,int min,int max) {$/;"	f	class:KDTree
construct	KDTree.h	/^  void construct(SVec<double,3>& X) {$/;"	f	class:KDTree
construct	RTree.h	/^  void construct(SVec<double,3>& X, T** objects, int num) $/;"	f	class:RTree
constructApproximatedMetric	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::constructApproximatedMetric(const char* type, int iCluster, std::vector<std::vector<double> >* corrMat) {$/;"	f	class:GappyPreprocessing
constructDatabase	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::constructDatabase() {$/;"	f	class:EmbeddedAlternatingLeastSquare
constructDatabase	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::constructDatabase() {$/;"	f	class:NonlinearRomDatabaseConstruction
constructInternal	RTree.h	/^  Node* constructInternal(SVec<double,3>& X, T** objects, int num) $/;"	f	class:RTree
constructLines	SubDomainCore.C	/^void SubDomain::constructLines(std::vector<std::vector<int>*>& pLines, int& numLines) {$/;"	f	class:SubDomain
constructOperators	MatVecProd.C	/^void MatVecProd_dRdX<dim,Scalar,neq>::constructOperators(Vec3D &x0,$/;"	f	class:MatVecProd_dRdX
constructOperators	MatVecProd.h	/^  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,$/;"	f	class:MatVecProdFD
constructOperators	MatVecProd.h	/^  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,$/;"	f	class:MatVecProdH1
constructOperators	MatVecProd.h	/^  void constructOperators(Vec3D &, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &,$/;"	f	class:MatVecProdH2
constructPOD	Modal.C	/^void ModalSolver<dim>::constructPOD()  {$/;"	f	class:ModalSolver
constructPiercePoint	SubDomainCore.C	/^void constructPiercePoint(Vec3D& a, Vec3D& b, Vec3D& c, Vec3D& d, Vec3D& e,$/;"	f
constructROM2	Modal.C	/^void ModalSolver<dim>::constructROM2(double *romOpPlusVals, VecSet<Vec<double> > &romOperator0, double *romOpPlusVals1, double *romOpPlusVals2,$/;"	f	class:ModalSolver
constructTriangleMap	FSI/CrackingSurface.cpp	/^void CrackingSurface::constructTriangleMap() {$/;"	f	class:CrackingSurface
constructionProgress	MacroCell.h	/^  int constructionProgress;$/;"	m	class:MacroCell
containing	MacroCell.h	/^  int containing(int i) { return nodeToMacroCellMap[i]; }$/;"	f	class:MacroCellSet
contains	SparseGridCore.C	/^bool SparseGrid::contains(double *coord){$/;"	f	class:SparseGrid
context_	DistLeastSquareSolver.h	/^  Context context_;$/;"	m	class:DistLeastSquareSolver
contractionLS	ImplicitEmbeddedTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitEmbeddedTsDesc
contractionLS	ImplicitLevelSetTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitLevelSetTsDesc
contractionLS	ImplicitMultiPhysicsTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
contractionLS	ImplicitTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitTsDesc
contractionLS	MeshMotionSolver.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:TetMeshMotionSolver
controlVol	Modal.h	/^    DistVec<double> controlVol;$/;"	m	class:ModalSolver
controlVol	NonlinearRomOffline.h	/^    DistVec<double> controlVol;$/;"	m	class:NonlinearRomOfflineSolver
controlVolComp	Modal.h	/^    DistVec<bcomp> controlVolComp;  \/\/ failing in this destructor$/;"	m	class:ModalSolver
controlvolume	IoData.h	/^  const char *controlvolume;$/;"	m	struct:TransientData
conv_eps	LevelSet.h	/^  double conv_eps;$/;"	m	class:LevelSet
convergence_file	IoData.h	/^  const char* convergence_file;$/;"	m	struct:InputData
convert2	SubDomain.h	/^  void convert2(bcomp *Aij, int ln, double *Aij_c) {$/;"	f	class:SubDomain
convert2	SubDomain.h	/^  void convert2(double *Aij, int ln, double *Aij_c) {$/;"	f	class:SubDomain
convert2cplusplus	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::convert2cplusplus()$/;"	f	class:RectangularSparseMat
convert2cplusplus	SparseMatrix.C	/^void SparseMat<Scalar,dim>::convert2cplusplus()$/;"	f	class:SparseMat
convert2fortran	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::convert2fortran()$/;"	f	class:RectangularSparseMat
convert2fortran	SparseMatrix.C	/^void SparseMat<Scalar,dim>::convert2fortran()$/;"	f	class:SparseMat
convertToSHSeries	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::convertToSHSeries$/;"	f	class:KirchhoffIntegrator
coordType	IoData.h	/^  enum CoordinateType {CARTESIAN = 0, CYLINDRICAL = 1, SPHERICAL = 2} coordType;$/;"	m	struct:OneDimensionalInfo	typeref:enum:OneDimensionalInfo::CoordinateType
coordType	OneDimensionalSolver.h	/^  OneDimensionalInfo::CoordinateType coordType;$/;"	m	class:OneDimensional
copy	LevelSet.h	/^  MultiFluidData::CopyCloseNodes copy;             \/\/ true if nodes close to interface are unchanged$/;"	m	class:LevelSet
copy	TimeData.C	/^void TimeData::copy(TimeData& oth) {$/;"	f	class:TimeData
copy	arpack++/include/blas1c.h	/^inline void copy(const ARint &n, const arcomplex<double> dx[], $/;"	f
copy	arpack++/include/blas1c.h	/^inline void copy(const ARint &n, const arcomplex<float> dx[], $/;"	f
copy	arpack++/include/blas1c.h	/^inline void copy(const ARint &n, const double dx[], const ARint &incx,$/;"	f
copy	arpack++/include/blas1c.h	/^inline void copy(const ARint &n, const float dx[], const ARint &incx,$/;"	f
copyCloseNodes	IoData.h	/^  enum CopyCloseNodes {FALSE = 0, TRUE = 1} copyCloseNodes;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::CopyCloseNodes
copyCloseNodes	SubDomain.C	/^void SubDomain::copyCloseNodes(int lsdim, int level, Vec<int> &Tag,SVec<double,dimLS> &Phi,SVec<double,1> &Psi)$/;"	f	class:SubDomain
copyFile	TsOutput.C	/^static void copyFile(const char* fname) {$/;"	f	file:
copyRefinedState	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::copyRefinedState(const DistInfo& refinedNodeDistInfo, const DistInfo& refinedEdgeDistInfo,const DistInfo& refinedInletNodeDistInfo,const DistInfo& refinedFaceDistInfo,$/;"	f	class:MultiGridLevel
copyTimeData	DistTimeState.C	/^void DistTimeState<dim>::copyTimeData(DistTimeState<dim>* oth) {$/;"	f	class:DistTimeState
corner	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    TV corner; \/\/ root corner of the box$/;"	m	class:PhysBAM::ORIENTED_BOX
correlMatrix	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
correlationMatrixName	IoData.h	/^  const char *correlationMatrixName;$/;"	m	struct:NonlinearRomFilesData
correlationMatrixName	NonlinearRom.h	/^  char* correlationMatrixName;$/;"	m	class:NonlinearRom
cos	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^cos(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
cos	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^cos(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
cos	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^cos(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
cos	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^cos(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
count	MemoryPool.h	/^  int count;$/;"	m	class:MemoryPool
countBurnableFluids	ProgrammedBurnCore.C	/^int ProgrammedBurn::countBurnableFluids(IoData& ioData) {$/;"	f	class:ProgrammedBurn
countMasters	EmbeddedAlternatingLeastSquare.C	/^std::vector<int> EmbeddedAlternatingLeastSquare<dim>::countMasters(DistInfo &distinfo){$/;"	f	class:EmbeddedAlternatingLeastSquare
countMasters	ParallelRomExtension.cpp	/^std::vector<int> ParallelRomExtension<dim>::countMasters(const DistInfo &distinfo){$/;"	f	class:ParallelRomExtension
countNodesOnBoundaries	ElemCore.C	/^int Elem::countNodesOnBoundaries(Vec<bool> &tagNodes)$/;"	f	class:Elem
countWstarij	EmbeddedTsDesc.h	/^  DistVec<int> *countWstarij, *countWstarji;   \/\/<! only used if ioData.embed.interfaceAlg==INTERSECTION$/;"	m	class:EmbeddedTsDesc
countWstarji	EmbeddedTsDesc.h	/^  DistVec<int> *countWstarij, *countWstarji;   \/\/<! only used if ioData.embed.interfaceAlg==INTERSECTION$/;"	m	class:EmbeddedTsDesc
counter	Timer.h	/^  int *counter;$/;"	m	class:Timer
counter	TsOutput.h	/^  static int counter;$/;"	m	class:TsOutput
counter	TsOutput.h	/^int TsOutput<dim>::counter = 0;$/;"	m	class:TsOutput
counts	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    TV_INT counts;$/;"	m	class:PhysBAM::ARRAY_BASE
counts	SpaceOperator.h	/^    DistVec<int>* counts[2];$/;"	m	struct:MultiPhaseSpaceOperator::__anon28
coupled	FSI/DynamicNodalTransfer.h	/^  bool coupled;$/;"	m	class:EmbeddedStructure
cout	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^log_null_class cout;$/;"	m	namespace:PhysBAM::LOG_NULL	file:
cout_Helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^cout_Helper()$/;"	f	namespace:PhysBAM::LOG_REAL
cout_buffer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^std::streambuf* cout_buffer=0;$/;"	m	namespace:PhysBAM::LOG_REAL::__anon18	file:
cout_initialized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^bool cout_initialized=false;$/;"	m	namespace:PhysBAM::LOG_REAL::__anon18	file:
cp	EdgeGalerkin.h	/^  CommPattern<double> *cp;$/;"	m	class:EdgeGalerkin
cperm	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::cperm(int *perm) $/;"	f	class:RectangularSparseMat
cperm	SparseMatrix.C	/^void SparseMat<Scalar,dim>::cperm(int *perm) $/;"	f	class:SparseMat
cpos	BinFileHandler.h	/^  OffType cpos;$/;"	m	class:BinFileHandler
cpu	Communicator.h	/^  int cpu, len;$/;"	m	struct:RecInfo
cpuForChannel	Communicator.h	/^  int *cpuForChannel;$/;"	m	class:CommPattern
cpuID	Communicator.h	/^    int from, to, cpuID;$/;"	m	struct:SubDTopo::CPair
cpuMasterNodes	ParallelRom.h	/^	int *cpuMasterNodes;	\/\/number of master nodes on cpu for given mesh decomposition$/;"	m	class:ParallelRom
cpuNodes	ParallelRom.h	/^	int *cpuNodes;	\/\/number of master nodes needed by cpu for scalapack block cyclic decomposition$/;"	m	class:ParallelRom
cpuNum	Communicator.h	/^  int cpuNum() const { return thisCPU; }$/;"	f	class:Communicator
cpuNum	Communicator.h	/^  int cpuNum;\/\/ this CPU's number$/;"	m	class:SubDTopo
cpuNum	GeoSource.h	/^  int numLocSub, cpuNum, numLocThreads;$/;"	m	class:GeoSource
cpuRC	Communicator.h	/^  Connectivity *cpuRC;$/;"	m	class:SubDTopo
cpuRcvChannels	Communicator.h	/^  Connectivity *cpuRcvChannels() { return cpuRC; }$/;"	f	class:SubDTopo
cpuSC	Communicator.h	/^  Connectivity *cpuSC;$/;"	m	class:SubDTopo
cpuSample	GappyPreprocessing.h	/^	std::vector<int> cpuSample, locSubSample, locNodeSample;$/;"	m	class:GappyPreprocessing
cpuSndChannels	Communicator.h	/^  Connectivity *cpuSndChannels() { return cpuSC; }$/;"	f	class:SubDTopo
cpuToSub	GeoSource.h	/^  Connectivity *cpuToSub;$/;"	m	class:GeoSource
cpuToThreads	GeoSource.h	/^  int *cpuToThreads;$/;"	m	class:GeoSource
cpumap	IoData.h	/^  const char *cpumap;$/;"	m	struct:InputData
cpus	GappyPreprocessing.h	/^  std::vector <int> *cpus;	\/\/ globalNodes[iSampleNode][iNode] is the global node number of the iNode in the iSampleNode island $/;"	m	class:GappyPreprocessing
cputiming	IoData.h	/^  const char *cputiming;$/;"	m	struct:TransientData
cputiming	TsOutput.h	/^  char *cputiming;$/;"	m	class:TsOutput
cracked	FSI/CrackingSurface.h	/^  bool *cracked; \/\/size: nTotalQuads$/;"	m	class:CrackingSurface
cracking	FSI/DynamicNodalTransfer.h	/^        bool cracking()   {return (structure.cracking) ? true : false;}$/;"	f	class:DynamicNodalTransfer
cracking	FSI/DynamicNodalTransfer.h	/^  CrackingSurface *cracking; \/\/activated only if cracking is considered in the structure code.$/;"	m	class:EmbeddedStructure
cracking	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    CrackingSurface *cracking; \/\/only a pointer.$/;"	m	class:DistIntersectorPhysBAM
cracking	IoData.h	/^  const char *cracking;$/;"	m	struct:InputData
cracking	IoData.h	/^  const char *cracking;$/;"	m	struct:RestartData
cracking	TsRestart.h	/^  char *cracking[3];$/;"	m	class:TsRestart
crackingWithLevelset	IoData.h	/^  enum CrackingWithLevelSet {OFF = 0, ON = 1} crackingWithLevelset;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::CrackingWithLevelSet
createBcData	TsDesc.C	/^DistBcData<dim> *TsDesc<dim>::createBcData(IoData &ioData)$/;"	f	class:TsDesc
createBcFcn	SpaceOperator.C	/^BcFcn *SpaceOperator<dim>::createBcFcn(IoData &ioData)$/;"	f	class:SpaceOperator
createConstantToConstantConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createConstantToConstantConnectivity()$/;"	f	class:SubDomain
createConstantToNodeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createConstantToNodeConnectivity()$/;"	f	class:SubDomain
createDirectories	NonlinearRom.C	/^void NonlinearRom<dim>::createDirectories() { $/;"	f	class:NonlinearRom
createEdgeBasedConnectivity	MultiGridLevel.C	/^Connectivity* MultiGridLevel<Scalar>::createEdgeBasedConnectivity(int iSub)$/;"	f	class:MultiGridLevel
createEdgeBasedConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createEdgeBasedConnectivity()$/;"	f	class:SubDomain
createElemBasedConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createElemBasedConnectivity()$/;"	f	class:SubDomain
createElementBasedEdgeToNodeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createElementBasedEdgeToNodeConnectivity()$/;"	f	class:SubDomain
createElementBasedNodeToEdgeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createElementBasedNodeToEdgeConnectivity()$/;"	f	class:SubDomain
createElementToElementConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createElementToElementConnectivity()$/;"	f	class:SubDomain
createElementToNodeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createElementToNodeConnectivity()$/;"	f	class:SubDomain
createEmbeddedALEMeshMotionHandler	EmbeddedTsDesc.C	/^createEmbeddedALEMeshMotionHandler(IoData &ioData, GeoSource &geoSource, DistLevelSetStructure *distLSS)$/;"	f	class:EmbeddedTsDesc
createFaceToNodeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createFaceToNodeConnectivity()$/;"	f	class:SubDomain
createFemEquationTerm	SpaceOperator.C	/^FemEquationTerm *SpaceOperator<dim>::createFemEquationTerm(IoData &ioData)$/;"	f	class:SpaceOperator
createFluxFcn	FluxFcn.h	/^FluxFcnBase *FluxFcn::createFluxFcn(int rshift, int ffType, FluidModelData &fmodel, IoData &iod, $/;"	f	class:FluxFcn
createFluxFcn	SpaceOperator.C	/^FluxFcn **SpaceOperator<dim>::createFluxFcn(IoData &ioData)$/;"	f	class:SpaceOperator
createFluxFcnSeg1	FluxFcn.h	/^FluxFcnBase *FluxFcn::createFluxFcnSeg1(int rshift, int ffType, FluidModelData &fmodel, IoData &iod, $/;"	f	class:FluxFcn
createFluxFcnSeg2	FluxFcn.h	/^FluxFcnBase *FluxFcn::createFluxFcnSeg2(int rshift, int ffType, FluidModelData &fmodel, IoData &iod, $/;"	f	class:FluxFcn
createHeatTransferHandler	TsDesc.C	/^HeatTransferHandler* TsDesc<dim>::createHeatTransferHandler(IoData& iod, GeoSource& gs)$/;"	f	class:TsDesc
createHigherOrderFSI	DomainCore.C	/^void Domain::createHigherOrderFSI() {$/;"	f	class:Domain
createHigherOrderFSI	SubDomainCore.C	/^void SubDomain::createHigherOrderFSI() {$/;"	f	class:SubDomain
createHigherOrderMultiFluid	DomainCore.C	/^void Domain::createHigherOrderMultiFluid() {$/;"	f	class:Domain
createHigherOrderMultiFluid	SubDomainCore.C	/^void SubDomain::createHigherOrderMultiFluid() {$/;"	f	class:SubDomain
createKrylovSolver	ImplicitCoupledTsDesc.C	/^ImplicitCoupledTsDesc<dim>::createKrylovSolver(const DistInfo &info, KspData &kspdata,$/;"	f	class:ImplicitCoupledTsDesc
createKrylovSolver	ImplicitEmbeddedTsDesc.C	/^ImplicitEmbeddedTsDesc<dim>::createKrylovSolver($/;"	f	class:ImplicitEmbeddedTsDesc
createKrylovSolver	ImplicitLevelSetTsDesc.C	/^ImplicitLevelSetTsDesc<dim,dimLS>::createKrylovSolver($/;"	f	class:ImplicitLevelSetTsDesc
createKrylovSolver	ImplicitMultiPhysicsTsDesc.C	/^ImplicitMultiPhysicsTsDesc<dim,dimLS>::createKrylovSolver($/;"	f	class:ImplicitMultiPhysicsTsDesc
createKrylovSolver	ImplicitTsDesc.C	/^ImplicitTsDesc<dim>::createKrylovSolver(const DistInfo &info, KspData &kspdata, $/;"	f	class:ImplicitTsDesc
createKrylovSolverLS	ImplicitLevelSetTsDesc.C	/^ImplicitLevelSetTsDesc<dim,dimLS>::createKrylovSolverLS($/;"	f	class:ImplicitLevelSetTsDesc
createKrylovSolverLS	ImplicitMultiPhysicsTsDesc.C	/^ImplicitMultiPhysicsTsDesc<dim,dimLS>::createKrylovSolverLS(							    const DistInfo &info, KspData &kspdata,$/;"	f	class:ImplicitMultiPhysicsTsDesc
createLookupTable	VarFcnTait.h	/^  void createLookupTable(int lsize) {$/;"	f	class:VarFcnTait
createMacroCellConnectivities	SubDomainCore.C	/^void SubDomain::createMacroCellConnectivities(MacroCellSet **macroCells, int scopeDepth)$/;"	f	class:SubDomain
createMaskDiagonal	SubDomain.C	/^DiagMat<Scalar,dim> *SubDomain::createMaskDiagonal(typename DiagMat<Scalar,dim>::Type type,$/;"	f	class:SubDomain
createMaskILU	MultiGridLevel.C	/^SparseMat<Scalar,dim>* MultiGridLevel<Scalar>::createMaskILU(int iSub,int fill, $/;"	f	class:MultiGridLevel
createMaskILU	SubDomain.C	/^SparseMat<Scalar,dim> *SubDomain::createMaskILU(int fill, int renum, int *ndType)$/;"	f	class:SubDomain
createMaskJacobian	SubDomain.C	/^SparseMat<Scalar,dim> *SubDomain::createMaskJacobian(int *ndType, MemoryPool *mp)$/;"	f	class:SubDomain
createMaskMatVecProd	SubDomain.C	/^MvpMat<Scalar,dim> *SubDomain::createMaskMatVecProd(bool nsFlag)$/;"	f	class:SubDomain
createMeshMotionHandler	TsDesc.C	/^createMeshMotionHandler(IoData &ioData, GeoSource &geoSource, MemoryPool *mp)$/;"	f	class:TsDesc
createNodeToConstantConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createNodeToConstantConnectivity()$/;"	f	class:SubDomain
createNodeToElementConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createNodeToElementConnectivity()$/;"	f	class:SubDomain
createNodeToFaceConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createNodeToFaceConnectivity()$/;"	f	class:SubDomain
createNodeToMacroCellNodeConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createNodeToMacroCellNodeConnectivity(MacroCellSet *macroCells)$/;"	f	class:SubDomain
createNodeToSubDomainConnectivity	SubDomainCore.C	/^Connectivity *SubDomain::createNodeToSubDomainConnectivity()$/;"	f	class:SubDomain
createPODInTime	Modal.C	/^void ModalSolver<dim>::createPODInTime()  {$/;"	f	class:ModalSolver
createPhiVecPat	DomainCore.C	/^void Domain::createPhiVecPat(int dimLS, IoData *ioData)$/;"	f	class:Domain
createPointers	EdgeCore.C	/^void EdgeSet::createPointers(Vec<int> &newNum)$/;"	f	class:EdgeSet
createPointers	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::createPointers(EdgeSet &edges)$/;"	f	class:RectangularSparseMat
createPointers	SparseMatrix.C	/^void SparseMat<Scalar,dim>::createPointers(EdgeSet &edges)$/;"	f	class:SparseMat
createPreconditioner	ImplicitEmbeddedTsDesc.C	/^KspPrec<neq> *ImplicitEmbeddedTsDesc<dim>::createPreconditioner(PcData &pcdata, Domain *dom)$/;"	f	class:ImplicitEmbeddedTsDesc
createPreconditioner	ImplicitLevelSetTsDesc.C	/^KspPrec<neq> *ImplicitLevelSetTsDesc<dim,dimLS>::createPreconditioner(PcData &pcdata, Domain *dom)$/;"	f	class:ImplicitLevelSetTsDesc
createPreconditioner	ImplicitMultiPhysicsTsDesc.C	/^KspPrec<neq> *ImplicitMultiPhysicsTsDesc<dim,dimLS>::createPreconditioner(PcData &pcdata, Domain *dom)$/;"	f	class:ImplicitMultiPhysicsTsDesc
createPreconditioner	ImplicitRomTsDesc.C	/^KspPrec<neq> *ImplicitRomTsDesc<dim>::createPreconditioner(PcData &pcdata, Domain *dom)$/;"	f	class:ImplicitRomTsDesc
createPreconditioner	ImplicitTsDesc.C	/^KspPrec<neq> *ImplicitTsDesc<dim>::createPreconditioner(PcData &pcdata, Domain *dom)$/;"	f	class:ImplicitTsDesc
createRecFcn	OneDimensionalSolver.C	/^RecFcn* OneDimensional::createRecFcn(IoData &ioData)$/;"	f	class:OneDimensional
createRecFcn	SpaceOperator.C	/^RecFcn *SpaceOperator<dim>::createRecFcn(IoData &ioData)$/;"	f	class:SpaceOperator
createRecFcnLS	OneDimensionalSolver.C	/^RecFcn* OneDimensional::createRecFcnLS(IoData &ioData)$/;"	f	class:OneDimensional
createRecFcnLS	SpaceOperator.C	/^RecFcn *MultiPhaseSpaceOperator<dim,dimLS>::createRecFcnLS(IoData &ioData)$/;"	f	class:MultiPhaseSpaceOperator
createRenumbering	MultiGridLevel.C	/^compStruct* MultiGridLevel<Scalar>::createRenumbering(int iSub,Connectivity *nodeToNode,$/;"	f	class:MultiGridLevel
createRenumbering	SubDomainCore.C	/^compStruct *SubDomain::createRenumbering(Connectivity *nodeToNode,$/;"	f	class:SubDomain
createRhsPat	DomainCore.C	/^void Domain::createRhsPat(int dim, IoData &ioData)$/;"	f	class:Domain
createSharedInletNodeConnectivity	SubDomainCore.C	/^void SubDomain::createSharedInletNodeConnectivity(int subd)$/;"	f	class:SubDomain
createSlipSurfProjection	SubDomainCore.C	/^SubDomain::createSlipSurfProjection(int*surfOwn, CommPattern<int>&cpat,$/;"	f	class:SubDomain
createSpaceOperator1	ImplicitEmbeddedSegTsDesc.C	/^createSpaceOperator1(IoData &ioData, SpaceOperator<dim> *spo)$/;"	f	class:ImplicitEmbeddedSegTsDesc
createSpaceOperator1	ImplicitSegTsDesc.C	/^createSpaceOperator1(IoData &ioData, SpaceOperator<dim> *spo)$/;"	f	class:ImplicitSegTsDesc
createSpaceOperator2	ImplicitEmbeddedSegTsDesc.C	/^createSpaceOperator2(IoData &ioData, SpaceOperator<dim> *spo)$/;"	f	class:ImplicitEmbeddedSegTsDesc
createSpaceOperator2	ImplicitSegTsDesc.C	/^createSpaceOperator2(IoData &ioData, SpaceOperator<dim> *spo)$/;"	f	class:ImplicitSegTsDesc
createSubStates	DistTimeState.C	/^void DistTimeState<dim>::createSubStates() {$/;"	f	class:DistTimeState
createSubVec	DistVector.h	/^DistSVec<Scalar,dim>::createSubVec()$/;"	f	class:DistSVec
createSubVec	DistVector.h	/^DistVec<Scalar>::createSubVec()$/;"	f	class:DistVec
createVarFcn	SparseGridGeneratorDesc.h	/^  VarFcn *createVarFcn(IoData &ioData){$/;"	f	class:SparseGridGeneratorDesc
createVarFcn	TsDesc.C	/^VarFcn *TsDesc<dim>::createVarFcn(IoData &ioData)$/;"	f	class:TsDesc
createVarFcnBase	VarFcn.h	/^VarFcnBase *VarFcn::createVarFcnBase(IoData &iod, FluidModelData &fluidModel) { $/;"	f	class:VarFcn
createVecPat	DomainCore.C	/^void Domain::createVecPat(int dim, IoData *ioData)$/;"	f	class:Domain
createVolumicForceTerm	SpaceOperator.C	/^VolumicForceTerm *SpaceOperator<dim>::createVolumicForceTerm(IoData &ioData)$/;"	f	class:SpaceOperator
create_ConstantToConstantBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_ConstantToConstantBaseddRdXoperators()$/;"	f	class:SubDomain
create_ConstantToNodeBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_ConstantToNodeBaseddRdXoperators()$/;"	f	class:SubDomain
create_EdgeBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_EdgeBaseddRdXoperators()$/;"	f	class:SubDomain
create_FaceBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_FaceBaseddRdXoperators()$/;"	f	class:SubDomain
create_NodeBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_NodeBaseddRdXoperators()$/;"	f	class:SubDomain
create_NodeToConstantBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_NodeToConstantBaseddRdXoperators()$/;"	f	class:SubDomain
create_NodeToEdgeBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_NodeToEdgeBaseddRdXoperators()$/;"	f	class:SubDomain
create_NodeToFaceBaseddRdXoperators	SubDomain.C	/^RectangularSparseMat<double,dim,dim2> *SubDomain::create_NodeToFaceBaseddRdXoperators()$/;"	f	class:SubDomain
crossNeighb	Communicator.h	/^  int *crossNeighb() { return neighbCPU; }$/;"	f	class:SubDTopo
crossNeighb	Communicator.h	/^  int crossNeighb(int iCpu) { return neighbCPU[iCpu]; }$/;"	f	class:SubDTopo
crossProductSensitivityOperator	Vector3D.h	/^void Vec3D::crossProductSensitivityOperator(const Vec3D &v2, double dReturndv1[3][3])$/;"	f	class:Vec3D
crossProductSensitivityOperator	Vector3D.h	/^void Vec3D::crossProductSensitivityOperator(double dReturndv2[3][3])$/;"	f	class:Vec3D
crossRcvBuffer	Communicator.h	/^  T **crossRcvBuffer;$/;"	m	class:CommPattern
crossRcvLen	Communicator.h	/^  int *crossSendLen, *crossRcvLen;$/;"	m	class:CommPattern
crossSendBuffer	Communicator.h	/^  T **crossSendBuffer;$/;"	m	class:CommPattern
crossSendLen	Communicator.h	/^  int *crossSendLen, *crossRcvLen;$/;"	m	class:CommPattern
cs	KspSolver.h	/^  GenFullM<ScalarT> cs, H;$/;"	m	class:GmresSolver
cs	MeshMotionHandler.h	/^  CorotSolver *cs;$/;"	m	class:RbmExtractor
cs	MeshMotionHandler.h	/^  EmbeddedCorotSolver *cs;$/;"	m	class:EmbeddedALEMeshMotionHandler
cs	MeshMotionSolver.h	/^  CorotSolver *cs;$/;"	m	class:TetMeshMotionSolver
csPat	Domain.h	/^  CommPattern<double> *csPat;$/;"	m	class:Domain
cs_max	IoData.h	/^  double cs_max;$/;"	m	struct:ClippingData
cs_mult	arpack++/include/arlcomp.h	102;"	d
cscal_	arpack++/include/arlnames.h	106;"	d
cscal_	arpack++/include/arlnames.h	177;"	d
csdles	IoData.h	/^  const char *csdles;$/;"	m	struct:TransientData
csdvms	IoData.h	/^  const char *csdvms;$/;"	m	struct:TransientData
csize	Connectivity.h	/^Connectivity::csize() { return size; }$/;"	f	class:Connectivity
csize	ResizeArray.h	/^  int  csize;  \/\/ current size$/;"	m	class:ResizeArray
csmax	DynamicLESTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicLESTerm
csmax	DynamicVMSTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicVMSTerm
csprime	DynamicLESTerm.h	/^  double csprime; $/;"	m	class:DynamicLESTerm
csprime	DynamicVMSTerm.h	/^  double csprime;$/;"	m	class:DynamicVMSTerm
csprime	VMSLESTerm.h	/^  double csprime;$/;"	m	class:VMSLESTerm
ctrlSurf	OneDimensionalSolver.h	/^  SVec<double,1> ctrlSurf;$/;"	m	class:OneDimensional
ctrlVol	MatVecProd.h	/^  DistVec<double> *ctrlVol;$/;"	m	class:MatVecProdFD
ctrlVol	MatVecProd.h	/^  DistVec<double> *ctrlVol;$/;"	m	class:MatVecProdFDMultiPhase
ctrlVol	MatVecProd.h	/^  DistVec<double> *ctrlVol;$/;"	m	class:MatVecProdH2
ctrlVol	MatVecProd.h	/^  DistVec<double> *ctrlVol;$/;"	m	class:MatVecProdLS
ctrlVol	MatVecProd.h	/^  DistVec<double> *ctrlVol;$/;"	m	class:MatVecProd_dRdX
ctrlVol	MultiGridLevel.h	/^    DistVec<double>* ctrlVol; $/;"	m	class:MultiGridLevel
ctrlVol	OneDimensionalSolver.h	/^  SVec<double,1> ctrlVol;$/;"	m	class:OneDimensional
ctrlVolCount	MultiGridLevel.h	/^    DistVec<double>* ctrlVolCount;$/;"	m	class:MultiGridLevel
ctrlVolCount	MultiGridLevel.h	/^  int* ctrlVolCount;$/;"	m	struct:MultigridSubdomain
ctrlVol_n	DistGeoState.h	/^  DistVec<double> *ctrlVol_n;$/;"	m	class:DistGeoState
ctrlVol_n	GeoState.h	/^  Vec<double> &ctrlVol_n;$/;"	m	class:GeoState
ctrlVol_nm1	DistGeoState.h	/^  DistVec<double> *ctrlVol_nm1;$/;"	m	class:DistGeoState
ctrlVol_nm1	GeoState.h	/^  Vec<double> &ctrlVol_nm1;$/;"	m	class:GeoState
ctrlVol_nm2	DistGeoState.h	/^  DistVec<double> *ctrlVol_nm2;$/;"	m	class:DistGeoState
ctrlVol_nm2	GeoState.h	/^  Vec<double> &ctrlVol_nm2;$/;"	m	class:GeoState
ctrlVol_save	DistGeoState.h	/^  DistVec<double> *ctrlVol_save;$/;"	m	class:DistGeoState
ctrsm_	arpack++/include/arlnames.h	112;"	d
ctrsm_	arpack++/include/arlnames.h	183;"	d
ctrsv_	arpack++/include/arlnames.h	110;"	d
ctrsv_	arpack++/include/arlnames.h	181;"	d
cube	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cube.h	/^inline T cube(const T a)$/;"	f	namespace:PhysBAM
cumulativeSnapWeights	NonlinearRom.h	/^  std::vector<double> cumulativeSnapWeights;  \/\/ needed in order to ouput a correct columnSumsV that accounts for normalizing snapshots$/;"	m	class:NonlinearRom
current	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    int current;$/;"	m	class:PhysBAM::POINTER_POOL
currentCluster	ImplicitRomTsDesc.h	/^  int currentCluster;$/;"	m	class:ImplicitRomTsDesc
currentDt	Face.h	/^  double currentDt;$/;"	m	struct:HHCoeffs
currentPressure	EmbeddedTsDesc.C	/^double EmbeddedTsDesc<dim>::currentPressure(double t)$/;"	f	class:EmbeddedTsDesc
currentPressure	MultiPhysicsTsDesc.C	/^double MultiPhysicsTsDesc<dim,dimLS>::currentPressure(double t)$/;"	f	class:MultiPhysicsTsDesc
currentProblemSize	ImplicitPGTsDesc.h	/^  int currentProblemSize; \/\/ for local rom  $/;"	m	class:ImplicitPGTsDesc
currentSubGrid	SparseGridCore.C	/^int SparseGrid::currentSubGrid(bool &adaptivity){$/;"	f	class:SparseGrid
currentTime	EmbeddedTsDesc.h	/^  double currentTime;$/;"	m	class:EmbeddedTsDesc
currentTime	LevelSetTsDesc.h	/^  double currentTime,progBurnIgnitionTime;$/;"	m	class:LevelSetTsDesc
currentTime	MultiPhysicsTsDesc.h	/^  double currentTime;$/;"	m	class:MultiPhysicsTsDesc
currentTimeStep	EmbeddedTsDesc.h	/^  double currentTimeStep;$/;"	m	class:EmbeddedTsDesc
currentTimeStep	LevelSetTsDesc.h	/^  double currentTimeStep;$/;"	m	class:LevelSetTsDesc
current_address	tools/alloca.cougar.c	/^    long current_address;	\/* Current stack segment address.  *\/$/;"	m	struct:stk_stat	file:
current_entry	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    LOG_ENTRY* current_entry;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
current_h	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    int current_h;$/;"	m	class:PhysBAM::HASHTABLE_ITERATOR
current_size	tools/alloca.cougar.c	/^    long current_size;		\/* Current stack segment size.  This$/;"	m	struct:stk_stat	file:
curvature	SpaceOperator.h	/^  DistSVec<double,dimLS>* curvature;$/;"	m	class:MultiPhaseSpaceOperator
cutCellStatus	OneDimensionalSolver.h	/^  Vec<int> cutCellStatus;$/;"	m	class:OneDimensional
cutgrads	SpaceOperator.h	/^    DistNodalGrad<dim,double>* cutgrads[2];    $/;"	m	struct:MultiPhaseSpaceOperator::__anon28
cv1	IoData.h	/^  double cv1;$/;"	m	struct:DESModelData
cv1	IoData.h	/^  double cv1;$/;"	m	struct:SAModelData
cv1_pow3	DESTerm.h	/^  double cv1_pow3;$/;"	m	class:DESTerm
cv1_pow3	SpalartAllmarasTerm.h	/^  double cv1_pow3;$/;"	m	class:SATerm
cv1_pow3	WallFcn.h	/^  double cv1_pow3;$/;"	m	class:WallFcnSA
cv2	IoData.h	/^  double cv2;$/;"	m	struct:DESModelData
cv2	IoData.h	/^  double cv2;$/;"	m	struct:SAModelData
cw1	DESTerm.h	/^  double cw1;$/;"	m	class:DESTerm
cw1	SpalartAllmarasTerm.h	/^  double cw1;$/;"	m	class:SATerm
cw2	DESTerm.h	/^  double cw2;$/;"	m	class:DESTerm
cw2	IoData.h	/^  double cw2;$/;"	m	struct:DESModelData
cw2	IoData.h	/^  double cw2;$/;"	m	struct:SAModelData
cw2	SpalartAllmarasTerm.h	/^  double cw2;$/;"	m	class:SATerm
cw3	IoData.h	/^  double cw3;$/;"	m	struct:DESModelData
cw3	IoData.h	/^  double cw3;$/;"	m	struct:SAModelData
cw3_pow6	DESTerm.h	/^  double cw3_pow6;$/;"	m	class:DESTerm
cw3_pow6	SpalartAllmarasTerm.h	/^  double cw3_pow6;$/;"	m	class:SATerm
cycle	MultiGridCoupledTsDesc.C	/^void MultiGridCoupledTsDesc<dim>::cycle(DistSVec<double,dim>& x) {$/;"	f	class:MultiGridCoupledTsDesc
cycle	MultiGridCoupledTsDesc.C	/^void MultiGridCoupledTsDesc<dim>::cycle(int lvl, DistSVec<double,dim>& f,$/;"	f	class:MultiGridCoupledTsDesc
cycle	MultiGridEmbeddedTsDesc.C	/^void MultiGridEmbeddedTsDesc<dim>::cycle(DistSVec<double,dim>& x) {$/;"	f	class:MultiGridEmbeddedTsDesc
cycle	MultiGridEmbeddedTsDesc.C	/^void MultiGridEmbeddedTsDesc<dim>::cycle(int lvl, DistSVec<double,dim>& f,$/;"	f	class:MultiGridEmbeddedTsDesc
cycle	MultiGridPrec.C	/^void MultiGridPrec<Scalar,dim,Scalar2>::cycle(int lvl, MultiGridDistSVec<double,dim>& b,$/;"	f	class:MultiGridPrec
cycle	MultiGridSegTsDesc.C	/^void MultiGridSegTsDesc<dim,neq1,neq2>::cycle(DistSVec<double,dim>& x) {$/;"	f	class:MultiGridSegTsDesc
cycle	MultiGridSegTsDesc.C	/^void MultiGridSegTsDesc<dim,neq1,neq2>::cycle(int lvl, DistSVec<double,dim>& f,$/;"	f	class:MultiGridSegTsDesc
cycle_scheme	IoData.h	/^  enum CycleScheme { VCYCLE = 0, WCYCLE = 1} cycle_scheme;$/;"	m	struct:MultiGridData	typeref:enum:MultiGridData::CycleScheme
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(T& i,T& j,T& k) $/;"	f	namespace:PhysBAM
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(T& i,T& j,T& k,T& l) $/;"	f	namespace:PhysBAM
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
cyclic_shift	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/cyclic_shift.h	/^cyclic_shift(VECTOR<T,4>& v)$/;"	f	namespace:PhysBAM
cylinderMap	IoData.h	/^  ObjectMap<CylinderData>  cylinderMap;$/;"	m	struct:MultiInitialConditionsData
d	AutoDiff/Taylor.h	/^    Scalar &d(int i) { return a[i]; }$/;"	f	class:Taylor2
d	AutoDiff/Taylor.h	/^    Scalar &d(int i, int j) { return b[i][j]; }$/;"	f	class:Taylor2
d	AutoDiff/Taylor.h	/^    Scalar d(int i) const { return a[i]; }$/;"	f	class:Taylor2
d	AutoDiff/Taylor.h	/^    Scalar d(int i, int j) const { return b[i][j]; }$/;"	f	class:Taylor2
d	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^    enum WORKAROUND {d=TV::dimension};$/;"	e	enum:PhysBAM::BOX::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    enum WORKAROUND{d=TV::dimension};$/;"	e	enum:PhysBAM::ORIENTED_BOX::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    enum WORKAROUND {d=TV::m};$/;"	e	enum:PhysBAM::RAY::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    enum WORKAROUND {d=TV::m};$/;"	e	enum:PhysBAM::IMPLICIT_OBJECT::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    enum WORKAROUND {d=dimension};$/;"	e	enum:PhysBAM::ARRAY_BASE::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    enum WORKAROUND {d=TV::dimension};$/;"	e	enum:PhysBAM::RANGE::WORKAROUND
d	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    enum WORKAROUND {d=TV::m};$/;"	e	enum:PhysBAM::FRAME::WORKAROUND
d	ResizeArray.h	/^  Type *d;$/;"	m	class:ResizeArray
d2wall	DistGeoState.h	/^  DistVec<double> *d2wall;$/;"	m	class:DistGeoState
d2wall	GeoState.h	/^  Vec<double> &d2wall;$/;"	m	class:GeoState
d2wall	IoData.h	/^  WallDistanceMethodData d2wall;$/;"	m	struct:TurbulenceModelData
d2wall	IoData.h	/^  const char *d2wall;$/;"	m	struct:InputData
d2wall	IoData.h	/^  const char* d2wall;$/;"	m	struct:TransientData
d2wall	ReinitializeDistanceToWall.h	/^  DistSVec<double,1> d2wall;$/;"	m	class:ReinitializeDistanceToWall
dAdS	FluidCollocationShapeOptimizationHandler.h	/^  DistVec<double> dAdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dAdS	FluidGnatShapeOptimizationHandler.h	/^  DistVec<double> dAdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dAdS	FluidMetricShapeOptimizationHandler.h	/^  DistVec<double> dAdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dAdS	FluidRomShapeOptimizationHandler.h	/^  DistVec<double> dAdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dAdS	FluidShapeOptimizationHandler.h	/^  DistVec<double> dAdS;$/;"	m	class:FluidShapeOptimizationHandler
dCtrlVoldX	MatVecProd.h	/^  RectangularSparseMat<double,3,1> **dCtrlVoldX;$/;"	m	struct:dRdXoperators
dDensity	IoData.h	/^  const char *dDensity;$/;"	m	struct:TransientData
dDisplacement	IoData.h	/^  const char *dDisplacement;$/;"	m	struct:TransientData
dEddyvis	IoData.h	/^  const char *dEddyvis;$/;"	m	struct:TransientData
dEdgeNorm	DistGeoState.h	/^  DistVec<Vec3D> *dEdgeNorm;$/;"	m	class:DistGeoState
dEdgeNorm	FluidShapeOptimizationHandler.h	/^  DistVec<Vec3D> dEdgeNorm;      \/\/ derivative of edge normal or adjoint vectors$/;"	m	class:FluidShapeOptimizationHandler
dEdgeNorm	GeoState.h	/^  Vec<Vec3D> * dEdgeNorm;$/;"	m	class:GeoState
dEdgeNormVel	DistGeoState.h	/^  DistVec<double> *dEdgeNormVel;$/;"	m	class:DistGeoState
dEdgeNormVel	GeoState.h	/^  Vec<double> * dEdgeNormVel;$/;"	m	class:GeoState
dEdgeNormdX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dEdgeNormdX;$/;"	m	struct:dRdXoperators
dFaceNorm	DistGeoState.h	/^  DistVec<Vec3D> *dFaceNorm;$/;"	m	class:DistGeoState
dFaceNorm	FluidShapeOptimizationHandler.h	/^  DistVec<Vec3D> dFaceNorm;      \/\/ derivative of face normal or adjoint vectors$/;"	m	class:FluidShapeOptimizationHandler
dFaceNorm	GeoState.h	/^  Vec<Vec3D> * dFaceNorm;$/;"	m	class:GeoState
dFaceNormVel	DistGeoState.h	/^  DistVec<double> *dFaceNormVel;$/;"	m	class:DistGeoState
dFaceNormVel	FluidShapeOptimizationHandler.h	/^  DistVec<double> dFaceNormVel;  \/\/ derivative of face normal velocity or adjoint vectors$/;"	m	class:FluidShapeOptimizationHandler
dFaceNormVel	GeoState.h	/^  Vec<double> * dFaceNormVel;$/;"	m	class:GeoState
dFaceNormdX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dFaceNormdX;$/;"	m	struct:dRdXoperators
dFdS	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dFdS	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dFdS	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dFdS	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dFdS	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dFdS	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdS;$/;"	m	class:FluidShapeOptimizationHandler
dFdS_debug	EmbeddedFluidShapeOptimizationHandler.h	/^DistSVec<double,dim> dFdS_debug;   $/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dFdSref	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dFdSref;$/;"	m	class:FluidShapeOptimizationHandler
dFidGradP	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dFidGradP;$/;"	m	struct:dRdXoperators
dFidS	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dFidS;$/;"	m	struct:dRdXoperators
dFidV	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dFidV;$/;"	m	struct:dRdXoperators
dFidX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dFidX;$/;"	m	struct:dRdXoperators
dFluxNorm	IoData.h	/^  const char *dFluxNorm;$/;"	m	struct:ROMOutputData
dFluxNorm	TsOutput.h	/^  char *dFluxNorm;$/;"	m	class:TsOutput
dFluxdEdgeNorm	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dFluxdEdgeNorm;$/;"	m	struct:dRdXoperators
dFluxdFaceNormal	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dFluxdFaceNormal;$/;"	m	struct:dRdXoperators
dFluxdFaceNormalVel	MatVecProd.h	/^  RectangularSparseMat<double,1,dim> **dFluxdFaceNormalVel;$/;"	m	struct:dRdXoperators
dFluxdUb	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dFluxdUb;$/;"	m	struct:dRdXoperators
dFluxdX	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dFluxdX;$/;"	m	struct:dRdXoperators
dFluxdddx	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dFluxdddx;$/;"	m	struct:dRdXoperators
dFluxdddy	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dFluxdddy;$/;"	m	struct:dRdXoperators
dFluxdddz	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dFluxdddz;$/;"	m	struct:dRdXoperators
dForcedGradP	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dForcedGradP;$/;"	m	struct:dRdXoperators
dForcedS	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dForcedS;$/;"	m	struct:dRdXoperators
dForcedV	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dForcedV;$/;"	m	struct:dRdXoperators
dForcedX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dForcedX;$/;"	m	struct:dRdXoperators
dForces	IoData.h	/^  const char *dForces;$/;"	m	struct:TransientData
dForces	TsOutput.h	/^  char *dForces;$/;"	m	class:TsOutput
dFrdS	FluidCollocationShapeOptimizationHandler.h	/^  Vec<double> dFrdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dFrdS	FluidGnatShapeOptimizationHandler.h	/^  Vec<double> dFrdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dFrdS	FluidMetricShapeOptimizationHandler.h	/^  Vec<double> dFrdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dFrdS	FluidRomShapeOptimizationHandler.h	/^  Vec<double> dFrdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dFs	EmbeddedTsDesc.h	/^  double (*dFs)[3]; \/\/ derivative of force distribution on the structure surface$/;"	m	class:EmbeddedTsDesc
dFvdV	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dFvdV;$/;"	m	struct:dRdXoperators
dFvdX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dFvdX;$/;"	m	struct:dRdXoperators
dGlobalLU_t	arpack++/include/arlspdef.h	/^} dGlobalLU_t;$/;"	t	typeref:struct:__anon36
dGradP	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dGradP;    \/\/ nodal pressure gradient$/;"	m	class:FluidShapeOptimizationHandler
dGradP	SubDomain.h	/^  double *dGradP[3];$/;"	m	class:SubDomain
dGradPSVec	SubDomain.h	/^  SVec<double,3> *dGradPSVec;$/;"	m	class:SubDomain
dGradPdddx	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dGradPdddx;$/;"	m	struct:dRdXoperators
dGradPdddy	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dGradPdddy;$/;"	m	struct:dRdXoperators
dGradPdddz	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dGradPdddz;$/;"	m	struct:dRdXoperators
dIdti	DistTimeState.h	/^  DistVec<double> *dIdti;$/;"	m	class:DistTimeState
dIdtv	DistTimeState.h	/^  DistVec<double> *dIdtv;$/;"	m	class:DistTimeState
dIrey	DistTimeState.h	/^  DistVec<double> *dIrey;$/;"	m	class:DistTimeState
dLiftDrag	IoData.h	/^  const char *dLiftDrag;$/;"	m	struct:TransientData
dLiftDrag	TsOutput.h	/^  char *dLiftDrag;$/;"	m	class:TsOutput
dLiftx	IoData.h	/^  const char *dLiftx;$/;"	m	struct:TransientData
dLiftx	TsOutput.h	/^  char *dLiftx;$/;"	m	class:TsOutput
dLifty	IoData.h	/^  const char *dLifty;$/;"	m	struct:TransientData
dLifty	TsOutput.h	/^  char *dLifty;$/;"	m	class:TsOutput
dLiftz	IoData.h	/^  const char *dLiftz;$/;"	m	struct:TransientData
dLiftz	TsOutput.h	/^  char *dLiftz;$/;"	m	class:TsOutput
dLoad	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *dLoad;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dLoad	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *dLoad;$/;"	m	class:FluidShapeOptimizationHandler
dLoadref	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *dLoadref;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dLoadref	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *dLoadref;$/;"	m	class:FluidShapeOptimizationHandler
dMach	IoData.h	/^  const char *dMach;$/;"	m	struct:TransientData
dMatchPressure	IoData.h	/^  const char *dMatchPressure;$/;"	m	struct:TransientData
dMatchPressure	TsOutput.h	/^  char *dMatchPressure;$/;"	m	class:TsOutput
dMidGradP	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dMidGradP;$/;"	m	struct:dRdXoperators
dMidS	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dMidS;$/;"	m	struct:dRdXoperators
dMidV	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dMidV;$/;"	m	struct:dRdXoperators
dMidX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dMidX;$/;"	m	struct:dRdXoperators
dMvdV	MatVecProd.h	/^  RectangularSparseMat<double,dim,3> **dMvdV;$/;"	m	struct:dRdXoperators
dMvdX	MatVecProd.h	/^  RectangularSparseMat<double,3,3> **dMvdX;$/;"	m	struct:dRdXoperators
dNutturb	IoData.h	/^  const char *dNutturb;$/;"	m	struct:TransientData
dPdS	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> dPdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dPdS	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> dPdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dPdS	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> dPdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dPdS	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> dPdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dPdS	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dPdS;$/;"	m	class:FluidShapeOptimizationHandler
dPhi	NewtonSolver.h	/^  typename ProblemDescriptor::PhiVecType dPhi; \/\/ $/;"	m	class:NewtonSolver
dPin	PostFcn.h	/^  double dPin;$/;"	m	class:PostFcnEuler
dPressure	IoData.h	/^  const char *dPressure;$/;"	m	struct:TransientData
dPstiff	VarFcnSGEuler.h	/^  double dPstiff;$/;"	m	class:VarFcnSGEuler
dPstiff	VarFcnSGKE.h	/^  double dPstiff;$/;"	m	class:VarFcnSGKE
dPstiff	VarFcnSGSA.h	/^  double dPstiff;$/;"	m	class:VarFcnSGSA
dQ	NewtonSolver.h	/^  typename ProblemDescriptor::SolVecType dQ; \/\/ gradient of F$/;"	m	class:NewtonSolver
dQ1	ImplicitSegTsDesc.h	/^  DistSVec<double,neq1> b1, dQ1;$/;"	m	class:ImplicitSegTsDesc
dQ2	ImplicitSegTsDesc.h	/^  DistSVec<double,neq2> b2, dQ2;$/;"	m	class:ImplicitSegTsDesc
dR	DistNodalGrad.h	/^  DistSVec<double,6> *dR;$/;"	m	class:DistNodalGrad
dR	FluidShapeOptimizationHandler.h	/^  DistSVec<double,6> dR;        \/\/ derivative of least square gradient coefficient or adjoint vectors$/;"	m	class:FluidShapeOptimizationHandler
dRdR	MatVecProd.h	/^  RectangularSparseMat<double,6,6> **dRdR;$/;"	m	struct:dRdXoperators
dRdX	FluidShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *dRdX;$/;"	m	class:FluidShapeOptimizationHandler
dRdX	MatVecProd.h	/^  RectangularSparseMat<double,3,6> **dRdX;$/;"	m	struct:dRdXoperators
dRdXop	MatVecProd.h	/^  dRdXoperators<dim> *dRdXop;$/;"	m	class:MatVecProd_dRdX
dRdXoperators	MatVecProd.h	/^  dRdXoperators() { dRdX = 0; dRdR = 0; dddxdX = 0; dddydX = 0; dddzdX = 0; dddxdR = 0; $/;"	f	struct:dRdXoperators
dRdXoperators	MatVecProd.h	/^struct dRdXoperators$/;"	s
dReMach	ViscoFcn.h	/^  double dReMach;$/;"	m	class:ViscoFcn
dRe_muMach	ViscoFcn.h	/^  double dRe_muMach;$/;"	m	class:ViscoFcn
dRe_mudMach	DESTerm.h	/^  double dRe_mudMach;$/;"	m	class:DESTerm
dRe_mudMach	IoData.h	/^  double dRe_mudMach;$/;"	m	struct:ReferenceStateData
dRe_mudMach	KEpsilonTerm.h	/^  double dRe_mudMach;$/;"	m	class:KEpsilonTerm
dRe_mudMachNS	NavierStokesTerm.h	/^  double dRe_mudMachNS;$/;"	m	class:NavierStokesTerm
dRedMach	WallFcn.h	/^  double dRedMach;$/;"	m	class:WallFcn
dRedMachNS	NavierStokesTerm.h	/^  double dRedMachNS;$/;"	m	class:NavierStokesTerm
dRm	SpaceOperator.h	/^  DistSVec<double,dim> *dRm;$/;"	m	class:SpaceOperator
dScalars	TsOutput.h	/^  char *dScalars[PostFcn::DSSIZE];$/;"	m	class:TsOutput
dSigma	KirchhoffIntegrator.C	/^double KirchhoffIntegrator::dSigma$/;"	f	class:KirchhoffIntegrator
dSolutions	IoData.h	/^  const char *dSolutions;$/;"	m	struct:TransientData
dSolutions	TsOutput.h	/^  char *dSolutions;$/;"	m	class:TsOutput
dSpatialres	IoData.h	/^  const char *dSpatialres;$/;"	m	struct:TransientData
dSpatialresnorm	IoData.h	/^  const char *dSpatialresnorm;$/;"	m	struct:TransientData
dSscale	TsOutput.h	/^  double dSscale[PostFcn::DSSIZE];$/;"	m	class:TsOutput
dTdx	DistNodalGrad.h	/^  DistVec<Scalar> *dTdx;$/;"	m	class:DistNodalGrad
dTdx	NodalGrad.h	/^  Vec<Scalar> &dTdx;$/;"	m	class:NodalGrad
dTdy	DistNodalGrad.h	/^  DistVec<Scalar> *dTdy;$/;"	m	class:DistNodalGrad
dTdy	NodalGrad.h	/^  Vec<Scalar> &dTdy;$/;"	m	class:NodalGrad
dTdz	DistNodalGrad.h	/^  DistVec<Scalar> *dTdz;$/;"	m	class:DistNodalGrad
dTdz	NodalGrad.h	/^  Vec<Scalar> &dTdz;$/;"	m	class:NodalGrad
dTemp	DistBcData.h	/^  DistVec<double> *dTemp;$/;"	m	class:DistBcData
dTemperature	IoData.h	/^  const char *dTemperature;$/;"	m	struct:TransientData
dTotalpressure	IoData.h	/^  const char *dTotalpressure;$/;"	m	struct:TransientData
dU	SpaceOperator.h	/^  DistSVec<double,dim> *dU;$/;"	m	class:SpaceOperator
dUdS	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dUdS	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dUdS	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dUdS	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dUdS	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dUdS	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dUdS;$/;"	m	class:FluidShapeOptimizationHandler
dUface	BcData.h	/^  SVec<double,dim> *dUface;$/;"	m	class:BcData
dUface	DistBcData.h	/^  DistSVec<double,dim> *dUface;$/;"	m	class:DistBcData
dUfaceSA	BcData.h	/^  SVec<double,dim> *dUfaceSA;$/;"	m	class:BcData
dUfaceSA	DistBcData.h	/^  DistSVec<double,dim> *dUfaceSA;$/;"	m	class:DistBcData
dUfarin	BcData.h	/^  SVec<double,dim> *dUfarin;$/;"	m	class:BcData
dUfarin	DistBcData.h	/^  DistSVec<double,dim> *dUfarin;$/;"	m	class:DistBcData
dUfarout	BcData.h	/^  SVec<double,dim> *dUfarout;$/;"	m	class:BcData
dUfarout	DistBcData.h	/^  DistSVec<double,dim> *dUfarout;$/;"	m	class:DistBcData
dUin	DistBcData.h	/^  double dUin[dim], dVin[dim];$/;"	m	class:DistBcData
dUinletnode	BcData.h	/^  SVec<double,dim> *dUinletnode;$/;"	m	class:BcData
dUinletnode	DistBcData.h	/^  DistSVec<double,dim> *dUinletnode;$/;"	m	class:DistBcData
dUnode	BcData.h	/^  SVec<double,dim> *dUnode;$/;"	m	class:BcData
dUnode	DistBcData.h	/^  DistSVec<double,dim> *dUnode;$/;"	m	class:DistBcData
dUnodeSA	BcData.h	/^  SVec<double,dim> *dUnodeSA;$/;"	m	class:BcData
dUnodeSA	DistBcData.h	/^  DistSVec<double,dim> *dUnodeSA;$/;"	m	class:DistBcData
dUnormAccum	IoData.h	/^  const char *dUnormAccum;$/;"	m	struct:ROMOutputData
dUout	DistBcData.h	/^  double dUout[dim], dVout[dim];$/;"	m	class:DistBcData
dUporouswall	BcData.h	/^  SVec<double,dim> *dUporouswall;$/;"	m	class:BcData
dUporouswall	DistBcData.h	/^  DistSVec<double,dim> *dUporouswall;$/;"	m	class:DistBcData
dUromCurrentROB	ImplicitRomTsDesc.h	/^  Vec<double> dUromCurrentROB;  \/\/ set to zero after each cluster switch$/;"	m	class:ImplicitRomTsDesc
dUromNewtonIt	ImplicitRomTsDesc.h	/^  Vec<double> dUromNewtonIt;    \/\/ set to zero before each newton iteration$/;"	m	class:ImplicitRomTsDesc
dUromTimeIt	ImplicitRomTsDesc.h	/^  Vec<double> dUromTimeIt;      \/\/ set to zero before each time iteration$/;"	m	class:ImplicitRomTsDesc
dV	PostOperator.h	/^  DistSVec<double,dim> *dV;$/;"	m	class:PostOperator
dV	SpaceOperator.h	/^  DistSVec<double,dim> *dV;$/;"	m	class:SpaceOperator
dVdPstiff	MatVecProd.h	/^  RectangularSparseMat<double,1,dim> **dVdPstiff;$/;"	m	struct:dRdXoperators
dVdU	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dVdU;$/;"	m	struct:dRdXoperators
dVectors	TsOutput.h	/^  char *dVectors[PostFcn::DVSIZE];$/;"	m	class:TsOutput
dVelocityScalar	IoData.h	/^  const char *dVelocityScalar;$/;"	m	struct:TransientData
dVelocityVector	IoData.h	/^  const char *dVelocityVector;$/;"	m	struct:TransientData
dVin	DistBcData.h	/^  double dUin[dim], dVin[dim];$/;"	m	class:DistBcData
dViscousFluxdX	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dViscousFluxdX;$/;"	m	struct:dRdXoperators
dVmax	DistNodalGrad.h	/^  DistSVec<double,dim> *dVmax;$/;"	m	class:DistNodalGrad
dVmin	DistNodalGrad.h	/^  DistSVec<double,dim> *dVmin;$/;"	m	class:DistNodalGrad
dVout	DistBcData.h	/^  double dUout[dim], dVout[dim];$/;"	m	class:DistBcData
dVscale	TsOutput.h	/^  double dVscale[PostFcn::DVSIZE];$/;"	m	class:TsOutput
dWBardt	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *dWBardt;$/;"	m	class:DistDynamicVMSTerm
dWdt	DistDynamicVMSTerm.h	/^  DistSVec<double,dim> *dWdt;$/;"	m	class:DistDynamicVMSTerm
dX	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dX	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:FluidGnatShapeOptimizationHandler
dX	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:FluidMetricShapeOptimizationHandler
dX	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:FluidRomShapeOptimizationHandler
dX	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:FluidShapeOptimizationHandler
dX	GeoState.h	/^  SVec<double,3> * dX;$/;"	m	class:GeoState
dX	MeshMotionHandler.h	/^  DistSVec<double,3> dX;$/;"	m	class:MeshMotionHandler
dX0	MeshMotionSolver.h	/^  DistSVec<double,3> *dX0;$/;"	m	class:TetMeshMotionSolver
dXb	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> dXb;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dXb	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> dXb;$/;"	m	class:FluidGnatShapeOptimizationHandler
dXb	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> dXb;$/;"	m	class:FluidMetricShapeOptimizationHandler
dXb	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> dXb;$/;"	m	class:FluidRomShapeOptimizationHandler
dXb	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dXb;$/;"	m	class:FluidShapeOptimizationHandler
dXdS	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dXdS	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dXdS	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dXdS	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dXdS	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:FluidRomShapeOptimizationHandler
dXdS	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdS;$/;"	m	class:FluidShapeOptimizationHandler
dXdSb	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdSb;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dXdSb	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdSb;$/;"	m	class:FluidGnatShapeOptimizationHandler
dXdSb	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdSb;$/;"	m	class:FluidMetricShapeOptimizationHandler
dXdSb	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdSb;$/;"	m	class:FluidRomShapeOptimizationHandler
dXdSb	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dXdSb;$/;"	m	class:FluidShapeOptimizationHandler
dXdSb	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *dXdSb;$/;"	m	class:DistIntersectorFRG
dXdSb	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *dXdSb;$/;"	m	class:DistIntersectorPhysBAM
dXdSb_file	EmbeddedFluidShapeOptimizationHandler.h	/^  char *dXdSb_file;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
dXdot	DistBcData.h	/^  DistSVec<double,3> *dXdot;$/;"	m	class:DistBcData
dXds	MeshMotionHandler.h	/^  DistSVec<double,3> dXds;$/;"	m	class:MeshMotionHandler
dXmax	FSI/DynamicNodalTransfer.h	/^  double (*dXmax)[3]; \/\/maximum deformation$/;"	m	class:EmbeddedStructure
dXmax	MeshMotionHandler.h	/^  DistSVec<double,3> *dXmax;$/;"	m	class:DeformingMeshMotionHandler
dXsa	DistGeoState.h	/^  DistSVec<double,3> *dXsa;$/;"	m	class:DistGeoState
dYdS	FluidCollocationShapeOptimizationHandler.h	/^  Vec<double> dYdS;$/;"	m	class:FluidCollocationShapeOptimizationHandler
dYdS	FluidGnatShapeOptimizationHandler.h	/^  Vec<double> dYdS;$/;"	m	class:FluidGnatShapeOptimizationHandler
dYdS	FluidMetricShapeOptimizationHandler.h	/^  Vec<double> dYdS;$/;"	m	class:FluidMetricShapeOptimizationHandler
dYdS	FluidRomShapeOptimizationHandler.h	/^  Vec<double> dYdS;$/;"	m	class:FluidRomShapeOptimizationHandler
d_R	KirchhoffIntegrator.h	/^  double d_R;$/;"	m	class:KirchhoffIntegrator
d_SurfType	KirchhoffIntegrator.h	/^  enum TypeGamma {SPHERE = 0, CYLINDER = 1} d_SurfType;$/;"	m	class:KirchhoffIntegrator	typeref:enum:KirchhoffIntegrator::TypeGamma
d_X_p	KirchhoffIntegrator.h	/^  DistSVec<double,3> *d_X_p;$/;"	m	class:KirchhoffIntegrator
d_angularIncrement	IoData.h	/^  int d_angularIncrement;$/;"	m	struct:KirchhoffData
d_cyl_axis	KirchhoffIntegrator.h	/^  double d_cyl_axis[2];$/;"	m	class:KirchhoffIntegrator
d_domain_p	KirchhoffIntegrator.h	/^  Domain *d_domain_p;$/;"	m	class:KirchhoffIntegrator
d_energyFraction	IoData.h	/^  double d_energyFraction;$/;"	m	struct:KirchhoffData
d_globalToNodeID	KirchhoffIntegrator.h	/^  std::vector<int> d_globalToNodeID;$/;"	m	class:KirchhoffIntegrator
d_iod	KirchhoffIntegrator.h	/^  IoData &d_iod;$/;"	m	class:KirchhoffIntegrator
d_nyquist	IoData.h	/^  int d_nyquist;$/;"	m	struct:KirchhoffData
d_omega_t	KirchhoffIntegrator.h	/^  std::vector<double> d_omega_t;$/;"	m	class:KirchhoffIntegrator
d_surfaceType	IoData.h	/^  enum Type {CYLINDRICAL = 0, SPHERICAL = 1} d_surfaceType;$/;"	m	struct:KirchhoffData	typeref:enum:KirchhoffData::Type
d_timer_p	KirchhoffIntegrator.h	/^  Timer *d_timer_p;$/;"	m	class:KirchhoffIntegrator
dads	LevelSet/LevelSetStructure.h	/^  double dads;$/;"	m	struct:LevelSetResult
dalpha	ViscoFcn.h	/^  double dalpha;$/;"	m	class:PrandtlViscoFcn
dalpha	ViscoFcn.h	/^  double dalpha;$/;"	m	class:SutherlandViscoFcn
dasum_	arpack++/include/arlnames.h	158;"	d
dasum_	arpack++/include/arlnames.h	87;"	d
data	Communicator.h	/^    T *data;$/;"	m	struct:SubRecInfo
data	DenseMatrix.h	/^   Scalar* data() const { return v; }$/;"	f	class:GenFullM
data	DenseMatrix.h	/^  Scalar* data() const { return v; }$/;"	f	class:SymFullM
data	DiagMatrix.h	/^  Scalar (*data())[dim*dim] { return a.v; }$/;"	f	class:DiagMat
data	DistGeoState.h	/^  GeoData data;$/;"	m	class:DistGeoState
data	DistTimeState.h	/^  TimeData *data;$/;"	m	class:DistTimeState
data	GeoState.h	/^  const GeoData &data;$/;"	m	class:GeoState
data	IoData.h	/^  const char *data;$/;"	m	struct:RestartData
data	KDTree.h	/^    ScalarGlob data;$/;"	m	struct:KDTree::KDTreeNode
data	LevelSet.h	/^  TimeData *data;$/;"	m	class:LevelSet
data	MultiGridSmoothingMatrix.h	/^  Scalar (*data())[dim*dim] { return a.data(); }$/;"	f	class:MultiGridSmoothingMatrix
data	MvpMatrix.h	/^  Scalar (*data())[dim*dim] { return a.data(); }$/;"	f	class:MvpMat
data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK,class T> struct HASHTABLE_ENTRY_TEMPLATE{HASHTABLE_ENTRY_STATE state;TK key;T data;};$/;"	m	struct:PhysBAM::HASHTABLE_ENTRY_TEMPLATE
data	RectangularSparseMatrix.h	/^  Scalar (*data())[dim*dim2] { return a.v; }$/;"	f	class:RectangularSparseMat
data	SparseMatrix.h	/^  Scalar (*data())[dim*dim] { return a.v; }$/;"	f	class:SparseMat
data	TimeState.h	/^  TimeData &data;$/;"	m	class:TimeState
data	Timer.h	/^  double *data;$/;"	m	class:Timer
data	TsDesc.h	/^  TsParameters *data;$/;"	m	class:TsDesc
data	TsRestart.h	/^  char *data[3];$/;"	m	class:TsRestart
data	Vector.h	/^  Scalar (*data() const)[dim] { return v; }$/;"	f	class:SVec
data	Vector.h	/^  Scalar *data() const { return v; }$/;"	f	class:Vec
dataCompression	IoData.h	/^  DataCompressionData dataCompression;$/;"	m	struct:JacobianActionData
dataCompression	IoData.h	/^  DataCompressionData dataCompression;$/;"	m	struct:KrylovData
dataCompression	IoData.h	/^  DataCompressionData dataCompression;$/;"	m	struct:ResidualData
dataCompression	IoData.h	/^  DataCompressionData dataCompression;$/;"	m	struct:SensitivityData
dataCompression	IoData.h	/^  DataCompressionData dataCompression;$/;"	m	struct:StateData
dataMap	IoData.h	/^  map<int, DataType *> dataMap;$/;"	m	class:ObjectMap
databaseName	IoData.h	/^  const char *databaseName;$/;"	m	struct:NonlinearRomDirectoriesData
databaseName	NonlinearRom.h	/^  const char* databaseName;$/;"	m	class:NonlinearRom
databasePrefix	NonlinearRom.h	/^  const char* databasePrefix;$/;"	m	class:NonlinearRom
datafile	arpack++/include/ardfmat.h	/^  char*    datafile;  \/\/ Filename.$/;"	m	class:ARdfMatrix
datafile	arpack++/include/arhbmat.h	/^  char*   datafile;        \/\/ Filename.$/;"	m	class:ARhbMatrix
daxpy_	arpack++/include/arlnames.h	166;"	d
daxpy_	arpack++/include/arlnames.h	95;"	d
dcopy_	arpack++/include/arlnames.h	160;"	d
dcopy_	arpack++/include/arlnames.h	89;"	d
dddx	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *dddx;$/;"	m	class:DistNodalGrad
dddx	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dddx;  \/\/ nodal gradients or adjoint vectors$/;"	m	class:FluidShapeOptimizationHandler
dddx	NodalGrad.h	/^  SVec<Scalar,dim> *dddx;$/;"	m	class:NodalGrad
dddxdR	MatVecProd.h	/^  RectangularSparseMat<double,6,dim> **dddxdR;$/;"	m	struct:dRdXoperators
dddxdV	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dddxdV;$/;"	m	struct:dRdXoperators
dddxdX	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dddxdX;$/;"	m	struct:dRdXoperators
dddy	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *dddy;$/;"	m	class:DistNodalGrad
dddy	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dddy;$/;"	m	class:FluidShapeOptimizationHandler
dddy	NodalGrad.h	/^  SVec<Scalar,dim> *dddy;$/;"	m	class:NodalGrad
dddydR	MatVecProd.h	/^  RectangularSparseMat<double,6,dim> **dddydR;$/;"	m	struct:dRdXoperators
dddydV	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dddydV;$/;"	m	struct:dRdXoperators
dddydX	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dddydX;$/;"	m	struct:dRdXoperators
dddz	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *dddz;$/;"	m	class:DistNodalGrad
dddz	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dddz;$/;"	m	class:FluidShapeOptimizationHandler
dddz	NodalGrad.h	/^  SVec<Scalar,dim> *dddz;$/;"	m	class:NodalGrad
dddzdR	MatVecProd.h	/^  RectangularSparseMat<double,6,dim> **dddzdR;$/;"	m	struct:dRdXoperators
dddzdV	MatVecProd.h	/^  RectangularSparseMat<double,dim,dim> **dddzdV;$/;"	m	struct:dRdXoperators
dddzdX	MatVecProd.h	/^  RectangularSparseMat<double,3,dim> **dddzdX;$/;"	m	struct:dRdXoperators
ddot_	arpack++/include/arlnames.h	165;"	d
ddot_	arpack++/include/arlnames.h	94;"	d
ddx	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *ddx;$/;"	m	class:DistNodalGrad
ddx	NodalGrad.h	/^  SVec<Scalar,dim> &ddx;$/;"	m	class:NodalGrad
ddy	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *ddy;$/;"	m	class:DistNodalGrad
ddy	NodalGrad.h	/^  SVec<Scalar,dim> &ddy;$/;"	m	class:NodalGrad
ddz	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *ddz;$/;"	m	class:DistNodalGrad
ddz	NodalGrad.h	/^  SVec<Scalar,dim> &ddz;$/;"	m	class:NodalGrad
debugMultiPhysics	Domain.C	/^void Domain::debugMultiPhysics(DistLevelSetStructure &distLSS, DistSVec<double,dimLS> &PhiV, $/;"	f	class:Domain
debugMultiPhysics	SubDomain.C	/^void SubDomain::debugMultiPhysics(LevelSetStructure &LSS, SVec<double,dimLS> &PhiV, Vec<int> &fluidId, SVec<double,dim> &U)$/;"	f	class:SubDomain
debugging	GappyPreprocessing.h	/^	bool debugging; 	\/\/ debugging flag$/;"	m	class:GappyPreprocessing
decName	GeoSource.h	/^  char *decName;$/;"	m	class:GeoSource
decodeArgumentLine	tools/loader.C	/^void decodeArgumentLine(char *line, int &size, int &argc, char **&argv)$/;"	f
decomposition	IoData.h	/^  const char *decomposition;$/;"	m	struct:InputData
deep	tools/alloca.cougar.c	/^      char *deep;		\/* For stack depth measure.  *\/$/;"	m	struct:hdr::__anon53	file:
defineLowMachPrecType	LowMachPrec.h	/^  virtual void defineLowMachPrecType(IoData &iod){$/;"	f	class:LowMachPrec
defineMaps	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::defineMaps() {$/;"	f	class:GappyPreprocessing
defined	arpack++/include/armat.h	/^  bool defined;$/;"	m	class:ARMatrix
deformMeshFile	FSI/DynamicNodalTransfer.h	/^  char *deformMeshFile;$/;"	m	class:EmbeddedStructure
degDen	IoData.h	/^  int degDen;$/;"	m	struct:PadeData
degNum	IoData.h	/^  int degNum;$/;"	m	struct:PadeData
deleteCharStar	TsRestart.h	/^  bool deleteCharStar;$/;"	m	class:TsRestart
deletePointers	DistVector.h	/^  void deletePointers() $/;"	f	class:DistVec
deleteRestrictedQuantities	ImplicitGappyTsDesc.C	/^void ImplicitGappyTsDesc<dim>::deleteRestrictedQuantities() {$/;"	f	class:ImplicitGappyTsDesc
deleteRestrictedQuantities	ImplicitRomTsDesc.h	/^  virtual void deleteRestrictedQuantities() {};$/;"	f	class:ImplicitRomTsDesc
deleteRestrictedQuantities	NonlinearRom.C	/^void NonlinearRom<dim>::deleteRestrictedQuantities() {$/;"	f	class:NonlinearRom
deleted	FSI/CrackingSurface.h	/^  bool *deleted; \/\/size: nTotalQuads, in the case of Element Deletion, a "cracked" element is "deleted".$/;"	m	class:CrackingSurface
deletion_list	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    ARRAY<int> deletion_list;$/;"	m	class:PhysBAM::ARRAY_COLLECTION
delta	DynamicLESTerm.h	/^  bool delta;$/;"	m	class:DynamicLESTerm
delta	DynamicVMSTerm.h	/^  bool delta;$/;"	m	class:DynamicVMSTerm
delta	IoData.h	/^  double delta;$/;"	m	struct:BcsWallData
delta	IoData.h	/^  enum Delta {VOLUME = 0, SIDE = 1} delta;$/;"	m	struct:LESModelData	typeref:enum:LESModelData::Delta
delta	MeshMotionHandler.h	/^  double delta[3];$/;"	m	class:HeavingMeshMotionHandler
delta	MeshMotionHandler.h	/^  double delta[3];$/;"	m	class:SpiralingMeshMotionHandler
delta	SmagorinskyLESTerm.h	/^  bool delta;$/;"	m	class:SmagorinskyLESTerm
delta	VMSLESTerm.h	/^  bool delta;$/;"	m	class:VMSLESTerm
delta	WaleLESTerm.h	/^  bool delta;$/;"	m	class:WaleLESTerm
deltaX	MeshMotionHandler.h	/^  Vec3D  deltaX;$/;"	m	class:RigidMeshMotionHandler
delta_given	IoData.h	/^	bool delta_given;$/;"	m	struct:BcsWallData
deltadensitythreshold	IoData.h	/^  int deltadensitythreshold;$/;"	m	struct:TsData
deltapressurethreshold	IoData.h	/^  int deltapressurethreshold;$/;"	m	struct:TsData
densFlag	IoData.h	/^  bool densFlag;$/;"	m	struct:SensitivityAnalysis
denseMatrixTimesDenseMatrixInPlace	DenseMatrixOps.h	/^void denseMatrixTimesDenseMatrixInPlace(Scalar m1[dim][dim], Scalar m2[dim][dim])$/;"	f
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDES
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDESmean
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKE
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKEmean
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermNS
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSA
density	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSAmean
density	IoData.h	/^  const char *density;$/;"	m	struct:LinePlot
density	IoData.h	/^  const char *density;$/;"	m	struct:Probes
density	IoData.h	/^  const char *density;$/;"	m	struct:TransientData
density	IoData.h	/^  double density;$/;"	m	struct:BcsFreeStreamData
density	IoData.h	/^  double density;$/;"	m	struct:BoundaryData
density	IoData.h	/^  double density;$/;"	m	struct:InitialConditions
density	IoData.h	/^  double density;$/;"	m	struct:ReferenceStateData
density	RefVal.h	/^  double density;$/;"	m	class:RefVal
density1	IoData.h	/^  double density1, velocity1, pressure1,temperature1;$/;"	m	struct:OneDimensionalInfo
density2	IoData.h	/^  double density2, velocity2, pressure2,temperature2;$/;"	m	struct:OneDimensionalInfo
densityMax	IoData.h	/^  double densityMin,densityMax;$/;"	m	struct:MultiGridData
densityMax	MultiGridEmbeddedTsDesc.h	/^  double densityMin, densityMax;$/;"	m	class:MultiGridEmbeddedTsDesc
densityMin	IoData.h	/^  double densityMin,densityMax;$/;"	m	struct:MultiGridData
densityMin	MultiGridEmbeddedTsDesc.h	/^  double densityMin, densityMax;$/;"	m	class:MultiGridEmbeddedTsDesc
depth	DistBcData.h	/^  double depth;$/;"	m	class:DistBcData
depth	IoData.h	/^  double depth;$/;"	m	struct:BcsHydroData
depth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    int depth;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
depth	PostFcn.h	/^  double depth;$/;"	m	class:PostFcnEuler
depth	VarFcn.h	/^  double depth;$/;"	m	class:VarFcn
derivativeOFalpha	IntersectorFRG/IntersectorFRG.C	/^double IntersectorFRG::derivativeOFalpha(Vec3D  xA, Vec3D  xB, Vec3D  xC, $/;"	f	class:IntersectorFRG
derivativeOFalpha	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::derivativeOFalpha(Vec3D  xA, Vec3D  xB, Vec3D  xC, $/;"	f	class:IntersectorPhysBAM
derivativeOFnormal	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::derivativeOFnormal(Vec3D  xA, Vec3D  xB, Vec3D  xC, $/;"	f	class:IntersectorFRG
derivativeOFnormal	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::derivativeOFnormal(Vec3D  xA, Vec3D  xB, Vec3D  xC, $/;"	f	class:IntersectorPhysBAM
derivativeofHOFSI	HigherOrderFSI.C	/^void HigherOrderFSI::derivativeofHOFSI(int l, int vertex, int i, $/;"	f	class:HigherOrderFSI
des	IoData.h	/^  DESModelData des;$/;"	m	struct:TurbulenceModelData
desc_a	ParallelRom.h	/^	int desc_a [9], desc_b [9];$/;"	m	class:ParallelRom
desc_b	ParallelRom.h	/^	int desc_a [9], desc_b [9];$/;"	m	class:ParallelRom
descriptorCase	SpaceOperator.h	/^  DescriptorCase descriptorCase;$/;"	m	class:SpaceOperator
descriptorCase	TimeState.h	/^  DescriptorCase descriptorCase;$/;"	m	class:TimeState
descriptor_form	TimeData.h	/^  int descriptor_form;$/;"	m	class:TimeData
destruct	RTree.h	/^  void destruct() $/;"	f	class:RTree
destructInternal	RTree.h	/^  void destructInternal(Node* nn) $/;"	f	class:RTree
determineFileName	NonlinearRom.C	/^void NonlinearRom<dim>::determineFileName(const char* fileNameInput, const char* fileNameExtension, const char* prefix, char*& fileName) { $/;"	f	class:NonlinearRom
determineNumResJacMat	NonlinearRom.C	/^void NonlinearRom<dim>::determineNumResJacMat() { $/;"	f	class:NonlinearRom
determinePath	NonlinearRom.C	/^void NonlinearRom<dim>::determinePath(char* fileName, int iCluster, char*& path) { $/;"	f	class:NonlinearRom
determinePrefixName	NonlinearRom.C	/^void NonlinearRom<dim>::determinePrefixName(const char* prefixInput, const char* prefixDefault, char*& prefix) { $/;"	f	class:NonlinearRom
determineSampleNodes	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::determineSampleNodes() {$/;"	f	class:GappyPreprocessing
determineSampleNodes	SurfMeshGen.h	/^	void determineSampleNodes() { ;}$/;"	f	class:SurfMeshGen
df	IoData.h	/^  DeformingData df;$/;"	m	struct:ForcedData
dfaU	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> dfaU;$/;"	m	class:FluidShapeOptimizationHandler
dfaX	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> dfaX;$/;"	m	class:FluidShapeOptimizationHandler
dfactor_param_t	arpack++/include/arlspdef.h	/^} dfactor_param_t;$/;"	t	typeref:struct:__anon40
dft	TsParameters.h	/^  complex<double>* dft;$/;"	m	class:TsParameters
dft_freqcutoff	IoData.h	/^  int dft_freqcutoff;$/;"	m	struct:CFLData
dft_freqcutoff	TsParameters.h	/^  int dft_freqcutoff;$/;"	m	class:TsParameters
dft_growth	IoData.h	/^  double dft_growth;$/;"	m	struct:CFLData
dft_growth	TsParameters.h	/^  double dft_growth;$/;"	m	class:TsParameters
dft_history	IoData.h	/^  int dft_history;$/;"	m	struct:CFLData
dft_history	TsParameters.h	/^  int dft_history;$/;"	m	class:TsParameters
dgcl	IoData.h	/^  DGCLData dgcl;$/;"	m	class:IoData
dgemm_	arpack++/include/arlnames.h	100;"	d
dgemm_	arpack++/include/arlnames.h	171;"	d
dgemv_	arpack++/include/arlnames.h	169;"	d
dgemv_	arpack++/include/arlnames.h	98;"	d
dger_	arpack++/include/arlnames.h	162;"	d
dger_	arpack++/include/arlnames.h	91;"	d
di	FSI/DynamicNodalTransfer.h	/^  DistInfo *di;$/;"	m	class:EmbeddedStructure
diag	BlockTridiagonalMatrix.h	/^  Scalar (*diag)[dim*dim];$/;"	m	class:BlockTridiagonalMatrix
diagMatPat	DistMatrix.h	/^  CommPattern<Scalar> *diagMatPat;$/;"	m	class:DistMat
diag_pivot_thresh	arpack++/include/arlspdef.h	/^    double diag_pivot_thresh;$/;"	m	struct:__anon40
diag_pivot_thresh	arpack++/include/arlspdef.h	/^    float diag_pivot_thresh;$/;"	m	struct:__anon39
dictionary	parser/Dictionary.C	/^Dictionary *dictionary = 0;$/;"	v
diff	LevelSet.h	/^  bool diff;$/;"	m	class:LevelSet
difference	EmbeddedFluidShapeOptimizationHandler.h	/^DistSVec<double,dim> difference;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
difference_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef int difference_type; \/\/ for stl$/;"	t	class:PhysBAM::ARRAY_BASE
diffpressure	IoData.h	/^  const char *diffpressure;$/;"	m	struct:Probes
diffpressure	IoData.h	/^  const char *diffpressure;$/;"	m	struct:TransientData
dihedralAngle	IoData.h	/^  double dihedralAngle;$/;"	m	struct:SchemeFixData
dim	AlternatingLeastSquare/als_lapack.h	/^    int nrow, ncol, dim;$/;"	m	class:AlternatingLeastSquare
dim	DenseMatrix.h	/^   int dim()    { return nrow;    }$/;"	f	class:GenFullM
dim	DenseMatrix.h	/^  int dim()    { return n;    }$/;"	f	class:SymFullM
dim	DistTimeState.C	/^  int dim;$/;"	m	struct:MultiphaseRiemannCopy	file:
dim	LocalRiemann.h	/^  int dim;$/;"	m	class:LocalRiemannLowMach
dim	OneDimensionalSolver.h	/^  const static int dim = 5, dimLS = 1;$/;"	m	class:OneDimensional
dim	SparseGrid.h	/^  int dim, out;           \/\/ number of inputs and outputs$/;"	m	class:SparseGrid
dimAdaptDegree	IoData.h	/^  double dimAdaptDegree;$/;"	m	struct:SparseGridData
dimAdaptDegree	SparseGrid.h	/^  double dimAdaptDegree;  \/\/ degree of dimensional adaptivity$/;"	m	class:SparseGrid
dimFlag	PostFcn.h	/^  bool dimFlag;$/;"	m	class:PostFcnEuler
dimGreedy	GappyPreprocessing.h	/^	int dimGreedy; \/\/ number of basis vectors used for greedy$/;"	m	class:GappyPreprocessing
dimGreedyAlgorithmFactor	IoData.h	/^  double dimGreedyAlgorithmFactor;$/;"	m	struct:GappyConstructionData
dimLS	OneDimensionalSolver.h	/^  const static int dim = 5, dimLS = 1;$/;"	m	class:OneDimensional
dim_	SparseGridCluster.h	/^  int dim_;$/;"	m	class:SparseGridCluster
dimension	IoData.h	/^  int dimension;$/;"	m	struct:EquationsData
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    enum WORKAROUND {dimension=d};$/;"	e	enum:PhysBAM::SIMPLEX_MESH::WORKAROUND
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    enum WORKAROUND {dimension=TV::m+T_SPIN::m,m=dimension};$/;"	e	enum:PhysBAM::TWIST::WORKAROUND
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    enum WORKAROUND1 {dimension=d};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND1
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    enum WORKAROUND1 {dimension=0};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND1
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    enum WORKAROUND1 {dimension=1};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND1
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    enum WORKAROUND1 {dimension=2};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND1
dimension	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    enum WORKAROUND1 {dimension=3};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND1
dir	IntersectorFRG/Geometry/KDTree.h	/^     int dir;$/;"	m	class:KDTree
dir	IntersectorFRG/Geometry/KDTree.h	/^    int dir;$/;"	m	class:DirComp
direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    bool direction; \/\/ false for -1 and true for 1 direction$/;"	m	class:PhysBAM::POINT_SIMPLEX_1D
direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV direction; \/\/ direction the ray sweeps out - unit vector$/;"	m	class:PhysBAM::RAY
direction_is_negative	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV_INT direction_is_negative;$/;"	m	class:PhysBAM::RAY
direction_x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    T1 x_not,direction_x;$/;"	m	class:PhysBAM::PARAMETRIC_LINE
direction_y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    T2 y_not,direction_y;$/;"	m	class:PhysBAM::PARAMETRIC_LINE
directional_coarsening_factor	IoData.h	/^  double directional_coarsening_factor;$/;"	m	struct:MultiGridData
directions	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/POINT_SIMPLEX_MESH.h	/^    ARRAY<bool> directions; \/\/ false for left and true for right$/;"	m	class:PhysBAM::POINT_SIMPLEX_MESH
directories	IoData.h	/^  NonlinearRomDirectoriesData directories;$/;"	m	struct:NonlinearRomFileSystemData
directstateflux3D	FluxFcnDescSG.C	/^void directstateflux3D(int type, VarFcnBase *vf, double* normal, $/;"	f
directstateflux3DDerivative	FluxFcnDescSG.C	/^void directstateflux3DDerivative(int type, VarFcnBase *vf, double* normal, double* dNormal,$/;"	f
disableConvergenceInfo	KspSolver.C	/^disableConvergenceInfo() {$/;"	f	class:GmresSolver
disableOutput	KspSolver.h	/^  void disableOutput() { output = NULL; } $/;"	f	class:KspSolver
disableRapidlyChangingValueCheck	DistTimeState.h	/^  void disableRapidlyChangingValueCheck() { checkForRapidlyChangingValues = false; }$/;"	f	class:DistTimeState
displacement	IoData.h	/^  const char *displacement;$/;"	m	struct:Probes
displacement	IoData.h	/^  const char *displacement;$/;"	m	struct:TransientData
displacementScaling	IoData.h	/^  double displacementScaling;$/;"	m	struct:AeroelasticData
displacements	IoData.h	/^  const char *displacements;$/;"	m	struct:InputData
displacements	TsInput.h	/^  char *displacements;$/;"	m	struct:TsInput
display	AlternatingLeastSquare/als_lapack.cpp	/^void AlternatingLeastSquare::display(){$/;"	f	class:AlternatingLeastSquare
dissipation	IoData.h	/^  enum Dissipation {SECOND_ORDER = 0, SIXTH_ORDER = 1} dissipation;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::Dissipation
dist	LevelSet/LevelSetStructure.h	/^  double dist; \/\/this is the unsigned distance. always >= 0.$/;"	m	struct:ClosestPoint
dist	NonlinearRomDatabaseConstruction.C	/^  double dist; \/\/ distance to second closest cluster$/;"	m	struct:sortStruct	file:
dist2othernode	IntersectorFRG/IntersectorFRG.C	/^  double dist2othernode;$/;"	m	class:ClosestTriangle	file:
distCalcsPrepro	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
distInfo	DistVector.h	/^  const DistInfo &distInfo;$/;"	m	class:DistSVec
distInfo	DistVector.h	/^  const DistInfo &distInfo;$/;"	m	class:DistVec
distInfo	ParallelRom.h	/^	const DistInfo &distInfo;$/;"	m	class:ParallelRom
distInfo	ProgrammedBurn.h	/^  const DistInfo* distInfo;$/;"	m	class:ProgrammedBurn
distIntersector	IntersectorFRG/IntersectorFRG.h	/^    DistIntersectorFRG &distIntersector;$/;"	m	class:IntersectorFRG
distIntersector	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistIntersectorPhysBAM &distIntersector;$/;"	m	class:IntersectorPhysBAM
distLSS	EmbeddedTsDesc.h	/^  DistLevelSetStructure *distLSS; \/\/<! tool for FS tracking (not necessarily a  "levelset solver".)$/;"	m	class:EmbeddedTsDesc
distLSS	LevelSet/MultiGridLevelSetStructure.h	/^    class DistMultiGridLevelSetStructure& distLSS;$/;"	m	class:MultiGridLevelSetStructure	typeref:class:MultiGridLevelSetStructure::DistMultiGridLevelSetStructure
distLSS	MeshMotionHandler.h	/^  DistLevelSetStructure *distLSS; \/\/<! interface finder (not necessarily a levelset solver).$/;"	m	class:EmbeddedALEMeshMotionHandler
distLSS	MeshMotionHandler.h	/^  DistLevelSetStructure *distLSS; \/\/<! interface finder (not necessarily a levelset solver).$/;"	m	class:EmbeddedMeshMotionHandler
distLSS	MultiPhysicsTsDesc.h	/^  DistLevelSetStructure *distLSS; \/\/<! tool for FS tracking (not necessarily using level-sets) $/;"	m	class:MultiPhysicsTsDesc
distToInterface	LevelSet/LevelSetStructure.h	/^    double distToInterface(double t, int n) const         { return distance[n]; } $/;"	f	class:LevelSetStructure
distance	LevelSet/LevelSetStructure.h	/^    DistVec<double> *distance;$/;"	m	class:DistLevelSetStructure
distance	LevelSet/LevelSetStructure.h	/^    Vec<double> &distance;$/;"	m	class:LevelSetStructure
distance	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<double> &distance;$/;"	m	class:MultiGridLevelSetStructure
distanceComparisons	IoData.h	/^  enum DistanceComparisons {DISTANCE_COMPARISONS_OFF = 0, DISTANCE_COMPARISONS_ON = 1} distanceComparisons;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::DistanceComparisons
distanceComparisons	NonlinearRom.h	/^  std::vector<std::vector<double> > distanceComparisons;  \/\/ this is "z_(m,p)" from Amsallem et al., INJME 2012, but with p<m$/;"	m	class:NonlinearRom
distanceComparisonsForIncrements	NonlinearRom.C	/^void NonlinearRom<dim>::distanceComparisonsForIncrements(Vec<double> dUromTimeIt, int currentCluster) {$/;"	f	class:NonlinearRom
distanceComparisonsForProjection	NonlinearRom.C	/^void NonlinearRom<dim>::distanceComparisonsForProjection(Vec<double> UromCurrentROB, int currentCluster) {$/;"	f	class:NonlinearRom
distanceFull	NonlinearRom.C	/^double NonlinearRom<dim>::distanceFull(DistSVec<double, dim> &U1, DistSVec<double, dim> &U2) {$/;"	f	class:NonlinearRom
distanceMatrixName	IoData.h	/^  const char *distanceMatrixName;$/;"	m	struct:NonlinearRomFilesData
distanceMatrixName	NonlinearRom.h	/^  char* distanceMatrixName;$/;"	m	class:NonlinearRom
distanceMetric	IoData.h	/^  enum DistanceMetric {DIST_EUCLIDEAN = 0, DIST_ANGLE = 1 } distanceMetric;$/;"	m	struct:NonlinearRomFileSystemData	typeref:enum:NonlinearRomFileSystemData::DistanceMetric
distancesToCentersFull	NonlinearRom.C	/^void NonlinearRom<dim>::distancesToCentersFull(DistSVec<double, dim> &vec, std::vector<double> &distances, int* closest) {$/;"	f	class:NonlinearRom
distributeBCs	GeoSource.C	/^void GeoSource::distributeBCs(SubDomain *sub, MapType &cl2LocNodeMap)$/;"	f	class:GeoSource
distributeColorMap	IntersectorPhysBAM/Mpi_Utilities.C	/^void distributeColorMap(Domain& domain, Communicator& com,const int* colorCount,const GLOBAL_SUBD_ID nGlobalSubDomains,const int* subDomainToProcessorMap,$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
distributeValue	IntersectorPhysBAM/Mpi_Utilities.h	/^void distributeValue(Communicator& com,T& localValue,T toDistribute)$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
dles	IoData.h	/^  DynamicLESData dles;$/;"	m	struct:LESModelData
dles	PostOperator.h	/^  DistDynamicLESTerm<dim> *dles;$/;"	m	class:PostOperator
dles	SpaceOperator.h	/^  DistDynamicLESTerm<dim> *dles;$/;"	m	class:SpaceOperator
dlest	DistDynamicLESTerm.h	/^  DynamicLESTerm *dlest;$/;"	m	class:DistDynamicLESTerm
dmesh	IoData.h	/^  DefoMeshMotionData dmesh;$/;"	m	class:IoData
dmmh	TsOutput.h	/^  DeformingMeshMotionHandler *dmmh;$/;"	m	class:TsOutput
dnds	LevelSet/LevelSetStructure.h	/^  Vec3D dnds;$/;"	m	struct:LevelSetResult
dnormsa	DistBcData.h	/^  DistSVec<double,1> *dnormsa;$/;"	m	class:DistBcDataSA
dnrm2_	arpack++/include/arlnames.h	163;"	d
dnrm2_	arpack++/include/arlnames.h	92;"	d
doErrorEstimation	ImplicitEmbeddedTsDesc.C	/^void ImplicitEmbeddedTsDesc<dim>::doErrorEstimation(DistSVec<double,dim> &U) $/;"	f	class:ImplicitEmbeddedTsDesc
doErrorEstimation	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::doErrorEstimation(DistSVec<double,dim> &U) $/;"	f	class:ImplicitLevelSetTsDesc
doErrorEstimation	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::doErrorEstimation(DistSVec<double,dim> &U)$/;"	f	class:ImplicitTsDesc
doGramSchmidt	IoData.h	/^  enum GramSchmidt {TRUE_GS = 1, FALSE_GS = 0} doGramSchmidt;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::GramSchmidt
doPrepro	IoData.h	/^  enum DoPrepro {DO_PREPRO_FALSE = 0, DO_PREPRO_TRUE = 1} doPrepro;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::DoPrepro
doPreproApproxMetricNonlinear	IoData.h	/^  enum DoPreproApproxMetricNonlinear {DO_PREPRO_APPROX_METRIC_NL_FALSE = 0, DO_PREPRO_APPROX_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinear;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::DoPreproApproxMetricNonlinear
doPreproApproxMetricNonlinearNNLS	IoData.h	/^  enum DoPreproApproxMetricNonlinearNNLS {DO_PREPRO_NNLS_METRIC_NL_FALSE = 0, DO_PREPRO_NNLS_METRIC_NL_TRUE = 1} doPreproApproxMetricNonlinearNNLS;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::DoPreproApproxMetricNonlinearNNLS
doPreproGNAT	IoData.h	/^  enum DoPreproGNAT {DO_PREPRO_GNAT_FALSE = 0, DO_PREPRO_GNAT_TRUE = 1} doPreproGNAT;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::DoPreproGNAT
doVerification	VarFcn.h	/^  bool doVerification() const{$/;"	f	class:VarFcn
doVerification	VarFcnBase.h	/^  virtual bool doVerification() const{ return (rhomin!=-1.e9||pmin!=-1.e9); }$/;"	f	class:VarFcnBase
doesFaceNeedGradientP1Function	FemEquationTerm.h	/^  virtual bool doesFaceNeedGradientP1Function() {$/;"	f	class:FemEquationTerm
doesFaceNeedGradientP1Function	FemEquationTermDesc.h	/^  bool doesFaceNeedGradientP1Function() { return false; }$/;"	f	class:FemEquationTermDESturb
doesFaceNeedGradientP1Function	FemEquationTermDesc.h	/^  bool doesFaceNeedGradientP1Function() { return false; }$/;"	f	class:FemEquationTermKEturb
doesFaceNeedGradientP1Function	FemEquationTermDesc.h	/^  bool doesFaceNeedGradientP1Function() { return false; }$/;"	f	class:FemEquationTermSAturb
doesFaceNeedGradientP1Function	PostFcn.h	/^  bool doesFaceNeedGradientP1Function() { return ((wallFcn) ? false : true); }$/;"	f	class:PostFcnNS
doesFaceNeedGradientP1Function	PostFcn.h	/^  virtual bool doesFaceNeedGradientP1Function() { return false; }$/;"	f	class:PostFcn
doesFaceTermExist	FemEquationTerm.h	/^  virtual bool doesFaceTermExist(int code) {$/;"	f	class:FemEquationTerm
doesFaceTermExist	FemEquationTermDesc.h	/^  bool doesFaceTermExist(int code) { return false; }$/;"	f	class:FemEquationTermDESturb
doesFaceTermExist	FemEquationTermDesc.h	/^  bool doesFaceTermExist(int code) { return false; }$/;"	f	class:FemEquationTermKEturb
doesFaceTermExist	FemEquationTermDesc.h	/^  bool doesFaceTermExist(int code) { return false; }$/;"	f	class:FemEquationTermSAturb
doesSourceTermExist	FemEquationTerm.h	/^  virtual bool doesSourceTermExist() { return false; }$/;"	f	class:FemEquationTerm
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermDES
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermDESturb
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermKE
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermKEturb
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermSA
doesSourceTermExist	FemEquationTermDesc.h	/^  bool doesSourceTermExist() { return true; }$/;"	f	class:FemEquationTermSAturb
dofType	BCApplier.h	/^    int **dofType;$/;"	m	class:BCApplier
dofTypeStep1	BCApplier.h	/^    int **dofTypeStep1; $/;"	m	class:BCApplier
dofTypeStep2	BCApplier.h	/^    int **dofTypeStep2;$/;"	m	class:BCApplier
dofnum	BCond.h	/^  int dofnum;$/;"	m	struct:BCond
dom	ReinitializeDistanceToWall.h	/^  Domain& dom;$/;"	m	class:ReinitializeDistanceToWall
dom	RestrictionMapping.h	/^  Domain *dom;$/;"	m	class:RestrictionMapping
domain	BCApplier.h	/^    Domain* domain;$/;"	m	class:BCApplier
domain	CorotSolver.h	/^  Domain *domain;$/;"	m	class:CorotSolver
domain	DistDynamicLESTerm.h	/^  Domain            *domain;$/;"	m	class:DistDynamicLESTerm
domain	DistDynamicVMSTerm.h	/^  Domain            *domain;$/;"	m	class:DistDynamicVMSTerm
domain	DistExactRiemannSolver.h	/^  Domain *domain;$/;"	m	class:DistExactRiemannSolver
domain	DistGeoState.h	/^  Domain *domain;$/;"	m	class:DistGeoState
domain	DistMacroCell.h	/^  Domain* domain;$/;"	m	class:DistMacroCellSet
domain	DistMvpMatrix.h	/^  Domain* domain;$/;"	m	class:DistMvpMatrix
domain	DistNodalGrad.h	/^  Domain *domain;$/;"	m	class:DistNodalGrad
domain	DistTimeState.h	/^  Domain *domain;$/;"	m	class:DistTimeState
domain	DistVMSLESTerm.h	/^  Domain            *domain;$/;"	m	class:DistVMSLESTerm
domain	EmbeddedCorotSolver.h	/^  Domain *domain;$/;"	m	class:EmbeddedCorotSolver
domain	FluidCollocationShapeOptimizationHandler.h	/^  Domain *domain;$/;"	m	class:FluidCollocationShapeOptimizationHandler
domain	FluidGnatShapeOptimizationHandler.h	/^  Domain *domain;$/;"	m	class:FluidGnatShapeOptimizationHandler
domain	FluidMetricShapeOptimizationHandler.h	/^  Domain *domain;$/;"	m	class:FluidMetricShapeOptimizationHandler
domain	FluidRomShapeOptimizationHandler.h	/^  Domain *domain;$/;"	m	class:FluidRomShapeOptimizationHandler
domain	FluidSelector.h	/^  Domain *domain;$/;"	m	class:FluidSelector
domain	FluidShapeOptimizationHandler.h	/^  Domain *domain;$/;"	m	class:FluidShapeOptimizationHandler
domain	GappyPreprocessing.h	/^	Domain &domain;$/;"	m	class:GappyPreprocessing
domain	HeatTransferHandler.h	/^  Domain* domain;$/;"	m	class:HeatTransferHandler
domain	IntersectorFRG/IntersectorFRG.h	/^    Domain *domain;$/;"	m	class:DistIntersectorFRG
domain	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Domain *domain;$/;"	m	class:DistIntersectorPhysBAM
domain	IoData.h	/^  enum Domain {TIME = 0, FREQUENCY = 1} domain;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::Domain
domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	m	struct:DeformingData	typeref:enum:DeformingData::Domain
domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	m	struct:HeavingData	typeref:enum:HeavingData::Domain
domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	m	struct:PitchingData	typeref:enum:PitchingData::Domain
domain	IoData.h	/^  enum Domain {VOLUME = 0, SURFACE = 1} domain;$/;"	m	struct:SpiralingData	typeref:enum:SpiralingData::Domain
domain	KspBinaryOutput.h	/^  Domain* domain;$/;"	m	class:KspBinaryOutput
domain	KspPrec.h	/^  Domain* domain;$/;"	m	class:IluPrec
domain	LevelSet.h	/^  Domain *domain;$/;"	m	class:LevelSet
domain	LevelSet/MultiGridLevelSetStructure.h	/^  Domain* domain;$/;"	m	class:DistMultiGridLevelSetStructure
domain	MeshMotionHandler.h	/^  Domain *domain;$/;"	m	class:MeshMotionHandler
domain	MeshMotionSolver.h	/^  Domain *domain;$/;"	m	class:TetMeshMotionSolver
domain	Modal.h	/^    Domain &domain;$/;"	m	class:ModalSolver
domain	MultiGridKernel.h	/^  Domain* domain;$/;"	m	class:MultiGridKernel
domain	MultiGridLevel.h	/^    Domain& domain;$/;"	m	class:MultiGridLevel
domain	MultiGridPrec.h	/^  Domain* domain;$/;"	m	class:MultiGridPrec
domain	NonlinearRom.h	/^  Domain& domain;$/;"	m	class:NonlinearRom
domain	NonlinearRomOffline.h	/^    Domain &domain;$/;"	m	class:NonlinearRomOfflineSolver
domain	ParallelRom.h	/^	Domain &domain;$/;"	m	class:ParallelRom
domain	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    RANGE<TV_INT> domain;$/;"	m	class:PhysBAM::ARRAY_BASE
domain	PostOperator.h	/^  Domain *domain;$/;"	m	class:PostOperator
domain	SpaceOperator.h	/^  Domain *domain;$/;"	m	class:SpaceOperator
domain	TsDesc.h	/^  Domain *domain;$/;"	m	class:TsDesc
domain	TsOutput.h	/^  Domain *domain;$/;"	m	class:TsOutput
done	ReinitializeDistanceToWall.h	/^  DistVec<bool> done;$/;"	m	class:ReinitializeDistanceToWall
dot	arpack++/include/blas1c.h	/^inline double dot(const ARint &n, const double dx[], const ARint &incx,$/;"	f
dot	arpack++/include/blas1c.h	/^inline float dot(const ARint &n, const float dx[], const ARint &incx,$/;"	f
dotProduct	RestrictionMapping.C	/^RestrictionMapping<dim>::dotProduct(const DistSVec<double, dim> & originVec, const DistSVec<double, dim> & restrictedVec) const {$/;"	f	class:RestrictionMapping
dotc	arpack++/include/blas1c.h	/^inline arcomplex<double> dotc(const ARint &n, const arcomplex<double> dx[], $/;"	f
dotc	arpack++/include/blas1c.h	/^inline arcomplex<float> dotc(const ARint &n, const arcomplex<float> dx[], $/;"	f
dotu	arpack++/include/blas1c.h	/^inline arcomplex<double> dotu(const ARint &n, const arcomplex<double> dx[], $/;"	f
dotu	arpack++/include/blas1c.h	/^inline arcomplex<float> dotu(const ARint &n, const arcomplex<float> dx[], $/;"	f
doubleMap	parser/ParseTree.h	/^    std::map<Token,double> doubleMap;$/;"	m	class:ParseTree
doublerand	utils/Predicate.C	/^double doublerand()$/;"	f
dphi	DistNodalGrad.h	/^  DistSVec<double,dim> *dphi;$/;"	m	class:DistNodalGrad
dpinfty	PostFcn.h	/^  double dpinfty;$/;"	m	class:PostFcnEuler
dplus	IoData.h	/^  const char *dplus;$/;"	m	struct:TransientData
drop_tol	arpack++/include/arlspdef.h	/^    double drop_tol;$/;"	m	struct:__anon40
drop_tol	arpack++/include/arlspdef.h	/^    float drop_tol;$/;"	m	struct:__anon39
drot_	arpack++/include/arlnames.h	168;"	d
drot_	arpack++/include/arlnames.h	97;"	d
dscal_	arpack++/include/arlnames.h	161;"	d
dscal_	arpack++/include/arlnames.h	90;"	d
dsvdc	f77src/dsvdc.f	/^      subroutine dsvdc(/;"	s
dsymv_	arpack++/include/arlnames.h	164;"	d
dsymv_	arpack++/include/arlnames.h	93;"	d
dsyr2_	arpack++/include/arlnames.h	167;"	d
dsyr2_	arpack++/include/arlnames.h	96;"	d
dt	DistTimeState.h	/^  DistVec<double> *dt;			\/\/actual   time stepping$/;"	m	class:DistTimeState
dt	FSI/DynamicNodalTransfer.h	/^  double dt, tMax;$/;"	m	class:EmbeddedStructure
dt	ImplicitRomPostproTsDesc.h	/^  double dt;$/;"	m	class:ImplicitRomPostproTsDesc
dt	LevelSet.h	/^  DistVec<double> dt;			\/\/ pseudo-time steps$/;"	m	class:LevelSet
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:AccMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:DeformingMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:EmbeddedALEMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:HeavingMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:PitchingMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:RigidRollMeshMotionHandler
dt	MeshMotionHandler.h	/^  double dt;$/;"	m	class:SpiralingMeshMotionHandler
dt	Modal.h	/^    double dt;$/;"	m	class:ModalSolver
dt	ODEIntegrator.h	/^  double dt;$/;"	m	class:ODEIntegrator
dt	StructExc.h	/^  double dt;$/;"	m	class:StructExc
dt	TimeState.h	/^  Vec<double> &dt;$/;"	m	class:TimeState
dt0	Modal.h	/^    double dt0;$/;"	m	class:ModalSolver
dtMin	DistTimeState.h	/^  double dtMin;$/;"	m	class:DistTimeState
dt_coeff	DistTimeState.h	/^  double dt_coeff;$/;"	m	class:DistTimeState
dt_coeff_count	DistTimeState.h	/^  int dt_coeff_count;$/;"	m	class:DistTimeState
dt_imposed	TimeData.h	/^  double dt_imposed;$/;"	m	class:TimeData
dt_imposed	TsParameters.h	/^  double dt_imposed;$/;"	m	class:TsParameters
dt_n	TimeData.h	/^  double dt_n;$/;"	m	class:TimeData
dt_nm1	IoData.h	/^  double dt_nm1;$/;"	m	struct:RestartParametersData
dt_nm1	TimeData.h	/^  double dt_nm1;$/;"	m	class:TimeData
dt_nm2	IoData.h	/^  double dt_nm2;$/;"	m	struct:RestartParametersData
dt_nm2	TimeData.h	/^  double dt_nm2;$/;"	m	class:TimeData
dt_tmax	FSI/DynamicNodalTransfer.h	/^        double *dt_tmax;$/;"	m	class:DynamicNodalTransfer
dt_tmax	FSI/DynamicNodalTransfer.h	/^  double dt_tmax[2];$/;"	m	class:EmbeddedStructure
dtau	DistTimeState.h	/^  DistVec<double> *dtau;		\/\/dual time stepping$/;"	m	class:DistTimeState
dtau	TimeState.h	/^  Vec<double> &dtau;$/;"	m	class:TimeState
dtau_switch	TimeData.h	/^  double dtau_switch;$/;"	m	class:TimeData
dtf	EmbeddedTsDesc.h	/^  double dtf;     \/\/<! fluid time-step$/;"	m	class:EmbeddedTsDesc
dtf	MultiPhysicsTsDesc.h	/^  double dtf;     \/\/<! fluid time-step$/;"	m	class:MultiPhysicsTsDesc
dtf0	MeshMotionHandler.h	/^  double dtf0;$/;"	m	class:MeshMotionHandler
dtfLeft	EmbeddedTsDesc.h	/^  double dtfLeft; \/\/<! time until next structure time-step is reached.$/;"	m	class:EmbeddedTsDesc
dtfLeft	MultiPhysicsTsDesc.h	/^  double dtfLeft; \/\/<! time until next structure time-step is reached.$/;"	m	class:MultiPhysicsTsDesc
dtimedMach	RefVal.h	/^  double dtimedMach;$/;"	m	class:RefVal
dtmp	DistBcData.h	/^  DistSVec<double,2> *dtmp;$/;"	m	class:DistBcDataSA
dtmp	DistBcData.h	/^  DistSVec<double,3> *dtmp;$/;"	m	class:DistBcDataKE
dtmpsa	DistBcData.h	/^  DistSVec<double,dim> *dtmpsa;$/;"	m	class:DistBcDataSA
dtrefdMach	DistBcData.h	/^  double dtrefdMach;$/;"	m	class:DistBcData
dtrsm_	arpack++/include/arlnames.h	101;"	d
dtrsm_	arpack++/include/arlnames.h	172;"	d
dtrsv_	arpack++/include/arlnames.h	170;"	d
dtrsv_	arpack++/include/arlnames.h	99;"	d
dts	EmbeddedTsDesc.h	/^  double dts;     \/\/<! structure time-step$/;"	m	class:EmbeddedTsDesc
dts	FSI/DynamicNodalTransfer.h	/^        double dts;$/;"	m	class:DynamicNodalTransfer
dts	MeshMotionHandler.h	/^  double dts;            \/\/<! structure time-step.$/;"	m	class:EmbeddedMeshMotionHandler
dts	MultiPhysicsTsDesc.h	/^  double dts;     \/\/<! structure time-step$/;"	m	class:MultiPhysicsTsDesc
dual_traversal_stack	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    mutable STACK<VECTOR<int,2> > dual_traversal_stack;$/;"	m	class:PhysBAM::BOX_HIERARCHY
dualtimecfl	IoData.h	/^  double dualtimecfl;$/;"	m	struct:CFLData
dualtimecfl	IoData.h	/^  double dualtimecfl;$/;"	m	struct:TsData
dualtimecfl	TsParameters.h	/^  double dualtimecfl;$/;"	m	class:TsParameters
dualtimestepping	IoData.h	/^  enum DualTimeStepping {OFF = 0, ON = 1} dualtimestepping;$/;"	m	struct:TsData	typeref:enum:TsData::DualTimeStepping
dummy	tools/loader.C	/^void dummy()$/;"	f
dummyClustering	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::dummyClustering(){$/;"	f	class:EmbeddedAlternatingLeastSquare
dummyPhi	ReinitializeDistanceToWall.h	/^  DistSVec<double,dimLS> dummyPhi;$/;"	m	class:ReinitializeDistanceToWall
dummyPointMap	IoData.h	/^  ObjectMap<DummyPointData>  dummyPointMap;$/;"	m	struct:MultiInitialConditionsData
dummycp	LevelSet/MultiGridLevelSetStructure.h	/^  DistVec<ClosestPoint>* dummycp;$/;"	m	class:DistMultiGridLevelSetStructure
dumpColorsToFile	IntersectorPhysBAM/FloodFill.C	/^void FloodFill::dumpColorsToFile(const std::string& prefix,SubDomain& subDomain,const SVec<double,3>& X,Vec<int>& color){$/;"	f	class:FloodFill
dump_stack_trace	IntersectorPhysBAM/Mpi_Utilities.C	/^void dump_stack_trace()$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
dunavant_degree	Dunavant.C	/^int dunavant_degree ( int rule )$/;"	f
dunavant_order_num	Dunavant.C	/^int dunavant_order_num ( int rule )$/;"	f
dunavant_rule	Dunavant.C	/^void dunavant_rule ( int rule, int order_num, double xy[], double w[] )$/;"	f
dunavant_rule_num	Dunavant.C	/^int dunavant_rule_num ( )$/;"	f
dunavant_suborder	Dunavant.C	/^int *dunavant_suborder ( int rule, int suborder_num )$/;"	f
dunavant_suborder_num	Dunavant.C	/^int dunavant_suborder_num ( int rule )$/;"	f
dunavant_subrule	Dunavant.C	/^void dunavant_subrule ( int rule, int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_01	Dunavant.C	/^void dunavant_subrule_01 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_02	Dunavant.C	/^void dunavant_subrule_02 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_03	Dunavant.C	/^void dunavant_subrule_03 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_04	Dunavant.C	/^void dunavant_subrule_04 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_05	Dunavant.C	/^void dunavant_subrule_05 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_06	Dunavant.C	/^void dunavant_subrule_06 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_07	Dunavant.C	/^void dunavant_subrule_07 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_08	Dunavant.C	/^void dunavant_subrule_08 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_09	Dunavant.C	/^void dunavant_subrule_09 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_10	Dunavant.C	/^void dunavant_subrule_10 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_11	Dunavant.C	/^void dunavant_subrule_11 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_12	Dunavant.C	/^void dunavant_subrule_12 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_13	Dunavant.C	/^void dunavant_subrule_13 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_14	Dunavant.C	/^void dunavant_subrule_14 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_15	Dunavant.C	/^void dunavant_subrule_15 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_16	Dunavant.C	/^void dunavant_subrule_16 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_17	Dunavant.C	/^void dunavant_subrule_17 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_18	Dunavant.C	/^void dunavant_subrule_18 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_19	Dunavant.C	/^void dunavant_subrule_19 ( int suborder_num, double suborder_xyz[],$/;"	f
dunavant_subrule_20	Dunavant.C	/^void dunavant_subrule_20 ( int suborder_num, double suborder_xyz[],$/;"	f
duplicateSnaps	NonlinearRom.h	/^  bool duplicateSnaps;$/;"	m	class:NonlinearRom
duplicateSnapshots	IoData.h	/^  enum DuplicateSnapshots {DUPLICATE_SNAPSHOTS_FALSE = 0, DUPLICATE_SNAPSHOTS_TRUE = 1} duplicateSnapshots;$/;"	m	struct:NonlinearRomFilesData	typeref:enum:NonlinearRomFilesData::DuplicateSnapshots
dvelocitydMach	RefVal.h	/^  double dvelocitydMach;$/;"	m	class:RefVal
dvms	IoData.h	/^  DynamicVMSData dvms;$/;"	m	struct:LESModelData
dvms	PostOperator.h	/^  DistDynamicVMSTerm<dim> *dvms;$/;"	m	class:PostOperator
dvms	SpaceOperator.h	/^  DistDynamicVMSTerm<dim> *dvms;$/;"	m	class:SpaceOperator
dvms	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
dvmst	DistDynamicVMSTerm.h	/^  DynamicVMSTerm    *dvmst;$/;"	m	class:DistDynamicVMSTerm
dvrefdMach	DistBcData.h	/^  double dvrefdMach;$/;"	m	class:DistBcData
dwii	DistNodalGrad.h	/^  DistSVec<double,3> *dwii;$/;"	m	class:DistNodalGrad
dwij	DistNodalGrad.h	/^  DistSVec<double,3> *dwij;$/;"	m	class:DistNodalGrad
dwji	DistNodalGrad.h	/^  DistSVec<double,3> *dwji;$/;"	m	class:DistNodalGrad
dx	FSI/DynamicNodalTransfer.h	/^  double dx, dy, dz;$/;"	m	class:EmbeddedStructure
dx	KspSolver.h	/^  VecType dx, r;$/;"	m	class:RichardsonSolver
dx	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
dx	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
dx	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
dx1	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,neq1> R1,dx1;$/;"	m	class:MultiGridSegTsDesc
dx2	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,neq2> R2,dx2;$/;"	m	class:MultiGridSegTsDesc
dy	FSI/DynamicNodalTransfer.h	/^  double dx, dy, dz;$/;"	m	class:EmbeddedStructure
dynNodalTransfer	EmbeddedTsDesc.h	/^  DynamicNodalTransfer *dynNodalTransfer;$/;"	m	class:EmbeddedTsDesc
dynNodalTransfer	MeshMotionHandler.h	/^  DynamicNodalTransfer *dynNodalTransfer; $/;"	m	class:EmbeddedMeshMotionHandler
dynNodalTransfer	MultiPhysicsTsDesc.h	/^  DynamicNodalTransfer *dynNodalTransfer;$/;"	m	class:MultiPhysicsTsDesc
dynamicViscosity	IoData.h	/^  double dynamicViscosity;$/;"	m	struct:ViscosityModelData
dz	FSI/DynamicNodalTransfer.h	/^  double dx, dy, dz;$/;"	m	class:EmbeddedStructure
dzasum_	arpack++/include/arlnames.h	117;"	d
dzasum_	arpack++/include/arlnames.h	188;"	d
dznrm2_	arpack++/include/arlnames.h	121;"	d
dznrm2_	arpack++/include/arlnames.h	192;"	d
e0	IoData.h	/^  double e0;$/;"	m	struct:ProgrammedBurnData
eWallWithSI	LevelSet/LevelSetStructure.h	/^	 int  eWallWithSI(int n) const { return TriID_SI[n]; }$/;"	f	class:LevelSetStructure
eddyLengthScale	IoData.h	/^  double eddyLengthScale;$/;"	m	struct:NonlinearRomOnlineData
eddyvis	IoData.h	/^  const char *eddyvis;$/;"	m	struct:TransientData
edge	PolygonReconstructionData.h	/^    int edge[4];$/;"	m	struct:PolygonReconstructionData
edgeArea	MultiGridLevel.h	/^    DistVec<double>* edgeArea;$/;"	m	class:MultiGridLevel
edgeAreaPattern	MultiGridLevel.h	/^    CommPattern<double> * edgeAreaPattern;$/;"	m	class:MultiGridLevel
edgeDistInfo	Domain.h	/^  DistInfo *edgeDistInfo;$/;"	m	class:Domain
edgeDistInfo	MultiGridLevel.h	/^    DistInfo * edgeDistInfo;$/;"	m	class:MultiGridLevel
edgeDistInfoMF	Domain.h	/^  DistInfo *edgeDistInfoMF;$/;"	m	class:Domain
edgeEnd	ElemTet.h	/^  int  edgeEnd(int i, int k) { return edgeEndTet[i][k]; }$/;"	f	class:ElemTet
edgeEnd	FaceTria.h	/^  int  edgeEnd(int i, int k) { return edgeEndT[i][k]; }$/;"	f	class:FaceTria
edgeEndT	FaceTria.h	/^  static const int edgeEndT[Face::MaxNumNd][2];$/;"	m	class:FaceTria
edgeEndT	FaceTriaCore.C	/^const int FaceTria::edgeEndT[Face::MaxNumNd][2] = { {0,1}, {1,2}, {2,0}, {-1,-1} };$/;"	m	class:FaceTria	file:
edgeEndTet	ElemTet.h	/^  static const int edgeEndTet[6][2];$/;"	m	class:ElemTet
edgeEndTet	ElemTetCore.C	/^const int ElemTet::edgeEndTet[6][2]  = { {0,1}, {0,2}, {0,3}, {1,2}, {1,3}, {2,3} };$/;"	m	class:ElemTet	file:
edgeFace	ElemTet.h	/^  int  edgeFace(int i, int k) { return edgeFaceTet[i][k]; }$/;"	f	class:ElemTet
edgeFaceTet	ElemTet.h	/^  static const int edgeFaceTet[6][2];$/;"	m	class:ElemTet
edgeFaceTet	ElemTetCore.C	/^const int ElemTet::edgeFaceTet[6][2] = { {0,1}, {2,0}, {1,2}, {0,3}, {3,1}, {2,3} };$/;"	m	class:ElemTet	file:
edgeIntersectsStructure	LevelSet/LevelSetStructure.h	/^    bool edgeIntersectsStructure(double t, int eij) const { return edge_intersects[eij]; }$/;"	f	class:LevelSetStructure
edgeLength	Edge.h	/^  double* edgeLength;$/;"	m	class:EdgeSet
edgeNorm	DistGeoState.h	/^  DistVec<Vec3D>  *edgeNorm;$/;"	m	class:DistGeoState
edgeNorm	GeoState.h	/^  Vec<Vec3D> &edgeNorm;$/;"	m	class:GeoState
edgeNormVel	DistGeoState.h	/^  DistVec<double> *edgeNormVel;$/;"	m	class:DistGeoState
edgeNormVel	GeoState.h	/^  Vec<double> &edgeNormVel;$/;"	m	class:GeoState
edgeNormVel_nm1	DistGeoState.h	/^  DistVec<double> *edgeNormVel_nm1;$/;"	m	class:DistGeoState
edgeNormVel_nm2	DistGeoState.h	/^  DistVec<double> *edgeNormVel_nm2;$/;"	m	class:DistGeoState
edgeNorm_nm1	DistGeoState.h	/^  DistVec<Vec3D>  *edgeNorm_nm1;$/;"	m	class:DistGeoState
edgeNorm_nm2	DistGeoState.h	/^  DistVec<Vec3D>  *edgeNorm_nm2;$/;"	m	class:DistGeoState
edgeNormals	MultiGridLevel.h	/^    DistVec<Vec3D>* edgeNormals;$/;"	m	class:MultiGridLevel
edgeNum	ElemTet.h	/^  int& edgeNum(int i) { return edgeNumTet[i]; }$/;"	f	class:ElemTet
edgeNum	FaceTria.h	/^  int& edgeNum(int i) { return edgeNumT[i]; }$/;"	f	class:FaceTria
edgeNum	SubDomain.h	/^  int glLeft, glRight, edgeNum, sign;$/;"	m	struct:EdgeDef
edgeNumT	FaceTria.h	/^  int edgeNumT[3];$/;"	m	class:FaceTria
edgeNumTet	ElemTet.h	/^  int edgeNumTet[6];$/;"	m	class:ElemTet
edgePat	Domain.h	/^  CommPattern<double> *edgePat;$/;"	m	class:Domain
edgeProject	IntersectorFRG/IntersectorFRG.C	/^double ClosestTriangle::edgeProject(Vec3D x0, int n1, int n2, double &alpha) const$/;"	f	class:ClosestTriangle
edgeProject	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::edgeProject(Vec3D x0, Vec3D& xA, Vec3D& xB, double &alpha) const$/;"	f	class:IntersectorPhysBAM
edgeProject	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::edgeProject(Vec3D x0, int n1, int n2, double &alpha) const$/;"	f	class:IntersectorPhysBAM
edgeVecPattern	MultiGridLevel.h	/^    CommPattern<double> * edgeVecPattern;$/;"	m	class:MultiGridLevel
edgeWithSI	LevelSet/LevelSetStructure.h	/^	 bool edgeWithSI( int n) const { return edge_SI[n];  } $/;"	f	class:LevelSetStructure
edgeWithVertex	PolygonReconstructionData.h	/^    int edgeWithVertex[4][2];$/;"	m	struct:PolygonReconstructionData
edge_SI	LevelSet/LevelSetStructure.h	/^    DistVec<bool> *edge_SI;   \/\/ d2d$/;"	m	class:DistLevelSetStructure
edge_SI	LevelSet/LevelSetStructure.h	/^    Vec<bool>   &edge_SI; \/\/ ID of the edge that contains the SI $/;"	m	class:LevelSetStructure
edge_intersects	LevelSet/LevelSetStructure.h	/^    DistVec<bool> *edge_intersects;$/;"	m	class:DistLevelSetStructure
edge_intersects	LevelSet/LevelSetStructure.h	/^    Vec<bool> &edge_intersects;$/;"	m	class:LevelSetStructure
edge_intersects	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<bool> &edge_intersects;$/;"	m	class:MultiGridLevelSetStructure
edge_triangles	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    ARRAY<ARRAY<int> >* edge_triangles; \/\/ for each edge, the indices of the incident triangles$/;"	m	class:PhysBAM::TRIANGLE_MESH
edges	DistMvpMatrix.h	/^  EdgeSet** edges;$/;"	m	class:DistMvpMatrix
edges	IntersectorFRG/IntersectorFRG.h	/^    EdgeSet &edges;$/;"	m	class:IntersectorFRG
edges	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    EdgeSet &edges;$/;"	m	class:IntersectorPhysBAM
edges	LevelSet/MultiGridLevelSetStructure.h	/^    EdgeSet &edges;$/;"	m	class:MultiGridLevelSetStructure
edges	MultiGridLevel.h	/^    EdgeSet ** edges;$/;"	m	class:MultiGridLevel
edges	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/ORIENTED_BOX.h	/^    MATRIX<T,d> edges; \/\/ principal edges of the box, emanating from the corner$/;"	m	class:PhysBAM::ORIENTED_BOX
edges	SubDomain.h	/^  EdgeSet  edges;$/;"	m	class:SubDomain
edgesConnectedToSampleNode	Edge.h	/^  std::vector<int> edgesConnectedToSampleNode;	\/\/ for Gappy ROM$/;"	m	class:EdgeSet
edgesTwoLayersSampleNode	Edge.h	/^  std::vector<int> edgesTwoLayersSampleNode;	\/\/ for Gappy ROM$/;"	m	class:EdgeSet
efficient	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    static const bool efficient=EFFICIENT_OR_VOID<A>::value && EFFICIENT_OR_VOID<B>::value;$/;"	m	struct:PhysBAM::__anon21::ASSERT_EFFICIENT
egrad	DistDynamicVMSTerm.h	/^  DistEdgeGrad<dim> *egrad;$/;"	m	class:DistDynamicVMSTerm
egrad	SpaceOperator.h	/^  DistEdgeGrad<dim> *egrad;$/;"	m	class:SpaceOperator
egradLS	SpaceOperator.h	/^  DistEdgeGrad<dimLS>          *egradLS; \/\/d2d$/;"	m	class:MultiPhaseSpaceOperator
eigSolv	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
elapsed	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^        double start,elapsed,accumulator;$/;"	m	struct:PhysBAM::TIMER::DATA
elemNum	Face.h	/^  int elemNum;$/;"	m	class:Face
elemToNode	GappyPreprocessing.h	/^  std::vector <int> *(elemToNode [4]);	\/\/ elemToNode[iNode][iSampleNode][iEle] is the global node number of the iNode attached to the iEle element of the iSampleNode island $/;"	m	class:GappyPreprocessing::std
elemToNodeMap	GappyPreprocessing.h	/^  boost::unordered_map <int, StaticArray <int, 4> > elemToNodeMap;	\/\/ key: global elem #, values: global node #s$/;"	m	class:GappyPreprocessing
elemType	FSI/CrackingSurface.h	/^  const int elemType; \/\/currently only support quadrangles.$/;"	m	class:CrackingSurface
elemType	FSI/DynamicNodalTransfer.h	/^  int elemType;$/;"	m	class:EmbeddedStructure
elem_	SparseGrid.h	/^    int *elem_;$/;"	m	class:SparseGrid::Heap
element	IoData.h	/^  enum Element {LINEAR_FE = 0, NON_LINEAR_FE = 1, TORSIONAL_SPRINGS = 2, BALL_VERTEX = 3, NL_BALL_VERTEX = 4 } element;$/;"	m	struct:DefoMeshMotionData	typeref:enum:DefoMeshMotionData::Element
element_edges	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    ARRAY<VECTOR<int,3> >* element_edges; \/\/ array of 3 indices for each triangle - edge element_edges(j,i) is edge j in triangle i$/;"	m	class:PhysBAM::TRIANGLE_MESH
elements	GappyPreprocessing.h	/^  std::vector <int> *elements;		\/\/ elements[iSampleNode][iEle] is the global element number of the iEle element in the iSampleNode island $/;"	m	class:GappyPreprocessing
elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    ARRAY<VECTOR<int,d+1> > elements; \/\/ array of d+1 indices for each simplex - elements(i,t) is i'th index in simplex t$/;"	m	class:PhysBAM::SIMPLEX_MESH
elems	Elem.h	/^  Elem **elems;$/;"	m	class:ElemSet
elems	HigherOrderFSI.h	/^   ElemSet* elems;$/;"	m	class:HigherOrderFSI
elems	HigherOrderMultiFluid.h	/^   ElemSet* elems;$/;"	m	class:HigherOrderMultiFluid
elems	SubDomain.h	/^  ElemSet &elems;$/;"	m	class:SubDomain
elemsConnectedToSampleNode	Elem.h	/^	std::vector<int> elemsConnectedToSampleNode;	\/\/ for Gappy ROM$/;"	m	class:ElemSet
eleventh	WallFcn.h	/^  const static double eleventh;$/;"	m	class:WallFcn
eleventh	WallFcnCore.C	/^const double WallFcn::eleventh = 1.0 \/ 11.0;$/;"	m	class:WallFcn	file:
embed	IoData.h	/^  EmbeddedFramework embed;$/;"	m	class:IoData
embedCom	Domain.h	/^  Communicator *embedCom;$/;"	m	class:Domain
embedIC	IoData.h	/^  MultiInitialConditionsData embedIC;$/;"	m	struct:EmbeddedFramework
embedPhaseChange	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
embeddedALS	ImplicitEmbeddedRomTsDesc.h	/^    EmbeddedAlternatingLeastSquare<dim> embeddedALS;$/;"	m	class:ImplicitEmbeddedRomTsDesc
embeddedALS	IoData.h	/^    EmbeddedAlternatingLeastSquareData embeddedALS;$/;"	m	struct:ROBConstructionData
embeddedB	ImplicitEmbeddedTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitEmbeddedTsDesc
embeddedB	ImplicitLevelSetTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitLevelSetTsDesc
embeddedB	ImplicitMultiPhysicsTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitMultiPhysicsTsDesc
embeddedB1	ImplicitEmbeddedSegTsDesc.h	/^  DistEmbeddedVec<double,neq1> embeddedB1,embeddeddQ1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
embeddedB2	ImplicitEmbeddedSegTsDesc.h	/^  DistEmbeddedVec<double,neq2> embeddedB2,embeddeddQ2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
embeddedMeshByFEM	FSI/DynamicNodalTransfer.h	/^        bool embeddedMeshByFEM() {return structure.embeddedMeshByFEM();}$/;"	f	class:DynamicNodalTransfer
embeddedMeshByFEM	FSI/DynamicNodalTransfer.h	/^  bool embeddedMeshByFEM() {return getSurfFromFEM;}$/;"	f	class:EmbeddedStructure
embeddedSurface	IoData.h	/^  const char *embeddedSurface;$/;"	m	struct:InputData
embeddedU	ImplicitEmbeddedTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitEmbeddedTsDesc
embeddedU	ImplicitLevelSetTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitLevelSetTsDesc
embeddedU	ImplicitMultiPhysicsTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitMultiPhysicsTsDesc
embeddeddQ	ImplicitEmbeddedTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitEmbeddedTsDesc
embeddeddQ	ImplicitLevelSetTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitLevelSetTsDesc
embeddeddQ	ImplicitMultiPhysicsTsDesc.h	/^  DistEmbeddedVec<double,dim> embeddedU,embeddedB,embeddeddQ;$/;"	m	class:ImplicitMultiPhysicsTsDesc
embeddeddQ1	ImplicitEmbeddedSegTsDesc.h	/^  DistEmbeddedVec<double,neq1> embeddedB1,embeddeddQ1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
embeddeddQ2	ImplicitEmbeddedSegTsDesc.h	/^  DistEmbeddedVec<double,neq2> embeddedB2,embeddeddQ2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
embeddedpositions	IoData.h	/^  const char *embeddedpositions;$/;"	m	struct:InputData
embeddedpositions	IoData.h	/^  const char *embeddedpositions;$/;"	m	struct:RestartData
embeddedsurface	IoData.h	/^  const char *embeddedsurface;$/;"	m	struct:TransientData
embeddedsurface	TsOutput.h	/^  char *embeddedsurface;$/;"	m	class:TsOutput
embeddedsurfaceCf	TsOutput.h	/^  char *embeddedsurfaceCf;$/;"	m	class:TsOutput
embeddedsurfaceCp	TsOutput.h	/^  char *embeddedsurfaceCp;$/;"	m	class:TsOutput
embedforce	Timer.h	/^		eulerFSI, embedforce, walldistance, lsreinitialization, readSnapshotFile,$/;"	e	enum:Timer::TimerIndex
embmeshmatch	IoData.h	/^  const char *embmeshmatch;$/;"	m	struct:InputData
embsurfmatch	IoData.h	/^  const char *embsurfmatch;$/;"	m	struct:InputData
emmh	EmbeddedTsDesc.h	/^  MeshMotionHandler* emmh;$/;"	m	class:EmbeddedTsDesc
enableHHTerms	GenMatrix.h	/^  virtual void enableHHTerms(int) { }$/;"	f	class:GenMat
enableHHTerms	MvpMatrix.h	/^  void enableHHTerms(int subLen) {$/;"	f	class:MvpMat
end	LevelSet/LevelSetStructure.h	/^   iterator end() { return iterator(xi+3, trNodes+3); }$/;"	f	struct:LevelSetResult
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T* end() \/\/ for stl$/;"	f	class:PhysBAM::ARRAY_BASE
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    const T* end() const \/\/ for stl$/;"	f	class:PhysBAM::ARRAY_BASE
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    ENTRY* end()$/;"	f	class:PhysBAM::HASHTABLE
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    const ENTRY* end() const$/;"	f	class:PhysBAM::HASHTABLE
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    T* end() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    const T* end() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T* end() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    const T* end() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T* end() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    const T* end() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T* end() \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    const T* end() const \/\/ for stl$/;"	f	class:PhysBAM::VECTOR
end_on_separate_line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    bool end_on_separate_line,log_file_end_on_separate_line;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
endpoint	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV endpoint; \/\/ endpoint of the ray where t=0$/;"	m	class:PhysBAM::RAY
energy	IoData.h	/^  double energy;$/;"	m	struct:NonlinearRomOnlineData
energy	IoData.h	/^  double energy;$/;"	m	struct:NonlinearRomOnlineNonStateData
energy	IoData.h	/^  double energy;$/;"	m	struct:ReferenceStateData
energy	IoData.h	/^  double energy;$/;"	m	struct:RelativeProjectionErrorData
energy	IoData.h	/^  double energy;$/;"	m	struct:RestartParametersData
energy	KspBinaryOutput.C	/^  double energy; \/\/ distance to second closest cluster$/;"	m	struct:kspSortStruct	file:
energy	RefVal.h	/^  double energy;$/;"	m	class:RefVal
energy	TsRestart.h	/^  double energy[2];$/;"	m	class:TsRestart
energyJacAction	IoData.h	/^  double energyJacAction;$/;"	m	struct:GappyConstructionData
energyKrylov	IoData.h	/^  double energyKrylov;$/;"	m	struct:GappyConstructionData
energyOnly	IoData.h	/^  enum EnergyOnly {ENERGY_ONLY_FALSE = 0, ENERGY_ONLY_TRUE = 1} energyOnly;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::EnergyOnly
energyResidual	IoData.h	/^  double energyResidual;$/;"	m	struct:GappyConstructionData
energySensitivity	IoData.h	/^  double energySensitivity;$/;"	m	struct:GappyConstructionData
energyState	IoData.h	/^  double energyState;$/;"	m	struct:GappyConstructionData
energyWeightVec	MatVecProd.h	/^  DistSVec<double, neq>* energyWeightVec;$/;"	m	class:MatVecProdFD
engPat	Domain.h	/^  CommPattern<double> *engPat;$/;"	m	class:Domain
entries	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    HASHTABLE<std::string,int> entries;$/;"	m	class:PhysBAM::LOG_REAL::LOG_SCOPE
entropy	ImplicitRiemann.C	/^  double omega,entropy;$/;"	m	struct:JwlInfo	file:
entropy	LocalRiemann.h	/^    double entropy;$/;"	m	struct:LocalRiemannGfmpar::RiemannInvParams
entropy	RefVal.h	/^  double entropy;$/;"	m	class:RefVal
entrypoint	Main.C	/^extern "C" int entrypoint(int argc, char **argv)$/;"	f
eosChange	IoData.h	/^  enum EOSChange {NODAL_STATE = 0, RIEMANN_SOLUTION = 1} eosChange;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::EOSChange
eps	IoData.h	/^  double eps;$/;"	m	struct:BcsFreeStreamData
eps	IoData.h	/^  double eps;$/;"	m	struct:KspData
eps	IoData.h	/^  double eps;$/;"	m	struct:LinearizedData
eps	IoData.h	/^  double eps;$/;"	m	struct:MultiFluidData
eps	IoData.h	/^  double eps;$/;"	m	struct:NewtonData
eps	IoData.h	/^  double eps;$/;"	m	struct:SchemeData
eps	IoData.h	/^  double eps;$/;"	m	struct:SensitivityAnalysis
eps	IoData.h	/^  double eps;$/;"	m	struct:TsData
eps	IoData.h	/^  double eps;$/;"	m	struct:WallDistanceMethodData
eps	KspSolver.h	/^  double eps;$/;"	m	class:KspSolver
eps	TsParameters.h	/^  double eps;$/;"	m	class:TsParameters
eps0	KspConvCriterion.h	/^  double eps0;$/;"	m	class:KspConvCriterion
eps0	RecFcn.h	/^  double eps0;$/;"	m	class:RecFcn
eps2	IoData.h	/^  double eps2;$/;"	m	struct:LinearizedData
eps3	RecFcn.h	/^  double eps3;$/;"	m	class:RecFcn
epsAbsInc	IoData.h	/^  double epsAbsRes, epsAbsInc;$/;"	m	struct:NewtonData
epsAbsIncNewton	ImplicitEmbeddedTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
epsAbsIncNewton	ImplicitLevelSetTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitLevelSetTsDesc
epsAbsIncNewton	ImplicitMultiPhysicsTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
epsAbsIncNewton	ImplicitRomTsDesc.h	/^  double epsAbsIncNewton;$/;"	m	class:ImplicitRomTsDesc
epsAbsIncNewton	ImplicitTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitTsDesc
epsAbsIncNewton	MeshMotionSolver.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:TetMeshMotionSolver
epsAbsRes	IoData.h	/^  double epsAbsRes, epsAbsInc;$/;"	m	struct:NewtonData
epsAbsResNewton	ImplicitEmbeddedTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
epsAbsResNewton	ImplicitLevelSetTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitLevelSetTsDesc
epsAbsResNewton	ImplicitMultiPhysicsTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
epsAbsResNewton	ImplicitRomTsDesc.h	/^  double epsAbsResNewton;$/;"	m	class:ImplicitRomTsDesc
epsAbsResNewton	ImplicitTsDesc.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:ImplicitTsDesc
epsAbsResNewton	MeshMotionSolver.h	/^  double epsAbsResNewton, epsAbsIncNewton;$/;"	m	class:TetMeshMotionSolver
epsEV	IoData.h	/^  double epsEV;$/;"	m	struct:LinearizedData
epsFormula	IoData.h	/^  enum EpsFormula {CONSTANT = 0, EISENSTADT = 1} epsFormula;$/;"	m	struct:KspData	typeref:enum:KspData::EpsFormula
epsNewton	ImplicitEmbeddedTsDesc.h	/^  double epsNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
epsNewton	ImplicitLevelSetTsDesc.h	/^  double epsNewton;$/;"	m	class:ImplicitLevelSetTsDesc
epsNewton	ImplicitMultiPhysicsTsDesc.h	/^  double epsNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
epsNewton	ImplicitRomTsDesc.h	/^  double epsNewton;$/;"	m	class:ImplicitRomTsDesc
epsNewton	ImplicitTsDesc.h	/^  double epsNewton;$/;"	m	class:ImplicitTsDesc
epsNewton	MeshMotionSolver.h	/^  double epsNewton;$/;"	m	class:TetMeshMotionSolver
epsPrev	KspConvCriterion.h	/^  double epsPrev;$/;"	m	class:KspConvCriterion
epsabs	IoData.h	/^  double epsabs;$/;"	m	struct:TsData
epsabs	TsParameters.h	/^  double epsabs;$/;"	m	class:TsParameters
epsilon	IoData.h	/^  double epsilon;$/;"	m	struct:BoundaryData
epsilon	RefVal.h	/^  double epsilon;$/;"	m	class:RefVal
epsilon	utils/Predicate.C	/^REAL epsilon;                \/* = 2^(-p).  Used to estimate roundoff errors. *\/$/;"	v
epsturb	IoData.h	/^  const char *epsturb;$/;"	m	struct:TransientData
eqs	IoData.h	/^  EquationsData eqs;$/;"	m	class:IoData
eqsType	EmbeddedTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	m	class:EmbeddedTsDesc	typeref:enum:EmbeddedTsDesc::Type
eqsType	MultiPhysicsTsDesc.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} eqsType;$/;"	m	class:MultiPhysicsTsDesc	typeref:enum:MultiPhysicsTsDesc::Type
equal	VarFcnBase.h	/^  virtual bool equal(VarFcnBase* oth) { return false; }$/;"	f	class:VarFcnBase
equal	VarFcnSGEuler.h	/^  virtual bool equal(VarFcnBase* oth) {$/;"	f	class:VarFcnSGEuler
equality	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
equationCount	DistLeastSquareSolver.h	/^  int equationCount()    const { return equationCount_;    }$/;"	f	class:DistLeastSquareSolver
equationCount_	DistLeastSquareSolver.h	/^  int equationCount_, unknownCount_;$/;"	m	class:DistLeastSquareSolver
eriemannfs	LocalRiemannDesc.h	/^int LocalRiemannFluidStructure<dim>::eriemannfs(double rho, double u, double p,$/;"	f	class:LocalRiemannFluidStructure
eriemannfs_grad	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::eriemannfs_grad(double rho, double u, double p,$/;"	f	class:LocalRiemannFluidStructure
eriemannfs_tait	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::eriemannfs_tait(double rho, double u, double p,$/;"	f	class:LocalRiemannFluidStructure
eriemannfs_tait_grad	LocalRiemannDesc.h	/^void LocalRiemannFluidStructure<dim>::eriemannfs_tait_grad(double rho, double u, double p,$/;"	f	class:LocalRiemannFluidStructure
eriemanngj	LocalRiemannDesc.h	/^bool LocalRiemannGfmparGasJWL::eriemanngj(double rhol, double ul, double pl, $/;"	f	class:LocalRiemannGfmparGasJWL
eriemanngj_selector	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasJWL::eriemanngj_selector($/;"	f	class:LocalRiemannGfmparGasJWL
eriemanngj_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasJWL::eriemanngj_wrapper($/;"	f	class:LocalRiemannGfmparGasJWL
eriemannjj	LocalRiemannDesc.h	/^void LocalRiemannGfmparJWLJWL::eriemannjj(double rhol, double ul, double pl, $/;"	f	class:LocalRiemannGfmparJWLJWL
eriemanntj	LocalRiemannDesc.h	/^bool LocalRiemannGfmparTaitJWL::eriemanntj(double rhol, double ul, double pl, $/;"	f	class:LocalRiemannGfmparTaitJWL
eriemanntj_selector	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitJWL::eriemanntj_selector($/;"	f	class:LocalRiemannGfmparTaitJWL
eriemanntj_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitJWL::eriemanntj_wrapper($/;"	f	class:LocalRiemannGfmparTaitJWL
error	GappyPreprocessing.h	/^	VecSetArray<dim> error;	\/\/ error vectors$/;"	m	class:GappyPreprocessing
error	SparseGrid.h	/^  double **error;         \/\/ errors for each subgrid in each dimension$/;"	m	class:SparseGrid
errorBasis	GappyPreprocessing.h	/^	int errorBasis[2];	\/\/ basis indices for determining error$/;"	m	class:GappyPreprocessing
errorEstiNorm	DistTimeState.h	/^  double errorEstiNorm;                 \/\/norm of estimated error$/;"	m	class:DistTimeState
errorHandler	DistTimeState.C	/^  ErrorHandler* errorHandler;$/;"	m	struct:SetFirstOrderNodes	file:
errorHandler	DistTimeState.h	/^  ErrorHandler* errorHandler;$/;"	m	class:DistTimeState
errorHandler	Domain.h	/^  ErrorHandler *errorHandler;$/;"	m	class:Domain
errorHandler	Edge.h	/^  ErrorHandler* errorHandler;$/;"	m	class:EdgeSet
errorHandler	SubDomain.h	/^  ErrorHandler* errorHandler;$/;"	m	class:SubDomain
errorHandler	TsDesc.h	/^  ErrorHandler *errorHandler;$/;"	m	class:TsDesc
errorHandler	TsParameters.h	/^  ErrorHandler* errorHandler;$/;"	m	class:TsParameters
errorHat	GappyPreprocessing.h	/^        VecSetArray<dim> errorHat;$/;"	m	class:GappyPreprocessing
errorHatJac	GappyPreprocessing.h	/^        SetOfVec errorHatRes, errorHatJac;$/;"	m	class:GappyPreprocessing
errorHatRes	GappyPreprocessing.h	/^        SetOfVec errorHatRes, errorHatJac;$/;"	m	class:GappyPreprocessing
errorIndicator	IoData.h	/^  enum ErrorIndicator {OIBEI = 0, RBEI1 = 1, RBEI2 = 2, RBEI3 = 3, RBEI4 = 4} errorIndicator;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::ErrorIndicator
errorJac	GappyPreprocessing.h	/^	SetOfVec errorRes, errorJac;$/;"	m	class:GappyPreprocessing
errorRes	GappyPreprocessing.h	/^	SetOfVec errorRes, errorJac;$/;"	m	class:GappyPreprocessing
errorTol	IoData.h	/^  double errorTol;$/;"	m	struct:TsData
errorTol	TimeData.h	/^  double errorTol;$/;"	m	class:TimeData
error_mat	AlternatingLeastSquare/als_lapack.h	/^    double *error_mat;$/;"	m	class:AlternatingLeastSquare
error_tolerance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T error_tolerance; \/\/ there will be errors in the iterative solver$/;"	m	class:PhysBAM::CUBIC
error_trajectory	AlternatingLeastSquare/als_lapack.h	/^    double *error_trajectory;$/;"	m	class:AlternatingLeastSquare
estimate	utils/Predicate.C	/^REAL estimate(int elen, REAL *e)$/;"	f
estimateR	HigherOrderFSI.C	/^void HigherOrderFSI::estimateR(int l, int vertex, $/;"	f	class:HigherOrderFSI
estimateR	HigherOrderMultiFluid.C	/^estimateR(int l, int vertex, $/;"	f	class:HigherOrderMultiFluid
estimateRderivative	HigherOrderFSI.C	/^void HigherOrderFSI::estimateRderivative(int l, int vertex, $/;"	f	class:HigherOrderFSI
eta_SI	LevelSet/LevelSetStructure.h	/^	 DistVec<double> *eta_SI;$/;"	m	class:DistLevelSetStructure
eta_SI	LevelSet/LevelSetStructure.h	/^	 Vec<double>  &eta_SI; \/\/ intersection point on the wall $/;"	m	class:LevelSetStructure
eta_node	LevelSet/LevelSetStructure.h	/^	 DistVec<double> *eta_node;$/;"	m	class:DistLevelSetStructure
eta_node	LevelSet/LevelSetStructure.h	/^	 Vec<double>  &eta_node; \/\/ intersection point on the wall $/;"	m	class:LevelSetStructure
etime	IoData.h	/^  double etime;$/;"	m	struct:RestartParametersData
etime	TsRestart.h	/^  double etime;$/;"	m	class:TsRestart
euclideanDistances	NonlinearRom.h	/^  bool euclideanDistances;$/;"	m	class:NonlinearRom
euclideanFull	NonlinearRom.C	/^double NonlinearRom<dim>::euclideanFull(DistSVec<double, dim> &U1, DistSVec<double, dim> &U2) {$/;"	f	class:NonlinearRom
eulerFSI	Timer.h	/^		eulerFSI, embedforce, walldistance, lsreinitialization, readSnapshotFile,$/;"	e	enum:Timer::TimerIndex
evalAeroSys	Modal.C	/^void ModalSolver<dim>::evalAeroSys(VecSet<Vec<double> > &outRom, $/;"	f	class:ModalSolver
evalDerivativeOfFlux	FluxFcnDesc.C	/^void FluxFcnVanLeerEuler3D::evalDerivativeOfFlux(double vfgam, double vfp, double dvfp, double *normal, double *dNormal, double normalVel, double dNormalVel,$/;"	f	class:FluxFcnVanLeerEuler3D
evalFluidSys	Modal.C	/^void ModalSolver<dim>::evalFluidSys(VecSet<DistSVec<double, dim> > &podVecs, int nPodVecs)  {$/;"	f	class:ModalSolver
evalFlux	FluxFcnDesc.C	/^void FluxFcnVanLeerEuler3D::evalFlux(double vfgam, double vfp, double *normal, double normalVel, $/;"	f	class:FluxFcnVanLeerEuler3D
evalH	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evalH(int it, DistSVec<double,3> &x,$/;"	f	class:MatVecProdH2
evalJac	FluxFcnDesc.C	/^void FluxFcnVanLeerEuler3D::evalJac(double vfgam, double vfp, double *normal, double normalVel,$/;"	f	class:FluxFcnVanLeerEuler3D
evalMatForEvProblem	Modal.C	/^void ModalSolver<dim>::evalMatForEvProblem(double sReal, double sImag, VecSet<Vec<bcomp> > &compGAM,$/;"	f	class:ModalSolver
evaluate	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluate(DistExactRiemannSolver<dim> &riemann, int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdFD
evaluate	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluate(int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdFD
evaluate	MatVecProd.C	/^void MatVecProdFDMultiPhase<dim, dimLS>::evaluate(int it,$/;"	f	class:MatVecProdFDMultiPhase
evaluate	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::evaluate(DistExactRiemannSolver<dim> &riemann,$/;"	f	class:MatVecProdH1
evaluate	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::evaluate(int it, DistSVec<double,3> &X, DistVec<double> &ctrlVol, $/;"	f	class:MatVecProdH1
evaluate	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::evaluate(int it, DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MatVecProdH1MultiPhase
evaluate	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluate(int it, DistSVec<double,3> &x, $/;"	f	class:MatVecProdH2
evaluate	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluate(int it, DistSVec<double,3> &x, DistVec<double> &cv, $/;"	f	class:MatVecProdH2
evaluate	MatVecProd.C	/^void MatVecProdLS<dim,dimLS>::evaluate(int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdLS
evaluate	MatVecProd.h	/^  void evaluate(DistExactRiemannSolver<dim> &, int, DistSVec<double,3> &, DistVec<double> &,$/;"	f	class:MatVecProdH2
evaluate	MatVecProd.h	/^  void evaluate(DistExactRiemannSolver<dim> &, int, DistSVec<double,3> &, DistVec<double> &,$/;"	f	class:MatVecProd_dRdX
evaluate	MatVecProd.h	/^  void evaluate(int , DistSVec<double,3> &, DistVec<double> &, $/;"	f	class:MatVecProd_dRdX
evaluate	MatVecProd.h	/^  void evaluate(int, DistSVec<double,3> &, DistVec<double> &,$/;"	f	class:MatVecProd_dRdX
evaluate2	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluate2(int it, DistSVec<double,3> &x, DistVec<double> &cv, $/;"	f	class:MatVecProdH2
evaluate2	MatVecProd.h	/^  void evaluate2(int, DistSVec<double,3> &, DistVec<double> &,$/;"	f	class:MatVecProd_dRdX
evaluateF	ProgrammedBurnCore.C	/^void evaluateF(double rho_0,double e_0,double p_0, double rho_cj, double e_cj, double &f_1, double &f_2, const EOS& theEOS) {$/;"	f	namespace:ProgrammedBurn_CJ
evaluateFluxAtMultipleSolutions	TsDesc.C	/^void TsDesc<dim>::evaluateFluxAtMultipleSolutions(IoData &iod, char* best_soln)$/;"	f	class:TsDesc
evaluateFunctionOnGrid	SparseGrid.C	/^void SparseGrid::evaluateFunctionOnGrid(double **subGrid,$/;"	f	class:SparseGrid
evaluateHH	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProdFD
evaluateHH	MatVecProd.C	/^void MatVecProdFDMultiPhase<dim, dimLS>::evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProdFDMultiPhase
evaluateHH	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProdH1
evaluateHH	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProdH1MultiPhase
evaluateHH	MatVecProd.h	/^  virtual void evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProd
evaluateHH	MatVecProd.h	/^  virtual void evaluateHH(DistVec<double> &hhterm,$/;"	f	class:MatVecProdMultiPhase
evaluateInviscid	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateInviscid(int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdFD
evaluateInviscid	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluateInviscid(int it, DistSVec<double,3> &x, DistVec<double> &cv, $/;"	f	class:MatVecProdH2
evaluateInviscid	MatVecProd.h	/^  virtual void evaluateInviscid(int , DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &){$/;"	f	class:MatVecProd
evaluateInviscid	MatVecProd.h	/^  void evaluateInviscid(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &)$/;"	f	class:MatVecProd_dRdX
evaluatePreviousInterpolation	SparseGridCore.C	/^void SparseGrid::evaluatePreviousInterpolation(double **subGrid,$/;"	f	class:SparseGrid
evaluateRestrict	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateRestrict(int it, DistSVec<double,3> &x,$/;"	f	class:MatVecProdFD
evaluateRestrict	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::evaluateRestrict(int it, DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MatVecProdH1
evaluateRestrict	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluateRestrict(int it, DistSVec<double,3> &X, DistVec<double> &ctrlVol,$/;"	f	class:MatVecProdH2
evaluateRestrict	MatVecProd.h	/^  virtual void evaluateRestrict(int, DistSVec<double,3> &, DistVec<double> &,$/;"	f	class:MatVecProd
evaluateSHS	KirchhoffIntegrator.C	/^std::complex<double> KirchhoffIntegrator::evaluateSHS$/;"	f	class:KirchhoffIntegrator
evaluateViscous	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateViscous(int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdFD
evaluateViscous	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::evaluateViscous(int it, DistSVec<double,3> &X,$/;"	f	class:MatVecProdH1
evaluateViscous	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::evaluateViscous(int it, DistSVec<double,3> &x, DistVec<double> &cv, $/;"	f	class:MatVecProdH2
evaluateViscous	MatVecProd.h	/^  virtual void evaluateViscous(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &){$/;"	f	class:MatVecProd
evaluateViscous	MatVecProd.h	/^  void evaluateViscous(int, DistSVec<double,3> &, DistVec<double> &, DistSVec<double,dim> &, DistSVec<double,dim> &)$/;"	f	class:MatVecProd_dRdX
evaluateWeighted	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateWeighted(int it, DistSVec<double,3> &x, DistVec<double> &cv,$/;"	f	class:MatVecProdFD
evaluateWeighted	MatVecProd.h	/^  virtual void evaluateWeighted(int, DistSVec<double,3> &, DistVec<double> &, $/;"	f	class:MatVecProd
evaluateWeightedRestrict	MatVecProd.C	/^void MatVecProdFD<dim, neq>::evaluateWeightedRestrict(int it, DistSVec<double,3> &x,$/;"	f	class:MatVecProdFD
evaluateWeightedRestrict	MatVecProd.h	/^  virtual void evaluateWeightedRestrict(int, DistSVec<double,3> &, DistVec<double> &, $/;"	f	class:MatVecProd
exactInterfaceLocation	IoData.h	/^  const char* exactInterfaceLocation;$/;"	m	struct:InputData
exactInterfacePoint	LevelSetTsDesc.h	/^  struct exactInterfacePoint {$/;"	s	class:LevelSetTsDesc
exactUpdateInfoPrefix	IoData.h	/^  const char *exactUpdateInfoPrefix;$/;"	m	struct:NonlinearRomFilesData
exactUpdateInfoPrefix	NonlinearRom.h	/^  char* exactUpdateInfoPrefix;      \/\/ only user-specified value for exact update file names$/;"	m	class:NonlinearRom
exactUpdatesAlpha	NonlinearRom.h	/^  std::vector<double> exactUpdatesAlpha;  \/\/ [jVec]$/;"	m	class:NonlinearRom
exactUpdatesAlphaSwitch	NonlinearRom.h	/^  double exactUpdatesAlphaSwitch;  \/\/ scalar$/;"	m	class:NonlinearRom
exactUpdatesBeta	NonlinearRom.h	/^  std::vector<std::vector<double> > exactUpdatesBeta; \/\/[iCluster][jVec]  $/;"	m	class:NonlinearRom
exactUpdatesBetaSwitch	NonlinearRom.h	/^  std::vector<double> exactUpdatesBetaSwitch; \/\/[iCluster]$/;"	m	class:NonlinearRom
exactUpdatesN	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > exactUpdatesN;  \/\/ [iCluster][iVec][jVec]$/;"	m	class:NonlinearRom
exactUpdatesNSwitch	NonlinearRom.h	/^  std::vector<std::vector<double> > exactUpdatesNSwitch;  \/\/ [iCluster][iVec]$/;"	m	class:NonlinearRom
exactUpdatesPrepro	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
exactinit	utils/Predicate.C	/^void exactinit()$/;"	f
exchange	Communicator.C	/^CommPattern<T>::exchange()$/;"	f	class:CommPattern
exchange	Communicator.C	/^void Communicator::exchange(int tag, int numNeighb, int *cpus, int *sndLen,$/;"	f	class:Communicator
exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T> inline void exchange(ARRAY_VIEW<T>& a,ARRAY_VIEW<T>& b) \/\/ TODO: replace Exchange_Arrays with specialization of exchange$/;"	f	namespace:PhysBAM
exchange	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange.h	/^template<class T> void exchange(T& a,T& b)$/;"	f	namespace:PhysBAM
exchange_sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange_sort.h	/^inline void exchange_sort(T& a,T& b)$/;"	f	namespace:PhysBAM
exchange_sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange_sort.h	/^inline void exchange_sort(T& a,T& b,T& c)$/;"	f	namespace:PhysBAM
exchange_sort	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/exchange_sort.h	/^inline void exchange_sort(T& a,T& b,T& c,T& d)$/;"	f	namespace:PhysBAM
excsol	IoData.h	/^  enum ExactSolution {OFF_EXACTSOLUTION = 0, ON_EXACTSOLUTION = 1} excsol;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::ExactSolution
exist_nm1	TimeData.h	/^  bool exist_nm1;$/;"	m	class:TimeData
exist_nm2	TimeData.h	/^  bool exist_nm2;$/;"	m	class:TimeData
existsNm1	DistTimeState.h	/^  inline bool existsNm1() const { return data->exist_nm1; }$/;"	f	class:DistTimeState
existsWstarnm1	EmbeddedTsDesc.h	/^  bool existsWstarnm1;$/;"	m	class:EmbeddedTsDesc
existsWstarnm1	MultiPhysicsTsDesc.h	/^  bool existsWstarnm1;$/;"	m	class:MultiPhysicsTsDesc
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline DIAGONAL_MATRIX<T,2> exp(const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline DIAGONAL_MATRIX<T,3> exp(const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline MATRIX<T,0> exp(const MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline MATRIX<T,0,1> exp(const MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> exp(const MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> exp(const SYMMETRIC_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> exp(const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^exp(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^exp(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^exp(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
exp	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^exp(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
expandScope	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::expandScope()$/;"	f	class:DistIntersectorFRG
expandScope	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::expandScope()$/;"	f	class:DistIntersectorPhysBAM
expandVector	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::expandVector(Vec<double>& p, DistSVec<double, dim>& dQ){$/;"	f	class:ImplicitEmbeddedRomTsDesc
expandVector	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::expandVector(Vec<double> &romV, DistSVec<double, dim> &fullV)  {$/;"	f	class:ImplicitRomTsDesc
expansion	RestrictionMapping.C	/^RestrictionMapping<dim>::expansion(const DistSVec<double, dim> & in, DistSVec<double, dim> & out) const {$/;"	f	class:RestrictionMapping
expansion_sum	utils/Predicate.C	/^int expansion_sum(int elen, REAL *e, int flen, REAL *f, REAL *h)$/;"	f
expansion_sum_zeroelim1	utils/Predicate.C	/^int expansion_sum_zeroelim1(int elen, REAL *e, int flen, REAL *f, REAL *h)$/;"	f
expansion_sum_zeroelim2	utils/Predicate.C	/^int expansion_sum_zeroelim2(int elen, REAL *e, int flen, REAL *f, REAL *h)$/;"	f
expansions	arpack++/include/arlspdef.h	/^    int   expansions;$/;"	m	struct:__anon41
expl	IoData.h	/^  ExplicitData expl;$/;"	m	struct:TsData
exportInfo	MatchNodeCore.C	/^void MatchNodeSet::exportInfo(int iSub, int (*list)[3])$/;"	f	class:MatchNodeSet
exportMemory	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::exportMemory(MemoryPool *mp)$/;"	f	class:IluPrec
exportMemory	KspPrec.h	/^  virtual void exportMemory(MemoryPool *mp) {}$/;"	f	class:KspPrec
exportMemory	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::exportMemory(MemoryPool *mp)$/;"	f	class:MatVecProdH1
exportMemory	MatVecProd.C	/^void MatVecProdH1MultiPhase<dim,dimLS>::exportMemory(MemoryPool *mp)$/;"	f	class:MatVecProdH1MultiPhase
exportMemory	MatVecProd.h	/^  virtual void exportMemory(MemoryPool *mp) {}$/;"	f	class:MatVecProd
exportMemory	MatVecProd.h	/^  virtual void exportMemory(MemoryPool *mp) {}$/;"	f	class:MatVecProdMultiPhase
extendedLinearExtrapolationToIntersection	Edge.C	/^void extendedLinearExtrapolationToIntersection(ElemSet& elems, int idxTet, int idxFace, $/;"	f
extends	tools/alloca.cougar.c	/^    long extends;		\/* Number of block extensions.  *\/$/;"	m	struct:stk_stat	file:
extension_registry	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    HASHTABLE<std::string,FACTORY_BASE<T_BASE_OBJECT>*> extension_registry;$/;"	m	class:PhysBAM::REGISTRY
externalSI	IntersectorFRG/IntersectorFRG.h	/^	 bool externalSI;$/;"	m	class:DistIntersectorFRG
externalSI	IntersectorPhysBAM/IntersectorPhysBAM.h	/^	 bool externalSI;$/;"	m	class:DistIntersectorPhysBAM
externalSI	SpaceOperator.h	/^  bool externalSI; \/\/d2d$/;"	m	class:SpaceOperator
externalSI	TsOutput.h	/^  bool externalSI;$/;"	m	class:TsOutput
extractElementsRelativeToAComponentAndAMode	SubDomainCore.C	/^void SubDomain::extractElementsRelativeToAComponentAndAMode(double* tempMat, bcomp* compMat, int iDim, int iStrMode,int numPadeDeriv, int numFreqCoarse, int nStrMode, int nSnapsCoarse, double freq1)$/;"	f	class:SubDomain
extractElementsRelativeToANode	SubDomain.C	/^void SubDomain::extractElementsRelativeToANode(SVec<double, dim> **dataCoarse, double *tempMat, int iNode, int nSnapsCoarse)$/;"	f	class:SubDomain
extractElementsRelativeToANodeAndAVector	SubDomain.C	/^void SubDomain::extractElementsRelativeToANodeAndAVector(SVec<double, dim> ***dataCoarse, double *tempMat, int iNode, int nData, int jDataMin, int iPod)$/;"	f	class:SubDomain
extrapolateCharacteristic	VarFcn.h	/^  void extrapolateCharacteristic(double n[3], double un, double c, double *Vb, double *dV, int tag=0) { check(tag); varFcn[tag]->extrapolateCharacteristic(n,un,c,Vb,dV); }$/;"	f	class:VarFcn
extrapolateCharacteristic	VarFcnBase.h	/^  virtual void extrapolateCharacteristic(double n[3], double un, double c, double *Vb, double *dV) {$/;"	f	class:VarFcnBase
extrapolateCharacteristic	VarFcnJwl.h	/^void VarFcnJwl::extrapolateCharacteristic(double n[3], double un, double c,$/;"	f	class:VarFcnJwl
extrapolateCharacteristic	VarFcnSGEuler.h	/^void VarFcnSGEuler::extrapolateCharacteristic(double n[3], double un, double c, $/;"	f	class:VarFcnSGEuler
extrapolateCharacteristic	VarFcnTait.h	/^void VarFcnTait::extrapolateCharacteristic(double n[3], double un, double c,$/;"	f	class:VarFcnTait
extrapolatePhaseChange	SpaceOperator.C	/^extrapolatePhaseChange(DistSVec<double,3> &X, DistVec<double> &ctrlVol,int phaseChangeAlg,$/;"	f	class:MultiPhaseSpaceOperator
extrapolatePhiV	Domain.C	/^void Domain::extrapolatePhiV(DistLevelSetStructure *distLSS, DistSVec<double,dimLS> &PhiV)$/;"	f	class:Domain
extrapolatePhiV	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::extrapolatePhiV(DistLevelSetStructure *distLSS, DistSVec<double,dimLS> &PhiV)$/;"	f	class:MultiPhaseSpaceOperator
extrapolatePhiV	SubDomain.C	/^void SubDomain::extrapolatePhiV(LevelSetStructure &LSS, SVec<double,dimLS> &PhiV)$/;"	f	class:SubDomain
extrapolatePhiV2	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::extrapolatePhiV2(DistLevelSetStructure *distLSS, DistSVec<double,dimLS> &PhiV)$/;"	f	class:MultiPhaseSpaceOperator
extrapolatePrimitive	VarFcn.h	/^  void extrapolatePrimitive(double un, double c, double *Vb, double *Vinter, double *V, int tag=0) { check(tag); varFcn[tag]->extrapolatePrimitive(un,c,Vb,Vinter,V); }$/;"	f	class:VarFcn
extrapolatePrimitive	VarFcnBase.h	/^  virtual void extrapolatePrimitive(double un, double c, double *Vb, double *Vinter, double *V) {$/;"	f	class:VarFcnBase
extrapolatePrimitive	VarFcnJwl.h	/^void VarFcnJwl::extrapolatePrimitive(double un, double c, double *Vb,$/;"	f	class:VarFcnJwl
extrapolatePrimitive	VarFcnSGEuler.h	/^void VarFcnSGEuler::extrapolatePrimitive(double un, double c, double *Vb,$/;"	f	class:VarFcnSGEuler
extrapolatePrimitive	VarFcnTait.h	/^void VarFcnTait::extrapolatePrimitive(double un, double c, double *Vb,$/;"	f	class:VarFcnTait
extrapolateToWall_1	HigherOrderFSI.C	/^void HigherOrderFSI::extrapolateToWall_1(int l, int n, int Fid, VarFcn *varFun, $/;"	f	class:HigherOrderFSI
extrapolateToWall_2	HigherOrderFSI.C	/^void HigherOrderFSI::extrapolateToWall_2(int l, int n, int Fid, VarFcn *varFun, $/;"	f	class:HigherOrderFSI
extrapolateV6	HigherOrderFSI.C	/^void HigherOrderFSI::extrapolateV6(int l, int vertex, int i, $/;"	f	class:HigherOrderFSI
extrapolateV6	HigherOrderMultiFluid.C	/^extrapolateV6(int l, int vertex, $/;"	f	class:HigherOrderMultiFluid
extrapolationdata	Extrapolation.h	/^  Extrapolationdata extrapolationdata;$/;"	m	class:Extrapolation
extrema1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T extrema1,extrema2; \/\/ extrema1 < extrema 2$/;"	m	class:PhysBAM::CUBIC
extrema2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T extrema1,extrema2; \/\/ extrema1 < extrema 2$/;"	m	class:PhysBAM::CUBIC
f	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    const NONLINEAR_FUNCTION<R(T1,T2)>& f;$/;"	m	class:PhysBAM::PARAMETRIC_LINE
f0	AutoDiff/Taylor.h	/^    Scalar f0;$/;"	m	class:Taylor2
fScale	FSI/DynamicNodalTransfer.h	/^        const double fScale; \/\/scaling factor for force$/;"	m	class:DynamicNodalTransfer
face	Extrapolation.h	/^  int face;$/;"	m	struct:ExtrapolationNodeData
face	V6NodeData.h	/^  int face;$/;"	m	struct:V6NodeData
faceCenter	Face.h	/^  Vec3D faceCenter;$/;"	m	class:Face
faceDef	ElemTet.h	/^  int  faceDef(int i, int k) { return faceDefTet[i][k]; }$/;"	f	class:ElemTet
faceDefTet	ElemTet.h	/^  static const int faceDefTet[4][3];$/;"	m	class:ElemTet
faceDefTet	ElemTetCore.C	/^const int ElemTet::faceDefTet[4][3]  = { {0,1,2}, {0,3,1}, {0,2,3}, {1,3,2} };$/;"	m	class:ElemTet	file:
faceDistInfo	DistBcData.h	/^  DistInfo& nodeDistInfo,&inletNodeDistInfo,&faceDistInfo;$/;"	m	class:DistBcData
faceDistInfo	Domain.h	/^  DistInfo *faceDistInfo;$/;"	m	class:Domain
faceDistInfo	MultiGridLevel.h	/^    DistInfo* faceDistInfo;$/;"	m	class:MultiGridLevel
faceID	IntersectorFRG/IntersectorFRG.h	/^    int *faceID;$/;"	m	class:DistIntersectorFRG
faceID	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int *faceID;$/;"	m	class:DistIntersectorPhysBAM
faceMapping	MultiGridLevel.h	/^    DistVec<int>* faceMapping;$/;"	m	class:MultiGridLevel
faceNnd	ElemTet.h	/^  int  faceNnd(int i) { return 3; }$/;"	f	class:ElemTet
faceNorm	DistGeoState.h	/^  DistVec<Vec3D>  *faceNorm;$/;"	m	class:DistGeoState
faceNorm	GeoState.h	/^  Vec<Vec3D> &faceNorm;$/;"	m	class:GeoState
faceNormDistInfo	Domain.h	/^  DistInfo *faceNormDistInfo;$/;"	m	class:Domain
faceNormDistInfo	MultiGridLevel.h	/^    DistInfo* faceNormDistInfo;$/;"	m	class:MultiGridLevel
faceNormVel	DistGeoState.h	/^  DistVec<double> *faceNormVel;$/;"	m	class:DistGeoState
faceNormVel	GeoState.h	/^  Vec<double> &faceNormVel;$/;"	m	class:GeoState
faceNormVel_nm1	DistGeoState.h	/^  DistVec<double> *faceNormVel_nm1;$/;"	m	class:DistGeoState
faceNormVel_nm2	DistGeoState.h	/^  DistVec<double> *faceNormVel_nm2;$/;"	m	class:DistGeoState
faceNorm_nm1	DistGeoState.h	/^  DistVec<Vec3D>  *faceNorm_nm1;$/;"	m	class:DistGeoState
faceNorm_nm2	DistGeoState.h	/^  DistVec<Vec3D>  *faceNorm_nm2;$/;"	m	class:DistGeoState
faces	DistMvpMatrix.h	/^  FaceSet** faces;$/;"	m	class:DistMvpMatrix
faces	Face.h	/^  Face **faces;$/;"	m	class:FaceSet
faces	InletNode.h	/^	int *faces;				\/\/list of the faces connected to the node$/;"	m	class:InletNode
faces	MultiGridLevel.h	/^    FaceSet** faces;$/;"	m	class:MultiGridLevel
faces	SubDomain.h	/^  FaceSet &faces;$/;"	m	class:SubDomain
facesConnectedToSampleNode	Face.h	/^  std::vector<int> facesConnectedToSampleNode;	\/\/ for Gappy ROM$/;"	m	class:FaceSet
factor	DenseMatrix.C	/^GenFullM<Scalar>::factor()$/;"	f	class:GenFullM
factor	DenseMatrix.C	/^void SymFullM<Scalar>::factor()$/;"	f	class:SymFullM
factorB	IoData.h	/^  double factorB;$/;"	m	struct:ProgrammedBurnData
factorS	IoData.h	/^  double factorS;$/;"	m	struct:ProgrammedBurnData
factored	arpack++/include/arbnsmat.h	/^  bool     factored;$/;"	m	class:ARbdNonSymMatrix
factored	arpack++/include/arbsmat.h	/^  bool     factored;$/;"	m	class:ARbdSymMatrix
factored	arpack++/include/ardnsmat.h	/^  bool                factored;$/;"	m	class:ARdsNonSymMatrix
factored	arpack++/include/ardsmat.h	/^  bool     factored;$/;"	m	class:ARdsSymMatrix
factored	arpack++/include/arlnsmat.h	/^  bool        factored;$/;"	m	class:ARluNonSymMatrix
factored	arpack++/include/arlnspen.h	/^  bool                               factored;$/;"	m	class:ARluNonSymPencil
factored	arpack++/include/arlsmat.h	/^  bool        factored;$/;"	m	class:ARluSymMatrix
factored	arpack++/include/arlspen.h	/^  bool                   factored;$/;"	m	class:ARluSymPencil
factored	arpack++/include/arunsmat.h	/^  bool    factored;$/;"	m	class:ARumNonSymMatrix
factored	arpack++/include/arusmat.h	/^  bool    factored;$/;"	m	class:ARumSymMatrix
factorial	OneDimensionalInterpolator.h	/^  static int factorial(int i) { $/;"	f	class:OneDimensionalInterpolator
factorial	OneDimensionalSourceTerm.h	/^  inline static int factorial(int i) { $/;"	f	class:OneDimensionalSourceTerm
factorial_oned	OneDimensionalSourceTerm.h	/^const static int factorial_oned[] = {1,1,2,6,24,120,720,5040,40320};$/;"	v
fail	IntersectorFRG/IntersectorFRG.C	/^  bool fail;$/;"	m	class:ClosestTriangle	file:
failSafeFlag	TsDesc.h	/^  bool failSafeFlag;$/;"	m	class:TsDesc
failSafeNewton	DistEdgeGrad.h	/^  int failSafeNewton;$/;"	m	class:DistEdgeGrad
failSafeNewton	DistNodalGrad.h	/^  int failSafeNewton;$/;"	m	class:DistNodalGrad
failSafeNewton	ImplicitEmbeddedTsDesc.h	/^  int failSafeNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
failSafeNewton	ImplicitLevelSetTsDesc.h	/^  int failSafeNewton;$/;"	m	class:ImplicitLevelSetTsDesc
failSafeNewton	ImplicitMultiPhysicsTsDesc.h	/^  int failSafeNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
failSafeNewton	ImplicitTsDesc.h	/^  int failSafeNewton;$/;"	m	class:ImplicitTsDesc
failsafe	IoData.h	/^  enum FailSafe {NO = 0, YES = 1, ALWAYS = 2} failsafe;$/;"	m	struct:NewtonData	typeref:enum:NewtonData::FailSafe
failsafe	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	m	struct:BFixData	typeref:enum:BFixData::__anon10
failsafe	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	m	struct:CFixData	typeref:enum:CFixData::__anon8
failsafe	IoData.h	/^  enum {OFF=0, ON=1, ALWAYSON=2} failsafe;$/;"	m	struct:SFixData	typeref:enum:SFixData::__anon9
failsafe	SpaceOperator.h	/^  int failsafe;$/;"	m	class:SpaceOperator
failsafeN	IoData.h	/^  int failsafeN;$/;"	m	struct:BFixData
failsafeN	IoData.h	/^  int failsafeN;$/;"	m	struct:CFixData
failsafeN	IoData.h	/^  int failsafeN;$/;"	m	struct:SFixData
false	arpack++/include/arch.h	/^  int false = 0;$/;"	v
farFieldNodes	SubDomain.h	/^  std::vector<int> farFieldNodes;$/;"	m	class:SubDomain
farfieldpattern	IoData.h	/^  const char *farfieldpattern;$/;"	m	struct:Probes
fast_expansion_sum	utils/Predicate.C	/^int fast_expansion_sum(int elen, REAL *e, int flen, REAL *f, REAL *h) $/;"	f
fast_expansion_sum_zeroelim	utils/Predicate.C	/^int fast_expansion_sum_zeroelim(int elen, REAL *e, int flen, REAL *f, REAL *h)  $/;"	f
fdOrder	IoData.h	/^  enum FiniteDifferenceOrder {FIRST_ORDER = 1, SECOND_ORDER = 2} fdOrder; $/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::FiniteDifferenceOrder
fdOrder	MatVecProd.h	/^  int fdOrder;$/;"	m	class:MatVecProdFD
fdOrder	MatVecProd.h	/^  int fdOrder;$/;"	m	class:MatVecProdFDMultiPhase
fdResiduals	IoData.h	/^  enum FDResiduals {FD_RESIDUALS_OFF = 0, FD_RESIDUALS_ON = 1} fdResiduals;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::FDResiduals
fdResiduals	TsOutput.h	/^  bool fdResiduals;$/;"	m	class:TsOutput
fdResidualsLimit	IoData.h	/^  enum FDResidualsLimit {FD_RESIDUALS_LIMIT_OFF = 0, FD_RESIDUALS_LIMIT_ON = 1} fdResidualsLimit;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::FDResidualsLimit
fdResidualsLimit	TsOutput.h	/^  bool fdResidualsLimit;$/;"	m	class:TsOutput
fdeps	MatVecProd.h	/^  double fdeps;$/;"	m	class:MatVecProdFD
feJac	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
feTerm	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
feedbackFrequency	IoData.h	/^   int feedbackFrequency;$/;"	m	struct:BLMeshMotionData
fence	Communicator.C	/^    void Window<Scalar>::fence(bool isBeginning) {$/;"	f	class:Communication::Window
fet	DistTimeState.h	/^  FemEquationTerm *fet;$/;"	m	class:DistTimeState
fet	MultiGridSpaceOperator.h	/^  FemEquationTerm* fet,*fet1, *fet2; $/;"	m	class:MultiGridSpaceOperator
fet	SpaceOperator.h	/^  FemEquationTerm *fet;$/;"	m	class:SpaceOperator
fet1	MultiGridSpaceOperator.h	/^  FemEquationTerm* fet,*fet1, *fet2; $/;"	m	class:MultiGridSpaceOperator
fet2	MultiGridSpaceOperator.h	/^  FemEquationTerm* fet,*fet1, *fet2; $/;"	m	class:MultiGridSpaceOperator
ff_	FluxFcn.h	/^  FluxFcnBase **ff_;$/;"	m	class:FluxFcn
ffjacobian	IoData.h	/^  enum FluxFcnJacobian {FINITE_DIFFERENCE = 0, APPROXIMATE = 1, EXACT = 2} ffjacobian;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::FluxFcnJacobian
ffpDataOnSphere	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::ffpDataOnSphere$/;"	f	class:KirchhoffIntegrator
fid	OneDimensionalSolver.C	/^  Vec<int>& fid;$/;"	m	class:EulerSource	file:
fidToSet	OneDimensionalSolver.h	/^  Vec<int> fidToSet;$/;"	m	class:OneDimensional
fids	OneDimensionalSolver.h	/^    int* fids;$/;"	m	class:OneDimensional::Veval
field	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    T_FIELD T::*field;$/;"	m	class:PhysBAM::FIELD_COMPARE::T
file	BinFileHandler.h	/^  FILE *file;$/;"	m	class:BinFileHandler
file	IoData.h	/^  const char* file;$/;"	m	struct:OneDimensionalInputData
file	arpack++/include/ardfmat.h	/^  ifstream file;      \/\/ File handler.$/;"	m	class:ARdfMatrix
fileName	KspBinaryOutput.h	/^  char* fileName;$/;"	m	class:KspBinaryOutput
file_extensions	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/FILE_UTILITIES.h	/^static const char *file_extensions[]={"rgd","rgd2d","tri","phi","phi2d","oct","ply","ply2d","rgb","tri2d","curve","curve2d","tet","hex","box","phoneme",0};$/;"	m	namespace:PhysBAM::FILE_UTILITIES
file_name_inc	Dunavant.C	/^void file_name_inc ( char *file_name )$/;"	f
fileid	BinFileHandler.h	/^  int fileid;$/;"	m	class:BinFileHandler
filepackage	IoData.h	/^  const char* filepackage;$/;"	m	struct:RestartData
files	IoData.h	/^  NonlinearRomFilesData files;$/;"	m	struct:NonlinearRomFileSystemData
fill	IoData.h	/^  int fill;$/;"	m	struct:PcData
fill	KspPrec.h	/^  int fill;$/;"	m	class:IluPrec
fillXYZ	ReducedMeshShapeChanger.C	/^void ReducedMeshShapeChanger<dim>::fillXYZ()  {$/;"	f	class:ReducedMeshShapeChanger
fillin	arpack++/include/arunsmat.h	/^  int     fillin;$/;"	m	class:ARumNonSymMatrix
fillin	arpack++/include/arusmat.h	/^  int     fillin;$/;"	m	class:ARumSymMatrix
finalTime	OneDimensionalSolver.h	/^  double finalTime;$/;"	m	class:OneDimensional
finalize	Communicator.C	/^CommPattern<T>::finalize()$/;"	f	class:CommPattern
finalize	DistBcData.C	/^void DistBcData<dim>::finalize(DistSVec<double,3> &X)$/;"	f	class:DistBcData
finalize	DistInfo.h	/^  void finalize(bool makeFlag) $/;"	f	struct:DistInfo
finalizeSA	DistBcData.C	/^void DistBcData<dim>::finalizeSA(DistSVec<double,3> &X, DistSVec<double,3> &dX, double &dMach)$/;"	f	class:DistBcData
finalizeStatus	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::finalizeStatus()$/;"	f	class:DistIntersectorFRG
finalizeTags	SubDomainCore.C	/^void SubDomain::finalizeTags(SVec<int,2> &tag)$/;"	f	class:SubDomain
find	EdgeCore.C	/^int EdgeSet::find(int first, int second)$/;"	f	class:EdgeSet
find	RectangularSparseMatrix.C	/^int RectangularSparseMat<Scalar,dim,dim2>::find(int i, int j) $/;"	f	class:RectangularSparseMat
find	SparseMatrix.C	/^int SparseMat<Scalar,dim>::find(int i, int j) $/;"	f	class:SparseMat
find1in3	SubDomainCore.C	/^bool find1in3(int node, int* itet)$/;"	f
findActiveNodes	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::findActiveNodes(const DistVec<bool>& tId) $/;"	f	class:DistIntersectorPhysBAM
findActiveNodesUsingFloodFill	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::findActiveNodesUsingFloodFill(const DistVec<bool>& tId, $/;"	f	class:DistIntersectorPhysBAM
findAgglomerateMesh	SubDomainCore.C	/^MacroCellSet** SubDomain::findAgglomerateMesh(int scopeWidth, int scopeDepth,$/;"	f	class:SubDomain
findCandidates	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::findCandidates(double x[dim], Obj *o, int maxNObj, int depth) {$/;"	f	class:KDTree
findCandidatesInBox	IntersectorFRG/Geometry/KDTree.h	/^int KDTree<Obj, dim, CompType>::findCandidatesInBox(double xmin[dim], double xmax[dim],  Obj *o, int maxNObj) {$/;"	f	class:KDTree
findCandidatesWithin	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::findCandidatesWithin(double x[dim],$/;"	f	class:KDTree
findCloseCandidates	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::findCloseCandidates(double x[dim],$/;"	f	class:KDTree
findEdgeTetrahedra	SubDomainCore.C	/^void SubDomain::findEdgeTetrahedra(SVec<double,3>& X, V6NodeData (*&v6data)[2])$/;"	f	class:SubDomain
findFarfieldNode	SubDomainCore.C	/^int SubDomain::findFarfieldNode()$/;"	f	class:SubDomain
findInAndOut	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::findInAndOut()$/;"	f	class:DistIntersectorFRG
findIndexObject	parser/Assigner.C	/^Assigner * SysMapObj<Target>::findIndexObject(int index)  {$/;"	f	class:SysMapObj
findIndexObject	parser/AssignerCore.C	/^Assigner * Assigner::findIndexObject(int)  {$/;"	f	class:Assigner
findIndexObject	parser/ParseTree.cpp	/^Assigner *ParseNode::findIndexObject(int tk) { return 0; }$/;"	f	class:ParseNode
findIndexObject	parser/ParseTree.cpp	/^Assigner *ParseTree::findIndexObject(int index) {$/;"	f	class:ParseTree
findIntersections	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::findIntersections(SVec<double,3>&X, bool useScope)$/;"	f	class:IntersectorFRG
findIntersections	IntersectorPhysBAM/IntersectorPhysBAM.C	/^int IntersectorPhysBAM::findIntersections(SVec<double,3>&X,Vec<bool>& tId,Communicator& com)$/;"	f	class:IntersectorPhysBAM
findLSIntersectionPoint	ElemTet.C	/^int ElemTet::findLSIntersectionPoint(int lsdim, SVec<double,dim> &Phi, SVec<double,dim> &ddx,$/;"	f	class:ElemTet
findLSIntersectionPointGradient	ElemTet.C	/^void ElemTet::findLSIntersectionPointGradient(int lsdim, SVec<double,dim> &Phi,  SVec<double,dim> &ddx,$/;"	f	class:ElemTet
findLSIntersectionPointHermite	ElemTet.C	/^int ElemTet::findLSIntersectionPointHermite(int lsdim, SVec<double,dim> &Phi,  SVec<double,dim> &ddx,$/;"	f	class:ElemTet
findLSIntersectionPointLinear	ElemTet.C	/^void ElemTet::findLSIntersectionPointLinear(int lsdim, SVec<double,dim> &Phi,  SVec<double,dim> &ddx,$/;"	f	class:ElemTet
findMaxAndFillPodHat	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::findMaxAndFillPodHat(const double myMaxNorm, const int$/;"	f	class:GappyPreprocessing
findMaxDist	ConnectivityCore.C	/^Connectivity::findMaxDist(int *renum)$/;"	f	class:Connectivity
findNeighbours	SparseGridCore.C	/^void SparseGrid::findNeighbours(const int currentMultiIndex,$/;"	f	class:SparseGrid
findNewSeedsAfterMerging	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::findNewSeedsAfterMerging(SVec<int,2>& status_and_weight, int& nUndecided)$/;"	f	class:IntersectorFRG
findNewSeedsAfterMerging	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::findNewSeedsAfterMerging(Vec<int>& status_temp, Vec<bool>& poly, int& nUndecided)$/;"	f	class:IntersectorFRG
findNode	OneDimensionalSolver.h	/^    int findNode(const double* loc,double& localRadius) {$/;"	f	class:OneDimensional::Veval
findNodeBoundingBoxes	DomainCore.C	/^void Domain::findNodeBoundingBoxes(DistSVec<double,3> &X, DistSVec<double,3> &Xmin, DistSVec<double,3> &Xmax)$/;"	f	class:Domain
findNodeBoundingBoxes	SubDomainCore.C	/^void SubDomain::findNodeBoundingBoxes(SVec<double,3>&X, SVec<double,3> &Xmin, SVec<double,3> &Xmax)$/;"	f	class:SubDomain
findNodeClosestPoint	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::findNodeClosestPoint(const int nodeId, Vec3D& x0, ARRAY<int> &cand)$/;"	f	class:IntersectorPhysBAM
findNodeInTet	SubDomainCore.C	/^bool SubDomain::findNodeInTet(int node, int tet)$/;"	f	class:SubDomain
findNodesNearInterface	IntersectorFRG/IntersectorFRG.h	/^    void findNodesNearInterface(SVec<double, 3>&, SVec<double, 3>&, SVec<double, 3>&) {\/* pure virtual in LevelSet *\/}$/;"	f	class:IntersectorFRG
findNodesNearInterface	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    void findNodesNearInterface(SVec<double, 3>&, SVec<double, 3>&, SVec<double, 3>&) {}$/;"	f	class:IntersectorPhysBAM
findNodesNearInterface	LevelSet/MultiGridLevelSetStructure.h	/^    void findNodesNearInterface(SVec<double, 3>&, SVec<double, 3>&, SVec<double, 3>&) { }$/;"	f	class:MultiGridLevelSetStructure
findNormalTet1	SubDomainCore.C	/^bool SubDomain::findNormalTet1(Vec3D a, Vec3D b, Vec3D c, Vec3D d, Vec3D e, int tt, int tf, ExtrapolationNodeData &data, bool adaptive)$/;"	f	class:SubDomain
findNormalTet2	SubDomainCore.C	/^void SubDomain::findNormalTet2( int* itet, Vec3D d, Vec3D e, int tt,$/;"	f	class:SubDomain
findNormalTetrahedra	SubDomainCore.C	/^void SubDomain::findNormalTetrahedra(SVec<double,3>& X, Vec<Vec3D>& normals,$/;"	f	class:SubDomain
findNormalTetrahedron	SubDomainCore.C	/^bool SubDomain::findNormalTetrahedron(int node, Vec3D normal,$/;"	f	class:SubDomain
findOnly	EdgeCore.C	/^int EdgeSet::findOnly(int first, int second) const$/;"	f	class:EdgeSet
findOppositeTet	SubDomainCore.C	/^int SubDomain::findOppositeTet(int *itet, int node)$/;"	f	class:SubDomain
findPoly	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::findPoly() {$/;"	f	class:DistIntersectorFRG
findProfileSize	ConnectivityCore.C	/^Connectivity::findProfileSize(EqNumberer *eqn, int unroll)$/;"	f	class:Connectivity
findPseudoDiam	ConnectivityCore.C	/^Connectivity::findPseudoDiam(int *s, int *e, int *mask)$/;"	f	class:Connectivity
findRootPolynomialLaguerre	ElemTetCore.C	/^int ElemTet::findRootPolynomialLaguerre(double f1, double f2, double fp1, double fp2,$/;"	f	class:ElemTet
findRootPolynomialNewtonRaphson	ElemTetCore.C	/^double ElemTet::findRootPolynomialNewtonRaphson(double f1, double f2, double fp1, double fp2)$/;"	f	class:ElemTet
findSeedsByPoints	IntersectorFRG/IntersectorFRG.C	/^int IntersectorFRG::findSeedsByPoints(SubDomain& sub, SVec<double,3>& X, list<pair<Vec3D,int> > P, int& nUndecided)$/;"	f	class:IntersectorFRG
findSignedVertexDistance	IntersectorFRG/IntersectorFRG.C	/^double ClosestTriangle::findSignedVertexDistance()$/;"	f	class:ClosestTriangle
findSubDomainBoundingBoxes	SubDomainCore.C	/^void SubDomain::findSubDomainBoundingBoxes(SVec<double,3>&X, double *Xmin, double *Xmax)$/;"	f	class:SubDomain
findSubToken	parser/AssignerCore.C	/^Assigner::findSubToken(int)$/;"	f	class:Assigner
findSubToken	parser/AssignerCore.C	/^ClassAssigner::findSubToken(int t)$/;"	f	class:ClassAssigner
findSubToken	parser/ParseTree.cpp	/^Assigner *ParseTree::findSubToken(Token token) {$/;"	f	class:ParseTree
findSubToken	parser/ParseTree.h	/^    Assigner *findSubToken(Token tk) {$/;"	f	class:ParseNode
findSubToken	parser/ParseTree.h	/^ClassParseTree<T>::findSubToken(int token) {$/;"	f	class:ClassParseTree
findSysObj	parser/Dictionary.C	/^findSysObj(int tk)$/;"	f
findSysToken	parser/Dictionary.C	/^int findSysToken(const char *str)$/;"	f
findTesterStatus	IntersectorFRG/IntersectorFRG.C	/^int ClosestTriangle::findTesterStatus(Vec3D xt) const$/;"	f	class:ClosestTriangle
findTetrahedron	SubDomainCore.C	/^bool SubDomain::findTetrahedron(int i, int j, Vec<int>& count, int** list,$/;"	f	class:SubDomain
find_col_index	AlternatingLeastSquare/als_util.cpp	/^std::vector<unsigned int> find_col_index(const unsigned char *mem, int M, int N,$/;"	f
find_row_index	AlternatingLeastSquare/als_util.cpp	/^std::vector<unsigned int> find_row_index(const unsigned char* mem, int M, int N,$/;"	f
find_stack_direction	tools/alloca.cougar.c	/^find_stack_direction ()$/;"	f	file:
fine_sweeps	MultiGridKernel.h	/^  int fine_sweeps;$/;"	m	class:MultiGridKernel
finestNodeMapping	MultiGridLevel.h	/^    DistVec<int>* finestNodeMapping;$/;"	m	class:MultiGridLevel
finishJacobianGalerkinTerm	Domain.C	/^void Domain::finishJacobianGalerkinTerm(DistVec<double> &ctrlVol, DistMat<Scalar,neq> &A)  {$/;"	f	class:Domain
finishJacobianGalerkinTerm	SubDomain.C	/^void SubDomain::finishJacobianGalerkinTerm(Vec<double> &ctrlVol, GenMat<Scalar,neq> &A)  {$/;"	f	class:SubDomain
finishStatusByHistory	IntersectorFRG/IntersectorFRG.C	/^bool IntersectorFRG::finishStatusByHistory(SubDomain& sub)$/;"	f	class:IntersectorFRG
finishStatusByPoints	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::finishStatusByPoints(IoData &iod, DistVec<int> *point_based_id)$/;"	f	class:DistIntersectorFRG
finished	ProgrammedBurn.h	/^    bool finished;$/;"	m	struct:ProgrammedBurn::Burn
first	arpack++/include/ardfmat.h	/^  int      first;     \/\/ First row\/column stored in val.$/;"	m	class:ARdfMatrix
firstCheckedNode	ReinitializeDistanceToWall.h	/^  int* nSortedNodes,*firstCheckedNode;$/;"	m	class:ReinitializeDistanceToWall
firstOrderNodes	DistTimeState.h	/^  DistVec<int> *firstOrderNodes;$/;"	m	class:DistTimeState
five_thirds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double five_thirds=5.\/3;$/;"	m	namespace:PhysBAM
fix	DistEdgeGrad.h	/^  void fix(DistSVec<bool,2> &fstag)$/;"	f	class:DistEdgeGrad
fix	DistEdgeGrad.h	/^  void fix(DistSVec<int,2> &fstag)$/;"	f	class:DistEdgeGrad
fix	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::fix(DistSVec<bool,2>& fstag)$/;"	f	class:DistNodalGrad
fix	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::fix(DistSVec<int,2>& fstag)$/;"	f	class:DistNodalGrad
fix	EdgeGrad.h	/^  void fix(bool (*fstag)[2], int size) {$/;"	f	class:EdgeGrad
fix	EdgeGrad.h	/^  void fix(int (*fstag)[2], int size) {$/;"	f	class:EdgeGrad
fix	SpaceOperator.C	/^void SpaceOperator<dim>::fix(DistSVec<bool,2>& tag)$/;"	f	class:SpaceOperator
fixLocations	MultiGridKernel.h	/^  std::set<int>** fixLocations;$/;"	m	class:MultiGridKernel
fixNegativeValues	MultiGridKernel.C	/^fixNegativeValues(int lvl,DistSVec<Scalar2,dim>& V, $/;"	f	class:MultiGridKernel
fixNodes	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::fixNodes(double *Xs, int nNodes, DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:EmbeddedCorotSolver
fixSol	TsDesc.h	/^  int fixSol;$/;"	m	class:TsDesc
fixSolution	Domain.C	/^void Domain::fixSolution(VarFcn *varFcn, DistSVec<double,dim> &U, DistSVec<double,dim> &dU,DistVec<int>* fluidId)$/;"	f	class:Domain
fixSolution	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::fixSolution(DistSVec<double,dim>& U,DistSVec<double,dim>& dU) {$/;"	f	class:EmbeddedTsDesc
fixSolution	ImplicitEmbeddedRomTsDesc.h	/^    void fixSolution(DistSVec<double, dim> &Q, DistSVec<double, dim> &dQ) { super::fixSolution(Q, dQ); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
fixSolution	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::fixSolution(DistSVec<double,dim>& U,DistSVec<double,dim>& dU) {$/;"	f	class:LevelSetTsDesc
fixSolution	MeshMotionSolver.h	/^  int fixSolution(DistSVec<double,3> &X, DistSVec<double,3> &dX) { return 0; }$/;"	f	class:TetMeshMotionSolver
fixSolution	SubDomain.C	/^int SubDomain::fixSolution(VarFcn *varFcn, SVec<double,dim> &U, SVec<double,dim> &dU, Vec<int>* fluidId,int verboseFlag)$/;"	f	class:SubDomain
fixSolution	TsDesc.C	/^void TsDesc<dim>::fixSolution(DistSVec<double,dim> &U, DistSVec<double,dim> &dU)$/;"	f	class:TsDesc
fixSolution2	Domain.C	/^void Domain::fixSolution2(VarFcn *varFcn, DistSVec<double,dim> &U, DistSVec<double,dim> &dU,DistVec<int>* fluidId)$/;"	f	class:Domain
fixSolution2	SubDomain.C	/^int SubDomain::fixSolution2(VarFcn *varFcn, SVec<double,dim> &U, SVec<double,dim> &dU, Vec<int>* fluidId,int verboseFlag)$/;"	f	class:SubDomain
fixedunsteady_counter	TsParameters.h	/^  int fixedunsteady_counter;$/;"	m	class:TsParameters
fixes	IoData.h	/^  SchemeFixData fixes;$/;"	m	struct:MultiGridData
fixes	IoData.h	/^  SchemeFixData fixes;$/;"	m	struct:SchemesData
fixsol	IoData.h	/^  enum FixSolution {NONEFIX = 0, PREVIOUSVALEUSFIX = 1} fixsol;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::FixSolution
flightDisplacement	IoData.h	/^  const char *flightDisplacement;$/;"	m	struct:TransientData
floatrand	utils/Predicate.C	/^float floatrand()$/;"	f
floodFill	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::floodFill(SubDomain& sub, int& nUndecided)$/;"	f	class:IntersectorFRG
floodFill	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    FloodFill* floodFill;$/;"	m	class:DistIntersectorPhysBAM
floodFillSubDomain	IntersectorPhysBAM/FloodFill.C	/^int FloodFill::floodFillSubDomain(SubDomain& sub, $/;"	f	class:FloodFill
floor	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^floor(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
floor	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^floor(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
floor	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^floor(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
floor	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^floor(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
flops_t	arpack++/include/arlutil.h	/^typedef float    flops_t;$/;"	t
fluid	Extrapolation.h	/^  FluidModelData::Fluid fluid;$/;"	m	class:Extrapolation
fluid	IoData.h	/^  enum Fluid { PERFECT_GAS = 0, LIQUID = 1, JWL = 2, STIFFENED_GAS = 3, UNDEFINED = 4} fluid;$/;"	m	struct:FluidModelData	typeref:enum:FluidModelData::Fluid
fluid	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
fluid1	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::fluid1(int IDi, int IDj)$/;"	f	class:ExactRiemannSolver
fluid1	LocalRiemann.h	/^  int fluid1, fluid2;  \/\/             fluid1 ~ phi>0           fluid2 ~ phi<0$/;"	m	class:LocalRiemann
fluid2	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::fluid2(int IDi, int IDj)$/;"	f	class:ExactRiemannSolver
fluid2	LocalRiemann.h	/^  int fluid1, fluid2;  \/\/             fluid1 ~ phi>0           fluid2 ~ phi<0$/;"	m	class:LocalRiemann
fluidId	FluidSelector.h	/^  DistVec<int> *fluidId;$/;"	m	class:FluidSelector
fluidId	ImplicitRiemann.C	/^  int fluidId;$/;"	m	struct:JwlInfo	file:
fluidId	IoData.h	/^  const char *fluidId;$/;"	m	struct:InputData
fluidId	IoData.h	/^  const char *fluidId;$/;"	m	struct:RestartData
fluidId	MatVecProd.h	/^    DistVec<int>* fluidId;$/;"	m	struct:MatVecProd::_fsi
fluidId	MatVecProd.h	/^    DistVec<int>* fluidId;$/;"	m	struct:MatVecProdMultiPhase::_fsi
fluidId	OneDimensionalSolver.h	/^  Vec<int> fluidId;$/;"	m	class:OneDimensional
fluidId	TsRestart.h	/^  char *fluidId[3];$/;"	m	class:TsRestart
fluidId0	ExplicitLevelSetTsDesc.h	/^  DistVec<int> fluidId0;$/;"	m	class:ExplicitLevelSetTsDesc
fluidId0	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<int> fluidId0; $/;"	m	class:ExplicitMultiPhysicsTsDesc
fluidId2	IoData.h	/^  int fluidId2;$/;"	m	struct:OneDimensionalInfo
fluidIdDummy	TsDesc.h	/^  DistVec<int> fluidIdDummy;$/;"	m	class:TsDesc
fluidIdToSet	DistExactRiemannSolver.h	/^  DistVec<int>* fluidIdToSet;$/;"	m	class:DistExactRiemannSolver
fluidIdToSet	ExactRiemannSolver.h	/^  Vec<int>       &fluidIdToSet;$/;"	m	class:ExactRiemannSolver
fluidIdn	FluidSelector.h	/^  DistVec<int> *fluidIdn;$/;"	m	class:FluidSelector
fluidIdn	OneDimensionalSolver.h	/^  Vec<int> fluidIdn;$/;"	m	class:OneDimensional
fluidIdnm1	FluidSelector.h	/^  DistVec<int> *fluidIdnm1;$/;"	m	class:FluidSelector
fluidIdnm2	FluidSelector.h	/^  DistVec<int> *fluidIdnm2;$/;"	m	class:FluidSelector
fluidKsp	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
fluidModel	IoData.h	/^  FluidModelData fluidModel;$/;"	m	struct:EquationsData
fluidModel	LevelSet/LevelSetStructure.h	/^    int fluidModel(double t, int n) const                 { return status[n]; }$/;"	f	class:LevelSetStructure
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:CylinderData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:DummyPointData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:PlaneData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:PointData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:PrismData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:SphereData
fluidModelID	IoData.h	/^  int fluidModelID;$/;"	m	struct:VolumeData
fluidModelMap	IoData.h	/^  ObjectMap<FluidModelData> fluidModelMap;$/;"	m	struct:EquationsData
fluidPrecSetup	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
fluidRemap	IoData.h	/^  ObjectMap<FluidRemapData> fluidRemap;$/;"	m	struct:OneDimensionalInputData
fluidSelector	LevelSetTsDesc.h	/^  FluidSelector fluidSelector;$/;"	m	class:LevelSetTsDesc
fluidSelector	MatVecProd.h	/^  FluidSelector *fluidSelector;$/;"	m	class:MatVecProdMultiPhase
fluidSelector	MultiPhysicsTsDesc.h	/^  FluidSelector fluidSelector;$/;"	m	class:MultiPhysicsTsDesc
fluidSelector	OneDimensionalSolver.h	/^  FluidSelector fluidSelector;$/;"	m	class:OneDimensional
fluidid	IoData.h	/^  const char* fluidid;$/;"	m	struct:TransientData
flux	IoData.h	/^    Flux flux;$/;"	m	struct:SchemeData::MaterialFluxData
flux	IoData.h	/^  enum Flux {ROE = 0, VANLEER = 1, HLLE = 2, HLLC = 3} flux;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::Flux
flux3Dwater	FluxFcnDescTait.C	/^void flux3Dwater(int type, VarFcnBase *vf, double *normal, double normalVel, double *V, double *Ub, double *flux){$/;"	f
fluxFcn	MatVecProd.h	/^  FluxFcn **fluxFcn;$/;"	m	class:MatVecProdH2
fluxFcn	MatVecProd.h	/^  FluxFcn **fluxFcn;$/;"	m	class:MatVecProd_dRdX
fluxFcn	MultiGridSpaceOperator.h	/^  FluxFcn** fluxFcn, **fluxFcn1, **fluxFcn2;$/;"	m	class:MultiGridSpaceOperator
fluxFcn	OneDimensionalSolver.h	/^  FluxFcn **fluxFcn;$/;"	m	class:OneDimensional
fluxFcn	SpaceOperator.h	/^  FluxFcn **fluxFcn;$/;"	m	class:SpaceOperator
fluxFcn1	MultiGridSpaceOperator.h	/^  FluxFcn** fluxFcn, **fluxFcn1, **fluxFcn2;$/;"	m	class:MultiGridSpaceOperator
fluxFcn2	MultiGridSpaceOperator.h	/^  FluxFcn** fluxFcn, **fluxFcn1, **fluxFcn2;$/;"	m	class:MultiGridSpaceOperator
fluxFcnAA	SpaceOperator.h	/^  FluxFcn **fluxFcnAA;$/;"	m	class:SpaceOperator
fluxFcnSA	SpaceOperator.h	/^  FluxFcn **fluxFcnSA;$/;"	m	class:SpaceOperator
fluxMap	IoData.h	/^  ObjectMap<MaterialFluxData> fluxMap;$/;"	m	struct:SchemeData
fluxnorm	IoData.h	/^  const char *fluxnorm;$/;"	m	struct:TransientData
fluxnorm	TsOutput.h	/^  char *fluxnorm;$/;"	m	class:TsOutput
fnmax	SparseGrid.h	/^  double *fnmax;          \/\/ maximum values of the interpolation$/;"	m	class:SparseGrid
fnmin	SparseGrid.h	/^  double *fnmin;          \/\/ minimum values of the interpolation$/;"	m	class:SparseGrid
fnormPrev	KspConvCriterion.h	/^  double fnormPrev;$/;"	m	class:KspConvCriterion
forClassTet	Elem.h	/^  void *forClassTet(ElemTet *tet, int size, char *memorySpace) {$/;"	f	class:ElemHelper_Scalar_dim_neq
forClassTet	Elem.h	/^  void *forClassTet(ElemTet *tet, int size, char *memorySpace) {$/;"	f	class:ElemHelper_dim
forClassTet	Elem.h	/^  void *forClassTet(ElemTet *tet, int size, char *memorySpace) {$/;"	f	class:ElemHelper_dim_obj
forClassTria	Face.h	/^  void *forClassTria(FaceTria *tface, int size, char *memorySpace) {$/;"	f	class:FaceHelper_Scalar_dim_neq
forClassTria	Face.h	/^  void *forClassTria(FaceTria *tface, int size, char *memorySpace) {$/;"	f	class:FaceHelper_dim
for_loop	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
for_lu	arpack++/include/arlspdef.h	/^    float for_lu;$/;"	m	struct:__anon41
force	IoData.h	/^  double force;$/;"	m	struct:ForcePoints
force	IoData.h	/^  enum Force {LAST = 0, AVERAGED = 1, LAST_KRIS = 2} force;$/;"	m	struct:AeroelasticData	typeref:enum:AeroelasticData::Force
force	RefVal.h	/^  double force;$/;"	m	class:RefVal
forceAlg	IoData.h	/^  enum ForceAlgorithm {RECONSTRUCTED_SURFACE = 0, CONTROL_VOLUME_BOUNDARY = 1, EMBEDDED_SURFACE = 2} forceAlg;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::ForceAlgorithm
forceApp	EmbeddedTsDesc.h	/^  int forceApp; \/\/ now have four options.$/;"	m	class:EmbeddedTsDesc
forceApp	MultiPhysicsTsDesc.h	/^  int forceApp; \/\/ now have four options.$/;"	m	class:MultiPhysicsTsDesc
forceComputation	MeshMotionHandler.h	/^  AeroelasticData::Force forceComputation;$/;"	m	class:AeroMeshMotionHandler
forceGen	PostOperator.h	/^  ForceGenerator<dim> *forceGen;$/;"	m	class:PostOperator
forceID	IoData.h	/^  int forceID;$/;"	m	struct:SurfaceData
forceNorm	TsDesc.h	/^  double forceNorm;$/;"	m	class:TsDesc
forceNorms	TsDesc.h	/^  double *forceNorms;$/;"	m	class:TsDesc
forceOccluded	LevelSet/LevelSetStructure.h	/^    void forceOccluded(double t, int n) const                { is_swept[n] = true; is_occluded[n] = true; }$/;"	f	class:LevelSetStructure
forceResults	IoData.h	/^  enum ForceResults {NO = 0, YES = 1} forceResults;$/;"	m	struct:SurfaceData	typeref:enum:SurfaceData::ForceResults
forceScaling	IoData.h	/^  double forceScaling;$/;"	m	struct:AeroelasticData
forced	IoData.h	/^  ForcedData forced;$/;"	m	class:IoData
forces	IoData.h	/^  const char *forces;$/;"	m	struct:TransientData
forces	TsOutput.h	/^  char *forces;$/;"	m	class:TsOutput
forest	parser/Dictionary.h	/^  map<int, Assigner *> forest;$/;"	m	class:SysSmbMap
form	IoData.h	/^  enum Form {DESCRIPTOR = 1, NONDESCRIPTOR = 0, HYBRID = 2} form;$/;"	m	struct:TsData	typeref:enum:TsData::Form
form	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	m	struct:DESModelData	typeref:enum:DESModelData::Form
form	IoData.h	/^  enum Form {ORIGINAL = 0, FV3 = 1} form;$/;"	m	struct:SAModelData	typeref:enum:SAModelData::Form
formInterpolatedInitialCondition	ImplicitGappyTsDesc.h	/^  void formInterpolatedInitialCondition(DistSVec<double,dim> *U, IoData &iod)  {$/;"	f	class:ImplicitGappyTsDesc
formInterpolatedInitialCondition	ImplicitRomPostproTsDesc.h	/^  void formInterpolatedInitialCondition(DistSVec<double,dim> *U, IoData &iod)  {$/;"	f	class:ImplicitRomPostproTsDesc
formInterpolatedInitialCondition	NonlinearRom.C	/^void NonlinearRom<dim>::formInterpolatedInitialCondition(DistSVec<double,dim> *U, IoData &iod) {$/;"	f	class:NonlinearRom
formInterpolatedInitialCondition	TsDesc.C	/^void TsDesc<dim>::formInterpolatedInitialCondition(DistSVec<double,dim> *U, IoData &iod)  {$/;"	f	class:TsDesc
formInterpolationWeights	TsDesc.C	/^void TsDesc<dim>::formInterpolationWeights(IoData &iod) {$/;"	f	class:TsDesc
formMaskedNonlinearROBs	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::formMaskedNonlinearROBs()$/;"	f	class:GappyPreprocessing
formOutputRom	Modal.C	/^void ModalSolver<dim>::formOutputRom(VecSet<Vec<double> > &outputRom,$/;"	f	class:ModalSolver
formReducedSampleNodeMap	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::formReducedSampleNodeMap()$/;"	f	class:GappyPreprocessing
fortran	RectangularSparseMatrix.h	/^  int fortran;              \/\/ fortran=1 if fortran style numbering$/;"	m	class:RectangularSparseMat
fortran	SparseMatrix.h	/^  int fortran;              \/\/ fortran=1 if fortran style numbering$/;"	m	class:SparseMat
forward_mapping	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    ARRAY<int> reverse_mapping,forward_mapping;$/;"	m	class:IntersectorPhysBAM
four_thirds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double four_thirds=4.\/3;$/;"	m	namespace:PhysBAM
four_thirds_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double four_thirds_pi=4.\/3*pi;$/;"	m	namespace:PhysBAM
fourth	ElemTet.h	/^  static const double fourth;$/;"	m	class:ElemTet
fourth	ElemTetCore.C	/^const double ElemTet::fourth = 1.0\/4.0;$/;"	m	class:ElemTet	file:
fourth	FemEquationTermDesc.C	/^const double NavierStokesTerm::fourth = 1.0\/4.0;$/;"	m	class:NavierStokesTerm	file:
fourth	NavierStokesTerm.h	/^  static const double fourth;$/;"	m	class:NavierStokesTerm
fpConservationErr	TsOutput.h	/^  FILE *fpConservationErr;$/;"	m	class:TsOutput
fpCpuTiming	TsOutput.h	/^  FILE *fpCpuTiming;$/;"	m	class:TsOutput
fpEmbeddedSurface	TsOutput.h	/^  FILE *fpEmbeddedSurface;$/;"	m	class:TsOutput
fpEmbeddedSurfaceCf	TsOutput.h	/^  FILE *fpEmbeddedSurfaceCf;$/;"	m	class:TsOutput
fpEmbeddedSurfaceCp	TsOutput.h	/^  FILE *fpEmbeddedSurfaceCp;$/;"	m	class:TsOutput
fpError	TsOutput.h	/^  FILE *fpError;$/;"	m	class:TsOutput
fpFluxNorm	TsOutput.h	/^  FILE *fpFluxNorm;$/;"	m	class:TsOutput
fpForces	TsOutput.h	/^  FILE **fpForces;$/;"	m	class:TsOutput
fpGnForces	TsOutput.h	/^  FILE *fpGnForces;$/;"	m	class:TsOutput
fpHeatFluxes	TsOutput.h	/^  FILE **fpHeatFluxes;$/;"	m	class:TsOutput
fpHydroDynamicForces	TsOutput.h	/^  FILE **fpHydroDynamicForces;$/;"	m	class:TsOutput
fpHydroDynamicLift	TsOutput.h	/^  FILE **fpHydroDynamicLift;$/;"	m	class:TsOutput
fpHydroStaticForces	TsOutput.h	/^  FILE **fpHydroStaticForces;$/;"	m	class:TsOutput
fpHydroStaticLift	TsOutput.h	/^  FILE **fpHydroStaticLift;$/;"	m	class:TsOutput
fpLift	TsOutput.h	/^  FILE **fpLift;$/;"	m	class:TsOutput
fpMatVolumes	TsOutput.h	/^  FILE *fpMatVolumes;$/;"	m	class:TsOutput
fpMatchPressure	TsOutput.h	/^  FILE *fpMatchPressure;$/;"	m	class:TsOutput
fpMatchState	TsOutput.h	/^  FILE *fpMatchState;$/;"	m	class:TsOutput
fpMaterialMassEnergy	TsOutput.h	/^  FILE *fpMaterialMassEnergy;$/;"	m	class:TsOutput
fpResiduals	TsOutput.h	/^  FILE *fpResiduals;$/;"	m	class:TsOutput
fpStateRom	TsOutput.h	/^  FILE *fpStateRom;$/;"	m	class:TsOutput
fpTavForces	TsOutput.h	/^  FILE **fpTavForces;$/;"	m	class:TsOutput
fpTavLift	TsOutput.h	/^  FILE **fpTavLift;$/;"	m	class:TsOutput
fpdFluxNorm	TsOutput.h	/^  FILE *fpdFluxNorm;$/;"	m	class:TsOutput
fpdForces	TsOutput.h	/^  FILE *fpdForces;$/;"	m	class:TsOutput
fpdLiftDrag	TsOutput.h	/^  FILE *fpdLiftDrag;$/;"	m	class:TsOutput
fpdLiftx	TsOutput.h	/^  FILE *fpdLiftx;$/;"	m	class:TsOutput
fpdLifty	TsOutput.h	/^  FILE *fpdLifty;$/;"	m	class:TsOutput
fpdLiftz	TsOutput.h	/^  FILE *fpdLiftz;$/;"	m	class:TsOutput
fpdMatchPressure	TsOutput.h	/^  FILE *fpdMatchPressure;$/;"	m	class:TsOutput
fpe_sigaction	Main.C	/^void fpe_sigaction(int signal, siginfo_t *si, void *arg)$/;"	f
fprintf	CommunicatorMPI.C	/^void Communicator::fprintf(FILE *file, const char *format, ...)$/;"	f	class:Communicator
fprintf	MeshMotionSolver.C	/^void TetMeshMotionSolver::fprintf(FILE *fp, const char *format, ...)$/;"	f	class:TetMeshMotionSolver
fprintf	TsDesc.C	/^void TsDesc<dim>::fprintf(FILE *fp, const char *format, ...)$/;"	f	class:TsDesc
fractionalStrategy	IoData.h	/^   enum FractionalStrategy {Distance = 1, DotProduct = 2} fractionalStrategy;$/;"	m	struct:BLMeshMotionData	typeref:enum:BLMeshMotionData::FractionalStrategy
framework	IoData.h	/^  enum Framework {BODYFITTED = 0, EMBEDDED = 1, EMBEDDEDALE = 2} framework;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::Framework
free	GenMatrix.h	/^  virtual void free(AuxilliaryIterator*) { }$/;"	f	class:GenMat
free	MultiGridDistSVec.C	/^free() {$/;"	f	class:MultiGridDistSVec
free	MvpMatrix.h	/^  void free(typename GenMat<Scalar,dim>::AuxilliaryIterator* genItr) { $/;"	f	class:MvpMat
freeMemoryForGappyPrepro	NonlinearRom.C	/^void NonlinearRom<dim>::freeMemoryForGappyPrepro() {$/;"	f	class:NonlinearRom
freeSlaves	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::freeSlaves(char *&mem, const VecSet<DistSVec<char, dim> > &X, const int M,$/;"	f	class:EmbeddedAlternatingLeastSquare
freeSlaves	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::freeSlaves(double *&mem, const VecSet<DistSVec<double, dim> > &X, const int M,$/;"	f	class:EmbeddedAlternatingLeastSquare
freeSlaves	ParallelRomExtension.cpp	/^void ParallelRomExtension<dim>::freeSlaves(D *&mem, const Mat &X, const int M,$/;"	f	class:ParallelRomExtension
free_timers	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    ARRAY<int> free_timers;$/;"	m	class:PhysBAM::TIMER
freq	IoData.h	/^  double freq[num];$/;"	m	struct:PadeData
freq1	IoData.h	/^  double freq1;$/;"	m	struct:PadeData
freq10	IoData.h	/^  double freq10;$/;"	m	struct:PadeData
freq11	IoData.h	/^  double freq11;$/;"	m	struct:PadeData
freq2	IoData.h	/^  double freq2;$/;"	m	struct:PadeData
freq3	IoData.h	/^  double freq3;$/;"	m	struct:PadeData
freq4	IoData.h	/^  double freq4;$/;"	m	struct:PadeData
freq5	IoData.h	/^  double freq5;$/;"	m	struct:PadeData
freq6	IoData.h	/^  double freq6;$/;"	m	struct:PadeData
freq7	IoData.h	/^  double freq7;$/;"	m	struct:PadeData
freq8	IoData.h	/^  double freq8;$/;"	m	struct:PadeData
freq9	IoData.h	/^  double freq9;$/;"	m	struct:PadeData
freqIntegrate	Modal.C	/^void ModalSolver<dim>::freqIntegrate(VecSet<DistSVec<double, dim> >&snaps,$/;"	f	class:ModalSolver
freqIntegrateMultipleRhs	Modal.C	/^void ModalSolver<dim>::freqIntegrateMultipleRhs(VecSet<DistSVec<double, dim> >&snapsCoarse,$/;"	f	class:ModalSolver
freqMap	IoData.h	/^  ObjectMap<double> freqMap;$/;"	m	struct:PadeFreq
freqStep	IoData.h	/^  double freqStep;$/;"	m	struct:LinearizedData
frequency	IoData.h	/^  double frequency;$/;"	m	struct:ForcedData
frequency	IoData.h	/^  double frequency;$/;"	m	struct:LinearizedData
frequency	IoData.h	/^  int frequency;$/;"	m	struct:MultiFluidData
frequency	IoData.h	/^  int frequency;$/;"	m	struct:RestartData
frequency	IoData.h	/^  int frequency;$/;"	m	struct:TransientData
frequency	OneDimensionalSolver.h	/^  int frequency; \/\/postprocessing output frequency$/;"	m	class:OneDimensional
frequency	TsOutput.h	/^  int frequency;$/;"	m	class:TsOutput
frequency	TsRestart.h	/^  int frequency;$/;"	m	class:TsRestart
frequencyLS	LevelSetTsDesc.h	/^  int frequencyLS;$/;"	m	class:LevelSetTsDesc
frequencyLS	MultiPhysicsTsDesc.h	/^  int frequencyLS; \/\/ frequency for reinitialization of level set$/;"	m	class:MultiPhysicsTsDesc
frequency_dt	IoData.h	/^  double frequency_dt; \/\/set to -1.0 by default. Used iff it is activated (>0.0) by user. $/;"	m	struct:RestartData
frequency_dt	IoData.h	/^  double frequency_dt; \/\/set to -1.0 by default. Used iff it is activated (>0.0) by user. $/;"	m	struct:TransientData
frequency_dt	TsOutput.h	/^  double frequency_dt, prtout;$/;"	m	class:TsOutput
frequency_dt	TsRestart.h	/^  double frequency_dt, prtout;$/;"	m	class:TsRestart
fres	IoData.h	/^  double fres;$/;"	m	struct:SensitivityAnalysis
frobenius_norm	AlternatingLeastSquare/als_util.cpp	/^double frobenius_norm(double *X, int M, int N){$/;"	f
from	Communicator.h	/^    int from, to, cpuID;$/;"	m	struct:SubDTopo::CPair
fsPat	Domain.h	/^  CommPattern<int> *fsPat;$/;"	m	class:Domain
fsaPrintTextOnScreen	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsaPrintTextOnScreen(const char *Text)$/;"	f	class:FluidShapeOptimizationHandler
fsaRestartBcFluxs	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsaRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidShapeOptimizationHandler
fsaSolve	TsSolver.h	/^int TsSolver<ProblemDescriptor>::fsaSolve(IoData &ioData)$/;"	f	class:TsSolver
fscale	StructExc.h	/^  double fscale;$/;"	m	class:StructExc
fseek	BinFileHandler.h	/^  inline OffType fseek(FILE *fp, OffType offset, int whence)  { return fseek64(fp, offset, whence); }$/;"	f	class:BinFileHandler
fsi	MatVecProd.h	/^  _fsi fsi;$/;"	m	class:MatVecProd
fsi	MatVecProd.h	/^  _fsi fsi;$/;"	m	class:MatVecProdMultiPhase
fsiFlag	IoData.h	/^  bool fsiFlag;$/;"	m	struct:SensitivityAnalysis
fsiRiemann	ExactRiemannSolver.h	/^  LocalRiemann *fsiRiemann;$/;"	m	class:ExactRiemannSolver
fsisoSolve	TsSolver.h	/^int TsSolver<ProblemDescriptor>::fsisoSolve(IoData &ioData)$/;"	f	class:TsSolver
fsoAdjointLinearSolver	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoAdjointLinearSolver$/;"	f	class:FluidShapeOptimizationHandler
fsoAeroelasticHandler	FluidShapeOptimizationHandler.C	/^int FluidShapeOptimizationHandler<dim>::fsoAeroelasticHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fsoAnalytical	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoAnalytical	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoAnalytical	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoAnalytical	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoAnalytical	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:FluidRomShapeOptimizationHandler
fsoAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoAnalytical$/;"	f	class:FluidShapeOptimizationHandler
fsoApply_dFdXtranspose	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoApply_dFdXtranspose$/;"	f	class:FluidShapeOptimizationHandler
fsoComputeAdjoint	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoComputeAdjoint(IoData &ioData, DistVec<double> &A, DistSVec<double,3> &dQdX, DistSVec<double,dim> &dQdU, bool isFSI)$/;"	f	class:FluidShapeOptimizationHandler
fsoComputeAndSendForceSensitivities	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoComputeAndSendForceSensitivities(bool isSparse, IoData &ioData, const char *fileName,$/;"	f	class:FluidShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoComputeDerivativesOfFluxAndSolution	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoComputeDerivativesOfFluxAndSolution(IoData &ioData,$/;"	f	class:FluidShapeOptimizationHandler
fsoComputeSensitivities	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoComputeSensitivities$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoComputeSensitivities	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoComputeSensitivities(IoData &ioData, const char *mesage, const char *fileName, DistSVec<double,3> &X, DistSVec<double,dim> &U)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoComputeSensitivities	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoComputeSensitivities(IoData &ioData, const char *mesage, const char *fileName, DistSVec<double,3> &X, DistSVec<double,dim> &U)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoComputeSensitivities	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoComputeSensitivities(IoData &ioData, const char *mesage, const char *fileName, DistSVec<double,3> &X, DistSVec<double,dim> &U)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoComputeSensitivities	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoComputeSensitivities(IoData &ioData, const char *mesage, const char *fileName, DistSVec<double,3> &X, DistSVec<double,dim> &U)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoComputeSensitivities	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoComputeSensitivities(bool isSparse,$/;"	f	class:FluidShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical(IoData &ioData,$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical(IoData &ioData,$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical(IoData &ioData,$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical(IoData &ioData,$/;"	f	class:FluidRomShapeOptimizationHandler
fsoGetDerivativeOfEffortsAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsAnalytical($/;"	f	class:FluidShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference(IoData &ioData,$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference(IoData &ioData,$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference(IoData &ioData,$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference(IoData &ioData,$/;"	f	class:FluidRomShapeOptimizationHandler
fsoGetDerivativeOfEffortsFiniteDifference	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsFiniteDifference($/;"	f	class:FluidShapeOptimizationHandler
fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfEffortsWRTStateAndMeshPositionAnalytical(IoData &ioData,$/;"	f	class:FluidShapeOptimizationHandler
fsoGetDerivativeOfLoadAnalytical	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadAnalytical(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoGetDerivativeOfLoadAnalytical	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadAnalytical(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:FluidGnatShapeOptimizationHandler
fsoGetDerivativeOfLoadAnalytical	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadAnalytical(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:FluidMetricShapeOptimizationHandler
fsoGetDerivativeOfLoadAnalytical	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadAnalytical(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, $/;"	f	class:FluidRomShapeOptimizationHandler
fsoGetDerivativeOfLoadAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadAnalytical(bool isSparse, IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:FluidShapeOptimizationHandler
fsoGetDerivativeOfLoadFiniteDifference	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoGetDerivativeOfLoadFiniteDifference	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoGetDerivativeOfLoadFiniteDifference	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoGetDerivativeOfLoadFiniteDifference	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,$/;"	f	class:FluidRomShapeOptimizationHandler
fsoGetDerivativeOfLoadFiniteDifference	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetDerivativeOfLoadFiniteDifference(IoData &ioData, DistSVec<double,3> &X, DistSVec<double,3> &dX, DistVec<double> &A,$/;"	f	class:FluidShapeOptimizationHandler
fsoGetEfforts	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoGetEfforts$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoGetEfforts	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoGetEfforts(IoData &ioData, $/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoGetEfforts	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoGetEfforts(IoData &ioData, $/;"	f	class:FluidGnatShapeOptimizationHandler
fsoGetEfforts	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoGetEfforts(IoData &ioData, $/;"	f	class:FluidMetricShapeOptimizationHandler
fsoGetEfforts	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoGetEfforts(IoData &ioData, $/;"	f	class:FluidRomShapeOptimizationHandler
fsoGetEfforts	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetEfforts(IoData &ioData,$/;"	f	class:FluidShapeOptimizationHandler
fsoGetTransposeDerivativeOfLoadAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoGetTransposeDerivativeOfLoadAnalytical(IoData &ioData,$/;"	f	class:FluidShapeOptimizationHandler
fsoHandler	EmbeddedFluidShapeOptimizationHandler.C	/^int EmbeddedFluidShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoHandler	FluidCollocationShapeOptimizationHandler.C	/^int FluidCollocationShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoHandler	FluidGnatShapeOptimizationHandler.C	/^int FluidGnatShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoHandler	FluidMetricShapeOptimizationHandler.C	/^int FluidMetricShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoHandler	FluidRomShapeOptimizationHandler.C	/^int FluidRomShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoHandler	FluidShapeOptimizationHandler.C	/^int FluidShapeOptimizationHandler<dim>::fsoHandler(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fsoInitialize	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoInitialize	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoInitialize	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoInitialize	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoInitialize	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoInitialize	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoInitialize(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fsoLinearSolver	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoLinearSolver$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoLinearSolver	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoLinearSolver$/;"	f	class:FluidShapeOptimizationHandler
fsoOutput1D	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoOutput1D(const char *fileName, DistVec<double> &V)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoOutput1D	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoOutput1D(const char *fileName, DistVec<double> &V)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoOutput1D	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoOutput1D(const char *fileName, DistVec<double> &V)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoOutput1D	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoOutput1D(const char *fileName, DistVec<double> &V)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoOutput1D	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoOutput1D(const char *fileName, DistVec<double> &V)$/;"	f	class:FluidShapeOptimizationHandler
fsoOutput3D	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoOutput3D(const char *fileName, DistSVec<double,3> &V)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoOutput3D	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoOutput3D(const char *fileName, DistSVec<double,3> &V)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoOutput3D	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoOutput3D(const char *fileName, DistSVec<double,3> &V)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoOutput3D	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoOutput3D(const char *fileName, DistSVec<double,3> &V)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoOutput3D	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoOutput3D(const char *fileName, DistSVec<double,3> &V)$/;"	f	class:FluidShapeOptimizationHandler
fsoOutputDimD	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoOutputDimD(const char *fileName, DistSVec<double,dim> &V)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoOutputDimD	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoOutputDimD(const char *fileName, DistSVec<double,dim> &V)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoOutputDimD	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoOutputDimD(const char *fileName, DistSVec<double,dim> &V)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoOutputDimD	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoOutputDimD(const char *fileName, DistSVec<double,dim> &V)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoOutputDimD	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoOutputDimD(const char *fileName, DistSVec<double,dim> &V)$/;"	f	class:FluidShapeOptimizationHandler
fsoPrintTextOnScreen	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text){$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoPrintTextOnScreen	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoPrintTextOnScreen	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoPrintTextOnScreen	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoPrintTextOnScreen	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoPrintTextOnScreen	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoPrintTextOnScreen(const char *Text)$/;"	f	class:FluidShapeOptimizationHandler
fsoRestartBcFluxs	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoRestartBcFluxs	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoRestartBcFluxs	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoRestartBcFluxs	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoRestartBcFluxs	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoRestartBcFluxs	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoRestartBcFluxs(IoData &ioData)$/;"	f	class:FluidShapeOptimizationHandler
fsoSemiAnalytical	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoSemiAnalytical	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoSemiAnalytical	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoSemiAnalytical	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoSemiAnalytical	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:FluidRomShapeOptimizationHandler
fsoSemiAnalytical	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoSemiAnalytical$/;"	f	class:FluidShapeOptimizationHandler
fsoSetUpAdjointLinearSolver	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoSetUpAdjointLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A,$/;"	f	class:FluidShapeOptimizationHandler
fsoSetUpLinearSolver	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fsoSetUpLinearSolver$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fsoSetUpLinearSolver	FluidCollocationShapeOptimizationHandler.C	/^void FluidCollocationShapeOptimizationHandler<dim>::fsoSetUpLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidCollocationShapeOptimizationHandler
fsoSetUpLinearSolver	FluidGnatShapeOptimizationHandler.C	/^void FluidGnatShapeOptimizationHandler<dim>::fsoSetUpLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidGnatShapeOptimizationHandler
fsoSetUpLinearSolver	FluidMetricShapeOptimizationHandler.C	/^void FluidMetricShapeOptimizationHandler<dim>::fsoSetUpLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidMetricShapeOptimizationHandler
fsoSetUpLinearSolver	FluidRomShapeOptimizationHandler.C	/^void FluidRomShapeOptimizationHandler<dim>::fsoSetUpLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A, DistSVec<double,dim> &U)$/;"	f	class:FluidRomShapeOptimizationHandler
fsoSetUpLinearSolver	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fsoSetUpLinearSolver(IoData &ioData, DistSVec<double,3> &X, DistVec<double> &A,$/;"	f	class:FluidShapeOptimizationHandler
fsoSolve	TsSolver.h	/^int TsSolver<ProblemDescriptor>::fsoSolve(IoData &ioData)$/;"	f	class:TsSolver
fso_on_AdjointSensitivityMesh	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_AdjointSensitivityMesh(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_aeroelasticAdjointSensitivityFSI	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_aeroelasticAdjointSensitivityFSI(IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_aeroelasticSensitivityFSI	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_aeroelasticSensitivityFSI(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_sensitivityAlpha	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fso_on_sensitivityAlpha$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fso_on_sensitivityAlpha	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityAlpha(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_sensitivityBeta	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fso_on_sensitivityBeta$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fso_on_sensitivityBeta	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityBeta(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_sensitivityMach	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fso_on_sensitivityMach$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fso_on_sensitivityMach	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityMach(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
fso_on_sensitivityMesh	EmbeddedFluidShapeOptimizationHandler.C	/^void EmbeddedFluidShapeOptimizationHandler<dim>::fso_on_sensitivityMesh$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
fso_on_sensitivityMesh	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::fso_on_sensitivityMesh(bool isSparse, IoData &ioData, DistSVec<double,dim> &U)$/;"	f	class:FluidShapeOptimizationHandler
ftell	BinFileHandler.h	/^  inline OffType ftell(FILE *fp)  { return ftell64(fp); }$/;"	f	class:BinFileHandler
ftest	FluxFcnDescJwl.C	/^FILE* ftest = NULL;$/;"	v
fullOptPressureName	TsOutput.h	/^  char *fullOptPressureName;$/;"	m	class:TsOutput
functionTest	SparseGridGeneratorDesc.h	/^  void functionTest(double *in, double *res, double *parameters){ $/;"	f
fvJac	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
fvTerm	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
fv_comp_tag	MultiGridLevel.h	/^    DistSVec<int,2>* fv_comp_tag;$/;"	m	class:MultiGridLevel
fvmers_3pbdf	DistTimeState.h	/^  int fvmers_3pbdf ;$/;"	m	class:DistTimeState
fvmers_3pbdf	IoData.h	/^  enum FVMERS3PBDFSchme { BDF_SCHEME1 = 1, BDF_SCHEME2 = 0 } fvmers_3pbdf;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::FVMERS3PBDFSchme
g	KspSolver.h	/^  Vec<ScalarT> g, y;$/;"	m	class:GmresSolver
g_t1DGrid	Manual/Aerof3d.html	/^<a name="g_t1DGrid"><\/a>$/;"	a
g_t1DRestartData	Manual/Aerof3d.html	/^<a name="g_t1DRestartData"><\/a>$/;"	a
gam	DistDynamicLESTerm.h	/^  double            gam, Rideal;$/;"	m	class:DistDynamicLESTerm
gam	DistTimeState.h	/^  double gam;$/;"	m	class:DistTimeState
gam	VarFcnSGEuler.h	/^  double gam;$/;"	m	class:VarFcnSGEuler
gam	VarFcnSGKE.h	/^  double gam;$/;"	m	class:VarFcnSGKE
gam	VarFcnSGSA.h	/^  double gam;$/;"	m	class:VarFcnSGSA
gam	WallFcn.h	/^  double gam;$/;"	m	class:WallFcn
gam1	VarFcnSGEuler.h	/^  double gam1;$/;"	m	class:VarFcnSGEuler
gam1	VarFcnSGKE.h	/^  double gam1;$/;"	m	class:VarFcnSGKE
gam1	VarFcnSGSA.h	/^  double gam1;$/;"	m	class:VarFcnSGSA
gamData	IoData.h	/^  const char *gamData;$/;"	m	struct:TransientData
gamFData	IoData.h	/^  const char *gamFData;$/;"	m	struct:TransientData
gamFreq	IoData.h	/^  double gamFreq[numFreq];$/;"	m	struct:LinearizedData
gamFreq1	IoData.h	/^  double gamFreq1;$/;"	m	struct:LinearizedData
gamFreq10	IoData.h	/^  double gamFreq10;$/;"	m	struct:LinearizedData
gamFreq11	IoData.h	/^  double gamFreq11;$/;"	m	struct:LinearizedData
gamFreq12	IoData.h	/^  double gamFreq12;$/;"	m	struct:LinearizedData
gamFreq13	IoData.h	/^  double gamFreq13;$/;"	m	struct:LinearizedData
gamFreq14	IoData.h	/^  double gamFreq14;$/;"	m	struct:LinearizedData
gamFreq15	IoData.h	/^  double gamFreq15;$/;"	m	struct:LinearizedData
gamFreq16	IoData.h	/^  double gamFreq16;$/;"	m	struct:LinearizedData
gamFreq17	IoData.h	/^  double gamFreq17;$/;"	m	struct:LinearizedData
gamFreq18	IoData.h	/^  double gamFreq18;$/;"	m	struct:LinearizedData
gamFreq19	IoData.h	/^  double gamFreq19;$/;"	m	struct:LinearizedData
gamFreq2	IoData.h	/^  double gamFreq2;$/;"	m	struct:LinearizedData
gamFreq20	IoData.h	/^  double gamFreq20;$/;"	m	struct:LinearizedData
gamFreq3	IoData.h	/^  double gamFreq3;$/;"	m	struct:LinearizedData
gamFreq4	IoData.h	/^  double gamFreq4;$/;"	m	struct:LinearizedData
gamFreq5	IoData.h	/^  double gamFreq5;$/;"	m	struct:LinearizedData
gamFreq6	IoData.h	/^  double gamFreq6;$/;"	m	struct:LinearizedData
gamFreq7	IoData.h	/^  double gamFreq7;$/;"	m	struct:LinearizedData
gamFreq8	IoData.h	/^  double gamFreq8;$/;"	m	struct:LinearizedData
gamFreq9	IoData.h	/^  double gamFreq9;$/;"	m	struct:LinearizedData
gamma	DynamicLESTerm.h	/^  double gamma;$/;"	m	class:DynamicLESTerm
gamma	DynamicVMSTerm.h	/^  double gamma;$/;"	m	class:DynamicVMSTerm
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLCEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLCKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLCSA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLEEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLEKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacHLLESA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacRoeEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacRoeKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnApprJacRoeSA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnExactJacRoeEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnExactJacRoeKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnExactJacRoeSA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLCEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLCKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLCSA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLEEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLEKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacHLLESA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacRoeEuler3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacRoeKE3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnFDJacRoeSA3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnRoeKEturb3D
gamma	FluxFcnDesc.h	/^  double gamma;$/;"	m	class:FluxFcnRoeSAturb3D
gamma	IoData.h	/^  double gamma;$/;"	m	struct:SchemeData
gamma	MacroCell.h	/^  double gamma;$/;"	m	class:MacroCell
gamma	ProgrammedBurnCore.C	/^	double gamma;$/;"	m	class:ProgrammedBurn_CJ::IdealGasEOS	file:
gamma	SmagorinskyLESTerm.h	/^  double gamma;$/;"	m	class:SmagorinskyLESTerm
gamma	VMSLESTerm.h	/^  double gamma;$/;"	m	class:VMSLESTerm
gamma	WaleLESTerm.h	/^  double gamma;$/;"	m	class:WaleLESTerm
gap	MatchNode.C	/^  double gap[3];$/;"	m	struct:MatchNode	file:
gap	MatchNode.h	/^  double (*gap)[3];$/;"	m	class:MatchNodeSet
gapVec	CorotSolver.h	/^  double (**gapVec)[3]; \/\/ gap vectors on structure interface$/;"	m	class:CorotSolver
gappy	IoData.h	/^  GappyConstructionData gappy;$/;"	m	struct:NonlinearRomOfflineData
gappyIO	GappyPreprocessing.h	/^        GappyConstructionData* gappyIO;$/;"	m	class:GappyPreprocessing
gappyJacActionName	IoData.h	/^  const char *gappyJacActionName;             \/\/jacMatrix in sampled coords; $/;"	m	struct:NonlinearRomFilesData
gappyJacActionName	NonlinearRom.h	/^  char* gappyJacActionName;$/;"	m	class:NonlinearRom
gappyOffline	Timer.h	/^                gappyOffline, romOffline, icInterp, NUMTIMINGS$/;"	e	enum:Timer::TimerIndex
gappyPrefix	IoData.h	/^  const char *gappyPrefix;$/;"	m	struct:NonlinearRomFilesData
gappyResidualName	IoData.h	/^  const char *gappyResidualName;             \/\/resMatrix in sampled coords;$/;"	m	struct:NonlinearRomFilesData
gappyResidualName	NonlinearRom.h	/^  char* gappyResidualName;$/;"	m	class:NonlinearRom
gasModel	IoData.h	/^  GasModelData gasModel;$/;"	m	struct:FluidModelData
gatherNumbers	IntersectorPhysBAM/Mpi_Utilities.h	/^void gatherNumbers(Communicator& com,T localValue,T* toGather)$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
gatherSet	IntersectorPhysBAM/Mpi_Utilities.C	/^void gatherSet(Communicator& com, set<pair<pair<GLOBAL_SUBD_ID,int>,pair<GLOBAL_SUBD_ID,int> > >& set)$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
gaussian_iset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^    int gaussian_iset; \/\/ Used to force Get_Gaussian to reset$/;"	m	class:PhysBAM::RANDOM_NUMBERS
gbmv	arpack++/include/blas1c.h	/^inline void gbmv(const char* trans, const ARint &m, $/;"	f
gbmv	arpack++/include/blas1c.h	/^inline void gbmv(const char* trans, const ARint &m, const ARint &n, $/;"	f
gbtrf	arpack++/include/lapackc.h	/^inline void gbtrf(const ARint &m, const ARint &n, const ARint &kl,$/;"	f
gbtrs	arpack++/include/lapackc.h	/^inline void gbtrs(const char* trans, const ARint &n, const ARint &kl,$/;"	f
gemv	arpack++/include/blas1c.h	/^inline void gemv(const char* trans, const ARint &m, $/;"	f
gemv	arpack++/include/blas1c.h	/^inline void gemv(const char* trans, const ARint &m, const ARint &n, $/;"	f
gendispFile	IoData.h	/^  const char *gendispFile;$/;"	m	struct:TransientData
generalizedforces	IoData.h	/^  const char *generalizedforces;$/;"	m	struct:TransientData
generalizedforces	TsOutput.h	/^  char *generalizedforces;$/;"	m	class:TsOutput
generate	SparseGridCluster.C	/^void SparseGridCluster::generate(SparseGridData &data, double *param,$/;"	f	class:SparseGridCluster
generateConnectionsSet	IntersectorPhysBAM/FloodFill.C	/^void FloodFill::generateConnectionsSet(Domain& domain,Communicator& com,DistVec<int>& nodeColors)$/;"	f	class:FloodFill
generateSubDToProcessorMap	IntersectorPhysBAM/FloodFill.C	/^void FloodFill::generateSubDToProcessorMap(Domain& domain,Communicator& com)$/;"	f	class:FloodFill
generateSubGrid	SparseGridCore.C	/^double **SparseGrid::generateSubGrid(const int newSubGrid,$/;"	f	class:SparseGrid
geoName	GeoSource.h	/^  char *geoName;$/;"	m	class:GeoSource
geoSource	NonlinearRomDatabaseConstruction.h	/^  GeoSource &geoSource;$/;"	m	class:NonlinearRomDatabaseConstruction
geoSource	NonlinearRomOffline.h	/^    GeoSource &geoSource;$/;"	m	class:NonlinearRomOfflineSolver
geoSourceTmp	GappyPreprocessing.h	/^	GeoSource *geoSourceTmp;$/;"	m	class:GappyPreprocessing
geoState	GappyPreprocessing.h	/^	DistGeoState *geoState;$/;"	m	class:GappyPreprocessing
geoState	MatVecProd.h	/^  DistGeoState *geoState;$/;"	m	class:MatVecProdFD
geoState	MatVecProd.h	/^  DistGeoState *geoState;$/;"	m	class:MatVecProdFDMultiPhase
geoState	MatVecProd.h	/^  DistGeoState *geoState;$/;"	m	class:MatVecProdLS
geoState	Modal.h	/^    DistGeoState *geoState;$/;"	m	class:ModalSolver
geoState	MultiGridKernel.h	/^  DistGeoState& geoState;$/;"	m	class:MultiGridKernel
geoState	NonlinearRomOffline.h	/^    DistGeoState *geoState;$/;"	m	class:NonlinearRomOfflineSolver
geoState	PostOperator.h	/^  DistGeoState *geoState;$/;"	m	class:PostOperator
geoState	SpaceOperator.h	/^  DistGeoState *geoState;$/;"	m	class:SpaceOperator
geoState	TsDesc.h	/^  DistGeoState *geoState;$/;"	m	class:TsDesc
geomTol	SubDomain.h	/^  double geomTol;$/;"	m	class:SubDomain
geometry	IoData.h	/^  const char *geometry;$/;"	m	struct:InputData
geometryprefix	IoData.h	/^  const char *geometryprefix;$/;"	m	struct:InputData
get	AlternatingLeastSquare/als_util.cpp	/^double get(double *M, int m, int n, int r, int c) {$/;"	f
get	AlternatingLeastSquare/als_util.cpp	/^unsigned char get(unsigned char *M, int m, int n, int r, int c) {$/;"	f
get	BlockTridiagonalMatrix.C	/^Scalar (*BlockTridiagonalMatrix<Scalar,dim>::get(int i,int j))[dim*dim] {$/;"	f
getA1	VarFcn.h	/^  double getA1(int tag=0) const{ check(tag); return varFcn[tag]->getA1(); }$/;"	f	class:VarFcn
getA1	VarFcnBase.h	/^  virtual double getA1() const{$/;"	f	class:VarFcnBase
getA1	VarFcnJwl.h	/^  double getA1()         const{ return A1; }$/;"	f	class:VarFcnJwl
getA2	VarFcn.h	/^  double getA2(int tag=0) const{ check(tag); return varFcn[tag]->getA2(); }$/;"	f	class:VarFcn
getA2	VarFcnBase.h	/^  virtual double getA2() const{$/;"	f	class:VarFcnBase
getA2	VarFcnJwl.h	/^  double getA2()         const{ return A2; }$/;"	f	class:VarFcnJwl
getAbs	DistVector.h	/^DistSVec<Scalar,dim>::getAbs(const DistSVec<bcomp,dim> &y)$/;"	f	class:DistSVec
getAgglomFaceDistInfo	MultiGridLevel.h	/^    DistInfo& getAgglomFaceDistInfo()       { return *agglomFaceDistInfo; }$/;"	f	class:MultiGridLevel
getAgglomeratedFaces	MultiGridLevel.h	/^    AgglomeratedFaceSet ** getAgglomeratedFaces()             { return agglomeratedFaces; }$/;"	f	class:MultiGridLevel
getAlgNum	MeshMotionHandler.h	/^  int getAlgNum()  { return dynNodalTransfer->getAlgorithmNumber(); }$/;"	f	class:EmbeddedMeshMotionHandler
getAlgNum	MeshMotionHandler.h	/^  virtual int getAlgNum()  { return 0; }$/;"	f	class:MeshMotionHandler
getAlgNum	MeshMotionHandlerCore.C	/^int AeroMeshMotionHandler::getAlgNum()  {$/;"	f	class:AeroMeshMotionHandler
getAlgorithmNumber	FSI/DynamicNodalTransfer.h	/^        int getAlgorithmNumber() {return algNum;}$/;"	f	class:DynamicNodalTransfer
getAlgorithmNumber	FSI/DynamicNodalTransfer.h	/^  int getAlgorithmNumber() {return algNum;}$/;"	f	class:EmbeddedStructure
getAlgorithmNumber	StructExc.h	/^  int getAlgorithmNumber() const { return algNum; }$/;"	f	class:StructExc
getAlphaWater	VarFcn.h	/^  double getAlphaWater(int tag=0) const{ check(tag); return varFcn[tag]->getAlphaWater(); }$/;"	f	class:VarFcn
getAlphaWater	VarFcnBase.h	/^  virtual double getAlphaWater() const{$/;"	f	class:VarFcnBase
getAlphaWater	VarFcnTait.h	/^  double getAlphaWater() const{ return a_; }$/;"	f	class:VarFcnTait
getArea	AgglomeratedFace.h	/^  double& getArea() { return area; }$/;"	f	class:AgglomeratedFace
getAssigner	IoDataCore.C	/^Assigner *BoundaryData::getAssigner()  {$/;"	f	class:BoundaryData
getAssigner	IoDataCore.C	/^Assigner *CylinderData::getAssigner()$/;"	f	class:CylinderData
getAssigner	IoDataCore.C	/^Assigner *DummyPointData::getAssigner()$/;"	f	class:DummyPointData
getAssigner	IoDataCore.C	/^Assigner *FluidModelData::getAssigner()$/;"	f	class:FluidModelData
getAssigner	IoDataCore.C	/^Assigner *PlaneData::getAssigner()$/;"	f	class:PlaneData
getAssigner	IoDataCore.C	/^Assigner *PointData::getAssigner()$/;"	f	class:PointData
getAssigner	IoDataCore.C	/^Assigner *PrismData::getAssigner()$/;"	f	class:PrismData
getAssigner	IoDataCore.C	/^Assigner *RotationData::getAssigner()  {$/;"	f	class:RotationData
getAssigner	IoDataCore.C	/^Assigner *SphereData::getAssigner()$/;"	f	class:SphereData
getAssigner	IoDataCore.C	/^Assigner *SurfaceData::getAssigner()  {$/;"	f	class:SurfaceData
getAssigner	IoDataCore.C	/^Assigner *VolumeData::getAssigner()  {$/;"	f	class:VolumeData
getAssigner	IoDataCore.C	/^Assigner* FluidRemapData::getAssigner() {$/;"	f	class:FluidRemapData
getAssigner	IoDataCore.C	/^Assigner* LinePlot::getAssigner()$/;"	f	class:LinePlot
getAssigner	IoDataCore.C	/^Assigner* OneDimensionalInputData::getAssigner() {$/;"	f	class:OneDimensionalInputData
getAssigner	IoDataCore.C	/^Assigner* SchemeData::MaterialFluxData::getAssigner() {$/;"	f	class:SchemeData::MaterialFluxData
getAuxilliaryRow	MvpMatrix.h	/^  Scalar* getAuxilliaryRow(AuxilliaryRows& A, int i, int j) {$/;"	f	class:MvpMat
getBC	GeoSource.C	/^void GeoSource::getBC(BCondSet *&subBC, MapType &cl2LocNodeMap)$/;"	f	class:GeoSource
getBcData	MultiGridOperator.h	/^  DistBcData<dim>& getBcData() const { return *myBcData; }$/;"	f	class:MultiGridOperator
getBcElem_ij	GenMatrix.h	/^  virtual Scalar *getBcElem_ij(int l) {fprintf(stderr, "No Implementation\\n"); return 0;}$/;"	f	class:GenMat
getBcElem_ij	MultiGridSmoothingMatrix.h	/^  Scalar *getBcElem_ij(int l) { return *(a.v + n + 2 * numEdges + 2 * l); }$/;"	f	class:MultiGridSmoothingMatrix
getBcElem_ij	MvpMatrix.h	/^  Scalar *getBcElem_ij(int l) { return *(a.v + n + 2 * numEdges + 2 * l); }$/;"	f	class:MvpMat
getBcElem_ji	GenMatrix.h	/^  virtual Scalar *getBcElem_ji(int l) {fprintf(stderr, "No Implementation\\n"); return 0;}$/;"	f	class:GenMat
getBcElem_ji	MultiGridSmoothingMatrix.h	/^  Scalar *getBcElem_ji(int l) { return *(a.v + n + 2 * numEdges + 2 * l + 1); }$/;"	f	class:MultiGridSmoothingMatrix
getBcElem_ji	MvpMatrix.h	/^  Scalar *getBcElem_ji(int l) { return *(a.v + n + 2 * numEdges + 2 * l + 1); }$/;"	f	class:MvpMat
getBcFcn	SpaceOperator.h	/^  BcFcn* getBcFcn() { return bcFcn; }$/;"	f	class:SpaceOperator
getBestSplit	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::getBestSplit(int nobj, Obj *allObjs, int dir) {$/;"	f	class:KDTree
getBeta	LowMachPrec.h	/^  double getBeta(double locMach, bool checktac = false) const $/;"	f	class:SpatialLowMachPrec
getBeta	LowMachPrec.h	/^  double getBeta(double locMach, bool checktac = false) const$/;"	f	class:TimeLowMachPrec
getBeta	LowMachPrec.h	/^  double getBeta(double locMach, double irey) const$/;"	f	class:TimeLowMachPrec
getBetaWater	VarFcn.h	/^  double getBetaWater(int tag=0)  const{ check(tag); return varFcn[tag]->getBetaWater(); }$/;"	f	class:VarFcn
getBetaWater	VarFcnBase.h	/^  virtual double getBetaWater() const{$/;"	f	class:VarFcnBase
getBetaWater	VarFcnTait.h	/^  double getBetaWater()  const{ return b_; }$/;"	f	class:VarFcnTait
getBlockAllocator	Elem.h	/^  BlockAlloc& getBlockAllocator() { return memElems; }$/;"	f	class:ElemSet
getBlockAllocator	Face.h	/^  BlockAlloc& getBlockAllocator() { return memFaces; }$/;"	f	class:FaceSet
getBoundaryState	MultiGridOperator.h	/^  DistSVec<Scalar,dim>& getBoundaryState() const { return *boundaryState; }$/;"	f	class:MultiGridOperator
getBoundaryStateHH	BcData.h	/^  Vec<double>* getBoundaryStateHH() { return boundaryStateHH; }$/;"	f	class:BcData
getBoundaryStateHH	DistBcData.h	/^  DistVec<double>* getBoundaryStateHH() { return boundaryStateHH; }$/;"	f	class:DistBcData
getBurnedEOS	ProgrammedBurnCore.C	/^int ProgrammedBurn::getBurnedEOS(int tag) const {$/;"	f	class:ProgrammedBurn
getCflMinOverCfl0	TsParameters.h	/^  double getCflMinOverCfl0(){return (cflMin\/cfl0);}$/;"	f	class:TsParameters
getChannelID	CommunicatorCore.C	/^SubDTopo::getChannelID(int glFrom, int glTo)$/;"	f	class:SubDTopo
getClosestPoints	IntersectorFRG/IntersectorFRG.h	/^    DistVec<ClosestPoint> & getClosestPoints() {$/;"	f	class:DistIntersectorFRG
getClosestPoints	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<ClosestPoint> & getClosestPoints() {return *closest;}$/;"	f	class:DistIntersectorPhysBAM
getClosestPoints	LevelSet/MultiGridLevelSetStructure.h	/^    virtual DistVec<ClosestPoint> &getClosestPoints() { return *dummycp; }$/;"	f	class:DistMultiGridLevelSetStructure
getClosestPointsPointer	IntersectorFRG/IntersectorFRG.h	/^    DistVec<ClosestPoint> * getClosestPointsPointer() {return NULL;}$/;"	f	class:DistIntersectorFRG
getClosestPointsPointer	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<ClosestPoint> * getClosestPointsPointer() {return closest;}$/;"	f	class:DistIntersectorPhysBAM
getClosestPointsPointer	LevelSet/MultiGridLevelSetStructure.h	/^    virtual DistVec<ClosestPoint> *getClosestPointsPointer() { return dummycp; }$/;"	f	class:DistMultiGridLevelSetStructure
getClosestTriangles	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::getClosestTriangles(SVec<double,3> &X, SVec<double,3> &boxMin, SVec<double,3> &boxMax, Vec<int> &tId, Vec<double> &dist, bool useScope) $/;"	f	class:IntersectorFRG
getCode	AgglomeratedFace.h	/^  int getCode() const { return code; }$/;"	f	class:AgglomeratedFace
getCode	Face.h	/^  int getCode()  { return code; }$/;"	f	class:Face
getCommPat	DistMatrix.h	/^  CommPattern<bcomp> *getCommPat(DistSVec<bcomp, dim> &)  { return compVecPat; }$/;"	f	class:DistMat
getCommPat	DistMatrix.h	/^  CommPattern<double> *getCommPat(DistSVec<double, dim> &)  { return vecPat; }$/;"	f	class:DistMat
getCommPat	Domain.h	/^  CommPattern<bcomp> *getCommPat(DistSVec<bcomp,dim> &vec) { return compVecPat; }$/;"	f	class:Domain
getCommPat	Domain.h	/^  CommPattern<double> *getCommPat(DistSVec<double,dim> &vec) { return vecPat; }$/;"	f	class:Domain
getCommPat	Domain.h	/^  CommPattern<double> *getCommPat(DistVec<double> &vec) { return volPat; }$/;"	f	class:Domain
getCommunicator	Domain.h	/^  Communicator *getCommunicator() const { return com; }$/;"	f	class:Domain
getCommunicator	TsDesc.h	/^  Communicator* getCommunicator() { return com; } $/;"	f	class:TsDesc
getCompVecPat	Domain.h	/^  CommPattern<bcomp> *getCompVecPat() const { return compVecPat; }$/;"	f	class:Domain
getConfig	DistGeoState.h	/^  int getConfig() const { return data.config; }$/;"	f	class:DistGeoState
getConfigSA	DistGeoState.h	/^  int getConfigSA() const { return data.configSA; }$/;"	f	class:DistGeoState
getConnectivity	MultiGridLevel.h	/^    Connectivity ** getConnectivity() { return connectivity; }$/;"	f	class:MultiGridLevel
getContractionLinSearch	ImplicitEmbeddedRomTsDesc.h	/^    double getContractionLinSearch() {return super::getContractionLinSearch(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getContractionLineSearch	ImplicitEmbeddedTsDesc.h	/^  double getContractionLineSearch() const { return contractionLS; }$/;"	f	class:ImplicitEmbeddedTsDesc
getContractionLineSearch	ImplicitLevelSetTsDesc.h	/^  double getContractionLineSearch() const { return contractionLS; }$/;"	f	class:ImplicitLevelSetTsDesc
getContractionLineSearch	ImplicitMultiPhysicsTsDesc.h	/^  double getContractionLineSearch() const { return contractionLS; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getContractionLineSearch	ImplicitTsDesc.h	/^  double getContractionLineSearch() const { return contractionLS; }$/;"	f	class:ImplicitTsDesc
getContractionLineSearch	MeshMotionSolver.h	/^  double getContractionLineSearch() const { return contractionLS; }$/;"	f	class:TetMeshMotionSolver
getCpuToSub	GeoSource.h	/^  Connectivity *getCpuToSub() const { return cpuToSub; }$/;"	f	class:GeoSource
getCrackingSurface	FSI/DynamicNodalTransfer.h	/^        CrackingSurface* getCrackingSurface() {return structure.cracking;}$/;"	f	class:DynamicNodalTransfer
getCrackingSurface	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    virtual CrackingSurface* getCrackingSurface() {$/;"	f	class:IntersectorPhysBAM
getCrackingSurface	LevelSet/LevelSetStructure.h	/^      getCrackingSurface() { return NULL; }$/;"	f	class:LevelSetStructure
getCsPat	Domain.h	/^  CommPattern<double> *getCsPat() const { return csPat; }$/;"	f	class:Domain
getCtrlVol	DistGeoState.h	/^  DistVec<double> &getCtrlVol() const { return *ctrlVol_n; }$/;"	f	class:DistGeoState
getCtrlVol	MultiGridLevel.h	/^    DistVec<double>& getCtrlVol() const { return *ctrlVol; }$/;"	f	class:MultiGridLevel
getCtrlVol_n	GeoState.h	/^  Vec<double> &getCtrlVol_n() const { return ctrlVol_n; }$/;"	f	class:GeoState
getCtrlVol_nm1	GeoState.h	/^  Vec<double> &getCtrlVol_nm1() const { return ctrlVol_nm1; }$/;"	f	class:GeoState
getCtrlVol_nm2	GeoState.h	/^  Vec<double> &getCtrlVol_nm2() const { return ctrlVol_nm2; }$/;"	f	class:GeoState
getCurrentPrimitiveVector	SpaceOperator.h	/^  DistSVec<double,dim>* getCurrentPrimitiveVector() { return V; }$/;"	f	class:SpaceOperator
getCurrentResidual	TsDesc.h	/^  DistSVec<double,dim>& getCurrentResidual() { return *R; }$/;"	f	class:TsDesc
getCutOffMach	LowMachPrec.h	/^  virtual double getCutOffMach() const     { return maxMach;      }$/;"	f	class:LowMachPrec
getCv	VarFcn.h	/^  double getCv(int tag=0)         const{ check(tag); return varFcn[tag]->getCv(); }$/;"	f	class:VarFcn
getCv	VarFcnBase.h	/^  virtual double getCv() const{$/;"	f	class:VarFcnBase
getCv	VarFcnTait.h	/^  double getCv()         const{ return C_; }$/;"	f	class:VarFcnTait
getData	DiagMatrix.C	/^void DiagMat<Scalar,dim>::getData(GenMat<MatScal,dim> &B)$/;"	f	class:DiagMat
getData	DistTimeState.h	/^  TimeData &getData() { return *data; }$/;"	f	class:DistTimeState
getData	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::getData(DistMat<MatScal,dim> &B)$/;"	f	class:IluPrec
getData	KspPrec.C	/^void JacobiPrec<Scalar,dim, Scalar2>::getData(DistMat<MatScal,dim> &B)$/;"	f	class:JacobiPrec
getData	MultiGridPrec.C	/^void MultiGridPrec<Scalar,dim,Scalar2>::getData(DistMat<Scalar2,dim>& mat)\/* ,$/;"	f	class:MultiGridPrec
getData	MultiGridSmoothingMatrix.C	/^getData(GenMat<Scalar,dim>& mat) {$/;"	f	class:MultiGridSmoothingMatrix
getData	SparseMatrix.C	/^void SparseMat<Scalar,dim>::getData(GenMat<MatScal,dim> &B)$/;"	f	class:SparseMat
getDataBlockJacobi	MultiGridSmoothingMatrix.C	/^getDataBlockJacobi(GenMat<Scalar,dim>& mat) {$/;"	f	class:MultiGridSmoothingMatrix
getDataLineJacobi	MultiGridSmoothingMatrix.C	/^getDataLineJacobi(GenMat<Scalar,dim>& mat) {$/;"	f	class:MultiGridSmoothingMatrix
getDensity	VarFcn.h	/^  double getDensity(double *V, int tag=0)   const{ check(tag); return varFcn[tag]->getDensity(V); }$/;"	f	class:VarFcn
getDensity	VarFcnBase.h	/^  virtual double getDensity(double *V)   const{ return V[0]; }$/;"	f	class:VarFcnBase
getDerivative	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* getDerivative(int i) { return DX[i]; }$/;"	f	class:MultiGridOperator
getDerivativeOfGradP	Domain.C	/^void Domain::getDerivativeOfGradP(DistNodalGrad<dim>& ngrad)$/;"	f	class:Domain
getDerivativeOfGradP	Domain.C	/^void Domain::getDerivativeOfGradP(RectangularSparseMat<double,dim,3> **dGradPdddx,$/;"	f	class:Domain
getDerivativeOfGradP	SubDomain.C	/^void SubDomain::getDerivativeOfGradP(NodalGrad<dim>& ngrad)$/;"	f	class:SubDomain
getDerivativeOfGradP	SubDomain.C	/^void SubDomain::getDerivativeOfGradP(RectangularSparseMat<double,dim,3> &dGradPdddx, $/;"	f	class:SubDomain
getDerivativeOfInvReynolds	DistTimeState.C	/^DistTimeState<dim>::getDerivativeOfInvReynolds(DistGeoState &geoState,$/;"	f	class:DistTimeState
getDerivativeOfPressureConstant	VarFcn.h	/^  double getDerivativeOfPressureConstant(int tag=0) { check(tag); return varFcn[tag]->getDerivativeOfPressureConstant(); }$/;"	f	class:VarFcn
getDerivativeOfPressureConstant	VarFcnBase.h	/^  virtual double getDerivativeOfPressureConstant() const { return 0.0; }$/;"	f	class:VarFcnBase
getDerivativeOfPressureConstant	VarFcnSGEuler.h	/^  double getDerivativeOfPressureConstant()    const {return dPstiff;}$/;"	f	class:VarFcnSGEuler
getDerivativeOfPressureConstant	VarFcnSGKE.h	/^  double getDerivativeOfPressureConstant()       const {return dPstiff;}$/;"	f	class:VarFcnSGKE
getDerivativeOfPressureConstant	VarFcnSGSA.h	/^  double getDerivativeOfPressureConstant()    const {return dPstiff;}$/;"	f	class:VarFcnSGSA
getDerivativeOfTemperatureVector	DistBcData.h	/^  DistVec<double> &getDerivativeOfTemperatureVector() { return (*dTemp); }$/;"	f	class:DistBcData
getDerivativeOfVelocity	VarFcn.h	/^  Vec3D getDerivativeOfVelocity(double *dV, int tag=0) { check(tag); return varFcn[tag]->getDerivativeOfVelocity(dV); }$/;"	f	class:VarFcn
getDerivativeOfVelocity	VarFcnBase.h	/^  virtual Vec3D getDerivativeOfVelocity(double *dV) const { return Vec3D(dV[1], dV[2], dV[3]); }$/;"	f	class:VarFcnBase
getDerivativeOfVelocityNorm	VarFcn.h	/^  double getDerivativeOfVelocityNorm(double *V, double *dV, int tag=0) { check(tag); return varFcn[tag]->getDerivativeOfVelocityNorm(V,dV); }$/;"	f	class:VarFcn
getDerivativeOfVelocityNorm	VarFcnBase.h	/^  virtual double getDerivativeOfVelocityNorm(double *V, double *dV) const { $/;"	f	class:VarFcnBase
getDerivativeOfVelocityVector	DistBcData.h	/^  DistSVec<double,3> &getDerivativeOfVelocityVector() { return *dXdot; }$/;"	f	class:DistBcData
getDetonationNormal	ProgrammedBurnCore.C	/^void ProgrammedBurn::getDetonationNormal(int tag,int i,int j, double xmid[3], double gradphi[3]) {$/;"	f	class:ProgrammedBurn
getDiagMatPat	DistMatrix.h	/^  CommPattern<Scalar> *getDiagMatPat() const { return diagMatPat; }$/;"	f	class:DistMat
getDim	SparseGrid.h	/^  int getDim() const { return dim; } $/;"	f	class:SparseGrid
getDisplacement	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::getDisplacement()$/;"	f	class:DynamicNodalTransfer
getDisplacement	MatchNodeCore.C	/^void MatchNodeSet::getDisplacement(double (*xs)[3], int (*stElem)[3],$/;"	f	class:MatchNodeSet
getDisplacement	MatchNodeCore.C	/^void MatchNodeSet::getDisplacement(int algNum, double dt, double lscale, double uscale, $/;"	f	class:MatchNodeSet
getDisplacement	StructExc.C	/^void StructExc::getDisplacement(DistSVec<double,3> &X0, DistSVec<double,3> &X, $/;"	f	class:StructExc
getDisplacementSensitivity	MatchNodeCore.C	/^void MatchNodeSet::getDisplacementSensitivity(bool *flag, double scale, double (*disp)[2][3],$/;"	f	class:MatchNodeSet
getDisplacementSensitivity	StructExc.C	/^void StructExc::getDisplacementSensitivity(DistSVec<double,3> &X, DistSVec<double,3> &dX, bool applyScale)$/;"	f	class:StructExc
getDistBcData	SpaceOperator.h	/^  DistBcData<dim>* getDistBcData() { return bcData; }$/;"	f	class:SpaceOperator
getDistNodalGrad	SpaceOperator.h	/^  DistNodalGrad<dim, bcomp> *getDistNodalGrad(DistSVec<bcomp,dim> &)  { return compNodalGrad; }$/;"	f	class:SpaceOperator
getDistNodalGrad	SpaceOperator.h	/^  DistNodalGrad<dim, double> *getDistNodalGrad(DistSVec<double,dim> &)  { return ngrad; }$/;"	f	class:SpaceOperator
getDistance	LevelSet/LevelSetStructure.h	/^    DistVec<double> & getDistance()       const { return *distance; }$/;"	f	class:DistLevelSetStructure
getDistanceToWall	GeoState.h	/^  Vec<double> &getDistanceToWall() const { return d2wall; }$/;"	f	class:GeoState
getDofType	BCApplier.h	/^    int** getDofType() { return(dofType); } $/;"	f	class:BCApplier
getDomain	SpaceOperator.h	/^  Domain* getDomain() { return domain; }$/;"	f	class:SpaceOperator
getDt	DistTimeState.h	/^  DistVec<double>& getDt() const { return *dt; }$/;"	f	class:DistTimeState
getDt	TimeState.h	/^  Vec<double>& getDt() { return dt; }$/;"	f	class:TimeState
getEdgeArea	MultiGridLevel.h	/^    DistVec<double>& getEdgeArea() { return *edgeArea; }$/;"	f	class:MultiGridLevel
getEdgeAreaPointer	MultiGridLevel.h	/^    DistVec<double>* getEdgeAreaPointer() { return edgeArea; }$/;"	f	class:MultiGridLevel
getEdgeDistInfo	Domain.h	/^  DistInfo &getEdgeDistInfo() const { return *edgeDistInfo; }$/;"	f	class:Domain
getEdgeDistInfo	MultiGridLevel.h	/^    DistInfo& getEdgeDistInfo()       { return *edgeDistInfo; }$/;"	f	class:MultiGridLevel
getEdgeDistInfoMF	Domain.h	/^  DistInfo &getEdgeDistInfoMF() const { return *edgeDistInfoMF; }$/;"	f	class:Domain
getEdgeNormal	DistGeoState.h	/^  DistVec<Vec3D> &getEdgeNormal() const { return *edgeNorm; }$/;"	f	class:DistGeoState
getEdgeNormal	GeoState.h	/^  Vec<Vec3D> &getEdgeNormal() const { return edgeNorm; }$/;"	f	class:GeoState
getEdgeNormalVel	DistGeoState.h	/^  DistVec<double> &getEdgeNormalVel() const { return *edgeNormVel; }$/;"	f	class:DistGeoState
getEdgeNormalVel	GeoState.h	/^  Vec<double> &getEdgeNormalVel() const { return edgeNormVel; }$/;"	f	class:GeoState
getEdgeNormals	MultiGridLevel.h	/^    DistVec<Vec3D>& getEdgeNormals() { return *edgeNormals; }$/;"	f	class:MultiGridLevel
getEdgeNum	Face.h	/^  int getEdgeNum(int i) { return edgeNum(i); }$/;"	f	class:Face
getEdges	MultiGridLevel.h	/^    EdgeSet ** getEdges()             { return edges; }$/;"	f	class:MultiGridLevel
getEdges	SubDomain.h	/^  EdgeSet &getEdges() { return edges; }$/;"	f	class:SubDomain
getElemHH	GenMatrix.h	/^  virtual Scalar* getElemHH(int) { return NULL; }$/;"	f	class:GenMat
getElemHH	MvpMatrix.h	/^  Scalar* getElemHH(int i) {$/;"	f	class:MvpMat
getElemHU	GenMatrix.h	/^  virtual Scalar* getElemHU(int) { return NULL; }$/;"	f	class:GenMat
getElemHU	MvpMatrix.h	/^  Scalar* getElemHU(int i) {$/;"	f	class:MvpMat
getElemMap	SubDomain.h	/^  int *getElemMap()  { return locToGlobElemMap; }$/;"	f	class:SubDomain
getElemNodeNum	SubDomain.h	/^  int* getElemNodeNum(int i) {return(elems[i].nodeNum()); }$/;"	f	class:SubDomain
getElemUH	GenMatrix.h	/^  virtual Scalar* getElemUH(int) { return NULL; }$/;"	f	class:GenMat
getElemUH	MvpMatrix.h	/^  Scalar* getElemUH(int i) {$/;"	f	class:MvpMat
getElem_ii	DiagMatrix.h	/^  Scalar *getElem_ii(int i) { return *(a.v + i); }$/;"	f	class:DiagMat
getElem_ii	MultiGridSmoothingMatrix.h	/^  Scalar *getElem_ii(int i) { return *(a.v + i); }$/;"	f	class:MultiGridSmoothingMatrix
getElem_ii	MvpMatrix.h	/^  Scalar *getElem_ii(int i) { return *(a.v + i); }$/;"	f	class:MvpMat
getElem_ii	RectangularSparseMatrix.h	/^  Scalar *getElem_ii(int i) { \/*fprintf(stdout, "getElem_ii(%d) = %d\\n", i, ptr_ii[i]);*\/ return *(a.v + ptr_ii[i]); }$/;"	f	class:RectangularSparseMat
getElem_ii	SparseMatrix.h	/^  Scalar *getElem_ii(int i) { \/*fprintf(stdout, "getElem_ii(%d) = %d\\n", i, ptr_ii[i]);*\/ return *(a.v + ptr_ii[i]); }$/;"	f	class:SparseMat
getElem_ij	DiagMatrix.h	/^  Scalar *getElem_ij(int l) { return 0; }$/;"	f	class:DiagMat
getElem_ij	MultiGridSmoothingMatrix.h	/^  Scalar *getElem_ij(int l) { return *(a.v + n + 2 * l); }$/;"	f	class:MultiGridSmoothingMatrix
getElem_ij	MvpMatrix.h	/^  Scalar *getElem_ij(int l) { return *(a.v + n + 2 * l); }$/;"	f	class:MvpMat
getElem_ij	RectangularSparseMatrix.h	/^  Scalar *getElem_ij(int edgeNumber) { \/*fprintf(stdout, "getElem_ij(%d) = %d\\n", edgeNumber, ptr_ij[edgeNumber]);*\/ return *(a.v + ptr_ij[edgeNumber]); }$/;"	f	class:RectangularSparseMat
getElem_ij	SparseMatrix.h	/^  Scalar *getElem_ij(int edgeNumber) { \/*fprintf(stdout, "getElem_ij(%d) = %d\\n", edgeNumber, ptr_ij[edgeNumber]);*\/ return *(a.v + ptr_ij[edgeNumber]); }$/;"	f	class:SparseMat
getElem_ji	DiagMatrix.h	/^  Scalar *getElem_ji(int l) { return 0; }$/;"	f	class:DiagMat
getElem_ji	MultiGridSmoothingMatrix.h	/^  Scalar *getElem_ji(int l) { return *(a.v + n + 2 * l + 1); }$/;"	f	class:MultiGridSmoothingMatrix
getElem_ji	MvpMatrix.h	/^  Scalar *getElem_ji(int l) { return *(a.v + n + 2 * l + 1); }$/;"	f	class:MvpMat
getElem_ji	RectangularSparseMatrix.h	/^  Scalar *getElem_ji(int edgeNumber) { \/*fprintf(stdout, "getElem_ji(%d) = %d\\n", edgeNumber, ptr_ji[edgeNumber]);*\/ return *(a.v + ptr_ji[edgeNumber]); }$/;"	f	class:RectangularSparseMat
getElem_ji	SparseMatrix.h	/^  Scalar *getElem_ji(int edgeNumber) { \/*fprintf(stdout, "getElem_ji(%d) = %d\\n", edgeNumber, ptr_ji[edgeNumber]);*\/ return *(a.v + ptr_ji[edgeNumber]); }$/;"	f	class:SparseMat
getElementNumber	Face.h	/^  int getElementNumber() const { return elemNum; }$/;"	f	class:Face
getElementStatistics	SubDomainCore.C	/^void SubDomain::getElementStatistics(int &numNodes, int &numEdges,$/;"	f	class:SubDomain
getElems	SubDomain.h	/^	ElemSet& getElems() {return elems;};$/;"	f	class:SubDomain
getEmbedCommunicator	Domain.h	/^  Communicator *getEmbedCommunicator() { return embedCom; }$/;"	f	class:Domain
getEmbeddedALEMeshMotionDofType	SubDomainCore.C	/^SubDomain::getEmbeddedALEMeshMotionDofType(map<int,SurfaceData*>& surfaceMap, CommPattern<int> &ntP, MatchNodeSet* matchNodes,$/;"	f	class:SubDomain
getEmbeddedWetSurface	StructExc.C	/^void StructExc::getEmbeddedWetSurface(int nNodes, double *nodes, int nElems, int *elems, int eType)$/;"	f	class:StructExc
getEmbeddedWetSurfaceInfo	StructExc.C	/^void StructExc::getEmbeddedWetSurfaceInfo(int& elemType, bool& crack, int& nNodes, int& nElems)$/;"	f	class:StructExc
getEngPat	Domain.h	/^  CommPattern<double> *getEngPat() const { return engPat; }$/;"	f	class:Domain
getEpsAbsIncNewton	ImplicitEmbeddedRomTsDesc.h	/^    double getEpsAbsIncNewton() {return super::getAbsIncNewton(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getEpsAbsIncNewton	ImplicitEmbeddedTsDesc.h	/^  double getEpsAbsIncNewton() const { return epsAbsIncNewton; }$/;"	f	class:ImplicitEmbeddedTsDesc
getEpsAbsIncNewton	ImplicitLevelSetTsDesc.h	/^  double getEpsAbsIncNewton() const { return epsAbsIncNewton; }$/;"	f	class:ImplicitLevelSetTsDesc
getEpsAbsIncNewton	ImplicitMultiPhysicsTsDesc.h	/^  double getEpsAbsIncNewton() const { return epsAbsIncNewton; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getEpsAbsIncNewton	ImplicitTsDesc.h	/^  double getEpsAbsIncNewton() const { return epsAbsIncNewton; }$/;"	f	class:ImplicitTsDesc
getEpsAbsIncNewton	MeshMotionSolver.h	/^  double getEpsAbsIncNewton() const { return epsAbsIncNewton; }$/;"	f	class:TetMeshMotionSolver
getEpsAbsResNewton	ImplicitEmbeddedRomTsDesc.h	/^    double getEpsAbsResNewton() { return super::getEpsAbsResNewton(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getEpsAbsResNewton	ImplicitEmbeddedTsDesc.h	/^  double getEpsAbsResNewton() const { return epsAbsResNewton; }$/;"	f	class:ImplicitEmbeddedTsDesc
getEpsAbsResNewton	ImplicitLevelSetTsDesc.h	/^  double getEpsAbsResNewton() const { return epsAbsResNewton; }$/;"	f	class:ImplicitLevelSetTsDesc
getEpsAbsResNewton	ImplicitMultiPhysicsTsDesc.h	/^  double getEpsAbsResNewton() const { return epsAbsResNewton; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getEpsAbsResNewton	ImplicitTsDesc.h	/^  double getEpsAbsResNewton() const { return epsAbsResNewton; }$/;"	f	class:ImplicitTsDesc
getEpsAbsResNewton	MeshMotionSolver.h	/^  double getEpsAbsResNewton() const { return epsAbsResNewton; }$/;"	f	class:TetMeshMotionSolver
getEpsNewton	ImplicitEmbeddedRomTsDesc.h	/^    double getEpsNewton() { return super::getMaxItsNewtion(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getEpsNewton	ImplicitEmbeddedTsDesc.h	/^  double getEpsNewton() const { return epsNewton; }$/;"	f	class:ImplicitEmbeddedTsDesc
getEpsNewton	ImplicitLevelSetTsDesc.h	/^  double getEpsNewton() const { return epsNewton; }$/;"	f	class:ImplicitLevelSetTsDesc
getEpsNewton	ImplicitMultiPhysicsTsDesc.h	/^  double getEpsNewton() const { return epsNewton; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getEpsNewton	ImplicitTsDesc.h	/^  double getEpsNewton() const { return epsNewton; }$/;"	f	class:ImplicitTsDesc
getEpsNewton	MeshMotionSolver.h	/^  double getEpsNewton() const { return epsNewton; }$/;"	f	class:TetMeshMotionSolver
getErrorHandler	Domain.h	/^  ErrorHandler *getErrorHandler() const {return errorHandler;}$/;"	f	class:Domain
getErrorHandler	MeshMotionSolver.h	/^  ErrorHandler* getErrorHandler() {return NULL; }$/;"	f	class:TetMeshMotionSolver
getErrorHandler	TsDesc.h	/^  ErrorHandler* getErrorHandler() {return errorHandler;}$/;"	f	class:TsDesc
getExtrapolationData	Extrapolation.h	/^  Extrapolationdata &getExtrapolationData()  { return extrapolationdata; }$/;"	f	class:Extrapolation
getExtrapolationValue	Domain.C	/^void Domain::getExtrapolationValue(DistExtrapolation<dim> *xpol, DistSVec<double,dim> &V,$/;"	f	class:Domain
getExtrapolationValue	InletNode.C	/^void InletNodeSet::getExtrapolationValue(Extrapolation<dim>* xpol,SVec<double,dim> &V, SVec<double,dim> &Ubc,$/;"	f	class:InletNodeSet
getExtrapolationValue	SpaceOperator.C	/^void SpaceOperator<dim>::getExtrapolationValue(DistSVec<double,dim> &U,$/;"	f	class:SpaceOperator
getExtrapolationValue	SubDomain.C	/^void SubDomain::getExtrapolationValue(Extrapolation<dim>* xpol,SVec<double,dim> &V, SVec<double,dim> &Ubc,$/;"	f	class:SubDomain
getFEMstencil	SubDomainCore.C	/^bool SubDomain::getFEMstencil(int Ni, SVec<double,3> &X, $/;"	f	class:SubDomain
getFEMstencil2	SubDomainCore.C	/^bool SubDomain::getFEMstencil2(int Ni, SVec<double,3> &X, $/;"	f	class:SubDomain
getFVCompTag	MultiGridLevel.h	/^    DistSVec<int,2>& getFVCompTag() const { return *fv_comp_tag; }$/;"	f	class:MultiGridLevel
getFaceDistInfo	Domain.h	/^  DistInfo &getFaceDistInfo() const { return *faceDistInfo; }$/;"	f	class:Domain
getFaceDistInfo	MultiGridLevel.h	/^    DistInfo& getFaceDistInfo()       { return *faceDistInfo; }$/;"	f	class:MultiGridLevel
getFaceNorVel	DistGeoState.h	/^  DistVec<double> &getFaceNorVel() const { return *faceNormVel; }$/;"	f	class:DistGeoState
getFaceNormDistInfo	Domain.h	/^  DistInfo &getFaceNormDistInfo() const { return *faceNormDistInfo; }$/;"	f	class:Domain
getFaceNormal	DistGeoState.h	/^  DistVec<Vec3D> &getFaceNormal() const { return *faceNorm; }$/;"	f	class:DistGeoState
getFaceNormal	GeoState.h	/^  Vec<Vec3D> &getFaceNormal() const { return faceNorm; }$/;"	f	class:GeoState
getFaceNormalVel	GeoState.h	/^  Vec<double> &getFaceNormalVel() const { return faceNormVel; }$/;"	f	class:GeoState
getFaceStateVector	BcData.h	/^  SVec<double,dim> &getFaceStateVector() const { return Uface; }$/;"	f	class:BcData
getFaceStateVector	DistBcData.h	/^  DistSVec<double,dim> &getFaceStateVector() { return Uface; }$/;"	f	class:DistBcData
getFaces	InletNode.h	/^  	int *getFaces()    { return faces; }$/;"	f	class:InletNode
getFaces	MultiGridLevel.h	/^    FaceSet ** getFaces()             { return faces; }$/;"	f	class:MultiGridLevel
getFaces	SubDomain.h	/^	FaceSet& getFaces() {return faces;};$/;"	f	class:SubDomain
getFarFieldBoundaryNodes	SubDomainCore.C	/^void SubDomain::getFarFieldBoundaryNodes(Aerof_unordered_set<int>::type& boundaryNodes) const {$/;"	f	class:SubDomain
getFemEquationTerm	SpaceOperator.h	/^  FemEquationTerm *getFemEquationTerm() { return fet;}$/;"	f	class:SpaceOperator
getFinestLevel	MultiGridLevel.h	/^    MultiGridLevel* getFinestLevel() {$/;"	f	class:MultiGridLevel
getFinestTopology	MultiGridLevel.h	/^    DistVec<Topology>* getFinestTopology() {$/;"	f	class:MultiGridLevel
getFirstOrderNodeSet	DistTimeState.h	/^  DistVec<int> * getFirstOrderNodeSet() const { return firstOrderNodes; }$/;"	f	class:DistTimeState
getFlightPositionVector	MeshMotionHandlerCore.C	/^DistSVec<double,3> &RigidMeshMotionHandler::getFlightPositionVector(double t, DistSVec<double,3> &X)  {$/;"	f	class:RigidMeshMotionHandler
getFluidId	FluidSelector.C	/^void FluidSelector::getFluidId(DistSVec<double,dim> &Phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelector.C	/^void FluidSelector::getFluidId(DistVec<int> &Tag, DistSVec<double,dim> &Phi, DistVec<int>* fsId){$/;"	f	class:FluidSelector
getFluidId	FluidSelector.C	/^void FluidSelector::getFluidId(Vec<int> &tag, SVec<double,dim> &phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelector.C	/^void FluidSelector::getFluidId(int &tag, double *phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelector.h	/^  void getFluidId(int &tag, double phi){ tag = (phi<0.0) ? 0 : 1; }$/;"	f	class:FluidSelector
getFluidId	FluidSelectorCore.C	/^void FluidSelector::getFluidId(DistVec<double> &Phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelectorCore.C	/^void FluidSelector::getFluidId(DistVec<int> &Tag, DistVec<double> &Phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelectorCore.C	/^void FluidSelector::getFluidId(TriangulatedInterface* T){$/;"	f	class:FluidSelector
getFluidId	FluidSelectorCore.C	/^void FluidSelector::getFluidId(Vec<int> &tag, Vec<double> &phi){$/;"	f	class:FluidSelector
getFluidId	FluidSelectorCore.C	/^void FluidSelector::getFluidId(int &tag, double *phi){$/;"	f	class:FluidSelector
getFluidIdToSet	DistExactRiemannSolver.h	/^  DistVec<int>* getFluidIdToSet() const { return fluidIdToSet; } $/;"	f	class:DistExactRiemannSolver
getFluxFcn	SpaceOperator.h	/^  FluxFcn** getFluxFcn() { return fluxFcn; }$/;"	f	class:SpaceOperator
getFluxFcnBase	FluxFcn.h	/^  FluxFcnBase* getFluxFcnBase(int tag = 0) const { check(tag); return ff_[tag]; }$/;"	f	class:FluxFcn
getForcesAndMoments	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::getForcesAndMoments(map<int,int> & surfOutMap, DistSVec<double,dim> &U, DistSVec<double,3> &X,$/;"	f	class:EmbeddedTsDesc
getForcesAndMoments	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::getForcesAndMoments(map<int,int> & surfOutMap, DistSVec<double,dim> &U, DistSVec<double,3> &X,$/;"	f	class:MultiPhysicsTsDesc
getFsPat	Domain.h	/^  CommPattern<int> *getFsPat() const { return fsPat; }$/;"	f	class:Domain
getGamma	VarFcn.h	/^  double getGamma(int tag=0)  const{ check(tag); return varFcn[tag]->getGamma(); }$/;"	f	class:VarFcn
getGamma	VarFcnBase.h	/^  virtual double getGamma() const{$/;"	f	class:VarFcnBase
getGamma	VarFcnSGEuler.h	/^  double getGamma()                           const {return gam;}$/;"	f	class:VarFcnSGEuler
getGamma	VarFcnSGKE.h	/^  double getGamma()                              const {return gam;}$/;"	f	class:VarFcnSGKE
getGamma	VarFcnSGSA.h	/^  double getGamma()                           const {return gam;}$/;"	f	class:VarFcnSGSA
getGamma1	VarFcn.h	/^  double getGamma1(int tag=0) const{ check(tag); return varFcn[tag]->getGamma1(); }$/;"	f	class:VarFcn
getGamma1	VarFcnBase.h	/^  virtual double getGamma1() const{$/;"	f	class:VarFcnBase
getGamma1	VarFcnSGEuler.h	/^  double getGamma1()                          const {return gam1;}$/;"	f	class:VarFcnSGEuler
getGamma1	VarFcnSGKE.h	/^  double getGamma1()                             const {return gam1;}$/;"	f	class:VarFcnSGKE
getGamma1	VarFcnSGSA.h	/^  double getGamma1()                          const {return gam1;}$/;"	f	class:VarFcnSGSA
getGap	MatchNodeCore.C	/^double (*MatchNodeSet::getGap(int size, int *list))[3]$/;"	f
getGeoData	DistGeoState.h	/^  const GeoData& getGeoData() const { return data; }$/;"	f	class:DistGeoState
getGeoSource	Domain.h	/^  GeoSource& getGeoSource() { return *pGeoSource; }$/;"	f	class:Domain
getGeoState	MultiGridLevel.h	/^    DistGeoState& getGeoState() const { return *myGeoState; }$/;"	f	class:MultiGridLevel
getGeoState	SpaceOperator.h	/^  DistGeoState* getGeoState() { return geoState; }$/;"	f	class:SpaceOperator
getGeometry	DomainCore.C	/^void Domain::getGeometry(GeoSource &geoSource, IoData &ioData)$/;"	f	class:Domain
getGhost	DistEmbeddedVector.h	/^void DistEmbeddedVec<Scalar,dim>::getGhost(DistVec<GhostPoint<dim>*>& gp,VarFcn* vf) {$/;"	f	class:DistEmbeddedVec
getGhostGhostElem_ij	GenMatrix.h	/^  virtual Scalar* getGhostGhostElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
getGhostGhostElem_ij	MvpMatrix.h	/^  Scalar* getGhostGhostElem_ij(int i,int j) {$/;"	f	class:MvpMat
getGhostNodeElem_ij	GenMatrix.h	/^  virtual Scalar* getGhostNodeElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
getGhostNodeElem_ij	MvpMatrix.h	/^  Scalar* getGhostNodeElem_ij(int i,int j) {$/;"	f	class:MvpMat
getGlobSubNum	IntersectorPhysBAM/Mpi_Utilities.C	/^    GLOBAL_SUBD_ID getGlobSubNum(SubDomain& subD)$/;"	f	namespace:PhysBAM
getGlobSubNum	SubDomain.h	/^  int getGlobSubNum()  { return globSubNum; }$/;"	f	class:SubDomain
getGradP	Domain.C	/^void Domain::getGradP(DistNodalGrad<dim>& ngrad)$/;"	f	class:Domain
getGradP	SubDomain.C	/^void SubDomain::getGradP(NodalGrad<dim>& ngrad)$/;"	f	class:SubDomain
getHU	GenMatrix.h	/^  virtual SVec<Scalar,dim*3>* getHU() { return NULL; }$/;"	f	class:GenMat
getHU	MvpMatrix.h	/^  SVec<Scalar,dim*3>* getHU() {$/;"	f	class:MvpMat
getHeatCommunicator	Domain.h	/^  Communicator *getHeatCommunicator() { return heatCom; }$/;"	f	class:Domain
getHeatTimer	Domain.h	/^  Timer *getHeatTimer() const { return heatTimer; }$/;"	f	class:Domain
getHigherOrderFSI	SubDomain.h	/^  HigherOrderFSI* getHigherOrderFSI() { return higherOrderFSI; }$/;"	f	class:SubDomain
getHigherOrderMF	SubDomain.h	/^  HigherOrderMultiFluid* getHigherOrderMF() { return higherOrderMF; }$/;"	f	class:SubDomain
getIdPat	MultiGridLevel.h	/^    CommPattern<int>& getIdPat()      { return *nodeIdPattern; }$/;"	f	class:MultiGridLevel
getImag	DistVector.h	/^DistSVec<Scalar,dim>::getImag(const DistSVec<bcomp,dim> &y)$/;"	f	class:DistSVec
getIndices	TriangulatedInterface.C	/^int (* TriangulatedInterface::getIndices())[3] {$/;"	f
getInfo	StructExc.C	/^double StructExc::getInfo() $/;"	f	class:StructExc
getInitialCrack	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::getInitialCrack()$/;"	f	class:EmbeddedStructure
getInitialCrackingSetup	StructExc.C	/^void StructExc::getInitialCrackingSetup(int& totalNodes, int& totalElems)$/;"	f	class:StructExc
getInitialIteration	TsDesc.h	/^  int getInitialIteration() const { return restart->iteration; }$/;"	f	class:TsDesc
getInitialPhantomNodes	StructExc.C	/^void StructExc::getInitialPhantomNodes(int newNodes, double(*xyz)[3], int nNodes)$/;"	f	class:StructExc
getInitialTime	TsDesc.h	/^  double getInitialTime() const { return restart->etime; }$/;"	f	class:TsDesc
getInletAngles	DistBcData.h	/^  double *getInletAngles() { return angles; }$/;"	f	class:DistBcData
getInletBoundaryVector	BcData.h	/^  SVec<double,dim> &getInletBoundaryVector() const { return Ufarin; }$/;"	f	class:BcData
getInletBoundaryVector	DistBcData.h	/^  DistSVec<double,dim> &getInletBoundaryVector()  { return Ufarin;  }$/;"	f	class:DistBcData
getInletConservativeState	DistBcData.h	/^  double *getInletConservativeState() { return Uin; }$/;"	f	class:DistBcData
getInletNodeDistInfo	Domain.h	/^  DistInfo &getInletNodeDistInfo() const { return *inletNodeDistInfo; }$/;"	f	class:Domain
getInletNodeDistInfo	MultiGridLevel.h	/^    DistInfo& getInletNodeDistInfo()       { return *inletNodeDistInfo; }$/;"	f	class:MultiGridLevel
getInletNodeNorm	DistGeoState.h	/^  DistVec<Vec3D> &getInletNodeNorm() const { return *inletNodeNorm; }$/;"	f	class:DistGeoState
getInletNodeNormal	GeoState.h	/^  Vec<Vec3D> &getInletNodeNormal() const { return inletNodeNorm; }$/;"	f	class:GeoState
getInletNodeStateVector	BcData.h	/^  SVec<double,dim> &getInletNodeStateVector() const { return Uinletnode; }$/;"	f	class:BcData
getInletOutletVector	BcData.h	/^  SVec<double,dim> &getInletOutletVector() const { return Ufarout; }$/;"	f	class:BcData
getInletPrimitiveState	DistBcData.h	/^  double *getInletPrimitiveState() { return Vin; }$/;"	f	class:DistBcData
getInletVecInfo	TsDesc.h	/^  DistInfo &getInletVecInfo() const {return domain->getInletNodeDistInfo(); }$/;"	f	class:TsDesc
getInterface	DistBcData.h	/^  double *getInterface() { return Ub; }$/;"	f	class:DistBcData
getInterface	IntersectorFRG/IntersectorFRG.h	/^    PhysBAMInterface<double> &getInterface() { return *globPhysInterface; }$/;"	f	class:DistIntersectorFRG
getInterface	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    PhysBAMInterface<double> &getInterface() { return *physInterface; }$/;"	f	class:DistIntersectorPhysBAM
getIntersectedEdges	LevelSet/LevelSetStructure.h	/^    DistVec<bool> & getIntersectedEdges() const { return *edge_intersects; }$/;"	f	class:DistLevelSetStructure
getIntersector	TriangulatedInterface.C	/^TriangulatedInterface::getIntersector() {$/;"	f	class:TriangulatedInterface
getInvOmega	VarFcn.h	/^  double getInvOmega(int tag=0) const{ check(tag); return varFcn[tag]->getInvOmega(); }$/;"	f	class:VarFcn
getInvOmega	VarFcnBase.h	/^  virtual double getInvOmega() const{$/;"	f	class:VarFcnBase
getInvOmega	VarFcnJwl.h	/^  double getInvOmega()   const{ return invomega; }$/;"	f	class:VarFcnJwl
getInvOmegap1	VarFcn.h	/^  double getInvOmegap1(int tag=0) const{ check(tag); return varFcn[tag]->getInvOmegap1(); }$/;"	f	class:VarFcn
getInvOmegap1	VarFcnBase.h	/^  virtual double getInvOmegap1() const{$/;"	f	class:VarFcnBase
getInvOmegap1	VarFcnJwl.h	/^  double getInvOmegap1() const{ return invomegap1; }$/;"	f	class:VarFcnJwl
getInvReynolds	DistTimeState.h	/^  DistVec<double>* getInvReynolds(){ return irey; }$/;"	f	class:DistTimeState
getInvWeight	DistInfo.h	/^  double* getInvWeight(int iSub) const$/;"	f	struct:DistInfo
getIsActive	LevelSet/LevelSetStructure.h	/^    DistVec<bool> & getIsActive()         const { return *is_active; }$/;"	f	class:DistLevelSetStructure
getIsOccluded	LevelSet/LevelSetStructure.h	/^    DistVec<bool> & getIsOccluded()       const { return *is_occluded; }$/;"	f	class:DistLevelSetStructure
getIsSwept	LevelSet/LevelSetStructure.h	/^    DistVec<bool> & getIsSwept()          const { return *is_swept; }$/;"	f	class:DistLevelSetStructure
getJacMat	NonlinearRom.h	/^  VecSet<DistSVec<double,dim> >* getJacMat() {if (numResJacMat==2) { return jacMat; } else { return resMat;} }$/;"	f	class:NonlinearRom
getKirchhoffNodeDistInfo	Domain.h	/^  DistInfo &getKirchhoffNodeDistInfo() const { return *kirchhoffNodeDistInfo; }$/;"	f	class:Domain
getKirchhoffNodesList	SubDomain.h	/^  const std::set<int>& getKirchhoffNodesList() const { return kirchhoffNodesList; };$/;"	f	class:SubDomain
getKrylovStep	DistTimeState.C	/^int DistTimeState<dim>::getKrylovStep() const {$/;"	f	class:DistTimeState
getKrylovStep	Domain.h	/^  int *getKrylovStep() { return &outputKrylovStep; }$/;"	f	class:Domain
getKrylovStep	TimeData.h	/^  int getKrylovStep() const  { return outputKrylovStep; }$/;"	f	class:TimeData
getLastPhaseChangeValue	HigherOrderFSI.C	/^const double* HigherOrderFSI::getLastPhaseChangeValue(int nodeId) $/;"	f	class:HigherOrderFSI
getLastPhaseChangeValue	HigherOrderMultiFluid.C	/^getLastPhaseChangeValue(int nodeId) {$/;"	f	class:HigherOrderMultiFluid
getLatestPhantomNodes	FSI/CrackingSurface.h	/^  std::map<int,int> getLatestPhantomNodes() const {return latest.phantomNodes;}$/;"	f	class:CrackingSurface
getLatestPhantomQuads	FSI/CrackingSurface.h	/^  std::set<int> getLatestPhantomQuads() const {return latest.phantomQuads;}$/;"	f	class:CrackingSurface
getLen	Communicator.h	/^  int getLen(int ID) const { return sRecInfo[ID].len; }$/;"	f	class:CommPattern
getLevel	MultiGridKernel.h	/^  MultiGridLevel<Scalar> * getLevel(int i) { return multiGridLevels[i]; }$/;"	f	class:MultiGridKernel
getLevelPat	Domain.h	/^  CommPattern<int> *getLevelPat() const { return levelPat; }$/;"	f	class:Domain
getLevelSetDataAtEdgeCenter	IntersectorFRG/IntersectorFRG.C	/^IntersectorFRG::getLevelSetDataAtEdgeCenter(double t, int l, bool i_less_j, double *Xr, double *Xg) {$/;"	f	class:IntersectorFRG
getLevelSetDataAtEdgeCenter	IntersectorPhysBAM/IntersectorPhysBAM.C	/^IntersectorPhysBAM::getLevelSetDataAtEdgeCenter(double t, int l, bool i_less_j, double *Xr, double *Xg) {$/;"	f	class:IntersectorPhysBAM
getLevelSetDataAtEdgeCenter	LevelSet/MultiGridLevelSetStructure.C	/^getLevelSetDataAtEdgeCenter(double t, int l, bool i_less_j, double *Xr, double *Xg) {$/;"	f	class:MultiGridLevelSetStructure
getLevelSetDim	FluidSelectorCore.C	/^int FluidSelector::getLevelSetDim(int fluidId1, int fluidId2, int node1, int node2){$/;"	f	class:FluidSelector
getLineData	MultiGridLevel.h	/^    int* getLineData(int iSub, int lineid) { return &lineids[iSub][lineid*8]; } $/;"	f	class:MultiGridLevel
getLineSearch	ImplicitEmbeddedRomTsDesc.h	/^    bool getLineSearch() { return super::getLineSearch(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getLineSearch	ImplicitEmbeddedTsDesc.h	/^  int getLineSearch() const { return (maxItsLS>0); }$/;"	f	class:ImplicitEmbeddedTsDesc
getLineSearch	ImplicitLevelSetTsDesc.h	/^  int getLineSearch() const { return (maxItsLS>0); }$/;"	f	class:ImplicitLevelSetTsDesc
getLineSearch	ImplicitMultiPhysicsTsDesc.h	/^  int getLineSearch() const { return (maxItsLS>0); }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getLineSearch	ImplicitTsDesc.h	/^  int getLineSearch() const { return (maxItsLS>0); }$/;"	f	class:ImplicitTsDesc
getLineSearch	MeshMotionSolver.h	/^  int getLineSearch() const { return (maxItsLS>0); }$/;"	f	class:TetMeshMotionSolver
getLocSubNum	SubDomain.h	/^  int getLocSubNum()   { return locSubNum; }$/;"	f	class:SubDomain
getLocalNodeNum	SubDomainCore.C	/^int SubDomain::getLocalNodeNum(int globNodeNum) const {$/;"	f	class:SubDomain
getMPIComm	Communicator.h	/^    MPI_Comm getMPIComm() {return comm;} \/\/<! Lei Lei, 24 March 2016, needed for ALS$/;"	f	class:Communicator
getMaster	InletNode.h	/^        bool getMaster()   {return master; }$/;"	f	class:InletNode
getMasterFlag	AgglomeratedFace.h	/^  bool& getMasterFlag() { return masterFlag; }$/;"	f	class:AgglomeratedFace
getMasterFlag	DistInfo.h	/^  bool* getMasterFlag(int iSub) const$/;"	f	struct:DistInfo
getMasterFlag	DistVector.h	/^  bool *getMasterFlag(int i) const { return distInfo.getMasterFlag(i); }$/;"	f	class:DistSVec
getMasterFlag	DistVector.h	/^  bool *getMasterFlag(int i) const { return distInfo.getMasterFlag(i); }$/;"	f	class:DistVec
getMasterFlag	Edge.h	/^  bool *getMasterFlag() const { return masterFlag; }$/;"	f	class:EdgeSet
getMatchNodes	GeoSource.h	/^  MatchNodeSet **getMatchNodes() const { return matchNodes; }$/;"	f	class:GeoSource
getMaxItsLineSearch	ImplicitEmbeddedRomTsDesc.h	/^    double getMaxItsLineSearch() {return super::getMaxItsLineSearch(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getMaxItsLineSearch	ImplicitEmbeddedTsDesc.h	/^  int getMaxItsLineSearch() const { return maxItsLS; }$/;"	f	class:ImplicitEmbeddedTsDesc
getMaxItsLineSearch	ImplicitLevelSetTsDesc.h	/^  int getMaxItsLineSearch() const { return maxItsLS; }$/;"	f	class:ImplicitLevelSetTsDesc
getMaxItsLineSearch	ImplicitMultiPhysicsTsDesc.h	/^  int getMaxItsLineSearch() const { return maxItsLS; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getMaxItsLineSearch	ImplicitTsDesc.h	/^  int getMaxItsLineSearch() const { return maxItsLS; }$/;"	f	class:ImplicitTsDesc
getMaxItsLineSearch	MeshMotionSolver.h	/^  int getMaxItsLineSearch() const { return maxItsLS; }$/;"	f	class:TetMeshMotionSolver
getMaxItsNewton	ImplicitEmbeddedRomTsDesc.h	/^    int getMaxItsNewton() { return super::getMaxItsNewtion(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getMaxItsNewton	ImplicitEmbeddedTsDesc.h	/^  int getMaxItsNewton() const { return maxItsNewton; }$/;"	f	class:ImplicitEmbeddedTsDesc
getMaxItsNewton	ImplicitLevelSetTsDesc.h	/^  int getMaxItsNewton() const { return maxItsNewton; }$/;"	f	class:ImplicitLevelSetTsDesc
getMaxItsNewton	ImplicitMultiPhysicsTsDesc.h	/^  int getMaxItsNewton() const { return maxItsNewton; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getMaxItsNewton	ImplicitTsDesc.h	/^  int getMaxItsNewton() const { return maxItsNewton; }$/;"	f	class:ImplicitTsDesc
getMaxItsNewton	MeshMotionSolver.h	/^  int getMaxItsNewton() const { return maxItsNewton; }$/;"	f	class:TetMeshMotionSolver
getMaxTime	StructExc.h	/^  double getMaxTime() const { return tmax; }$/;"	f	class:StructExc
getMaxVerbose	Communicator.h	/^  int getMaxVerbose() { return maxverbose; }$/;"	f	class:Communicator
getMdFreq	StructExc.C	/^void StructExc::getMdFreq(int &nf, double *&f)$/;"	f	class:StructExc
getMdStrDisp	StructExc.C	/^void StructExc::getMdStrDisp(int id, DistSVec<double,3> &X0,$/;"	f	class:StructExc
getMem	BlockAlloc.C	/^BlockAlloc::getMem(size_t nbyte)$/;"	f	class:BlockAlloc
getMeshInBoundingBox	SubDomainCore.C	/^void SubDomain::getMeshInBoundingBox(SVec<double,3> &X, const double xmin, const double xmax,$/;"	f	class:SubDomain
getMeshMotionBCs	Domain.h	/^  BCApplier* getMeshMotionBCs() const { return meshMotionBCs; } \/\/HB$/;"	f	class:Domain
getMeshMotionDofType	SubDomainCore.C	/^SubDomain::getMeshMotionDofType(map<int,SurfaceData*>& surfaceMap, CommPattern<int> &ntP, MatchNodeSet* matchNodes)$/;"	f	class:SubDomain
getMeshVel	PostFcn.h	/^  virtual double* getMeshVel()  { return varFcn->getMeshVel(); }$/;"	f	class:PostFcn
getMeshVel	VarFcn.h	/^  double *getMeshVel() { return meshVel.v; }$/;"	f	class:VarFcn
getMgSubDomains	MultiGridLevel.h	/^    MultigridSubdomain* getMgSubDomains() { return mgSubdomains; }$/;"	f	class:MultiGridLevel
getMinMach	LowMachPrec.h	/^  virtual double getMinMach() const        { return minMach;      }$/;"	f	class:LowMachPrec
getModalMotion	MeshMotionHandlerCore.C	/^int AeroMeshMotionHandler::getModalMotion(DistSVec<double,3> &X)$/;"	f	class:AeroMeshMotionHandler
getModes	MeshMotionHandlerCore.C	/^DistSVec<double,3> DeformingMeshMotionHandler::getModes()$/;"	f	class:DeformingMeshMotionHandler
getModes	MeshMotionHandlerCore.C	/^DistSVec<double,3> HeavingMeshMotionHandler::getModes()$/;"	f	class:HeavingMeshMotionHandler
getModes	MeshMotionHandlerCore.C	/^DistSVec<double,3> PitchingMeshMotionHandler::getModes()$/;"	f	class:PitchingMeshMotionHandler
getModes	MeshMotionHandlerCore.C	/^DistSVec<double,3> SpiralingMeshMotionHandler::getModes()$/;"	f	class:SpiralingMeshMotionHandler
getMomPat	Domain.h	/^  CommPattern<double> *getMomPat() const { return momPat; }$/;"	f	class:Domain
getMyLevel	MultiGridLevel.h	/^    int getMyLevel() const {$/;"	f	class:MultiGridLevel
getNdAeroLists	DomainCore.C	/^void Domain::getNdAeroLists(int *&nInterfNd, int **&interfNd, int *&nInfNd,$/;"	f	class:Domain
getNdAeroLists	SubDomainCore.C	/^void SubDomain::getNdAeroLists(int &nInterfNd, int *&interfNd, int &nInfNd,$/;"	f	class:SubDomain
getNeiElemOfNode	SubDomainCore.C	/^int* SubDomain::getNeiElemOfNode(int iNode, int depth, int& size )$/;"	f	class:SubDomain
getNeiNodeOfNode	SubDomainCore.C	/^int* SubDomain::getNeiNodeOfNode(int iNode, int& size)$/;"	f	class:SubDomain
getNeighb	SubDomain.h	/^  int *getNeighb()     { return neighb; }$/;"	f	class:SubDomain
getNeighboringSubdomains	MultiGridLevel.C	/^int* MultiGridLevel<Scalar>::getNeighboringSubdomains(int mySub) {$/;"	f	class:MultiGridLevel
getNewCracking	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::getNewCracking()$/;"	f	class:DynamicNodalTransfer
getNewCracking	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::getNewCracking()$/;"	f	class:EmbeddedStructure
getNewCracking	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::getNewCracking(int numConnUpdate, int numLSUpdate, int newNodes)$/;"	f	class:EmbeddedStructure
getNewCracking	StructExc.C	/^void StructExc::getNewCracking(int numConnUpdate, int numLSUpdate, int* phantoms, double* phi, int* phiIndex, int* new2old, int newNodes)$/;"	f	class:StructExc
getNewCrackingFlag	FSI/CrackingSurface.h	/^  bool getNewCrackingFlag() const {return gotNewCracking;}$/;"	f	class:CrackingSurface
getNewCrackingStats	StructExc.C	/^bool StructExc::getNewCrackingStats(int &numConnUpdate, int &numLSUpdate, int &newNodes)$/;"	f	class:StructExc
getNewtonIt	Domain.h	/^  int *getNewtonIt() { return &outputNewtonIt; }$/;"	f	class:Domain
getNewtonIt	ImplicitEmbeddedRomTsDesc.h	/^    double getNewtonIt(){return super::getNewtonIt(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getNewtonIt	MeshMotionSolver.h	/^  int *getNewtonIt() { return domain->getNewtonIt(); }$/;"	f	class:TetMeshMotionSolver
getNewtonIt	TsDesc.h	/^  int *getNewtonIt() { return domain->getNewtonIt(); }$/;"	f	class:TsDesc
getNewtonResidualStep	DistTimeState.C	/^int DistTimeState<dim>::getNewtonResidualStep() const {$/;"	f	class:DistTimeState
getNewtonResidualStep	Domain.h	/^  int *getNewtonResidualStep() { return &outputNewtonResidualStep; }$/;"	f	class:Domain
getNewtonResidualStep	TimeData.h	/^  int getNewtonResidualStep() const  { return outputNewtonResidualStep; }$/;"	f	class:TimeData
getNewtonStateStep	DistTimeState.C	/^int DistTimeState<dim>::getNewtonStateStep() const {$/;"	f	class:DistTimeState
getNewtonStateStep	Domain.h	/^  int *getNewtonStateStep() { return &outputNewtonStateStep; }$/;"	f	class:Domain
getNewtonStateStep	TimeData.h	/^  int getNewtonStateStep() const  { return outputNewtonStateStep; }$/;"	f	class:TimeData
getNewtonTag	DistTimeState.C	/^double DistTimeState<dim>::getNewtonTag() const {$/;"	f	class:DistTimeState
getNewtonTag	Domain.h	/^  double *getNewtonTag() { return &outputNewtonTag; } $/;"	f	class:Domain
getNewtonTag	TimeData.h	/^  int getNewtonTag() const  { return outputNewtonTag; }$/;"	f	class:TimeData
getNodalNorm	IntersectorFRG/IntersectorFRG.h	/^    const Vec3D &getNodalNorm(int i) const {if (!nodalNormal) {fprintf(stderr,"ERROR: nodal normal not initialized!\\n");exit(-1);} return nodalNormal[i];}$/;"	f	class:DistIntersectorFRG
getNodalNorm	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    const Vec3D &getNodalNorm(int i) const {if (!nodalNormal) {fprintf(stderr,"ERROR: nodal normal not initialized!\\n");exit(-1);} return nodalNormal[i];}$/;"	f	class:DistIntersectorPhysBAM
getNode	AgglomeratedFace.h	/^  int getNode() const { return node; }$/;"	f	class:AgglomeratedFace
getNodeCoords	SubDomainCore.C	/^void SubDomain::getNodeCoords(int iNode, SVec<double,3> &X, double& x, double& y, double& z)$/;"	f	class:SubDomain
getNodeDistInfo	Domain.h	/^  DistInfo &getNodeDistInfo() const { return *nodeDistInfo; }$/;"	f	class:Domain
getNodeDistInfo	MultiGridLevel.h	/^    DistInfo& getNodeDistInfo()       { return *nodeDistInfo; }$/;"	f	class:MultiGridLevel
getNodeFaceType	Domain.h	/^  int **getNodeFaceType() const { return nodeFaceType; }$/;"	f	class:Domain
getNodeMap	SubDomain.h	/^  int *getNodeMap()    { return locToGlobNodeMap; }$/;"	f	class:SubDomain
getNodeMapping	MultiGridLevel.h	/^    DistVec<int>& getNodeMapping() { return *pNodeMapping; }$/;"	f	class:MultiGridLevel
getNodeNum	InletNode.h	/^  	int getNodeNum()   { return node; }$/;"	f	class:InletNode
getNodeStateVector	BcData.h	/^  SVec<double,dim> &getNodeStateVector() const { return Unode; }$/;"	f	class:BcData
getNodeStateVector	DistBcData.h	/^  DistSVec<double,dim> &getNodeStateVector() { return Unode; }$/;"	f	class:DistBcData
getNodeToNode	SubDomain.h	/^  Connectivity *getNodeToNode() { if(!NodeToNode) NodeToNode = createEdgeBasedConnectivity();  return NodeToNode; }$/;"	f	class:SubDomain
getNodeToSubD	SubDomain.h	/^  Connectivity *getNodeToSubD() { if(!NodeToSubD) NodeToSubD = createNodeToSubDomainConnectivity();  return NodeToSubD; }$/;"	f	class:SubDomain
getNodeType	Domain.h	/^  int **getNodeType() const { return nodeType; }$/;"	f	class:Domain
getNodeType	MultiGridLevel.h	/^    int* getNodeType(int iSub) { return nodeType[iSub]; }$/;"	f	class:MultiGridLevel
getNodeType	SpaceOperator.h	/^  int **getNodeType() {return domain->getNodeType(); }$/;"	f	class:SpaceOperator
getNodeTypeExtrapolation	Domain.h	/^  int **getNodeTypeExtrapolation() const{$/;"	f	class:Domain
getNodeWithMostAgglomeratedNeighbors	MultiGridLevel.C	/^getNodeWithMostAgglomeratedNeighbors(std::vector<std::set<int> >& C,\/\/Connectivity* C, $/;"	f	class:MultiGridLevel
getNodes	SubDomain.h	/^  NodeSet &getNodes() { return nodes; }$/;"	f	class:SubDomain
getNormal	AgglomeratedFace.h	/^  Vec3D& getNormal() { return normal; }$/;"	f	class:AgglomeratedFace
getNormal	FaceTriaCore.C	/^Vec3D FaceTria::getNormal(Vec<Vec3D> &faceNorm) {$/;"	f	class:FaceTria
getNormal	FaceTriaCore.C	/^Vec3D FaceTria::getNormal(Vec<Vec3D> &faceNorm, int i) {$/;"	f	class:FaceTria
getNormalVel	FaceTriaCore.C	/^double FaceTria::getNormalVel(Vec<double> &faceNormVel) {$/;"	f	class:FaceTria
getNormalVel	FaceTriaCore.C	/^double FaceTria::getNormalVel(Vec<double> &faceNormVel, int i) {$/;"	f	class:FaceTria
getNumFaceNeighb	GeoState.h	/^  Vec<int> &getNumFaceNeighb() const {return numFaceNeighb; }$/;"	f	class:GeoState
getNumFaces	InletNode.h	/^  	int getNumFaces()  { return numFaces; }$/;"	f	class:InletNode
getNumGlobNode	DomainCore.C	/^int Domain::getNumGlobNode() {$/;"	f	class:Domain
getNumGlobSub	GeoSource.h	/^  int getNumGlobSub() const { return numGlobSub; }$/;"	f	class:GeoSource
getNumKrylovVecsOutputPrevNewtonIt	Domain.h	/^  int *getNumKrylovVecsOutputPrevNewtonIt() { return &numKrylovVecsOutputPrevNewtonIt; }$/;"	f	class:Domain
getNumLocSub	Domain.h	/^  int getNumLocSub() const { return numLocSub; }$/;"	f	class:Domain
getNumLocSub	GeoSource.h	/^  int getNumLocSub() const { return numLocSub; }$/;"	f	class:GeoSource
getNumLocThreads	GeoSource.h	/^  int getNumLocThreads() const { return numLocThreads; }$/;"	f	class:GeoSource
getNumNeighb	SubDomain.h	/^  int getNumNeighb()   { return numNeighb; }$/;"	f	class:SubDomain
getNumNeighborSubdomains	MultiGridLevel.C	/^int MultiGridLevel<Scalar>::getNumNeighborSubdomains(int mySub) {$/;"	f	class:MultiGridLevel
getNumOfPhases	FluidSelector.h	/^  int getNumOfPhases() {return numPhases;}$/;"	f	class:FluidSelector
getNumParam	MeshMotionHandler.h	/^  virtual void getNumParam(int &, int &, double &) {}$/;"	f	class:MeshMotionHandler
getNumParam	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::getNumParam(int &numParam, int &actvar, double &steadyTol)$/;"	f	class:AeroMeshMotionHandler
getNumParam	StructExc.C	/^void StructExc::getNumParam(int &numParam, int &actvar, double &steadyTol)$/;"	f	class:StructExc
getNumParam	TsDesc.C	/^void TsDesc<dim>::getNumParam(int &numParam, int &actvar, double &steadyTol)$/;"	f	class:TsDesc
getNumPhase	TsDesc.h	/^  int getNumPhase() { return numPhase; }$/;"	f	class:TsDesc
getNumResJacMat	NonlinearRom.h	/^  int getNumResJacMat() {return numResJacMat;}$/;"	f	class:NonlinearRom
getNumResidualOutputCurrentNewtonIt	ImplicitEmbeddedRomTsDesc.h	/^    double getNumResidualOutputCurrentNewtonIt() {return super::getNumResidualOutputCurrentNewtonIt(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getNumResidualsOutputCurrentNewtonIt	Domain.h	/^  int *getNumResidualsOutputCurrentNewtonIt() { return &numResidualsOutputCurrentNewtonIt; } $/;"	f	class:Domain
getNumResidualsOutputCurrentNewtonIt	MeshMotionSolver.h	/^  int *getNumResidualsOutputCurrentNewtonIt() { return domain->getNumResidualsOutputCurrentNewtonIt(); }$/;"	f	class:TetMeshMotionSolver
getNumResidualsOutputCurrentNewtonIt	TsDesc.h	/^  int *getNumResidualsOutputCurrentNewtonIt() { return domain->getNumResidualsOutputCurrentNewtonIt(); }$/;"	f	class:TsDesc
getNumSampledEdges	Edge.h	/^  int getNumSampledEdges() {return numSampledEdges;}$/;"	f	class:EdgeSet
getNumSampledFaces	Face.h	/^  int getNumSampledFaces() {return numSampledFaces;}$/;"	f	class:FaceSet
getNumSharedEdges	MultiGridLevel.h	/^    int** getNumSharedEdges() { return numSharedEdges; }$/;"	f	class:MultiGridLevel
getNumSharedEdges	SubDomain.h	/^  const int* getNumSharedEdges() const { return numSharedEdges; }$/;"	f	class:SubDomain
getNumStructElems	IntersectorFRG/IntersectorFRG.h	/^    int getNumStructElems () { return numStElems; }$/;"	f	class:DistIntersectorFRG
getNumStructElems	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int getNumStructElems () { return numStElems; }$/;"	f	class:DistIntersectorPhysBAM
getNumStructElems	LevelSet/MultiGridLevelSetStructure.h	/^    int getNumStructElems() { return parent->getNumStructElems(); }$/;"	f	class:DistMultiGridLevelSetStructure
getNumStructNodes	IntersectorFRG/IntersectorFRG.h	/^    int getNumStructNodes () { return numStNodes; }$/;"	f	class:DistIntersectorFRG
getNumStructNodes	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int getNumStructNodes () { return numStNodes; }$/;"	f	class:DistIntersectorPhysBAM
getNumStructNodes	LevelSet/MultiGridLevelSetStructure.h	/^    int getNumStructNodes() { return parent->getNumStructNodes(); }$/;"	f	class:DistMultiGridLevelSetStructure
getNumSurf	PostOperator.h	/^  int getNumSurf() { return numSurf; }$/;"	f	class:PostOperator
getNumSurfHF	PostOperator.h	/^  int getNumSurfHF() { return numSurfHF; }$/;"	f	class:PostOperator
getNumTets	InletNode.h	/^  	int getNumTets()   { return numTets; }$/;"	f	class:InletNode
getNumTriangle	TriangulatedSurface.h	/^  int getNumTriangle() {return numTriangle; }$/;"	f	class:TriangulatedSurface
getNumTwoLayersEdges	Edge.h	/^  int getNumTwoLayersEdges() {return numTwoLayerEdges;}$/;"	f	class:EdgeSet
getObservationPoints	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::getObservationPoints$/;"	f	class:KirchhoffIntegrator
getOffDiagMatPat	DistMatrix.h	/^  CommPattern<Scalar> *getOffDiagMatPat() const { return offDiagMatPat; }$/;"	f	class:DistMat
getOldSampledNodeDistInfo	Domain.h	/^  DistInfo &getOldSampledNodeDistInfo() const { return *oldSampledNodeDistInfo; }$/;"	f	class:Domain
getOldV	DistExactRiemannSolver.h	/^  DistSVec<double,dim> *getOldV() const { return oldV; }$/;"	f	class:DistExactRiemannSolver
getOmega	VarFcn.h	/^  double getOmega(int tag=0) const{ check(tag); return varFcn[tag]->getOmega(); }$/;"	f	class:VarFcn
getOmega	VarFcnBase.h	/^  virtual double getOmega() const{$/;"	f	class:VarFcnBase
getOmega	VarFcnJwl.h	/^  double getOmega()      const{ return omega; }$/;"	f	class:VarFcnJwl
getOmegap1	VarFcn.h	/^  double getOmegap1(int tag=0) const{ check(tag); return varFcn[tag]->getOmegap1(); }$/;"	f	class:VarFcn
getOmegap1	VarFcnBase.h	/^  virtual double getOmegap1() const{$/;"	f	class:VarFcnBase
getOmegap1	VarFcnJwl.h	/^  double getOmegap1()    const{ return omegap1; }$/;"	f	class:VarFcnJwl
getOperator	MultiGridSpaceOperator.h	/^  MultiGridOperator<Scalar,dim>* getOperator(int i) {$/;"	f	class:MultiGridSpaceOperator
getOutletBoundaryVector	DistBcData.h	/^  DistSVec<double,dim> &getOutletBoundaryVector() { return Ufarout; }$/;"	f	class:DistBcData
getOutletConservativeState	DistBcData.h	/^  double *getOutletConservativeState() { return Uout; }$/;"	f	class:DistBcData
getOutputNewton	ImplicitEmbeddedRomTsDesc.h	/^    FILE* getOutputNewton() { return super::getOutputNewton(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
getOutputNewton	ImplicitEmbeddedTsDesc.h	/^  FILE* getOutputNewton() const { return outputNewton; }$/;"	f	class:ImplicitEmbeddedTsDesc
getOutputNewton	ImplicitLevelSetTsDesc.h	/^  FILE* getOutputNewton() const { return outputNewton; }$/;"	f	class:ImplicitLevelSetTsDesc
getOutputNewton	ImplicitMultiPhysicsTsDesc.h	/^  FILE* getOutputNewton() const { return outputNewton; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getOutputNewton	ImplicitTsDesc.h	/^  FILE* getOutputNewton() const { return outputNewton; }$/;"	f	class:ImplicitTsDesc
getOutputNewton	MeshMotionSolver.h	/^  FILE* getOutputNewton() const { return outputNewton; }$/;"	f	class:TetMeshMotionSolver
getParent	MultiGridLevel.h	/^    MultiGridLevel* getParent() { return parent; }$/;"	f	class:MultiGridLevel
getPhi	FSI/CrackingSurface.cpp	/^double CrackingSurface::getPhi(int trId, double xi1, double xi2, bool* hasCracked, bool debug)$/;"	f	class:CrackingSurface
getPhiPhysBAM	FSI/CrackingSurface.cpp	/^getPhiPhysBAM(int trId, double xi1, double xi2, bool* hasCracked, bool debug) {$/;"	f	class:CrackingSurface
getPhiPhysBAM	PhysBAM_Interface/LOCAL_LEVELSET.h	/^  virtual double getPhiPhysBAM(int trId, double xi1, double xi2, bool* hasCracked=0, bool debug = false) {$/;"	f	class:LocalLevelSet
getPhinm1	LevelSet.h	/^  DistSVec<double,dimLS>& getPhinm1() { return Phinm1; }$/;"	f	class:LevelSet
getPiercedPoint	SubDomainCore.C	/^bool SubDomain::getPiercedPoint(Vec3D va, Vec3D vb, Vec3D vc, Vec3D vd, Vec3D ve, double &r, double &t)$/;"	f	class:SubDomain
getPmin	VarFcn.h	/^  double getPmin(int tag=0) const { check(tag); return varFcn[tag]->pmin; }$/;"	f	class:VarFcn
getPointer	Elem.h	/^  Elem** getPointer() { return elems; }$/;"	f	class:ElemSet
getPolygonNormal	PolygonReconstructionData.C	/^void getPolygonNormal(SVec<double,3>& X, Vec3D &normal, LevelSetStructure &LSS, PolygonReconstructionData &polygon)$/;"	f
getPolygons	PolygonReconstructionData.C	/^int getPolygons(Elem &elem, LevelSetStructure &LSS, PolygonReconstructionData* polygons)$/;"	f
getPostFcn	PostOperator.h	/^  PostFcn* getPostFcn() {return postFcn;}$/;"	f	class:PostOperator
getPrecTag	LowMachPrec.h	/^  virtual int    getPrecTag() const        { return prec;         }$/;"	f	class:LowMachPrec
getPrefWater	VarFcn.h	/^  double getPrefWater(int tag=0)  const{ check(tag); return varFcn[tag]->getPrefWater(); }$/;"	f	class:VarFcn
getPrefWater	VarFcnBase.h	/^  virtual double getPrefWater() const{$/;"	f	class:VarFcnBase
getPrefWater	VarFcnTait.h	/^  double getPrefWater()  const{ return p_; }$/;"	f	class:VarFcnTait
getPressure	VarFcn.h	/^  double getPressure(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->getPressure(V); }$/;"	f	class:VarFcn
getPressure	VarFcnBase.h	/^  virtual double getPressure(double *V)  const{ return V[4]; }$/;"	f	class:VarFcnBase
getPressure	VarFcnSGEuler.h	/^  double getPressure(double *V)               const {return V[4];}$/;"	f	class:VarFcnSGEuler
getPressure	VarFcnSGKE.h	/^  double getPressure(double *V)                  const {return V[4];}$/;"	f	class:VarFcnSGKE
getPressure	VarFcnSGSA.h	/^  double getPressure(double *V)               const {return V[4];}$/;"	f	class:VarFcnSGSA
getPressure	VarFcnTait.h	/^  double getPressure(const double density) const{ return p_ + a_ * pow(density, b_); }$/;"	f	class:VarFcnTait
getPressure	VarFcnTait.h	/^  double getPressure(double *V) const{ return p_ + a_*pow(V[0],b_); }$/;"	f	class:VarFcnTait
getPressureConstant	VarFcn.h	/^  double getPressureConstant(int tag=0) const{ check(tag); return varFcn[tag]->getPressureConstant(); }$/;"	f	class:VarFcn
getPressureConstant	VarFcnBase.h	/^  virtual double getPressureConstant() const{$/;"	f	class:VarFcnBase
getPressureConstant	VarFcnSGEuler.h	/^  double getPressureConstant()                const {return Pstiff;}$/;"	f	class:VarFcnSGEuler
getPressureConstant	VarFcnSGKE.h	/^  double getPressureConstant()                   const {return Pstiff;}$/;"	f	class:VarFcnSGKE
getPressureConstant	VarFcnSGSA.h	/^  double getPressureConstant()                const {return Pstiff;}$/;"	f	class:VarFcnSGSA
getPressureDerivative	VarFcnTait.h	/^  double getPressureDerivative(double *V) const { return computeSoundSpeed(V); }$/;"	f	class:VarFcnTait
getPrimeValues	DynamicVMSTerm.C	/^void DynamicVMSTerm::getPrimeValues(double *V[4], double *VBar[4],$/;"	f	class:DynamicVMSTerm
getPrimeValues	VMSLESTerm.C	/^void VMSLESTerm::getPrimeValues(double *V[4], double *VBar[4],$/;"	f	class:VMSLESTerm
getPrimitiveState	GhostPoint.h	/^  double* getPrimitiveState()$/;"	f	class:GhostPoint
getPrimitiveState	GhostPoint.h	/^double* getPrimitiveState(int dir)$/;"	f	class:GhostPoint
getProgrammedBurn	FluidSelector.h	/^  ProgrammedBurn* getProgrammedBurn() const { return programmedBurn; }$/;"	f	class:FluidSelector
getPtr	Edge.h	/^  int (*getPtr() const)[2] { return ptr; }$/;"	f	class:EdgeSet
getQuad2Tria	FSI/CrackingSurface.h	/^  void getQuad2Tria(int quad, int &trId1, int &trId2) {trId1=quad2tria[quad][0]; trId2=quad2tria[quad][1];}$/;"	f	class:CrackingSurface
getQuadrature	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::getQuadrature$/;"	f	class:KirchhoffIntegrator
getR	DistNodalGrad.h	/^  DistSVec<double,6>& getR() { return *R; }$/;"	f	class:DistNodalGrad
getR1	VarFcn.h	/^  double getR1(int tag=0) const{ check(tag); return varFcn[tag]->getR1(); }$/;"	f	class:VarFcn
getR1	VarFcnBase.h	/^  virtual double getR1() const{$/;"	f	class:VarFcnBase
getR1	VarFcnJwl.h	/^  double getR1()         const{ return R1; }$/;"	f	class:VarFcnJwl
getR1r	VarFcn.h	/^  double getR1r(int tag=0) const{ check(tag); return varFcn[tag]->getR1r(); }$/;"	f	class:VarFcn
getR1r	VarFcnBase.h	/^  virtual double getR1r() const{$/;"	f	class:VarFcnBase
getR1r	VarFcnJwl.h	/^  double getR1r()        const{ return R1r; }$/;"	f	class:VarFcnJwl
getR2	VarFcn.h	/^  double getR2(int tag=0) const{ check(tag); return varFcn[tag]->getR2(); }$/;"	f	class:VarFcn
getR2	VarFcnBase.h	/^  virtual double getR2() const{$/;"	f	class:VarFcnBase
getR2	VarFcnJwl.h	/^  double getR2()         const{ return R2; }$/;"	f	class:VarFcnJwl
getR2r	VarFcn.h	/^  double getR2r(int tag=0) const{ check(tag); return varFcn[tag]->getR2r(); }$/;"	f	class:VarFcn
getR2r	VarFcnBase.h	/^  virtual double getR2r() const{$/;"	f	class:VarFcnBase
getR2r	VarFcnJwl.h	/^  double getR2r()        const{ return R2r; }$/;"	f	class:VarFcnJwl
getRangeInfo	GeoSource.C	/^int GeoSource::getRangeInfo(BinFileHandler &file, int &numRanges, int (*&ranges)[2])$/;"	f	class:GeoSource
getRcvChannel	SubDomain.h	/^  int *getRcvChannel() { return rcvChannel; }$/;"	f	class:SubDomain
getReal	DistVector.h	/^DistSVec<Scalar,dim>::getReal(const DistSVec<bcomp,dim> &y)$/;"	f	class:DistSVec
getRealNodeElem_ij	GenMatrix.h	/^  virtual Scalar* getRealNodeElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
getRealNodeElem_ij	MvpMatrix.h	/^  Scalar* getRealNodeElem_ij(int i,int j) {$/;"	f	class:MvpMat
getReferenceMeshPosition	DomainCore.C	/^void Domain::getReferenceMeshPosition(DistSVec<double,3> &x)$/;"	f	class:Domain
getReferenceMeshPosition	SubDomainCore.C	/^void SubDomain::getReferenceMeshPosition(SVec<double,3> &X)$/;"	f	class:SubDomain
getRelResidual	MeshMotionHandler.h	/^  virtual void getRelResidual(double &) {}$/;"	f	class:MeshMotionHandler
getRelResidual	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::getRelResidual(double &relres)$/;"	f	class:AeroMeshMotionHandler
getRelResidual	StructExc.C	/^void StructExc::getRelResidual(double &relres)$/;"	f	class:StructExc
getRelResidual	TsDesc.C	/^void TsDesc<dim>::getRelResidual(double &relres)$/;"	f	class:TsDesc
getRelativePositionVector	MeshMotionHandlerCore.C	/^DistSVec<double,3> &RigidMeshMotionHandler::getRelativePositionVector(double t, DistSVec<double,3> &X)$/;"	f	class:RigidMeshMotionHandler
getResMat	NonlinearRom.h	/^  VecSet<DistSVec<double,dim> >* getResMat() {return resMat;}$/;"	f	class:NonlinearRom
getRestartFrequency	StructExc.h	/^  int getRestartFrequency() const { return rstrt; }$/;"	f	class:StructExc
getRestrictedDistInfo	NonlinearRom.h	/^  const DistInfo& getRestrictedDistInfo () const {return restrictionMapping->restrictedDistInfo();}$/;"	f	class:NonlinearRom
getRestrictedToOriginLocNode	RestrictionMapping.h	/^	const std::vector<std::vector<int> > & getRestrictedToOriginLocNode() { return restrictedToOrigin_;}$/;"	f	class:RestrictionMapping
getRhomin	VarFcn.h	/^  double getRhomin(int tag=0) const { check(tag); return varFcn[tag]->rhomin; }$/;"	f	class:VarFcn
getRhoref	VarFcn.h	/^  double getRhoref(int tag=0) const{ check(tag); return varFcn[tag]->getRhoref(); }$/;"	f	class:VarFcn
getRhoref	VarFcnBase.h	/^  virtual double getRhoref() const{$/;"	f	class:VarFcnBase
getRhoref	VarFcnJwl.h	/^  double getRhoref()     const{ return rhoref; }$/;"	f	class:VarFcnJwl
getRiemannSolverId	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::getRiemannSolverId(int i, int j) const {$/;"	f	class:ExactRiemannSolver
getRiemannUpdate	DistExactRiemannSolver.h	/^  DistSVec<double,dim> *getRiemannUpdate() const { return riemannupdate; }$/;"	f	class:DistExactRiemannSolver
getRiemannUpdate	ExactRiemannSolver.h	/^  SVec<double,dim> &getRiemannUpdate() const { return rupdate; }$/;"	f	class:ExactRiemannSolver
getRiemannWeight	DistExactRiemannSolver.h	/^  DistVec<double> *getRiemannWeight() const { return weight; }$/;"	f	class:DistExactRiemannSolver
getRiemannWeight	ExactRiemannSolver.h	/^  Vec<double> &getRiemannWeight() const { return weight; }$/;"	f	class:ExactRiemannSolver
getRotOwn	SubDomain.h	/^  int *getRotOwn() { return rotOwn; }$/;"	f	class:SubDomain
getRotSurfaceOwnership	SubDomainCore.C	/^int* SubDomain::getRotSurfaceOwnership(CommPattern<int> &cpat,$/;"	f	class:SubDomain
getRunTime	Timer.C	/^double Timer::getRunTime()$/;"	f	class:Timer
getSIstencil	SubDomainCore.C	/^bool SubDomain::getSIstencil(int Ni, int Nj, SVec<double,3> &X, LevelSetStructure &LSS, Vec<int> &fluidId,$/;"	f	class:SubDomain
getSampledNodeDistInfo	Domain.h	/^  DistInfo &getSampledNodeDistInfo() const { return *sampledNodeDistInfo; }$/;"	f	class:Domain
getScope	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    std::set<int>& getScope(const int subD){return SubD(subD).next_scope;}$/;"	f	class:PhysBAM::PhysBAMInterface
getSendBuffer	Communicator.C	/^CommPattern<T>::getSendBuffer(int channel)$/;"	f	class:CommPattern
getSharedEdges	MultiGridLevel.h	/^    EdgeDef*** getSharedEdges() { return sharedEdges; }$/;"	f	class:MultiGridLevel
getSharedEdges	SubDomain.h	/^  EdgeDef** getSharedEdges() { return sharedEdges; }$/;"	f	class:SubDomain
getSharedNodes	MultiGridLevel.h	/^    Connectivity ** getSharedNodes()  { return sharedNodes; }$/;"	f	class:MultiGridLevel
getSharedNodes	SubDomain.h	/^  Connectivity* getSharedNodes() {return sharedNodes;}$/;"	f	class:SubDomain
getShockParameter	LowMachPrec.h	/^  virtual double getShockParameter() const { return shockreducer; }$/;"	f	class:LowMachPrec
getSignedDistance	Domain.C	/^void Domain::getSignedDistance(int lsdim, DistSVec<double,1> &Psi, DistSVec<double,dimLS> &Phi)$/;"	f	class:Domain
getSignedDistance	SubDomain.C	/^void SubDomain::getSignedDistance(int lsdim, SVec<double,1> &Psi, SVec<double,dimLS> &Phi)$/;"	f	class:SubDomain
getSignedVertexDistance	IntersectorFRG/IntersectorFRG.C	/^double ClosestTriangle::getSignedVertexDistance() const {$/;"	f	class:ClosestTriangle
getSlipSurfOwnership	SubDomainCore.C	/^SubDomain::getSlipSurfOwnership(CommPattern<int> &cpat,$/;"	f	class:SubDomain
getSlope	LowMachPrec.h	/^  virtual double getSlope() const          { return slope;        }$/;"	f	class:LowMachPrec
getSmoothedVec	MultiGridCoupledTsDesc.h	/^  DistSVec<double,dim>* getSmoothedVec() { return NULL; }$/;"	f	class:MultiGridCoupledTsDesc
getSmoothedVec	MultiGridEmbeddedTsDesc.h	/^  DistSVec<double,dim>* getSmoothedVec() { return U_smoothed; }$/;"	f	class:MultiGridEmbeddedTsDesc
getSmoothedVec	MultiGridSegTsDesc.h	/^  DistSVec<double,dim>* getSmoothedVec() { return NULL; }$/;"	f	class:MultiGridSegTsDesc
getSndChannel	SubDomain.h	/^  int *getSndChannel() { return sndChannel; }$/;"	f	class:SubDomain
getSolidBoundaryNodes	SubDomainCore.C	/^void SubDomain::getSolidBoundaryNodes(Aerof_unordered_set<int>::type& boundaryNodes) const {$/;"	f	class:SubDomain
getSpaceOperator	TsDesc.h	/^  SpaceOperator<dim>* getSpaceOperator() { return spaceOp; }$/;"	f	class:TsDesc
getSpaceOrder	SpaceOperator.h	/^  int getSpaceOrder() {return order;}$/;"	f	class:SpaceOperator
getSpatialLowMachPrec	DistTimeState.h	/^  SpatialLowMachPrec& getSpatialLowMachPrec() { return sprec; }$/;"	f	class:DistTimeState
getStElems	FSI/DynamicNodalTransfer.h	/^        int    (*getStElems())[3] {return structure.Tria;}$/;"	f	class:DynamicNodalTransfer
getStNodes	FSI/DynamicNodalTransfer.h	/^        double *getStNodes() {return XandUdot;}$/;"	f	class:DynamicNodalTransfer
getStVelocity	FSI/DynamicNodalTransfer.h	/^        double *getStVelocity() {return XandUdot+structure.nNodes*3;}$/;"	f	class:DynamicNodalTransfer
getState	GhostPoint.h	/^  double* getState()$/;"	f	class:GhostPoint
getStatus	GhostPoint.h	/^bool getStatus()$/;"	f	class:GhostPoint
getStatus	LevelSet/LevelSetStructure.h	/^    DistVec<int> & getStatus()            const { return *status; }$/;"	f	class:DistLevelSetStructure
getStatus	LevelSet/LevelSetStructure.h	/^    Vec<int> & getStatus() { return status; }$/;"	f	class:LevelSetStructure
getStep	TsOutput.C	/^int TsOutput<dim>::getStep(int it, bool lastIt, double t)$/;"	f	class:TsOutput
getStrCommunicator	Domain.h	/^  Communicator *getStrCommunicator() { return strCom; }$/;"	f	class:Domain
getStrTimer	Domain.h	/^  Timer *getStrTimer() const { return strTimer; }$/;"	f	class:Domain
getStructDerivative	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> &getStructDerivative() { return *solidXdS; }$/;"	f	class:DistIntersectorFRG
getStructDerivative	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> &getStructDerivative() { return *solidXdS; }$/;"	f	class:DistIntersectorPhysBAM
getStructDerivative	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &getStructDerivative() { return parent->getStructDerivative(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructElems	IntersectorFRG/IntersectorFRG.h	/^    int (*getStructElems())[3] { return stElem; }$/;"	f	class:DistIntersectorFRG
getStructElems	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int (*getStructElems())[3] { return stElem; }$/;"	f	class:DistIntersectorPhysBAM
getStructElems	LevelSet/MultiGridLevelSetStructure.h	/^    int (*getStructElems())[3]  { return parent->getStructElems(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructExc	FSI/DynamicNodalTransfer.h	/^        StructExc* getStructExc() { return structure.structExc; }$/;"	f	class:DynamicNodalTransfer
getStructPosition	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> &getStructPosition() { return *solidX; }$/;"	f	class:DistIntersectorFRG
getStructPosition	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> &getStructPosition() { return *solidX; }$/;"	f	class:DistIntersectorPhysBAM
getStructPosition	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &getStructPosition()  { return parent->getStructPosition(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructPosition_0	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> &getStructPosition_0() { return *solidX0; }$/;"	f	class:DistIntersectorFRG
getStructPosition_0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> &getStructPosition_0() { return *solidX0; }$/;"	f	class:DistIntersectorPhysBAM
getStructPosition_0	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &getStructPosition_0()  { return parent->getStructPosition_0(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructPosition_n	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> &getStructPosition_n() { return *solidXn; }$/;"	f	class:DistIntersectorFRG
getStructPosition_n	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> &getStructPosition_n() { return *solidXn; }$/;"	f	class:DistIntersectorPhysBAM
getStructPosition_n	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &getStructPosition_n() { return parent->getStructPosition_n(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructPosition_np1	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> &getStructPosition_np1() { return *solidXnp1; }$/;"	f	class:DistIntersectorFRG
getStructPosition_np1	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> &getStructPosition_np1() { return *solidXnp1; }$/;"	f	class:DistIntersectorPhysBAM
getStructPosition_np1	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &getStructPosition_np1() { return parent->getStructPosition_np1(); }$/;"	f	class:DistMultiGridLevelSetStructure
getStructSubcyclingInfo	FSI/DynamicNodalTransfer.cpp	/^int DynamicNodalTransfer::getStructSubcyclingInfo()$/;"	f	class:DynamicNodalTransfer
getStructureMaxTime	FSI/DynamicNodalTransfer.h	/^        double getStructureMaxTime() {return tMax;}$/;"	f	class:DynamicNodalTransfer
getStructureTimeStep	FSI/DynamicNodalTransfer.h	/^        double getStructureTimeStep() {return dts;}$/;"	f	class:DynamicNodalTransfer
getSubDomain	Domain.h	/^  SubDomain **getSubDomain() const { return subDomain; }$/;"	f	class:Domain
getSubDomain	GeoSource.C	/^SubDomain *GeoSource::getSubDomain(int iSub)$/;"	f	class:GeoSource
getSubDomainBoundaryNodes	SubDomainCore.C	/^void SubDomain::getSubDomainBoundaryNodes(Aerof_unordered_set<int>::type& boundaryNodes) const {$/;"	f	class:SubDomain
getSubDomainError	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::getSubDomainError(int iSub) {$/;"	f	class:GappyPreprocessing
getSubLSS	TriangulatedInterface.C	/^getSubLSS(int iSub) {$/;"	f	class:TriangulatedInterface
getSubToSub	Domain.h	/^  Connectivity* getSubToSub() { return mySubToSub; } $/;"	f	class:Domain
getSubToSub	GeoSource.h	/^  Connectivity *getSubToSub() const { return subToSub; }$/;"	f	class:GeoSource
getSubToken	parser/ParseTree.cpp	/^Assigner *ParseTree::getSubToken(Token token, Token subToken)$/;"	f	class:ParseTree
getSubTopo	Domain.h	/^  SubDTopo *getSubTopo() const { return subTopo; }$/;"	f	class:Domain
getSubcyclingInfo	StructExc.C	/^int StructExc::getSubcyclingInfo()$/;"	f	class:StructExc
getSufficientDecreaseLinSearch	ImplicitEmbeddedRomTsDesc.h	/^    double getSufficientDecreaseLinSearch() {return super::getSufficientDecreaseLinSearch();};$/;"	f	class:ImplicitEmbeddedRomTsDesc
getSufficientDecreaseLineSearch	ImplicitEmbeddedTsDesc.h	/^  double getSufficientDecreaseLineSearch() const { return sufficDecreaseLS; }$/;"	f	class:ImplicitEmbeddedTsDesc
getSufficientDecreaseLineSearch	ImplicitLevelSetTsDesc.h	/^  double getSufficientDecreaseLineSearch() const { return sufficDecreaseLS; }$/;"	f	class:ImplicitLevelSetTsDesc
getSufficientDecreaseLineSearch	ImplicitMultiPhysicsTsDesc.h	/^  double getSufficientDecreaseLineSearch() const { return sufficDecreaseLS; }$/;"	f	class:ImplicitMultiPhysicsTsDesc
getSufficientDecreaseLineSearch	ImplicitTsDesc.h	/^  double getSufficientDecreaseLineSearch() const { return sufficDecreaseLS; }$/;"	f	class:ImplicitTsDesc
getSufficientDecreaseLineSearch	MeshMotionSolver.h	/^  double getSufficientDecreaseLineSearch() const { return sufficDecreaseLS; }$/;"	f	class:TetMeshMotionSolver
getSurfFromFEM	FSI/DynamicNodalTransfer.h	/^  bool getSurfFromFEM;$/;"	m	class:EmbeddedStructure
getSurfMap	PostOperator.h	/^  map<int, int> &getSurfMap() { return surfOutMap; }$/;"	f	class:PostOperator
getSurfMapHF	PostOperator.h	/^  map<int, int> &getSurfMapHF() { return surfOutMapHF; }$/;"	f	class:PostOperator
getSurfaceID	Face.h	/^  int getSurfaceID() { return surface_id; }$/;"	f	class:Face
getSurfaceID	IntersectorFRG/IntersectorFRG.h	/^    int getSurfaceID(int k) {$/;"	f	class:DistIntersectorFRG
getSurfaceID	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int getSurfaceID(int k) {$/;"	f	class:DistIntersectorPhysBAM
getSurfaceID	LevelSet/MultiGridLevelSetStructure.h	/^    int getSurfaceID(int k) { return parent->getSurfaceID(k); }$/;"	f	class:DistMultiGridLevelSetStructure
getSurfaceNodes	SubDomainCore.C	/^void SubDomain::getSurfaceNodes(Aerof_unordered_set<int>::type& boundaryNodes) const {$/;"	f	class:SubDomain
getSurfaceNorm	IntersectorFRG/IntersectorFRG.h	/^    const Vec3D &getSurfaceNorm(int i) const {return triNorms[i]; }$/;"	f	class:DistIntersectorFRG
getSurfaceNorm	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    const Vec3D &getSurfaceNorm(int i) const {return triNorms[i]; }$/;"	f	class:DistIntersectorPhysBAM
getSwept	LevelSet/LevelSetStructure.h	/^    void getSwept(DistVec<int>& swept){$/;"	f	class:DistLevelSetStructure
getTX	NodalGrad.h	/^  Vec<Scalar> &getTX() const { return dTdx; }$/;"	f	class:NodalGrad
getTY	NodalGrad.h	/^  Vec<Scalar> &getTY() const { return dTdy; }$/;"	f	class:NodalGrad
getTZ	NodalGrad.h	/^  Vec<Scalar> &getTZ() const { return dTdz; }$/;"	f	class:NodalGrad
getTagName	MeshMotionHandlerCore.C	/^const char* RigidMeshMotionHandler::getTagName()$/;"	f	class:RigidMeshMotionHandler
getTagValue	MeshMotionHandlerCore.C	/^double RigidMeshMotionHandler::getTagValue(double t)$/;"	f	class:RigidMeshMotionHandler
getTargetData	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::getTargetData() $/;"	f	class:EmbeddedStructure
getTauN	TimeData.h	/^  double getTauN() const { return tau_n; }$/;"	f	class:TimeData
getTemperature	MatchNodeCore.C	/^double MatchNodeSet::getTemperature(int algNum, double dt, double scale, $/;"	f	class:MatchNodeSet
getTemperature	StructExc.C	/^void StructExc::getTemperature(DistVec<double>& Temp)$/;"	f	class:StructExc
getTemperatureAndGradient	ElemTetCore.C	/^void ElemTet::getTemperatureAndGradient(double *v[4], double dp1dxj[4][3], double R,$/;"	f	class:ElemTet
getTemperatureVector	DistBcData.h	/^  DistVec<double> &getTemperatureVector() { return Temp; }$/;"	f	class:DistBcData
getTets	InletNode.h	/^  	int *getTets()     { return tets; }$/;"	f	class:InletNode
getTets2	InletNode.h	/^  	int *getTets2()     { return tets2; }$/;"	f	class:InletNode
getThermalCondFcn	NavierStokesTerm.h	/^  ThermalCondFcn* getThermalCondFcn() const { return thermalCondFcn; }$/;"	f	class:NavierStokesTerm
getThreshold	RecFcnDesc.h	/^  virtual double getThreshold() { return threshold; }$/;"	f	class:RecFcnLtdSensor
getTime	DistTimeState.h	/^  double getTime()  { return data->dt_n; }$/;"	f	class:DistTimeState
getTime	Timer.C	/^double Timer::getTime()$/;"	f	class:Timer
getTimeIt	Domain.h	/^  int *getTimeIt() { return &outputTimeIt; }$/;"	f	class:Domain
getTimeIt	MeshMotionSolver.h	/^  int *getTimeIt() { return domain->getTimeIt(); }$/;"	f	class:TetMeshMotionSolver
getTimeIt	TsDesc.h	/^  int *getTimeIt() { return domain->getTimeIt(); }$/;"	f	class:TsDesc
getTimeLowMachPrec	DistTimeState.h	/^  TimeLowMachPrec& getTimeLowMachPrec() { return tprec; }$/;"	f	class:DistTimeState
getTimeNorm	TimeState.h	/^  double getTimeNorm()  {  return dt.norm(); }$/;"	f	class:TimeState
getTimeState	MultiGridOperator.h	/^  DistTimeState<dim>& getTimeState() const { return *timeState; } $/;"	f	class:MultiGridOperator
getTimeStep	StructExc.h	/^  double getTimeStep() const { return dt; }$/;"	f	class:StructExc
getTimeSyncro	Timer.C	/^double Timer::getTimeSyncro()$/;"	f	class:Timer
getTimer	Domain.h	/^  Timer *getTimer() const { return timer; }$/;"	f	class:Domain
getTotalMeshVolume	MultiGridLevel.h	/^    double getTotalMeshVolume() { return parent ? parent->getTotalMeshVolume() : total_mesh_volume;  }$/;"	f	class:MultiGridLevel
getTransposeDerivativeOfGradP	Domain.C	/^void Domain::getTransposeDerivativeOfGradP(RectangularSparseMat<double,dim,3> **dGradPdddx,$/;"	f	class:Domain
getTransposeDerivativeOfGradP	SubDomain.C	/^void SubDomain::getTransposeDerivativeOfGradP(RectangularSparseMat<double,dim,3> &dGradPdddx, $/;"	f	class:SubDomain
getTriangleList	TriangulatedSurface.h	/^  Vec3D (*getTriangleList() const)[3] {return triangleList; }$/;"	f	class:TriangulatedSurface
getTriangleNodeNum	TriangulatedSurface.h	/^  int (*getTriangleNodeNum() const)[3] {return triangleNodeNum; }$/;"	f	class:TriangulatedSurface
getTriangulatedSurfaceFromFace	SubDomainCore.C	/^void SubDomain::getTriangulatedSurfaceFromFace( SVec<double,3> &X, TriangulatedSurface *triaSurf2 )$/;"	f	class:SubDomain
getTriangulatedSurfaceFromFace	SubDomainCore.C	/^void SubDomain::getTriangulatedSurfaceFromFace( TriangulatedSurface *triaSurf2 )$/;"	f	class:SubDomain
getTsParams	MeshMotionSolver.h	/^  TsParameters* getTsParams() { return NULL; }$/;"	f	class:TetMeshMotionSolver
getTsParams	TsDesc.h	/^  TsParameters* getTsParams() {return data;}$/;"	f	class:TsDesc
getTurbulentDissipationRate	VarFcn.h	/^  double getTurbulentDissipationRate(double *V, int tag=0) const{check(tag); return varFcn[tag]->getTurbulentDissipationRate(V); }$/;"	f	class:VarFcn
getTurbulentDissipationRate	VarFcnBase.h	/^  virtual double getTurbulentDissipationRate(double *V) const{ return V[6]; }$/;"	f	class:VarFcnBase
getTurbulentDissipationRate	VarFcnSGKE.h	/^  double getTurbulentDissipationRate(double *V)  const {return V[6];}$/;"	f	class:VarFcnSGKE
getTurbulentKineticEnergy	VarFcn.h	/^  double getTurbulentKineticEnergy(double *V, int tag=0)   const{check(tag); return varFcn[tag]->getTurbulentKineticEnergy(V); }$/;"	f	class:VarFcn
getTurbulentKineticEnergy	VarFcnBase.h	/^  virtual double getTurbulentKineticEnergy(double *V)   const{ return V[5]; }$/;"	f	class:VarFcnBase
getTurbulentKineticEnergy	VarFcnSGKE.h	/^  double getTurbulentKineticEnergy(double *V)    const {return V[5];}$/;"	f	class:VarFcnSGKE
getTurbulentNuTilde	VarFcn.h	/^  double getTurbulentNuTilde(double *V, int tag=0)         const{check(tag); return varFcn[tag]->getTurbulentNuTilde(V); }$/;"	f	class:VarFcn
getTurbulentNuTilde	VarFcnBase.h	/^  virtual double getTurbulentNuTilde(double *V)         const{ return V[5]; }$/;"	f	class:VarFcnBase
getTurbulentNuTilde	VarFcnSGSA.h	/^  double getTurbulentNuTilde(double *V)       const {return V[5];}$/;"	f	class:VarFcnSGSA
getTwall	IntersectorFRG/IntersectorFRG.h	/^	 bool getTwall(double &Tw)$/;"	f	class:IntersectorFRG
getTwall	IntersectorPhysBAM/IntersectorPhysBAM.h	/^	 bool getTwall(double &Tw)$/;"	f	class:IntersectorPhysBAM
getTwall	LevelSet/MultiGridLevelSetStructure.h	/^	 bool getTwall(double &Tw) {exit(-1);}$/;"	f	class:MultiGridLevelSetStructure
getType	VarFcn.h	/^  int getType(int tag=0) const{ $/;"	f	class:VarFcn
getType	VarFcnBase.h	/^  virtual int getType() const{ return type; }$/;"	f	class:VarFcnBase
getUfarin	DistBcData.h	/^  DistSVec<double,dim> &getUfarin() { return Ufarin; }$/;"	f	class:DistBcData
getUfarout	DistBcData.h	/^  DistSVec<double,dim> &getUfarout() { return Ufarout; }$/;"	f	class:DistBcData
getUn	DistTimeState.h	/^  DistSVec<double,dim> &getUn() const { return *Un; }$/;"	f	class:DistTimeState
getUnburnedEOS	ProgrammedBurnCore.C	/^int ProgrammedBurn::getUnburnedEOS(int tag) const {$/;"	f	class:ProgrammedBurn
getUnm1	DistTimeState.h	/^  DistSVec<double,dim> &getUnm1() const { return *Unm1; }$/;"	f	class:DistTimeState
getUporouswall	DistBcData.h	/^  DistSVec<double,dim> &getUporouswall() { return Uporouswall; }$/;"	f	class:DistBcData
getV4FromTemperature	VarFcn.h	/^  void getV4FromTemperature(double *V, double T, int tag=0) const{check(tag); varFcn[tag]->getV4FromTemperature(V,T); }$/;"	f	class:VarFcn
getV4FromTemperature	VarFcnBase.h	/^  virtual void getV4FromTemperature(double *V, double T) const{$/;"	f	class:VarFcnBase
getV4FromTemperature	VarFcnJwl.h	/^  void getV4FromTemperature(double *V, double T) const {$/;"	f	class:VarFcnJwl
getV4FromTemperature	VarFcnSGEuler.h	/^  void getV4FromTemperature(double *V, double T) const {$/;"	f	class:VarFcnSGEuler
getV4FromTemperature	VarFcnSGKE.h	/^  void getV4FromTemperature(double *V, double T) const {$/;"	f	class:VarFcnSGKE
getV4FromTemperature	VarFcnSGSA.h	/^  void getV4FromTemperature(double *V, double T) const {$/;"	f	class:VarFcnSGSA
getV4FromTemperature	VarFcnTait.h	/^  void getV4FromTemperature(double *V, double T) const {$/;"	f	class:VarFcnTait
getV6Data	HigherOrderFSI.h	/^   V6NodeData (*getV6Data() const) [2] { return v6data; }$/;"	f	class:HigherOrderFSI
getV6NodeData	EdgeGrad.h	/^  V6NodeDataOf2& getV6NodeData()  { return v6data; }$/;"	f	class:EdgeGrad
getVarFcn	FluxFcn.h	/^  VarFcn *getVarFcn() { return vf_; }$/;"	f	class:FluxFcn
getVarFcn	SpaceOperator.h	/^  VarFcn* getVarFcn() { return varFcn; }$/;"	f	class:SpaceOperator
getVarFcnBase	FluxFcnBase.h	/^  VarFcnBase* getVarFcnBase() const { return vf; }$/;"	f	class:FluxFcnBase
getVarFcnBase	VarFcn.h	/^  VarFcnBase* getVarFcnBase(int tag = 0) const { check(tag); return varFcn[tag]; }$/;"	f	class:VarFcn
getVec3DPat	Domain.h	/^  CommPattern<double> *getVec3DPat() const { return vec3DPat; }$/;"	f	class:Domain
getVecInfo	MeshMotionSolver.h	/^  DistInfo &getVecInfo() const { return domain->getNodeDistInfo(); }$/;"	f	class:TetMeshMotionSolver
getVecInfo	TsDesc.h	/^  DistInfo &getVecInfo() const { return domain->getNodeDistInfo(); }$/;"	f	class:TsDesc
getVecPat	Domain.h	/^  CommPattern<double> *getVecPat() const { return vecPat; }$/;"	f	class:Domain
getVelocity	VarFcn.h	/^  Vec3D  getVelocity(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->getVelocity(V); }$/;"	f	class:VarFcn
getVelocity	VarFcnBase.h	/^  virtual Vec3D  getVelocity(double *V)  const{ return Vec3D(V[1], V[2], V[3]); }$/;"	f	class:VarFcnBase
getVelocityAndGradient	ElemTetCore.C	/^void ElemTet::getVelocityAndGradient(double *v[4], double dp1dxj[4][3],$/;"	f	class:ElemTet
getVelocityNorm	VarFcn.h	/^  double getVelocityNorm(double *V, int tag=0)    const{ check(tag); return varFcn[tag]->getVelocityNorm(V); }$/;"	f	class:VarFcn
getVelocityNorm	VarFcnBase.h	/^  virtual double getVelocityNorm(double *V)    const{ return sqrt(getVelocitySquare(V)); }$/;"	f	class:VarFcnBase
getVelocitySquare	VarFcn.h	/^  double getVelocitySquare(double *V, int tag=0)  const{ check(tag); return varFcn[tag]->getVelocitySquare(V); }$/;"	f	class:VarFcn
getVelocitySquare	VarFcnBase.h	/^  virtual double getVelocitySquare(double *V)  const{ return V[1]*V[1]+V[2]*V[2]+V[3]*V[3]; }$/;"	f	class:VarFcnBase
getVelocityVector	DistBcData.h	/^  DistSVec<double,3> &getVelocityVector() { return Xdot; }$/;"	f	class:DistBcData
getVelocityX	VarFcn.h	/^  double getVelocityX(double *V, int tag=0) const{ check(tag); return varFcn[tag]->getVelocityX(V); }$/;"	f	class:VarFcn
getVelocityX	VarFcnBase.h	/^  virtual double getVelocityX(double *V) const{ return V[1]; }$/;"	f	class:VarFcnBase
getVelocityY	VarFcn.h	/^  double getVelocityY(double *V, int tag=0) const{ check(tag); return varFcn[tag]->getVelocityY(V); }$/;"	f	class:VarFcn
getVelocityY	VarFcnBase.h	/^  virtual double getVelocityY(double *V) const{ return V[2]; }$/;"	f	class:VarFcnBase
getVelocityZ	VarFcn.h	/^  double getVelocityZ(double *V, int tag=0) const{ check(tag); return varFcn[tag]->getVelocityZ(V); }$/;"	f	class:VarFcn
getVelocityZ	VarFcnBase.h	/^  virtual double getVelocityZ(double *V) const{ return V[3]; }$/;"	f	class:VarFcnBase
getVersion	BinFileHandler.h	/^  double getVersion() const { return version; }$/;"	f	class:BinFileHandler
getVertexLocations	TriangulatedInterface.C	/^double* TriangulatedInterface::getVertexLocations() {$/;"	f	class:TriangulatedInterface
getViscoFcn	NavierStokesTerm.h	/^  ViscoFcn * getViscoFcn() const { return viscoFcn; }$/;"	f	class:NavierStokesTerm
getViscousRatio	LowMachPrec.h	/^  virtual double getViscousRatio() const   { return betaviscous;  }$/;"	f	class:LowMachPrec
getVolPat	Domain.h	/^  CommPattern<double> *getVolPat() const { return volPat; }$/;"	f	class:Domain
getVolume	MacroCell.h	/^  double getVolume() { return volume; }$/;"	f	class:MacroCell
getVolume	MacroCell.h	/^  double getVolume(int i) { return macroCells[i]->getVolume(); }$/;"	f	class:MacroCellSet
getVolumeID	Elem.h	/^  int getVolumeID() { return volume_id; }$/;"	f	class:Elem
getWeightPat	Domain.h	/^  CommPattern<double> *getWeightPat() const { return weightPat; }$/;"	f	class:Domain
getWeightPhaseChangePat	Domain.h	/^  CommPattern<double> *getWeightPhaseChangePat() const {return weightPhaseChangePat; }$/;"	f	class:Domain
getWii	NodalGrad.h	/^  SVec<double,3> getWii() const { return *wii; }$/;"	f	class:NodalGrad
getWij	NodalGrad.h	/^  SVec<double,3> getWij() const { return *wij; }$/;"	f	class:NodalGrad
getWji	NodalGrad.h	/^  SVec<double,3> getWji() const { return *wji; }$/;"	f	class:NodalGrad
getWrapper_Scalar_dim_neq	ElemTet.h	/^  void *getWrapper_Scalar_dim_neq(GenElemHelper_Scalar_dim_neq *h, $/;"	f	class:ElemTet
getWrapper_Scalar_dim_neq	FaceTria.h	/^  void *getWrapper_Scalar_dim_neq(GenFaceHelper_Scalar_dim_neq *h, $/;"	f	class:FaceTria
getWrapper_dim	ElemTet.h	/^  void *getWrapper_dim(GenElemHelper_dim *h, $/;"	f	class:ElemTet
getWrapper_dim	FaceTria.h	/^  void *getWrapper_dim(GenFaceHelper_dim *h, $/;"	f	class:FaceTria
getWrapper_dim_obj	ElemTet.h	/^  void *getWrapper_dim_obj(GenElemHelper_dim_obj *h, $/;"	f	class:ElemTet
getX	DistNodalGrad.h	/^  DistSVec<Scalar,dim>& getX() { return *ddx; }$/;"	f	class:DistNodalGrad
getX	NodalGrad.h	/^  SVec<Scalar,dim> &getX() const { return ddx; }$/;"	f	class:NodalGrad
getXderivative	DistNodalGrad.h	/^  DistSVec<Scalar,dim> &getXderivative() const { return *dddx; }$/;"	f	class:DistNodalGrad
getXderivative	NodalGrad.h	/^  SVec<Scalar,dim> &getXderivative() const { return *dddx; }$/;"	f	class:NodalGrad
getXn	DistGeoState.h	/^  DistSVec<double,3> &getXn() const { return *Xn; }$/;"	f	class:DistGeoState
getXn	MultiGridLevel.h	/^    DistSVec<double,3>& getXn() const { return myGeoState->getXn(); }$/;"	f	class:MultiGridLevel
getY	DistNodalGrad.h	/^  DistSVec<Scalar,dim>& getY() { return *ddy; }$/;"	f	class:DistNodalGrad
getY	NodalGrad.h	/^  SVec<Scalar,dim> &getY() const { return ddy; }$/;"	f	class:NodalGrad
getYderivative	DistNodalGrad.h	/^  DistSVec<Scalar,dim> &getYderivative() const { return *dddy; }$/;"	f	class:DistNodalGrad
getYderivative	NodalGrad.h	/^  SVec<Scalar,dim> &getYderivative() const { return *dddy; }$/;"	f	class:NodalGrad
getZ	DistNodalGrad.h	/^  DistSVec<Scalar,dim>& getZ() { return *ddz; }$/;"	f	class:DistNodalGrad
getZ	NodalGrad.h	/^  SVec<Scalar,dim> &getZ() const { return ddz; }$/;"	f	class:NodalGrad
getZderivative	DistNodalGrad.h	/^  DistSVec<Scalar,dim> &getZderivative() const { return *dddz; }$/;"	f	class:DistNodalGrad
getZderivative	NodalGrad.h	/^  SVec<Scalar,dim> &getZderivative() const { return *dddz; }$/;"	f	class:NodalGrad
get_col_slice	AlternatingLeastSquare/als_util.cpp	/^double *get_col_slice(double *mem, int M, int N, int ColIndex,$/;"	f
get_dWBar_dt	TimeState.C	/^void TimeState<dim>::get_dWBar_dt(bool *nodeFlag, GeoState &geoState,$/;"	f	class:TimeState
get_dW_dt	DistTimeState.C	/^void DistTimeState<dim>::get_dW_dt(bool doInitialTasks,$/;"	f	class:DistTimeState
get_dW_dt	TimeState.C	/^void TimeState<dim>::get_dW_dt(bool *nodeFlag, GeoState &geoState,$/;"	f	class:TimeState
get_ooreynolds_mu	NavierStokesTerm.h	/^  double get_ooreynolds_mu() const { return ooreynolds_mu; }$/;"	f	class:NavierStokesTerm
get_row_slice	AlternatingLeastSquare/als_util.cpp	/^double *get_row_slice(double *mem, int M, int N, int RowIndex,$/;"	f
getd2wall	DistGeoState.h	/^  DistVec<double> *getd2wall() const { return d2wall; }$/;"	f	class:DistGeoState
getdBeta	LowMachPrec.h	/^  double getdBeta(double locMach, double dLocMach, bool checktac = false) const {$/;"	f	class:TimeLowMachPrec
getdEdgeNormal	DistGeoState.h	/^  DistVec<Vec3D> &getdEdgeNormal() const { return *dEdgeNorm; }$/;"	f	class:DistGeoState
getdEdgeNormal	GeoState.h	/^  Vec<Vec3D> &getdEdgeNormal() const { return *dEdgeNorm; }$/;"	f	class:GeoState
getdEdgeNormalVel	DistGeoState.h	/^  DistVec<double> &getdEdgeNormalVel() const { return *dEdgeNormVel; }$/;"	f	class:DistGeoState
getdEdgeNormalVel	GeoState.h	/^  Vec<double> &getdEdgeNormalVel() const { return *dEdgeNormVel; }$/;"	f	class:GeoState
getdFaceNormal	GeoState.h	/^  Vec<Vec3D> &getdFaceNormal() const { return *dFaceNorm; }$/;"	f	class:GeoState
getdFaceNormalVel	GeoState.h	/^  Vec<double> &getdFaceNormalVel() const { return *dFaceNormVel; }$/;"	f	class:GeoState
getdFaceStateVector	BcData.h	/^  SVec<double,dim> &getdFaceStateVector() const { return *dUface; }$/;"	f	class:BcData
getdFaceStateVectorSA	BcData.h	/^  SVec<double,dim> &getdFaceStateVectorSA() const { return *dUfaceSA; }$/;"	f	class:BcData
getdInletBoundaryVector	BcData.h	/^  SVec<double,dim> &getdInletBoundaryVector() const { return *dUfarin; }$/;"	f	class:BcData
getdInletNodeStateVector	BcData.h	/^  SVec<double,dim> &getdInletNodeStateVector() const { return *dUinletnode; }$/;"	f	class:BcData
getdInletOutletVector	BcData.h	/^  SVec<double,dim> &getdInletOutletVector() const { return *dUfarout; }$/;"	f	class:BcData
getdNodeStateVector	BcData.h	/^  SVec<double,dim> &getdNodeStateVector() const { return *dUnode; }$/;"	f	class:BcData
getdNodeStateVectorSA	BcData.h	/^  SVec<double,dim> &getdNodeStateVectorSA() const { return *dUnodeSA; }$/;"	f	class:BcData
getdNormal	FaceTriaCore.C	/^Vec3D FaceTria::getdNormal(Vec<Vec3D> &facedNorm) {$/;"	f	class:FaceTria
getdNormal	FaceTriaCore.C	/^Vec3D FaceTria::getdNormal(Vec<Vec3D> &facedNorm, int i) {$/;"	f	class:FaceTria
getdNormalVel	FaceTriaCore.C	/^double FaceTria::getdNormalVel(Vec<double> &facedNormVel) {$/;"	f	class:FaceTria
getdNormalVel	FaceTriaCore.C	/^double FaceTria::getdNormalVel(Vec<double> &facedNormVel, int i) {$/;"	f	class:FaceTria
getdRdXop	MatVecProd.h	/^  dRdXoperators<dim> *getdRdXop() { return 0; }$/;"	f	class:MatVecProdH1
getdRdXop	MatVecProd.h	/^  dRdXoperators<dim> *getdRdXop() { return 0; }$/;"	f	class:MatVecProdH2
getdRdXop	MatVecProd.h	/^  dRdXoperators<dim> *getdRdXop() { return 0;}$/;"	f	class:MatVecProdFD
getdRdXop	MatVecProd.h	/^  dRdXoperators<dim> *getdRdXop() {return dRdXop;}$/;"	f	class:MatVecProd_dRdX
getdXdSb	EmbeddedFluidShapeOptimizationHandler.C	/^bool EmbeddedFluidShapeOptimizationHandler<dim>::getdXdSb(int istep){$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
getderivativeOfForcesAndMoments	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::getderivativeOfForcesAndMoments(map<int,int> & surfOutMap, $/;"	f	class:EmbeddedTsDesc
getderivativeOfForcesAndMoments	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::getderivativeOfForcesAndMoments(map<int,int> & surfOutMap, $/;"	f	class:MultiPhysicsTsDesc
getdpdnSHseries	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::getdpdnSHseries$/;"	f	class:KirchhoffIntegrator
getrf	arpack++/include/lapackc.h	/^inline void getrf(const ARint &m, const ARint &n, arcomplex<double> A[], $/;"	f
getrf	arpack++/include/lapackc.h	/^inline void getrf(const ARint &m, const ARint &n, arcomplex<float> A[], $/;"	f
getrf	arpack++/include/lapackc.h	/^inline void getrf(const ARint &m, const ARint &n, double A[], $/;"	f
getrf	arpack++/include/lapackc.h	/^inline void getrf(const ARint &m, const ARint &n, float A[], $/;"	f
getrs	arpack++/include/lapackc.h	/^inline void getrs(const char* trans, const ARint &n, const ARint &nrhs,$/;"	f
ghost	DistEmbeddedVector.h	/^    Scalar ghost(int iSub,int i,int k) const { return a*x.ghost(iSub,i,k); }$/;"	f	class:EmbeddedScaleExpr
ghost	DistEmbeddedVector.h	/^    Scalar ghost(int iSub,int i,int k) const { return x.ghost(iSub,i,k) + y.ghost(iSub,i,k); }$/;"	f	class:EmbeddedSumExpr
ghost	DistEmbeddedVector.h	/^    Scalar ghost(int iSub,int i,int k) const { return x.ghost(iSub,i,k) - y.ghost(iSub,i,k); }$/;"	f	class:EmbeddedDiffExpr
ghost	DistEmbeddedVector.h	/^    Scalar ghost(int iSub,int i,int k) const { return x.ghost(iSub,i,k); }$/;"	f	class:EmbeddedExpr
ghost	DistEmbeddedVector.h	/^  DistSVec<Scalar,dim>& ghost() { return ghostVec; }$/;"	f	class:DistEmbeddedVec
ghost	DistEmbeddedVector.h	/^  Scalar ghost(int iSub,int i,int k) const { return ghostVec.subData(iSub)[i][k]; }$/;"	f	class:DistEmbeddedVec
ghostAuxilliaryRows	MvpMatrix.h	/^  AuxilliaryRows ghostAuxilliaryRows;$/;"	m	class:MvpMat
ghostGhostAuxilliaryRows	MvpMatrix.h	/^  AuxilliaryRows ghostGhostAuxilliaryRows;$/;"	m	class:MvpMat
ghostId	VarFcn.h	/^  int ghostId;$/;"	m	class:VarFcn
ghostNodes	DistEmbeddedVector.h	/^  std::set<int>* ghostNodes;$/;"	m	class:DistEmbeddedVec
ghostPhase	VarFcn.h	/^  int ghostPhase;$/;"	m	class:VarFcn
ghostPoints	EmbeddedTsDesc.h	/^  DistVec<GhostPoint<dim>*> *ghostPoints;$/;"	m	class:EmbeddedTsDesc
ghostPoints	MatVecProd.h	/^    DistVec<GhostPoint<dim>*>* ghostPoints;$/;"	m	struct:MatVecProd::_fsi
ghostPoints	MatVecProd.h	/^    DistVec<GhostPoint<dim>*>* ghostPoints;$/;"	m	struct:MatVecProdMultiPhase::_fsi
ghostPoints	MultiPhysicsTsDesc.h	/^  DistVec<GhostPoint<dim>*> *ghostPoints;$/;"	m	class:MultiPhysicsTsDesc
ghostTag	GhostPoint.h	/^  int ghostTag; \/\/ We store here the tag of the surrounding nodes. All the tags of the neighbours $/;"	m	class:GhostPoint
ghostTag2	GhostPoint.h	/^  int ghostTag2;$/;"	m	class:GhostPoint
ghostVec	DistEmbeddedVector.h	/^  DistSVec<Scalar,dim> realVec,ghostVec;$/;"	m	class:DistEmbeddedVec
glLeft	SubDomain.h	/^  int glLeft, glRight, edgeNum, sign;$/;"	m	struct:EdgeDef
glRight	SubDomain.h	/^  int glLeft, glRight, edgeNum, sign;$/;"	m	struct:EdgeDef
glSubToCPU	Communicator.h	/^  int *glSubToCPU;$/;"	m	class:SubDTopo
glSubToLocal	Communicator.h	/^  int *glSubToLocal;$/;"	m	class:SubDTopo
globCom	Domain.h	/^  Communicator *globCom;$/;"	m	class:Domain
globComp	KDTree.h	/^  static int globComp(const void* a, const void* b) {$/;"	f	class:KDTree
globIndex	IntersectorFRG/IntersectorFRG.h	/^    int globIndex;$/;"	m	class:IntersectorFRG
globIndex	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int locIndex,globIndex;$/;"	m	class:IntersectorPhysBAM
globIt	EmbeddedTsDesc.h	/^  int globIt;         \/\/<! current global(i.e. structure) iteration$/;"	m	class:EmbeddedTsDesc
globIt	MultiPhysicsTsDesc.h	/^  int globIt;         \/\/<! current global(i.e. structure) iteration$/;"	m	class:MultiPhysicsTsDesc
globPhysInterface	IntersectorFRG/IntersectorFRG.h	/^    PhysBAMInterface<double> *globPhysInterface;$/;"	m	class:DistIntersectorFRG
globSubNum	SubDomain.h	/^  int globSubNum;$/;"	m	class:SubDomain
globalColIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::globalColIdx(int localColIdx) const {$/;"	f	class:DistLeastSquareSolver
globalCom	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
globalErrors	ErrorHandler.h	/^  int globalErrors[SIZE];$/;"	m	struct:ErrorHandler
globalFaceNormals	MultiGridLevel.h	/^    DistSVec<double,3>* globalFaceNormals;$/;"	m	class:MultiGridLevel
globalIt	MultiGridCoupledTsDesc.h	/^  int globalIt;$/;"	m	class:MultiGridCoupledTsDesc
globalIt	MultiGridEmbeddedTsDesc.h	/^  int globalIt;$/;"	m	class:MultiGridEmbeddedTsDesc
globalIt	MultiGridSegTsDesc.h	/^  int globalIt;$/;"	m	class:MultiGridSegTsDesc
globalMax	Communicator.C	/^void Communicator::globalMax(int len, Scalar *x)$/;"	f	class:Communicator
globalMaxRoot	Communicator.C	/^void Communicator::globalMaxRoot(int len, Scalar *x)$/;"	f	class:Communicator
globalMin	Communicator.C	/^void Communicator::globalMin(int len, Scalar *x)$/;"	f	class:Communicator
globalMinRoot	Communicator.C	/^void Communicator::globalMinRoot(int len, Scalar *x)$/;"	f	class:Communicator
globalNodeToCpuMap	GappyPreprocessing.h	/^  boost::unordered_map<int, int > globalNodeToCpuMap;	\/\/ key: global node #, values: x, y, z$/;"	m	class:GappyPreprocessing
globalNodeToLocSubDomainsMap	GappyPreprocessing.h	/^  boost::unordered_map<int, int > globalNodeToLocSubDomainsMap;	\/\/ key: global node #, values: x, y, z$/;"	m	class:GappyPreprocessing
globalNodeToLocalNodesMap	GappyPreprocessing.h	/^  boost::unordered_map<int, int > globalNodeToLocalNodesMap;	\/\/ key: global node #, values: x, y, z$/;"	m	class:GappyPreprocessing
globalNodes	GappyPreprocessing.h	/^  std::vector <int> *globalNodes;	\/\/ globalNodes[iSampleNode][iNode] is the global node number of the iNode in the iSampleNode island $/;"	m	class:GappyPreprocessing
globalOp	Communicator.C	/^void Communicator::globalOp(int len, Scalar *x, MPI_Op op)$/;"	f	class:Communicator
globalOpRoot	Communicator.C	/^void Communicator::globalOpRoot(int len, Scalar *x, MPI_Op op)$/;"	f	class:Communicator
globalRhsRankIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::globalRhsRankIdx(int localRankIdx) const {$/;"	f	class:DistLeastSquareSolver
globalRhsRowIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::globalRhsRowIdx(int localRowIdx) const {$/;"	f	class:DistLeastSquareSolver
globalRowIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::globalRowIdx(int localRowIdx) const {$/;"	f	class:DistLeastSquareSolver
globalSampleNodeRankMap	GappyPreprocessing.h	/^	boost::unordered_map<int, int > globalSampleNodeRankMap, reducedSampleNodeRankMap;$/;"	m	class:GappyPreprocessing
globalSampleNodes	GappyPreprocessing.h	/^	std::vector<int> globalSampleNodes, reducedSampleNodes;$/;"	m	class:GappyPreprocessing
globalSampleNodesForCluster	GappyPreprocessing.h	/^  std::vector<std::vector<int> > globalSampleNodesForCluster; \/\/ stores sampled nodes for each of the clusters   $/;"	m	class:GappyPreprocessing
globalSampleNodesUnion	GappyPreprocessing.h	/^  std::vector<int> globalSampleNodesUnion; \/\/ union of sample nodes from each cluster (as a vector)$/;"	m	class:GappyPreprocessing
globalSampleNodesUnionForApproxMetricState	GappyPreprocessing.h	/^  std::vector<int> globalSampleNodesUnionForApproxMetricState; \/\/ union of sample nodes from each cluster for approx metric (as a vector)$/;"	m	class:GappyPreprocessing
globalSampleNodesUnionSet	GappyPreprocessing.h	/^  std::set<int> globalSampleNodesUnionSet; \/\/ union of sample nodes from each cluster$/;"	m	class:GappyPreprocessing
globalSampleNodesUnionSetForApproxMetricState	GappyPreprocessing.h	/^  std::set<int> globalSampleNodesUnionSetForApproxMetricState; \/\/ union of sample nodes from each cluster for approximated metric$/;"	m	class:GappyPreprocessing
globalSum	Communicator.C	/^void Communicator::globalSum(int len, Scalar *x)$/;"	f	class:Communicator
globalSumRoot	Communicator.C	/^void Communicator::globalSumRoot(int len, Scalar *x)$/;"	f	class:Communicator
global_error	AlternatingLeastSquare/als_lapack.h	/^    double global_error;$/;"	m	class:AlternatingLeastSquare
global_mat_data	AlternatingLeastSquare/als_lapack.h	/^    double *global_mat_data;$/;"	m	class:AlternatingLeastSquare
global_vec_data	AlternatingLeastSquare/als_lapack.h	/^    double *global_vec_data;$/;"	m	class:AlternatingLeastSquare
globalmatrices	f77src/globalmatrices.f	/^      subroutine globalmatrices(/;"	s
gotNewCracking	FSI/CrackingSurface.h	/^  bool gotNewCracking;$/;"	m	class:CrackingSurface
gotNewCracking	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    bool gotNewCracking;$/;"	m	class:DistIntersectorPhysBAM
gradP	SubDomain.h	/^  double *gradP[3];$/;"	m	class:SubDomain
gradPhi	LevelSet/LevelSetStructure.h	/^  Vec3D gradPhi;$/;"	m	struct:LevelSetResult
gradPhi	OneDimensionalSolver.h	/^  SVec<double,1> gradPhi;$/;"	m	class:OneDimensional
gradV	OneDimensionalSolver.h	/^  SVec<double,5> gradV;$/;"	m	class:OneDimensional
gradient	IoData.h	/^  enum Gradient {LEAST_SQUARES = 0, GALERKIN = 1, NON_NODAL = 2} gradient;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::Gradient
gramSchmidt	IoData.h	/^  enum GramSchmidt {GRAMSCHMIDT_OFF = 0, GRAMSCHMIDT_ON = 1} gramSchmidt;$/;"	m	struct:NonlinearRomOnlineNonStateData	typeref:enum:NonlinearRomOnlineNonStateData::GramSchmidt
gramSchmidt	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
gravity	DistBcData.h	/^  double gravity; \/\/!< intensity of the gravity$/;"	m	class:DistBcData
gravity	Extrapolation.h	/^  double gravity;$/;"	m	class:Extrapolation
gravity	PostFcn.h	/^  double gravity;$/;"	m	class:PostFcnEuler
gravity	VarFcn.h	/^  double gravity[3];$/;"	m	class:VarFcn
gravityOn	DistBcData.h	/^  bool gravityOn; \/\/!< Whether gravity is activated or not.$/;"	m	class:DistBcData
gravity_norm	VarFcn.h	/^  double gravity_norm;$/;"	m	class:VarFcn
gravity_value	VarFcn.h	/^  double gravity_value() const { return gravity_norm; }$/;"	f	class:VarFcn
gravity_x	IoData.h	/^  double gravity_x, gravity_y, gravity_z;$/;"	m	struct:EquationsData
gravity_y	IoData.h	/^  double gravity_x, gravity_y, gravity_z;$/;"	m	struct:EquationsData
gravity_z	IoData.h	/^  double gravity_x, gravity_y, gravity_z;$/;"	m	struct:EquationsData
greedyData	IoData.h	/^                   JACOBIAN_ROB_GREEDY = 2, RESIDUAL_AND_JACOBIAN_ROBS_GREEDY = 3, SPECIFIED_SNAPS_GREEDY = 4} greedyData;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::greedyData
greedyData	IoData.h	/^  enum greedyData {UNSPECIFIED_GREEDY = -1, STATE_ROB_GREEDY = 0, RESIDUAL_ROB_GREEDY = 1,$/;"	g	struct:GappyConstructionData
greedyDataFile	IoData.h	/^  const char *greedyDataFile;$/;"	m	struct:InputData
greedyIteration	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::greedyIteration(int greedyIt) {$/;"	f	class:GappyPreprocessing
greedyLeastSquaresSolver	IoData.h	/^  enum GreedyLeastSquaresSolver {GREEDY_LS_PROBABILISTIC = 0, GREEDY_LS_SCALAPACK = 1, GREEDY_LS_LINPACK = 2} greedyLeastSquaresSolver;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::GreedyLeastSquaresSolver
grow_expansion	utils/Predicate.C	/^int grow_expansion(int elen, REAL *e, REAL b, REAL *h) \/* e and h can be the same. *\/$/;"	f
grow_expansion_zeroelim	utils/Predicate.C	/^int grow_expansion_zeroelim(int elen, REAL *e, REAL b, REAL *h)$/;"	f
growth	Malloc.C	/^int growth = 32*1024*1024;$/;"	v
gset	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^    T gset; \/\/ used internally by Get_Gaussian$/;"	m	class:PhysBAM::RANDOM_NUMBERS
gstrf	arpack++/include/superluc.h	/^inline void gstrf(char* refact, SuperMatrix* A, double diag_pivot_thresh,$/;"	f
gstrs	arpack++/include/superluc.h	/^inline void gstrs(char *trans, SuperMatrix *L, SuperMatrix *U,$/;"	f
gttrf	arpack++/include/lapackc.h	/^inline void gttrf(const ARint &n, arcomplex<double> dl[], arcomplex<double> d[],$/;"	f
gttrf	arpack++/include/lapackc.h	/^inline void gttrf(const ARint &n, arcomplex<float> dl[], arcomplex<float> d[],$/;"	f
gttrf	arpack++/include/lapackc.h	/^inline void gttrf(const ARint &n, double dl[], double d[], double du[],$/;"	f
gttrf	arpack++/include/lapackc.h	/^inline void gttrf(const ARint &n, float dl[], float d[], float du[],$/;"	f
gttrs	arpack++/include/lapackc.h	/^inline void gttrs(const char* trans, const ARint &n, const ARint &nrhs,$/;"	f
h	tools/alloca.cougar.c	/^    } h;$/;"	m	union:hdr	typeref:struct:hdr::__anon53	file:
h2Assembly	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
hForFastDistComp	NonlinearRom.h	/^  double ***hForFastDistComp;$/;"	m	class:NonlinearRom
half_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double half_pi=.5*pi;$/;"	m	namespace:PhysBAM
handledNodes	GappyPreprocessing.h	/^	int nRhsMax, nGreedyIt, handledNodes;$/;"	m	class:GappyPreprocessing
handledVectors	GappyPreprocessing.h	/^	int handledVectors [2];$/;"	m	class:GappyPreprocessing
hankel	KirchhoffIntegrator.C	/^std::complex<double> KirchhoffIntegrator::hankel$/;"	f	class:KirchhoffIntegrator
hankel_prime	KirchhoffIntegrator.C	/^std::complex<double> KirchhoffIntegrator::hankel_prime$/;"	f	class:KirchhoffIntegrator
hardyInterpolationLogMap	Domain.C	/^void Domain::hardyInterpolationLogMap(VecSet<DistSVec<double, dim> >**logMap, VecSet<DistSVec<double, dim> >&logMapInterp, int nData, int numPod, int iDataMin, FullM &B, FullM &b)$/;"	f	class:Domain
hardyInterpolationLogMap	SubDomain.C	/^void SubDomain::hardyInterpolationLogMap(SVec<double, dim> ***dataCoarse, SVec<double, dim> **dataInterp, int nData, int numPod, int iDataMin, FullM &B, FullM &b)$/;"	f	class:SubDomain
hasBeenFixed	IntersectorFRG/IntersectorFRG.C	/^  bool isConsistent, isPositive, hasBeenFixed;$/;"	m	class:ClosestTriangle	file:
hasCloseTriangle	IntersectorPhysBAM/IntersectorPhysBAM.C	/^int IntersectorPhysBAM::hasCloseTriangle(SVec<double,3> &X, SVec<double,3> &Xn, $/;"	f	class:IntersectorPhysBAM
hasCracked	FSI/CrackingSurface.cpp	/^bool CrackingSurface::hasCracked(int trId)$/;"	f	class:CrackingSurface
hasHHBoundaryTerm	DistEmbeddedVector.h	/^    bool hasHHBoundaryTerm() const { return x.hasHHBoundaryTerm(); }$/;"	f	class:EmbeddedDiffExpr
hasHHBoundaryTerm	DistEmbeddedVector.h	/^    bool hasHHBoundaryTerm() const { return x.hasHHBoundaryTerm(); }$/;"	f	class:EmbeddedExpr
hasHHBoundaryTerm	DistEmbeddedVector.h	/^    bool hasHHBoundaryTerm() const { return x.hasHHBoundaryTerm(); }$/;"	f	class:EmbeddedScaleExpr
hasHHBoundaryTerm	DistEmbeddedVector.h	/^    bool hasHHBoundaryTerm() const { return x.hasHHBoundaryTerm(); }$/;"	f	class:EmbeddedSumExpr
hasHHBoundaryTerm	DistEmbeddedVector.h	/^  bool hasHHBoundaryTerm() const { return hhBoundaryTerm; }$/;"	f	class:DistEmbeddedVec
hasIntersection	Edge.C	/^hasIntersection(Elem& elem, LevelSetStructure& LSS) { $/;"	f
hasLastPhaseChangeValue	HigherOrderFSI.C	/^bool HigherOrderFSI::hasLastPhaseChangeValue(int nodeId) $/;"	f	class:HigherOrderFSI
hasLastPhaseChangeValue	HigherOrderMultiFluid.C	/^bool HigherOrderMultiFluid::hasLastPhaseChangeValue(int nodeId) {$/;"	f	class:HigherOrderMultiFluid
hashtable	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE_ITERATOR.h	/^    T_HASHTABLE& hashtable;$/;"	m	class:PhysBAM::HASHTABLE_ITERATOR
hdr	tools/alloca.cougar.c	/^typedef union hdr$/;"	u	file:
header	tools/alloca.cougar.c	/^} header;$/;"	t	typeref:union:hdr	file:
headersize	BinFileHandler.h	/^  int headersize;$/;"	m	class:BinFileHandler
headsize	arpack++/include/ardfmat.h	/^  int      headsize;  \/\/ Number of lines in the heading part of the file$/;"	m	class:ARdfMatrix
heatCom	Domain.h	/^  Communicator *heatCom;$/;"	m	class:Domain
heatFluxResults	IoData.h	/^  enum HeatFluxResults {UNSPECIFIED_HF = -1, NO_HF = 0, YES_HF = 1} heatFluxResults;$/;"	m	struct:SurfaceData	typeref:enum:SurfaceData::HeatFluxResults
heatTimer	Domain.h	/^  Timer *heatTimer;$/;"	m	class:Domain
heatfluxes	IoData.h	/^  const char *heatfluxes;$/;"	m	struct:TransientData
heatfluxes	TsOutput.h	/^  char *heatfluxes;$/;"	m	class:TsOutput
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<1,T1,T2,T3> {static T1& helper(T1& a,T2& b,T3& c){return a;}};$/;"	f	struct:PhysBAM::choice_helper
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<2,T1,T2,T3> {static T2& helper(T1& a,T2& b,T3& c){return b;}};$/;"	f	struct:PhysBAM::choice_helper
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2,class T3> struct choice_helper<3,T1,T2,T3> {static T3& helper(T1& a,T2& b,T3& c){return c;}};$/;"	f	struct:PhysBAM::choice_helper
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2> struct choice_helper<1,T1,T2,void> {static T1& helper(T1& a,T2& b){return a;}};$/;"	f	struct:PhysBAM::choice_helper
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^template<class T1,class T2> struct choice_helper<2,T1,T2,void> {static T2& helper(T1& a,T2& b){return b;}};$/;"	f	struct:PhysBAM::choice_helper
helper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef typename se_t::template type<T> helper;$/;"	t	struct:PhysBAM::IS_ENUM_IMPL
hh	DistEmbeddedVector.h	/^    Scalar hh(int iSub, int i) const { return a*x.hh(iSub,i); }$/;"	f	class:EmbeddedScaleExpr
hh	DistEmbeddedVector.h	/^    Scalar hh(int iSub, int i) const { return x.hh(iSub,i)+y.hh(iSub,i); }$/;"	f	class:EmbeddedSumExpr
hh	DistEmbeddedVector.h	/^    Scalar hh(int iSub, int i) const { return x.hh(iSub,i)-y.hh(iSub,i); }$/;"	f	class:EmbeddedDiffExpr
hh	DistEmbeddedVector.h	/^    Scalar hh(int iSub, int i) const { return x.hh(iSub,i); }$/;"	f	class:EmbeddedExpr
hh	DistEmbeddedVector.h	/^  DistVec<Scalar>& hh() { return *hhBoundaryTerm; }$/;"	f	class:DistEmbeddedVec
hh	DistEmbeddedVector.h	/^  Scalar hh(int iSub, int i) const { return hhBoundaryTerm->subData(iSub)[i]; }$/;"	f	class:DistEmbeddedVec
hh	MvpMatrix.h	/^  Vec<Scalar>* hh;$/;"	m	class:MvpMat
hh1	ExplicitEmbeddedTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitEmbeddedTsDesc
hh1	ExplicitLevelSetTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitLevelSetTsDesc
hh1	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitMultiPhysicsTsDesc
hh2	ExplicitEmbeddedTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitEmbeddedTsDesc
hh2	ExplicitLevelSetTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitLevelSetTsDesc
hh2	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitMultiPhysicsTsDesc
hh3	ExplicitEmbeddedTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitEmbeddedTsDesc
hh3	ExplicitLevelSetTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitLevelSetTsDesc
hh3	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitMultiPhysicsTsDesc
hh4	ExplicitEmbeddedTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitEmbeddedTsDesc
hh4	ExplicitLevelSetTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitLevelSetTsDesc
hh4	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitMultiPhysicsTsDesc
hhBoundaryTerm	DistEmbeddedVector.h	/^  DistVec<Scalar>* hhBoundaryTerm;$/;"	m	class:DistEmbeddedVec
hhEps	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFD
hhEps	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFDMultiPhase
hhInfo	DistEmbeddedVector.h	/^    const DistInfo& hhInfo() const { return x.hhInfo(); }$/;"	f	class:EmbeddedDiffExpr
hhInfo	DistEmbeddedVector.h	/^    const DistInfo& hhInfo() const { return x.hhInfo(); }$/;"	f	class:EmbeddedExpr
hhInfo	DistEmbeddedVector.h	/^    const DistInfo& hhInfo() const { return x.hhInfo(); }$/;"	f	class:EmbeddedScaleExpr
hhInfo	DistEmbeddedVector.h	/^    const DistInfo& hhInfo() const { return x.hhInfo(); }$/;"	f	class:EmbeddedSumExpr
hhInfo	DistEmbeddedVector.h	/^  const DistInfo& hhInfo() const { return hhBoundaryTerm->info(); }$/;"	f	class:DistEmbeddedVec
hhRes	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFD
hhRes	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFDMultiPhase
hhResidual	ImplicitEmbeddedTsDesc.h	/^  DistVec<double>* hhResidual;$/;"	m	class:ImplicitEmbeddedTsDesc
hhResidual	ImplicitLevelSetTsDesc.h	/^  DistVec<double>* hhResidual;$/;"	m	class:ImplicitLevelSetTsDesc
hhResidual	ImplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hhResidual;$/;"	m	class:ImplicitMultiPhysicsTsDesc
hhVal	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFD
hhVal	MatVecProd.h	/^  DistVec<double>* hhRes,*hhEps,*hhVal;$/;"	m	class:MatVecProdFDMultiPhase
hhVal	MatVecProd.h	/^  DistVec<double>* hhVal;$/;"	m	class:MatVecProdH1
hhVal	MatVecProd.h	/^  DistVec<double>* hhVal;$/;"	m	class:MatVecProdH1MultiPhase
hhcoeffptr	FluxFcnBase.h	/^  double* hhcoeffptr;$/;"	m	class:FluxFcnBase
hhn	DistTimeState.h	/^  DistVec<double>* hhn,*hhnm1;$/;"	m	class:DistTimeState
hhn	TimeState.h	/^  Vec<double> *hhn;$/;"	m	class:TimeState
hhnm1	DistTimeState.h	/^  DistVec<double>* hhn,*hhnm1;$/;"	m	class:DistTimeState
hhnm1	TimeState.h	/^  Vec<double> *hhnm1;$/;"	m	class:TimeState
hhorig	ExplicitEmbeddedTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitEmbeddedTsDesc
hhorig	ExplicitLevelSetTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitLevelSetTsDesc
hhorig	ExplicitMultiPhysicsTsDesc.h	/^  DistVec<double>* hh1,*hh2,*hh3,*hh4,*hhorig;$/;"	m	class:ExplicitMultiPhysicsTsDesc
high_water	tools/alloca.cougar.c	/^    long high_water;		\/* Stack high-water mark.  *\/$/;"	m	struct:stk_stat	file:
higherOrderData	SpaceOperator.h	/^  } higherOrderData;$/;"	m	class:MultiPhaseSpaceOperator	typeref:struct:MultiPhaseSpaceOperator::__anon28
higherOrderFSI	Edge.h	/^  HigherOrderFSI* higherOrderFSI;$/;"	m	class:EdgeSet
higherOrderFSI	SubDomain.h	/^  HigherOrderFSI* higherOrderFSI;$/;"	m	class:SubDomain
higherOrderMF	Edge.h	/^  HigherOrderMultiFluid* higherOrderMF;$/;"	m	class:EdgeSet
higherOrderMF	Face.h	/^	class HigherOrderMultiFluid* higherOrderMF;$/;"	m	class:FaceSet	typeref:class:FaceSet::HigherOrderMultiFluid
higherOrderMF	Face.h	/^  class HigherOrderMultiFluid* higherOrderMF;$/;"	m	class:Face	typeref:class:Face::HigherOrderMultiFluid
higherOrderMF	SubDomain.h	/^  HigherOrderMultiFluid* higherOrderMF;$/;"	m	class:SubDomain
hits	tools/alloca.cougar.c	/^    long hits;			\/* Number of internal buffer hits.  *\/$/;"	m	struct:stk_stat	file:
hllcjacappr3Dgas	FluxFcnDescSG.C	/^void hllcjacappr3Dgas(int type, double gamma, VarFcnBase *vf, double vfgam, double vfp, $/;"	f
hllejacappr3Dgas	FluxFcnDescSG.C	/^void hllejacappr3Dgas(int type, double gamma, VarFcnBase *vf, double vfgam, double vfp, $/;"	f
hmmh	TsOutput.h	/^  HeavingMeshMotionHandler *hmmh;$/;"	m	class:TsOutput
homotopy	IoData.h	/^  enum HomotopyComputation {OFF_HOMOTOPY = 0, ON_HOMOTOPY = 1} homotopy;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::HomotopyComputation
homotopyStepGrowthRate	ImplicitRomTsDesc.h	/^  double homotopyStepGrowthRate;$/;"	m	class:ImplicitRomTsDesc
homotopyStepInitial	ImplicitRomTsDesc.h	/^  double homotopyStepInitial;  \/\/ Reduced coordinate pseudo-time-stepping for spatial-only simulations. Only implemented for normal equations.$/;"	m	class:ImplicitRomTsDesc
homotopyStepMax	ImplicitRomTsDesc.h	/^  double homotopyStepMax;  $/;"	m	class:ImplicitRomTsDesc
hth	TsDesc.h	/^  HeatTransferHandler* hth;$/;"	m	class:TsDesc
hu	MvpMatrix.h	/^  SVec<Scalar, dim*3>* uh, *hu;$/;"	m	class:MvpMat
hv	IoData.h	/^  HeavingData hv;$/;"	m	struct:ForcedData
hydro	IoData.h	/^  BcsHydroData hydro;$/;"	m	struct:BcsData
hydrodynamicPressure	VarFcn.h	/^  double hydrodynamicPressure(double *V, double *X, int tag=0) const{ $/;"	f	class:VarFcn
hydrodynamicforces	IoData.h	/^  const char *hydrodynamicforces;$/;"	m	struct:TransientData
hydrodynamicforces	TsOutput.h	/^  char *hydrodynamicforces;$/;"	m	class:TsOutput
hydrodynamiclift	IoData.h	/^  const char *hydrodynamiclift;$/;"	m	struct:TransientData
hydrodynamiclift	TsOutput.h	/^  char *hydrodynamiclift;$/;"	m	class:TsOutput
hydrodynamicpressure	IoData.h	/^  const char *hydrodynamicpressure;$/;"	m	struct:TransientData
hydrostaticPressure	VarFcn.h	/^  double hydrostaticPressure(const double density, double *X) const{ $/;"	f	class:VarFcn
hydrostaticforces	IoData.h	/^  const char *hydrostaticforces;$/;"	m	struct:TransientData
hydrostaticforces	TsOutput.h	/^  char *hydrostaticforces;$/;"	m	class:TsOutput
hydrostaticlift	IoData.h	/^  const char *hydrostaticlift;$/;"	m	struct:TransientData
hydrostaticlift	TsOutput.h	/^  char *hydrostaticlift;$/;"	m	class:TsOutput
hydrostaticpressure	IoData.h	/^  const char *hydrostaticpressure;$/;"	m	struct:TransientData
i	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct EMPTY_HELPER_NOBASE{int i[256];};$/;"	m	struct:PhysBAM::EMPTY_HELPER_NOBASE
i	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct EMPTY_HELPER_BASE_T:public T{int i[256];};$/;"	m	struct:PhysBAM::EMPTY_HELPER_BASE_T
i	arpack++/include/arlcomp.h	/^typedef struct { double r, i; } ldcomplex;$/;"	m	struct:__anon30
i	arpack++/include/arlcomp.h	/^typedef struct { float r, i; } lscomplex;$/;"	m	struct:__anon31
i00afunc	tools/alloca.cougar.c	/^i00afunc (long *address)$/;"	f	file:
i00afunc	tools/alloca.cougar.c	/^i00afunc (long address)$/;"	f	file:
i4_max	Dunavant.C	/^int i4_max ( int i1, int i2 )$/;"	f
i4_min	Dunavant.C	/^int i4_min ( int i1, int i2 )$/;"	f
i4_modp	Dunavant.C	/^int i4_modp ( int i, int j )$/;"	f
i4_wrap	Dunavant.C	/^int i4_wrap ( int ival, int ilo, int ihi )$/;"	f
iForce	TsDesc.h	/^  int iForce;$/;"	m	class:TsDesc
iSub	MultiGridSmoothingMatrix.h	/^  int iSub;$/;"	m	class:MultiGridSmoothingMatrix
iTotal	TsDesc.h	/^  int iTotal;$/;"	m	class:TsDesc
ia	RectangularSparseMatrix.h	/^  Vec<int> ia;              \/\/ pointer to lines$/;"	m	class:RectangularSparseMat
ia	SparseMatrix.h	/^  Vec<int> ia;              \/\/ pointer to lines$/;"	m	class:SparseMat
ibpair	IntersectorFRG/IntersectorFRG.C	/^typedef pair<int, bool> ibpair;$/;"	t	file:
ibpair	IntersectorFRG/IntersectorFRG.h	/^  typedef pair<int, bool> ibpair;$/;"	t	class:DistIntersectorFRG
ibpair	IntersectorPhysBAM/IntersectorPhysBAM.C	/^typedef pair<int, bool> ibpair;$/;"	t	file:
ibpair	IntersectorPhysBAM/IntersectorPhysBAM.h	/^  typedef pair<int, bool> ibpair;$/;"	t	class:DistIntersectorPhysBAM
icInterp	Timer.h	/^                gappyOffline, romOffline, icInterp, NUMTIMINGS$/;"	e	enum:Timer::TimerIndex
icamax_	arpack++/include/arlnames.h	104;"	d
icamax_	arpack++/include/arlnames.h	175;"	d
iccerrboundA	utils/Predicate.C	/^REAL iccerrboundA, iccerrboundB, iccerrboundC;$/;"	v
iccerrboundB	utils/Predicate.C	/^REAL iccerrboundA, iccerrboundB, iccerrboundC;$/;"	v
iccerrboundC	utils/Predicate.C	/^REAL iccerrboundA, iccerrboundB, iccerrboundC;$/;"	v
icntl	arpack++/include/arunsmat.h	/^  int     icntl[20];$/;"	m	class:ARumNonSymMatrix
icntl	arpack++/include/arusmat.h	/^  int     icntl[20];$/;"	m	class:ARumSymMatrix
iconst	AutoDiff/SpaceDerivatives.h	/^                       FunctionTemplate<Scalar>::NumberOfIntegerConstants,1>& iconst;$/;"	m	class:FirstPartialSpaceDerivatives
iconst	AutoDiff/SpaceDerivatives.h	/^                       FunctionTemplate<Scalar>::NumberOfIntegerConstants,1>& iconst;$/;"	m	class:SpatialView
iconst	AutoDiff/SpaceDerivatives.h	/^                       VectorValuedFunctionTemplate<Scalar>::NumberOfIntegerConstants,1>& iconst;$/;"	m	class:Jacobian
iconst	AutoDiff/SpaceDerivatives.h	/^    const Eigen::Array<int, Base::NumberOfIntegerConstants, 1>& iconst;$/;"	m	class:JacobianVectorProduct
iconst	AutoDiff/roeturkeljac5.h	/^    const Eigen::Array<int,1,1> &iconst;$/;"	m	class:RoeTurkelFlux5Function
id	IntersectorFRG/IntersectorFRG.C	/^  int id;$/;"	m	class:MyTriangle	file:
id	IoData.h	/^    int id;$/;"	m	struct:Probes::Node
id	KDTree.h	/^    int id;$/;"	m	struct:KDTree::ScalarGlob
id	MultiGridLevel.h	/^  int id;$/;"	m	struct:NeighborDomain
id	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    ARRAY<int> id; \/\/TODO: Replace dynamic one with this$/;"	m	class:PhysBAM::POINT_CLOUD
id_value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    T id_value;$/;"	m	class:PhysBAM::ELEMENT_ID
idamax_	arpack++/include/arlnames.h	159;"	d
idamax_	arpack++/include/arlnames.h	88;"	d
idealGasConstant	IoData.h	/^  double idealGasConstant;$/;"	m	struct:GasModelData
idealGasConstant	IoData.h	/^  double idealGasConstant;$/;"	m	struct:JWLModelData
identifyEdges	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::identifyEdges(CommPattern<int> &edgeNumPat,$/;"	f	class:MultiGridLevel
identifyEdges	SubDomainCore.C	/^void SubDomain::identifyEdges(CommPattern<int> &edgeNumPat)$/;"	f	class:SubDomain
ido	arpack++/include/arrseig.h	/^  int     ido;        \/\/ Original ARPACK reverse communication flag.$/;"	m	class:ARrcStdEig
idr	IoData.h	/^  double idr,ldr;$/;"	m	struct:PorousMedia
ids	OneDimensionalSolver.h	/^    std::vector<int> ids;$/;"	m	struct:OneDimensional::__anon12
idti	DistTimeState.h	/^  DistVec<double> *idti;		\/\/inverse inviscid time stepping$/;"	m	class:DistTimeState
idti	MultiGridOperator.h	/^  DistVec<Scalar>* idti;$/;"	m	class:MultiGridOperator
idti	TimeState.h	/^  Vec<double> &idti;$/;"	m	class:TimeState
idtv	DistTimeState.h	/^  DistVec<double> *idtv;		\/\/inverse viscous  time stepping$/;"	m	class:DistTimeState
idtv	MultiGridOperator.h	/^  DistVec<Scalar>* idtv;$/;"	m	class:MultiGridOperator
idtv	TimeState.h	/^  Vec<double> &idtv;$/;"	m	class:TimeState
ignited	IoData.h	/^  int ignited;$/;"	m	struct:ProgrammedBurnData
ignited	ProgrammedBurn.h	/^    bool ignited;$/;"	m	struct:ProgrammedBurn::Burn
ignitionTime	IoData.h	/^  double ignitionTime;$/;"	m	struct:ProgrammedBurnData
ignitionX0	IoData.h	/^  double ignitionX0,ignitionY0,ignitionZ0;$/;"	m	struct:ProgrammedBurnData
ignitionY0	IoData.h	/^  double ignitionX0,ignitionY0,ignitionZ0;$/;"	m	struct:ProgrammedBurnData
ignitionZ0	IoData.h	/^  double ignitionX0,ignitionY0,ignitionZ0;$/;"	m	struct:ProgrammedBurnData
iipair	IntersectorFRG/IntersectorFRG.C	/^typedef pair<int, int> iipair;$/;"	t	file:
iipair	IntersectorFRG/IntersectorFRG.h	/^  typedef pair<int, int> iipair;$/;"	t	class:DistIntersectorFRG
iipair	IntersectorPhysBAM/IntersectorPhysBAM.C	/^typedef pair<int, int> iipair;$/;"	t	file:
iipair	IntersectorPhysBAM/IntersectorPhysBAM.h	/^  typedef pair<int, int> iipair;$/;"	t	class:DistIntersectorPhysBAM
ij	MultiGridLevel.C	/^  std::pair<int,int> ij;$/;"	m	struct:loc_edge	file:
iluA	MultiGridSmoothingMatrix.h	/^  SparseMat<Scalar,dim> *iluA;$/;"	m	class:MultiGridSmoothingMatrix
iluJW	MultiGridSmoothingMatrix.h	/^  Vec<int>* iluJW;$/;"	m	class:MultiGridSmoothingMatrix
im	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    T re,im;$/;"	m	class:PhysBAM::COMPLEX
implement	parser/ParseTree.cpp	/^void ParseTree::implement(Assigner *assigner) {$/;"	f	class:ParseTree
implicit	IoData.h	/^  ImplicitData implicit;$/;"	m	struct:TsData
implicit_object	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^    const T_IMPLICIT_OBJECT& implicit_object;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY
implicit_object	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^    const T_IMPLICIT_OBJECT& implicit_object;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION
implosion	IoData.h	/^  ImplosionSetup implosion;$/;"	m	class:IoData
implosionSetupType	EmbeddedTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;  $/;"	m	class:EmbeddedTsDesc	typeref:enum:EmbeddedTsDesc::ImplosionSetupType
implosionSetupType	MultiPhysicsTsDesc.h	/^  enum ImplosionSetupType {LINEAR = 0, SMOOTHSTEP = 1, NONE = 2} implosionSetupType;$/;"	m	class:MultiPhysicsTsDesc	typeref:enum:MultiPhysicsTsDesc::ImplosionSetupType
inRedoTimestep	MultiPhysicsTsDesc.h	/^  bool inRedoTimestep;$/;"	m	class:MultiPhysicsTsDesc
inSubCycling	EmbeddedTsDesc.h	/^  bool inSubCycling;  \/\/<! is it in subcyling (i.e. itSc>1)$/;"	m	class:EmbeddedTsDesc
inSubCycling	MultiPhysicsTsDesc.h	/^  bool inSubCycling;  \/\/<! is it in subcyling (i.e. itSc>1)$/;"	m	class:MultiPhysicsTsDesc
inVar	IoData.h	/^  bool inVar[SIZE], outVar[SIZE]; $/;"	m	struct:BoundaryData
in_bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/clamp.h	/^inline bool in_bounds(const T x,const T xmin,const T xmax)$/;"	f	namespace:PhysBAM
in_bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^in_bounds(const VECTOR<T,d>& v,const VECTOR<T,d>& vmin,const VECTOR<T,d>& vmax)$/;"	f	class:PhysBAM
in_bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^in_bounds(const VECTOR<T,1>& v,const VECTOR<T,1>& vmin,const VECTOR<T,1>& vmax)$/;"	f	namespace:PhysBAM
in_bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^in_bounds(const VECTOR<T,2>& v,const VECTOR<T,2>& vmin,const VECTOR<T,2>& vmax)$/;"	f	namespace:PhysBAM
in_bounds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^in_bounds(const VECTOR<T,3>& v,const VECTOR<T,3>& vmin,const VECTOR<T,3>& vmax)$/;"	f	namespace:PhysBAM
incident_elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    ARRAY<ARRAY<int> >* incident_elements; \/\/ for each node, list of neighboring simplices that contain it$/;"	m	class:PhysBAM::SIMPLEX_MESH
incircle	utils/Predicate.C	/^REAL incircle(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
incircleadapt	utils/Predicate.C	/^REAL incircleadapt(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL permanent)$/;"	f
incircleexact	utils/Predicate.C	/^REAL incircleexact(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
incirclefast	utils/Predicate.C	/^REAL incirclefast(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
incircleslow	utils/Predicate.C	/^REAL incircleslow(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
include	IoData.h	/^  enum Include {INCLUDE_OFF = 0, INCLUDE_ON = 1} include;$/;"	m	struct:NonlinearRomOnlineNonStateData	typeref:enum:NonlinearRomOnlineNonStateData::Include
includeLiftFaces	GappyPreprocessing.h	/^	int includeLiftFaces; 	\/\/ if the reduced mesh should include lift faces$/;"	m	class:GappyPreprocessing
includeLiftFaces	IoData.h	/^		SPECIFIED_LIFTFACE  = 1, ALL_LIFTFACE = 2} includeLiftFaces;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::IncludeLiftFaces
increasingPressure	EmbeddedTsDesc.h	/^  bool increasingPressure;$/;"	m	class:EmbeddedTsDesc
increasingPressure	MultiPhysicsTsDesc.h	/^  bool increasingPressure;$/;"	m	class:MultiPhysicsTsDesc
increment	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
incrementCoordsTol	IoData.h	/^  double incrementCoordsTol;$/;"	m	struct:NonlinearRomOnlineData
incrementDistanceComparisonsForApproxUpdates	NonlinearRom.C	/^void NonlinearRom<dim>::incrementDistanceComparisonsForApproxUpdates(Vec<double> dUromTimeIt, int currentCluster) {$/;"	f	class:NonlinearRom
incrementDistanceComparisonsForExactUpdates	NonlinearRom.C	/^void NonlinearRom<dim>::incrementDistanceComparisonsForExactUpdates(Vec<double> dUromTimeIt, int currentCluster) {$/;"	f	class:NonlinearRom
incrementDistanceComparisonsForNoUpdates	NonlinearRom.C	/^void NonlinearRom<dim>::incrementDistanceComparisonsForNoUpdates(Vec<double> dUromTimeIt, int currentCluster) {$/;"	f	class:NonlinearRom
incrementNewtonOutputTag	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::incrementNewtonOutputTag()$/;"	f	class:ImplicitTsDesc
incrementNewtonOutputTag	MeshMotionSolver.h	/^  void incrementNewtonOutputTag() {}$/;"	f	class:TetMeshMotionSolver
incrementNewtonOutputTag	TsDesc.h	/^  virtual void incrementNewtonOutputTag() {}$/;"	f	class:TsDesc
incrementalStateSnaps	NonlinearRom.h	/^  bool incrementalStateSnaps;$/;"	m	class:NonlinearRom
index	BlockAlloc.h	/^    int index;$/;"	m	class:BlockAlloc
index	MatchNode.C	/^  int index[3];$/;"	m	struct:MatchNode	file:
index	MatchNode.h	/^  int (*index)[3];$/;"	m	class:MatchNodeSet
index	OneDimensionalSourceTerm.h	/^    int* index;$/;"	m	struct:OneDimensionalSourceTerm::MyLU
index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    int index;$/;"	m	struct:PhysBAM::INDEX_PROJECTOR
index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    int index;$/;"	m	class:PhysBAM::MT19937
index	TsRestart.h	/^  int index;$/;"	m	class:TsRestart
index	arpack++/include/arunsmat.h	/^  int*    index;$/;"	m	class:ARumNonSymMatrix
index	arpack++/include/arusmat.h	/^  int*    index;$/;"	m	class:ARumSymMatrix
index-Installation-2	Manual/Aerof3d.html	/^<p><a name="index-Installation-2"><\/a>$/;"	a
index-Introduction-1	Manual/Aerof3d.html	/^<p><a name="index-Introduction-1"><\/a><!-- ARL_FLAG -->$/;"	a
index-Overview-3	Manual/Aerof3d.html	/^<p><a name="index-Overview-3"><\/a>$/;"	a
indexName	IoData.h	/^  const char *indexName;$/;"	m	struct:NonlinearRomFilesData
indexName	NonlinearRom.h	/^  char* indexName;$/;"	m	class:NonlinearRom
indices	BlockTridiagonalMatrix.h	/^  int (*indices)[dim];$/;"	m	class:BlockTridiagonalMatrix
indices	MultiGridSmoothingMatrix.h	/^  SVec<int,dim>* indices;$/;"	m	class:MultiGridSmoothingMatrix
indices	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    CONST_T_INDICES indices;$/;"	m	class:PhysBAM::INDIRECT_ARRAY
infNd	CorotSolver.h	/^  int **infNd;$/;"	m	class:CorotSolver
infRadius	IoData.h	/^  enum InfRadius {FALSE = 0, TRUE = 1} infRadius;$/;"	m	struct:RotationData	typeref:enum:RotationData::InfRadius
influx3D	FluxFcnDescSG.C	/^void influx3D(int type, VarFcnBase *vf, double* normal, $/;"	f
influx3DDerivative	FluxFcnDescSG.C	/^void influx3DDerivative(int type, VarFcnBase *vf, double* normal, double* dNormal,$/;"	f
info	DistEmbeddedVector.h	/^  const DistInfo &info() const { return real().info(); }$/;"	f	class:DistEmbeddedVec
info	DistVector.h	/^  const InfoType &info() const { return distInfo; }$/;"	f	class:DistSVec
info	DistVector.h	/^  const InfoType &info() const { return distInfo; }$/;"	f	class:DistVec
info	arpack++/include/arbnsmat.h	/^  int      info;$/;"	m	class:ARbdNonSymMatrix
info	arpack++/include/arbsmat.h	/^  int      info;$/;"	m	class:ARbdSymMatrix
info	arpack++/include/ardnsmat.h	/^  int                 info;$/;"	m	class:ARdsNonSymMatrix
info	arpack++/include/ardsmat.h	/^  int      info;$/;"	m	class:ARdsSymMatrix
info	arpack++/include/arrseig.h	/^  int     info;       \/\/ Original ARPACK error flag.$/;"	m	class:ARrcStdEig
info	arpack++/include/arunsmat.h	/^  int     info[40];$/;"	m	class:ARumNonSymMatrix
info	arpack++/include/arusmat.h	/^  int     info[40];$/;"	m	class:ARumSymMatrix
init	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::init(char *solidSurface, char *restartSolidSurface, double XScale) {$/;"	f	class:DistIntersectorFRG
init	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::init(int nNodes, double *xyz, int nElems, int (*abc)[3], char *restartSolidSurface) {$/;"	f	class:DistIntersectorFRG
init	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::init(char *solidSurface, char *restartSolidSurface, double XScale) {$/;"	f	class:DistIntersectorPhysBAM
init	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::init(int nNodes, double *xyz, int nElems, int (*abc)[3], char *restartSolidSurface) {$/;"	f	class:DistIntersectorPhysBAM
init	MultiGridDistSVec.C	/^void MultiGridDistSVec<Scalar,dim>::init(MultiGridKernel<Scalar>* K) {$/;"	f	class:MultiGridDistSVec
initCommunication	CommunicatorMPI.C	/^void initCommunication(int &argc, char **&argv)$/;"	f
initCond	IoData.h	/^  enum InitialCondition {DISPLACEMENT = 0, VELOCITY = 1} initCond;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::InitialCondition
initSize	Malloc.C	/^int initSize=2*1024*1024;$/;"	v
init_v	ResizeArray.h	/^  Type init_v;$/;"	m	class:ResizeArray
initialCluster	IoData.h	/^  double initialCluster; \/\/ for online matrix computations (restart)$/;"	m	struct:GappyConstructionData
initialCluster	IoData.h	/^  int initialCluster;$/;"	m	struct:DataCompressionData
initialClusterCentersFile	IoData.h	/^  const char *initialClusterCentersFile;$/;"	m	struct:InputData
initialCondition	NonlinearRomDatabaseConstruction.h	/^  DistSVec<double, dim>* initialCondition;$/;"	m	class:NonlinearRomDatabaseConstruction
initialConditionCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<double> > initialConditionCentersDifProduct; $/;"	m	class:NonlinearRom
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:CylinderData
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:PlaneData
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:PointData
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:PrismData
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:SphereData
initialConditions	IoData.h	/^  InitialConditions initialConditions;$/;"	m	struct:VolumeData
initialTime	Timer.h	/^  double initialTime;$/;"	m	class:Timer
initial_address	tools/alloca.cougar.c	/^    long initial_address;	\/* Address of initial segment.  *\/$/;"	m	struct:stk_stat	file:
initial_size	tools/alloca.cougar.c	/^    long initial_size;		\/* Size of initial segment.  *\/$/;"	m	struct:stk_stat	file:
initialization	EmbeddedAlternatingLeastSquare.C	/^int EmbeddedAlternatingLeastSquare<dim>::initialization(VecSet<DistSVec<double, dim> > &basisInit) {$/;"	f	class:EmbeddedAlternatingLeastSquare
initialize	DistBcData.C	/^void DistBcDataEuler<dim>::initialize(IoData &iod, DistSVec<double,3> &X)$/;"	f	class:DistBcDataEuler
initialize	DistBcData.h	/^  virtual void initialize(IoData &, DistSVec<double,3> &) {}$/;"	f	class:DistBcData
initialize	DistTimeState.C	/^void DistTimeState<dim>::initialize(IoData &ioData, SpaceOperator<dim> *spo, VarFcn *vf,$/;"	f	class:DistTimeState
initialize	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::initialize() $/;"	f	class:GappyPreprocessing
initialize	HigherOrderFSI.C	/^void HigherOrderFSI::initialize(IoData &iod, Communicator *comm, int numNodes, ElemSet& e, $/;"	f	class:HigherOrderFSI
initialize	HigherOrderFSI.C	/^void HigherOrderFSI::initialize(int numNodes, ElemSet& e, V6NodeData (*v)[2]) $/;"	f	class:HigherOrderFSI
initialize	HigherOrderMultiFluid.C	/^void HigherOrderMultiFluid::initialize(int numNodes,ElemSet& e, V6NodeData (*v)[2]) {$/;"	f	class:HigherOrderMultiFluid
initialize	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::initialize(Domain *d, DistSVec<double,3> &X, DistSVec<double,3> &Xn, IoData &iod, DistVec<int> *point_based_id, DistVec<int>* oldStatus) {$/;"	f	class:DistIntersectorFRG
initialize	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::initialize(Domain *d, DistSVec<double,3> &X, $/;"	f	class:DistIntersectorPhysBAM
initialize	LevelSet/MultiGridLevelSetStructure.C	/^initialize(Domain * d, DistSVec<double,3> &X, DistSVec<double,3> &Xn, $/;"	f	class:DistMultiGridLevelSetStructure
initialize	MatVecProd.h	/^  void initialize() {$/;"	f	struct:dRdXoperators
initialize	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::initialize(int dim,int neq1,int neq2) {$/;"	f	class:MultiGridKernel
initialize	MultiGridPrec.C	/^void MultiGridPrec<Scalar,dim,Scalar2>::initialize() {$/;"	f	class:MultiGridPrec
initialize	OneDimensionalSourceTerm.h	/^  void initialize(double _alpha, int _order, SVec<double,1>& X) {$/;"	f	class:OneDimensionalSourceTerm
initialize	SparseGrid.C	/^void SparseGrid::initialize(FnType fn){$/;"	f	class:SparseGrid
initialize	SparseGridCore.C	/^void SparseGrid::initialize(SparseGridData &data, double *param, $/;"	f	class:SparseGrid
initializeAsSquare	TriangulatedInterface.C	/^void TriangulatedInterface::initializeAsSquare(int N) {$/;"	f	class:TriangulatedInterface
initializeClusterCenters	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::initializeClusterCenters() {$/;"	f	class:NonlinearRomDatabaseConstruction
initializeClusteredOutputs	NonlinearRom.C	/^void NonlinearRom<dim>::initializeClusteredOutputs()$/;"	f	class:NonlinearRom
initializeDistanceComparisons	NonlinearRom.C	/^void NonlinearRom<dim>::initializeDistanceComparisons(DistSVec<double, dim> &ic) {$/;"	f	class:NonlinearRom
initializeFarfieldCoeffs	TsDesc.C	/^void TsDesc<dim>::initializeFarfieldCoeffs()$/;"	f	class:TsDesc
initializeFastExactUpdatesQuantities	NonlinearRom.C	/^void NonlinearRom<dim>::initializeFastExactUpdatesQuantities(DistSVec<double, dim> &ic) {$/;"	f	class:NonlinearRom
initializeFluidIds	FluidSelector.C	/^void FluidSelector::initializeFluidIds(DistSVec<double,dim> &Phin, DistSVec<double,dim> &Phinm1, DistSVec<double,dim> &Phinm2){$/;"	f	class:FluidSelector
initializeIntersector	TriangulatedInterface.C	/^void TriangulatedInterface::initializeIntersector(IoData& iod,  Communicator* com, $/;"	f	class:TriangulatedInterface
initializeLeastSquares	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::initializeLeastSquares() {$/;"	f	class:GappyPreprocessing
initializeLeastSquaresDone	GappyPreprocessing.h	/^  bool initializeLeastSquaresDone; $/;"	m	class:GappyPreprocessing
initializeLeastSquaresPseudoInv	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::initializeLeastSquaresPseudoInv(int numRhs) {$/;"	f	class:GappyPreprocessing
initializeOperators	MatVecProd.C	/^void MatVecProd_dRdX<dim,Scalar,neq>::initializeOperators(double x)$/;"	f	class:MatVecProd_dRdX
initializePhysBAM	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::initializePhysBAM() { \/\/NOTE: In PhysBAM array index starts from 1 instead of 0$/;"	f	class:DistIntersectorFRG
initializePhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::initializePhysBAM() { $/;"	f	class:DistIntersectorPhysBAM
initializeProjectionQuantities	NonlinearRom.C	/^void NonlinearRom<dim>::initializeProjectionQuantities(DistSVec<double, dim> &ic) {$/;"	f	class:NonlinearRom
initializeSA	DistBcData.C	/^void DistBcDataEuler<dim>::initializeSA(IoData &iod, DistSVec<double,3> &X, DistSVec<double,3> &dX, double & dM, double & dA, double & dB)$/;"	f	class:DistBcDataEuler
initializeSA	DistBcData.h	/^  virtual void initializeSA(IoData &, DistSVec<double,3> &, DistSVec<double,3> &, double &, double &, double &) {}$/;"	f	class:DistBcData
initialized	MultiGridKernel.h	/^  bool initialized;$/;"	m	class:MultiGridKernel
initialized	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    bool& initialized;$/;"	m	struct:PhysBAM::LOG_REAL::__anon18::INITIALIZATION_HELPER	file:
inlet	IoData.h	/^  BcsFreeStreamData inlet;$/;"	m	struct:BcsData
inletCountPat	Domain.h	/^  CommPattern<int> *inletCountPat;$/;"	m	class:Domain
inletNodeDistInfo	DistBcData.h	/^  DistInfo& nodeDistInfo,&inletNodeDistInfo,&faceDistInfo;$/;"	m	class:DistBcData
inletNodeDistInfo	Domain.h	/^  DistInfo *inletNodeDistInfo;$/;"	m	class:Domain
inletNodeDistInfo	MultiGridLevel.h	/^    DistInfo* inletNodeDistInfo;$/;"	m	class:MultiGridLevel
inletNodeNorm	DistGeoState.h	/^  DistVec<Vec3D> *inletNodeNorm;$/;"	m	class:DistGeoState
inletNodeNorm	GeoState.h	/^  Vec<Vec3D> &inletNodeNorm;$/;"	m	class:GeoState
inletNodes	InletNode.h	/^	InletNode *inletNodes;$/;"	m	class:InletNodeSet
inletNodes	SubDomain.h	/^  InletNodeSet inletNodes;$/;"	m	class:SubDomain
inletRhsPat	Domain.h	/^  CommPattern<double> *inletRhsPat;$/;"	m	class:Domain
inletVec3DPat	Domain.h	/^  CommPattern<double> *inletVec3DPat;$/;"	m	class:Domain
input	GappyPreprocessing.h	/^	TsInput *input;	$/;"	m	class:GappyPreprocessing
input	IoData.h	/^  InputData input;$/;"	m	class:IoData
input	TsDesc.h	/^  TsInput *input;$/;"	m	class:TsDesc
inputs	AutoDiff/SpaceDerivatives.h	/^    int inputs() const { return InputsAtCompileTime; }$/;"	f	class:SpatialView
insert	SparseGridCore.C	/^void SparseGrid::Heap::insert(const int newElem, const double *value){$/;"	f	class:SparseGrid::Heap
inside	IoDataCore.C	/^bool PrismData::inside(double x,double y, double z) const {$/;"	f	class:PrismData
insideOutside	SubDomainCore.C	/^bool SubDomain::insideOutside(double *position, const double xmin, const double xmax,$/;"	f	class:SubDomain
insphere	utils/Predicate.C	/^REAL insphere(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)$/;"	f
insphereadapt	utils/Predicate.C	/^REAL insphereadapt(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe, REAL permanent)$/;"	f
insphereexact	utils/Predicate.C	/^REAL insphereexact(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)$/;"	f
inspherefast	utils/Predicate.C	/^REAL inspherefast(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)$/;"	f
insphereslow	utils/Predicate.C	/^REAL insphereslow(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)$/;"	f
intMap	parser/ParseTree.h	/^    std::map<Token,int> intMap;$/;"	m	class:ParseTree
int_hash	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    unsigned int int_hash(unsigned int key) $/;"	f	class:PhysBAM::HASH
integer_log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^inline int integer_log(unsigned int v) \/\/ this works for any v, but it is slower$/;"	f	namespace:PhysBAM
integer_log_exact	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^inline int integer_log_exact(const unsigned int v) \/\/ this only works if v is a power of 2$/;"	f	namespace:PhysBAM
integrate	RKIntegrator.h	/^    void integrate(Obj* obj, void (Obj::*F)(double t, T& Y,T& k),$/;"	f	class:RKIntegrator
integrateFE	ODEIntegrator.h	/^    void integrateFE(T& obj,R& f,R (T::*df)(double t, const M&),const M& m ) {$/;"	f	class:ODEIntegrator
integrateFE	ODEIntegrator.h	/^    void integrateFE(T& obj,R& f,R (T::*df)(double t,const R& r, const M&),const M& m ) {$/;"	f	class:ODEIntegrator
integrateForwardAdmissible	SparseGrid.C	/^int SparseGrid::integrateForwardAdmissible(const int newSubGridIndex,$/;"	f	class:SparseGrid
integrateFunction	Domain.C	/^void Domain::integrateFunction(Obj* obj,DistSVec<double,3> &X,DistSVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),$/;"	f	class:Domain
integrateFunction	Elem.C	/^void ElemSet::integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),int npt) {$/;"	f	class:ElemSet
integrateFunction	Elem.h	/^    void integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),int npt) { $/;"	f	class:Elem
integrateFunction	Elem.h	/^    void integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),int npt) {$/;"	f	class:ElemWrapper_dim_obj
integrateFunction	Elem.h	/^    void integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),int) {$/;"	f	class:ElemDummy
integrateFunction	ElemTet.C	/^void ElemTet::integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),$/;"	f	class:ElemTet
integrateFunction	SubDomain.C	/^void SubDomain::integrateFunction(Obj* obj,SVec<double,3> &X,SVec<double,dim>& V, void (Obj::*F)(int node, const double* loc,double* f),$/;"	f	class:SubDomain
integrateMidpoint	ODEIntegrator.h	/^    void integrateMidpoint(T& obj,R& f,R (T::*df)(double t, const M&),const M& m ) {$/;"	f	class:ODEIntegrator
integrateMidpoint	ODEIntegrator.h	/^    void integrateMidpoint(T& obj,R& f,R (T::*df)(double t,const R& r, const M&),const M& m ) {$/;"	f	class:ODEIntegrator
integrateOnSphere	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::integrateOnSphere$/;"	f	class:KirchhoffIntegrator
integraterk2	TriangulatedInterface.h	/^  void integraterk2(Domain* domain, DistSVec<double,3>& X,$/;"	f	class:TriangulatedInterface
integration	IoData.h	/^  enum Integration {AUTO = 0, WALL_FUNCTION = 1, FULL = 2} integration;$/;"	m	struct:BcsWallData	typeref:enum:BcsWallData::Integration
interCom	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
interfNd	CorotSolver.h	/^  int **interfNd;  \/\/ int *interfNd[3] ==> array of nodes for sub 3$/;"	m	class:CorotSolver
interface	RecFcn.h	/^void RecFcn::interface(double Vi, double ddVij, double Vj, double ddVji,$/;"	f	class:RecFcn
interfaceAlg	EmbeddedTsDesc.h	/^  int interfaceAlg;		 \/\/ = 0. do not use information of intersection at surrogate interface$/;"	m	class:EmbeddedTsDesc
interfaceAlg	IoData.h	/^  enum InterfaceAlgorithm {MID_EDGE = 0, INTERSECTION = 1} interfaceAlg;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::InterfaceAlgorithm
interfaceAlg	MultiPhysicsTsDesc.h	/^  int interfaceAlg;		 \/\/ = 0. do not use information of intersection at surrogate interface$/;"	m	class:MultiPhysicsTsDesc
interfaceExtrapolation	IoData.h	/^  enum InterfaceExtrapolation {EXTRAPOLATIONFIRSTORDER=0, EXTRAPOLATIONSECONDORDER=1, AUTO=2} interfaceExtrapolation;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::InterfaceExtrapolation
interfaceExtrapolation	OneDimensionalSolver.h	/^  int interfaceExtrapolation;$/;"	m	class:OneDimensional
interfaceLimiter	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::InterfaceLimiter
interfaceLimiter	IoData.h	/^  enum InterfaceLimiter {LIMITERNONE = 0, LIMITERALEX1 = 1} interfaceLimiter;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::InterfaceLimiter
interfaceLocation	OneDimensionalSolver.h	/^  double interfaceLocation;$/;"	m	class:OneDimensional
interfaceOrder	LevelSetTsDesc.h	/^  int interfaceOrder;$/;"	m	class:LevelSetTsDesc
interfacePosition	IoData.h	/^  double interfacePosition;$/;"	m	struct:OneDimensionalInfo
interfaceThickness	IoData.h	/^  double interfaceThickness;$/;"	m	struct:EmbeddedFramework
interfaceTreatment	IoData.h	/^  enum InterfaceTreatment {FIRSTORDER=0, SECONDORDER=1} interfaceTreatment;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::InterfaceTreatment
interfaceTreatment	OneDimensionalSolver.h	/^  int interfaceTreatment;$/;"	m	class:OneDimensional
interfaceType	IoData.h	/^  enum InterfaceType {FSF = 0, FF = 1, FSFandFF = 2} interfaceType;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::InterfaceType
interfaceType	LevelSetTsDesc.h	/^  MultiFluidData::InterfaceType interfaceType; \/\/to advance levelset or not$/;"	m	class:LevelSetTsDesc
interface_thickness	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double interface_thickness;$/;"	m	class:DistIntersectorPhysBAM
interfacialWi	DistExactRiemannSolver.h	/^  DistSVec<double,dim-2> *interfacialWi; \/\/edge based$/;"	m	class:DistExactRiemannSolver
interfacialWi	ExactRiemannSolver.h	/^  SVec<double,dim-2>  &interfacialWi;$/;"	m	class:ExactRiemannSolver
interfacialWi	OneDimensionalSolver.h	/^  SVec<double,dim-2> interfacialWi;$/;"	m	class:OneDimensional
interfacialWj	DistExactRiemannSolver.h	/^  DistSVec<double,dim-2> *interfacialWj; \/\/edge based$/;"	m	class:DistExactRiemannSolver
interfacialWj	ExactRiemannSolver.h	/^  SVec<double,dim-2>  &interfacialWj;$/;"	m	class:ExactRiemannSolver
interfacialWj	OneDimensionalSolver.h	/^  SVec<double,dim-2> interfacialWj;$/;"	m	class:OneDimensional
internalNd	CorotSolver.h	/^  int **internalNd;$/;"	m	class:CorotSolver
internal_select	MultiGridLevel.C	/^CommPattern<Scalar>* internal_select(CommPattern<int>* a, CommPattern<double>* b) {$/;"	f
internal_select	MultiGridLevel.C	/^CommPattern<double>* internal_select<double>(CommPattern<int>* a, CommPattern<double>* b) {$/;"	f
internal_select	MultiGridLevel.C	/^CommPattern<int>* internal_select<int>(CommPattern<int>* a, CommPattern<double>* b) {$/;"	f
internal_select	MultiGridLevel.C	/^const CommPattern<Scalar>* internal_select(const CommPattern<int>* a, const CommPattern<double>* b) {$/;"	f
internal_select	MultiGridLevel.C	/^const CommPattern<double>* internal_select<double>(const CommPattern<int>* a,const  CommPattern<double>* b) {$/;"	f
internal_select	MultiGridLevel.C	/^const CommPattern<int>* internal_select<int>(const CommPattern<int>* a,const  CommPattern<double>* b) {$/;"	f
interpWeightsForMultiIC	NonlinearRom.h	/^  std::vector<double> interpWeightsForMultiIC;$/;"	m	class:NonlinearRom
interpolate	DistGeoState.C	/^void DistGeoState::interpolate(double dt, double dtLeft, $/;"	f	class:DistGeoState
interpolate	SparseGridClusterCore.C	/^int SparseGridCluster::interpolate(const int numRes, double **coord, double **res)$/;"	f	class:SparseGridCluster
interpolate	SparseGridCore.C	/^void SparseGrid::interpolate(const int numRes, double **coord, double **res){$/;"	f	class:SparseGrid
interpolateGradient	SparseGridClusterCore.C	/^int SparseGridCluster::interpolateGradient(const int numRes, double **coord, double **res)$/;"	f	class:SparseGridCluster
interpolateGradient	SparseGridCore.C	/^void SparseGrid::interpolateGradient(const int numRes, double **coord, double **res){$/;"	f	class:SparseGrid
interpolatePOD	Modal.C	/^void ModalSolver<dim>::interpolatePOD()  {$/;"	f	class:ModalSolver
interpolatePhiSolution	SubDomain.C	/^void SubDomain::interpolatePhiSolution(SVec<double,3>& X, SVec<double,dim>& U,$/;"	f	class:SubDomain
interpolatePositionVector	TsDesc.C	/^void TsDesc<dim>::interpolatePositionVector(double dt, double dtLeft)$/;"	f	class:TsDesc
interpolateSolution	Elem.C	/^void ElemSet::interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, $/;"	f	class:ElemSet
interpolateSolution	Elem.h	/^  int interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, const Vec3D& loc, double sol[dim], LevelSetStructure* LSS,$/;"	f	class:Elem
interpolateSolution	Elem.h	/^  int interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, const Vec3D& loc, double sol[dim], LevelSetStructure* LSS,$/;"	f	class:ElemDummy
interpolateSolution	Elem.h	/^  int interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, const Vec3D& loc,$/;"	f	class:ElemWrapper_dim
interpolateSolution	ElemTet.C	/^int ElemTet::interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, const Vec3D& loc, double sol[dim], LevelSetStructure* LSS,$/;"	f	class:ElemTet
interpolateSolution	SubDomain.C	/^void SubDomain::interpolateSolution(SVec<double,3>& X, SVec<double,dim>& U, $/;"	f	class:SubDomain
interpolateToSI	HigherOrderFSI.C	/^void HigherOrderFSI::interpolateToSI(int l, int n, int Fid, VarFcn *varFun, $/;"	f	class:HigherOrderFSI
interpolatedICWeights	TsDesc.h	/^  std::vector<double> interpolatedICWeights;$/;"	m	class:TsDesc
interpolatedMultiIC	NonlinearRom.h	/^  bool interpolatedMultiIC;$/;"	m	class:NonlinearRom
interpolatedNormal	IntersectorFRG/IntersectorFRG.h	/^    bool interpolatedNormal;$/;"	m	class:DistIntersectorFRG
interpolatedNormal	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    bool interpolatedNormal;$/;"	m	class:DistIntersectorPhysBAM
interruptCode	Main.C	/^int interruptCode = 0;$/;"	v
intersect	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
intersectAlpha	EmbeddedTsDesc.h	/^  double intersectAlpha; \/\/	relevant only if interfaceAlg==1$/;"	m	class:EmbeddedTsDesc
intersectAlpha	MultiPhysicsTsDesc.h	/^  double intersectAlpha; \/\/	relevant only if interfaceAlg==1$/;"	m	class:MultiPhysicsTsDesc
intersection_list	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    ARRAY<ARRAY<int> >& intersection_list;$/;"	m	struct:PhysBAM::BOX_VISITOR_TRIVIAL
intersection_location	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    LOCATION intersection_location; \/\/ indicates what type of intersection happened, LOCATION_UNKNOWN is used if not computed$/;"	m	class:PhysBAM::RAY
intersector	IntersectorFRG/IntersectorFRG.h	/^    IntersectorFRG **intersector;$/;"	m	class:DistIntersectorFRG
intersector	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    IntersectorPhysBAM **intersector;$/;"	m	class:DistIntersectorPhysBAM
intersectorName	IoData.h	/^  enum IntersectorName {PHYSBAM = 0, FRG = 1} intersectorName;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::IntersectorName
intersector_freq	EmbeddedTsDesc.h	/^  int intersector_freq;$/;"	m	class:EmbeddedTsDesc
intersector_freq	IoData.h	/^  int intersector_freq;$/;"	m	struct:ImplosionSetup
intersector_freq	MultiPhysicsTsDesc.h	/^  int intersector_freq;$/;"	m	class:MultiPhysicsTsDesc
invC_	VarFcnTait.h	/^  double invC_;$/;"	m	class:VarFcnTait
invMap	SparseGrid.h	/^    double invMap(double value){ return pow(base_,value);      }$/;"	f	class:SparseGrid::LogarithmicMapping
invNdWeight	DistInfo.h	/^  double *invNdWeight; \/\/ inverse of the number of subs touching a node$/;"	m	struct:DistInfo
invRotLocVec	CorotSolver.C	/^void invRotLocVec(double mat[3][3], double v[3]) $/;"	f
invRotLocVec	EmbeddedCorotSolver.C	/^void invRotLocVec(double mat[3][3], double v[3]) $/;"	f
inverse_direction	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    TV inverse_direction;$/;"	m	class:PhysBAM::RAY
invert	DenseMatrix.C	/^GenFullM<Scalar>::invert()$/;"	f	class:GenFullM
invert	DenseMatrix.C	/^void SymFullM<Scalar>::invert()$/;"	f	class:SymFullM
invert	DiagMatrix.C	/^void DiagMat<Scalar,dim>::invert()$/;"	f	class:DiagMat
invertDenseMatrix	DenseMatrixOps.h	/^int invertDenseMatrix(Scalar *a)$/;"	f
invgam1	VarFcnSGEuler.h	/^  double invgam1;$/;"	m	class:VarFcnSGEuler
invgam1	VarFcnSGKE.h	/^  double invgam1;$/;"	m	class:VarFcnSGKE
invgam1	VarFcnSGSA.h	/^  double invgam1;$/;"	m	class:VarFcnSGSA
invomega	VarFcnJwl.h	/^  double invomega;$/;"	m	class:VarFcnJwl
invomegap1	VarFcnJwl.h	/^  double invomegap1;$/;"	m	class:VarFcnJwl
io	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
ioData	EmbeddedTsDesc.h	/^  IoData& ioData;$/;"	m	class:EmbeddedTsDesc
ioData	GappyPreprocessing.h	/^	IoData *ioData;	$/;"	m	class:GappyPreprocessing
ioData	ImplicitRomTsDesc.h	/^  IoData *ioData;$/;"	m	class:ImplicitRomTsDesc
ioData	KspBinaryOutput.h	/^  IoData* ioData;$/;"	m	class:KspBinaryOutput
ioData	LevelSetTsDesc.h	/^  IoData& ioData;$/;"	m	class:LevelSetTsDesc
ioData	Modal.h	/^    IoData *ioData;$/;"	m	class:ModalSolver
ioData	MultiGridKernel.h	/^  IoData& ioData;$/;"	m	class:MultiGridKernel
ioData	NonlinearRom.h	/^  IoData* ioData;$/;"	m	class:NonlinearRom
ioData	NonlinearRomOffline.h	/^    IoData *ioData;$/;"	m	class:NonlinearRomOfflineSolver
ioData	Timer.h	/^  IoData *ioData;$/;"	m	class:Timer
ioOp	KspSolver.h	/^  IoOp *ioOp;$/;"	m	class:KspSolver
iod	EmbeddedCorotSolver.h	/^  IoData &iod;$/;"	m	class:EmbeddedCorotSolver
iod	FSI/DynamicNodalTransfer.h	/^        IoData& iod;$/;"	m	class:DynamicNodalTransfer
iod	FSI/DynamicNodalTransfer.h	/^  IoData& iod;$/;"	m	class:EmbeddedStructure
iod	GeoSource.h	/^  IoData *iod;$/;"	m	class:GeoSource
iod	IntersectorFRG/IntersectorFRG.h	/^    IoData &iod;$/;"	m	class:DistIntersectorFRG
iod	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    IoData &iod;$/;"	m	class:DistIntersectorPhysBAM
iod	MatVecProd.h	/^  IoData *iod;$/;"	m	class:MatVecProdFD
iod	MatVecProd.h	/^  IoData *iod;$/;"	m	class:MatVecProdFDMultiPhase
iod	MatVecProd.h	/^  IoData* iod;$/;"	m	class:MatVecProd_dRdX
iod	ReinitializeDistanceToWall.h	/^  IoData& iod;$/;"	m	class:ReinitializeDistanceToWall
iod	SpaceOperator.h	/^  IoData *iod;$/;"	m	class:SpaceOperator
iodp	FluidSelector.h	/^  IoData* iodp;$/;"	m	class:FluidSelector
iparam	arpack++/include/arrseig.h	/^  int     iparam[12]; \/\/ Vector that handles original ARPACK parameters.$/;"	m	class:ARrcStdEig
ipcol	DenseMatrix.h	/^   int *ipcol;$/;"	m	class:GenFullM
ipiv	arpack++/include/arbnsmat.h	/^  int*     ipiv;$/;"	m	class:ARbdNonSymMatrix
ipiv	arpack++/include/arbsmat.h	/^  int*     ipiv;$/;"	m	class:ARbdSymMatrix
ipiv	arpack++/include/ardnsmat.h	/^  int*                ipiv;$/;"	m	class:ARdsNonSymMatrix
ipiv	arpack++/include/ardsmat.h	/^  int*     ipiv;$/;"	m	class:ARdsSymMatrix
ipntr	arpack++/include/arrseig.h	/^  int     ipntr[15];  \/\/ Vector that handles original ARPACK pointers.$/;"	m	class:ARrcStdEig
iprimex	IoData.h	/^  double iprimex, iprimey, iprimez;$/;"	m	struct:PorousMedia
iprimey	IoData.h	/^  double iprimex, iprimey, iprimez;$/;"	m	struct:PorousMedia
iprimez	IoData.h	/^  double iprimex, iprimey, iprimez;$/;"	m	struct:PorousMedia
iprow	DenseMatrix.h	/^   int *iprow; $/;"	m	class:GenFullM
irey	DistTimeState.h	/^  DistVec<double> *irey;$/;"	m	class:DistTimeState
irow	arpack++/include/arhbmat.h	/^  ARINT*  irow;            \/\/ Row indices.$/;"	m	class:ARhbMatrix
irow	arpack++/include/arlnsmat.h	/^  int*        irow;$/;"	m	class:ARluNonSymMatrix
irow	arpack++/include/arlsmat.h	/^  int*        irow;$/;"	m	class:ARluSymMatrix
irow	arpack++/include/arunsmat.h	/^  int*    irow;$/;"	m	class:ARumNonSymMatrix
irow	arpack++/include/arusmat.h	/^  int*    irow;$/;"	m	class:ARumSymMatrix
isActive	LevelSet/LevelSetStructure.h	/^    bool isActive(double t, int n) const                  { return is_active[n]; }$/;"	f	class:LevelSetStructure
isBurnable	VarFcn.h	/^  bool isBurnable(int tag = 0) const { check(tag); return varFcn[tag]->isBurnable(); }$/;"	f	class:VarFcn
isBurnable	VarFcnBase.h	/^  virtual bool isBurnable() const { return false; }$/;"	f	class:VarFcnBase
isBurnable	VarFcnTait.h	/^  bool isBurnable() const { return burnable; }$/;"	f	class:VarFcnTait
isBurnedEOS	ProgrammedBurnCore.C	/^bool ProgrammedBurn::isBurnedEOS(int eos,int& tag) const {$/;"	f	class:ProgrammedBurn
isConsistent	IntersectorFRG/IntersectorFRG.C	/^  bool isConsistent, isPositive, hasBeenFixed;$/;"	m	class:ClosestTriangle	file:
isCoupled	FSI/DynamicNodalTransfer.h	/^	bool isCoupled() const { return structure.coupled; }$/;"	f	class:DynamicNodalTransfer
isDensity	DistTimeState.C	/^  int isDensity;$/;"	m	struct:SetFirstOrderNodes	file:
isDetonationInterface	ProgrammedBurnCore.C	/^bool ProgrammedBurn::isDetonationInterface(int i,int j,int& tag) const {$/;"	f	class:ProgrammedBurn
isEqualMaskMatrices	EmbeddedAlternatingLeastSquare.C	/^bool EmbeddedAlternatingLeastSquare<dim>::isEqualMaskMatrices(const VecSet<DistSVec<char, dim> > &X,$/;"	f	class:EmbeddedAlternatingLeastSquare
isEqualStateMatrices	EmbeddedAlternatingLeastSquare.C	/^bool EmbeddedAlternatingLeastSquare<dim>::isEqualStateMatrices(const VecSet<DistSVec<double, dim> > &X,$/;"	f	class:EmbeddedAlternatingLeastSquare
isFSI	MatVecProd.h	/^  bool isFSI;$/;"	m	class:MatVecProd
isFSI	MatVecProd.h	/^  bool isFSI;$/;"	m	class:MatVecProdMultiPhase
isFinished	ProgrammedBurn.h	/^  bool isFinished(int tag) const { return myBurns[tag].finished; }$/;"	f	class:ProgrammedBurn
isFirst	IntersectorFRG/IntersectorFRG.C	/^  bool isFirst;$/;"	m	class:ClosestTriangle	file:
isGFMPAR	DistTimeState.h	/^  bool isGFMPAR;$/;"	m	class:DistTimeState
isGeometric	MultiGridKernel.h	/^  bool isGeometric;$/;"	m	class:MultiGridKernel
isHigherOrder	ExactRiemannSolver.h	/^  bool isHigherOrder;$/;"	m	class:ExactRiemannSolver
isINodeinITet	SubDomainCore.C	/^bool SubDomain::isINodeinITet(Vec3D nodeCoord, int iTet, SVec<double,3> &X)$/;"	f	class:SubDomain
isIgnited	ProgrammedBurn.h	/^  bool isIgnited(int tag) const { return myBurns[tag].ignited; }$/;"	f	class:ProgrammedBurn
isInitialized	MultiGridKernel.h	/^  bool isInitialized() const { return initialized; }$/;"	f	class:MultiGridKernel
isInitialized	MultiGridPrec.C	/^bool MultiGridPrec<Scalar,dim,Scalar2>::isInitialized() {$/;"	f	class:MultiGridPrec
isLine	MultiGridLevel.C	/^bool MultiGridLevel<Scalar>::isLine(int iSub,int edgei,int edgej,int* lineid,int* loci,int* locj)$/;"	f	class:MultiGridLevel
isLocationBased	IoData.h	/^    bool isLocationBased;  $/;"	m	struct:Probes::Node
isMultigridTsDesc	TsDesc.h	/^  bool isMultigridTsDesc;$/;"	m	class:TsDesc
isNearInterface	IntersectorFRG/IntersectorFRG.h	/^    bool isNearInterface(double t, int n) const                  {return false;}$/;"	f	class:IntersectorFRG
isNearInterface	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    bool isNearInterface(double t, int n) const {return closest[n].nearInterface();}$/;"	f	class:IntersectorPhysBAM
isNearInterface	LevelSet/MultiGridLevelSetStructure.h	/^    bool isNearInterface(double, int) const { return false; }$/;"	f	class:MultiGridLevelSetStructure
isOccluded	LevelSet/LevelSetStructure.h	/^    bool isOccluded(double t, int n) const                { return is_occluded[n]; }$/;"	f	class:LevelSetStructure
isPointInside	ElemTetCore.C	/^bool ElemTet::isPointInside(SVec<double,3> & X,const Vec3D& V) {$/;"	f	class:ElemTet
isPointOnSurface	IntersectorFRG/IntersectorFRG.C	/^double IntersectorFRG::isPointOnSurface(Vec3D pt, int N1, int N2, int N3) $/;"	f	class:IntersectorFRG
isPointOnSurface	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::isPointOnSurface(Vec3D pt, int N1, int N2, int N3) $/;"	f	class:IntersectorPhysBAM
isPointOnSurface	LevelSet/MultiGridLevelSetStructure.h	/^    double isPointOnSurface(Vec3D, int, int, int) { return 0.0; }$/;"	f	class:MultiGridLevelSetStructure
isPositive	IntersectorFRG/IntersectorFRG.C	/^  bool isConsistent, isPositive, hasBeenFixed;$/;"	m	class:ClosestTriangle	file:
isSend	Communicator.h	/^  int *isSend;  \/\/ wether this channel is a send or receive channel$/;"	m	class:CommPattern
isSinglePhase	OneDimensionalSolver.h	/^  bool isSinglePhase;$/;"	m	class:OneDimensional
isSixthOrder	OneDimensionalSolver.h	/^  bool isSixthOrder;$/;"	m	class:OneDimensional
isSubLocal	Communicator.h	/^  bool isSubLocal(int sub) { return glSubToCPU[sub] == cpuNum; }$/;"	f	class:SubDTopo
isSwept	LevelSet/LevelSetStructure.h	/^    bool isSwept(double t, int n) const                   { return is_swept[n]; }$/;"	f	class:LevelSetStructure
isUnburnedEOS	ProgrammedBurnCore.C	/^bool ProgrammedBurn::isUnburnedEOS(int eos,int& tag) const {$/;"	f	class:ProgrammedBurn
is_active	LevelSet/LevelSetStructure.h	/^    DistVec<bool> *is_active;$/;"	m	class:DistLevelSetStructure
is_active	LevelSet/LevelSetStructure.h	/^    Vec<bool> &is_active;$/;"	m	class:LevelSetStructure
is_active	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<bool> &is_active;$/;"	m	class:MultiGridLevelSetStructure
is_occluded	LevelSet/LevelSetStructure.h	/^    DistVec<bool> *is_occluded;$/;"	m	class:DistLevelSetStructure
is_occluded	LevelSet/LevelSetStructure.h	/^    Vec<bool> &is_occluded;$/;"	m	class:LevelSetStructure
is_occluded	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<bool> &is_occluded;$/;"	m	class:MultiGridLevelSetStructure
is_swept	LevelSet/LevelSetStructure.h	/^    DistVec<bool> *is_swept;$/;"	m	class:DistLevelSetStructure
is_swept	LevelSet/LevelSetStructure.h	/^    Vec<bool> &is_swept;$/;"	m	class:LevelSetStructure
is_swept	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<bool> &is_swept;$/;"	m	class:MultiGridLevelSetStructure
is_swept_helper	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<int> *is_swept_helper;$/;"	m	class:DistIntersectorPhysBAM
isamax_	arpack++/include/arlnames.h	143;"	d
isamax_	arpack++/include/arlnames.h	72;"	d
isc_binder	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef typename selector::template rebind<T1,T2> isc_binder;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_DISPATCH_BASE
iscope	IntersectorFRG/IntersectorFRG.h	/^    int *iscope; $/;"	m	class:IntersectorFRG
isoThermalwall	IntersectorFRG/IntersectorFRG.h	/^	 bool isoThermalwall;	 $/;"	m	class:DistIntersectorFRG
isoThermalwall	IntersectorPhysBAM/IntersectorPhysBAM.h	/^	 bool isoThermalwall;	 $/;"	m	class:DistIntersectorPhysBAM
isperrboundA	utils/Predicate.C	/^REAL isperrboundA, isperrboundB, isperrboundC;$/;"	v
isperrboundB	utils/Predicate.C	/^REAL isperrboundA, isperrboundB, isperrboundC;$/;"	v
isperrboundC	utils/Predicate.C	/^REAL isperrboundA, isperrboundB, isperrboundC;$/;"	v
it	FSI/DynamicNodalTransfer.h	/^  int it;$/;"	m	class:EmbeddedStructure
it0	DistDynamicVMSTerm.h	/^  int          it0;$/;"	m	class:DistDynamicVMSTerm
it0	DistEdgeGrad.h	/^  int it0;$/;"	m	class:DistEdgeGrad
it0	DistExtrapolation.h	/^  int it0;$/;"	m	class:DistExtrapolation
it0	DistVMSLESTerm.h	/^  int it0;$/;"	m	class:DistVMSLESTerm
it0	HeatTransferHandler.h	/^  int it0;$/;"	m	class:HeatTransferHandler
it0	MeshMotionHandler.h	/^  int it0;            \/\/<! restart timestep$/;"	m	class:EmbeddedMeshMotionHandler
it0	MeshMotionHandler.h	/^  int it0;$/;"	m	class:AeroMeshMotionHandler
it0	TsOutput.h	/^  int it0;$/;"	m	class:TsOutput
iteration	DistNodalGrad.h	/^  int iteration;$/;"	m	class:DistNodalGrad
iteration	ExactRiemannSolver.h	/^  int iteration;$/;"	m	class:ExactRiemannSolver
iteration	IoData.h	/^  int iteration;$/;"	m	struct:RestartParametersData
iteration	TsRestart.h	/^  int iteration;$/;"	m	class:TsRestart
iterations	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^    int iterations,max_iterations;$/;"	m	class:PhysBAM::ITERATIVE_SOLVER
iterativelvl	IoData.h	/^  int iterativelvl;$/;"	m	struct:WallDistanceMethodData
iterator	LevelSet/LevelSetStructure.h	/^	   iterator(double *x, int *n) : xip(x), nodep(n) { }$/;"	f	class:LevelSetResult::iterator
iterator	LevelSet/LevelSetStructure.h	/^   class iterator {$/;"	c	struct:LevelSetResult
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef T* iterator; \/\/ for stl$/;"	t	class:PhysBAM::ARRAY_BASE
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef ENTRY* iterator; \/\/ for stl$/;"	t	class:PhysBAM::HASHTABLE
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef T* iterator; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef T* iterator; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef T* iterator; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
iterator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef T* iterator; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
itr	MvpMatrix.h	/^    typename AuxilliaryRows::iterator itr;$/;"	m	struct:MvpMat::MvpAuxilliaryIterator
ix	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
ix	MeshMotionHandler.h	/^  double ix, iy, iz;$/;"	m	class:PitchingMeshMotionHandler
iy	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
iy	MeshMotionHandler.h	/^  double ix, iy, iz;$/;"	m	class:PitchingMeshMotionHandler
iz	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
iz	MeshMotionHandler.h	/^  double ix, iy, iz;$/;"	m	class:PitchingMeshMotionHandler
izamax_	arpack++/include/arlnames.h	118;"	d
izamax_	arpack++/include/arlnames.h	189;"	d
j0prime	ExactSolution.C	/^double j0prime(double r) {$/;"	f
ja	RectangularSparseMatrix.h	/^  Vec<int> ja;              \/\/ pointer to columns$/;"	m	class:RectangularSparseMat
ja	SparseMatrix.h	/^  Vec<int> ja;              \/\/ pointer to columns$/;"	m	class:SparseMat
jac	ImplicitRomTsDesc.h	/^  FullM jac;$/;"	m	class:ImplicitRomTsDesc
jacAction	IoData.h	/^  JacobianActionData jacAction;$/;"	m	struct:ROBConstructionData
jacActionBasisName	IoData.h	/^  const char *jacActionBasisName;$/;"	m	struct:NonlinearRomFilesData
jacActionBasisName	NonlinearRom.h	/^  char* jacActionBasisName;$/;"	m	class:NonlinearRom
jacActionBasisPrefix	IoData.h	/^  const char *jacActionBasisPrefix;$/;"	m	struct:NonlinearRomFilesData
jacActionBasisPrefix	NonlinearRom.h	/^  char* jacActionBasisPrefix;$/;"	m	class:NonlinearRom
jacActionPrefix	IoData.h	/^  const char *jacActionPrefix;$/;"	m	struct:NonlinearRomFilesData
jacActionSingValsName	IoData.h	/^  const char *jacActionSingValsName;$/;"	m	struct:NonlinearRomFilesData
jacActionSingValsName	NonlinearRom.h	/^  char* jacActionSingValsName;$/;"	m	class:NonlinearRom
jacActionSnapsFileNameSpecified	NonlinearRom.h	/^  bool jacActionSnapsFileNameSpecified;$/;"	m	class:NonlinearRom
jacActionSnapsName	IoData.h	/^  const char *jacActionSnapsName;$/;"	m	struct:NonlinearRomFilesData
jacActionSnapsName	NonlinearRom.h	/^  char* jacActionSnapsName;$/;"	m	class:NonlinearRom
jacApply	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
jacEvaluate	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
jacMat	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* jacMat;$/;"	m	class:NonlinearRom
jacflux3Dwater	FluxFcnDescTait.C	/^void jacflux3Dwater(int type, VarFcnBase *vf, FluxFcnBase::Type localTypeJac, double *normal,$/;"	f
jacinflux3D	FluxFcnDescSG.C	/^void jacinflux3D(int type, VarFcnBase *vf, FluxFcnBase::Type localTypeJac, $/;"	f
jacobian	GappyPreprocessing.h	/^	const int jacobian;$/;"	m	class:GappyPreprocessing
jacobianAA	SpaceOperator.h	/^  int jacobianAA;$/;"	m	class:SpaceOperator
jacobianSA	SpaceOperator.h	/^  int jacobianSA;$/;"	m	class:SpaceOperator
jactmp	ImplicitGappyTsDesc.h	/^  double *jactmp, *column;$/;"	m	class:ImplicitGappyTsDesc
jactmp	ImplicitPGTsDesc.h	/^	double *jactmp;$/;"	m	class:ImplicitPGTsDesc
join_cols	AlternatingLeastSquare/als_util.cpp	/^double *join_cols(double *mem, int M, int N, std::vector<unsigned int> colIndices) {$/;"	f
jprimex	IoData.h	/^  double jprimex, jprimey, jprimez;$/;"	m	struct:PorousMedia
jprimey	IoData.h	/^  double jprimex, jprimey, jprimez;$/;"	m	struct:PorousMedia
jprimez	IoData.h	/^  double jprimex, jprimey, jprimez;$/;"	m	struct:PorousMedia
ju	SparseMatrix.h	/^  Vec<int> ju;              \/\/ pointer to U factors in LU decomposition$/;"	m	class:SparseMat
jw	KspPrec.h	/^  DistVec<int> jw;$/;"	m	class:IluPrec
jwlModel	IoData.h	/^  JWLModelData jwlModel;$/;"	m	struct:FluidModelData
jwlRelaxationFactor	IoData.h	/^  double jwlRelaxationFactor;$/;"	m	struct:MultiFluidData
jwlZeroSoundSpeedJwlDensity	LocalRiemannDesc.h	/^double LocalRiemannGfmpar::jwlZeroSoundSpeedJwlDensity(const double density, const double pressure)$/;"	f	class:LocalRiemannGfmpar
jx	MeshMotionHandler.h	/^  double jx, jy, jz;$/;"	m	class:PitchingMeshMotionHandler
jy	MeshMotionHandler.h	/^  double jx, jy, jz;$/;"	m	class:PitchingMeshMotionHandler
jz	MeshMotionHandler.h	/^  double jx, jy, jz;$/;"	m	class:PitchingMeshMotionHandler
k	IoData.h	/^  double k;$/;"	m	struct:PreconditionData
k1	ExplicitEmbeddedTsDesc.h	/^  DistSVec<double,dim> k1;$/;"	m	class:ExplicitEmbeddedTsDesc
k1	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> k1;$/;"	m	class:ExplicitLevelSetTsDesc
k1	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> k1;$/;"	m	class:ExplicitMultiPhysicsTsDesc
k1	ExplicitTsDesc.h	/^  DistSVec<double,dim> k1;$/;"	m	class:ExplicitTsDesc
k1	RKIntegrator.h	/^  T* k1,*k2,*k3,*k4;$/;"	m	class:RKIntegrator
k1water	IoData.h	/^  double k1water;$/;"	m	struct:LiquidModelData
k2	ExplicitEmbeddedTsDesc.h	/^  DistSVec<double,dim> k2;$/;"	m	class:ExplicitEmbeddedTsDesc
k2	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> k2;$/;"	m	class:ExplicitLevelSetTsDesc
k2	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> k2;$/;"	m	class:ExplicitMultiPhysicsTsDesc
k2	ExplicitTsDesc.h	/^  DistSVec<double,dim> k2;$/;"	m	class:ExplicitTsDesc
k2	RKIntegrator.h	/^  T* k1,*k2,*k3,*k4;$/;"	m	class:RKIntegrator
k2water	IoData.h	/^  double k2water;$/;"	m	struct:LiquidModelData
k3	ExplicitEmbeddedTsDesc.h	/^  DistSVec<double,dim> k3;$/;"	m	class:ExplicitEmbeddedTsDesc
k3	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> k3;$/;"	m	class:ExplicitLevelSetTsDesc
k3	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> k3;$/;"	m	class:ExplicitMultiPhysicsTsDesc
k3	ExplicitTsDesc.h	/^  DistSVec<double,dim> k3;$/;"	m	class:ExplicitTsDesc
k3	RKIntegrator.h	/^  T* k1,*k2,*k3,*k4;$/;"	m	class:RKIntegrator
k4	ExplicitEmbeddedTsDesc.h	/^  DistSVec<double,dim> k4;$/;"	m	class:ExplicitEmbeddedTsDesc
k4	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> k4;$/;"	m	class:ExplicitLevelSetTsDesc
k4	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dim> k4;$/;"	m	class:ExplicitMultiPhysicsTsDesc
k4	ExplicitTsDesc.h	/^  DistSVec<double,dim> k4;$/;"	m	class:ExplicitTsDesc
k4	RKIntegrator.h	/^  T* k1,*k2,*k3,*k4;$/;"	m	class:RKIntegrator
kMeansRandSeed	IoData.h	/^  int kMeansRandSeed;$/;"	m	struct:ClusteringData
kMeansTol	IoData.h	/^  double kMeansTol;$/;"	m	struct:ClusteringData
kc	SparseMatrix.h	/^  int *kc;                  \/\/ pointer to cols, transposed$/;"	m	class:SparseMat
ke	IoData.h	/^  KEModelData ke;$/;"	m	struct:TurbulenceModelData
keep	arpack++/include/arunsmat.h	/^  int     keep[20];$/;"	m	class:ARumNonSymMatrix
keep	arpack++/include/arusmat.h	/^  int     keep[20];$/;"	m	class:ARumSymMatrix
kenergy	IoData.h	/^  double kenergy;$/;"	m	struct:BcsFreeStreamData
kenergy	IoData.h	/^  double kenergy;$/;"	m	struct:BoundaryData
kenergy	RefVal.h	/^  double kenergy;$/;"	m	class:RefVal
kenergy0	EmbeddedFluidShapeOptimizationHandler.h	/^  double kenergy0;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
kenergy0	FluidCollocationShapeOptimizationHandler.h	/^  double kenergy0; $/;"	m	class:FluidCollocationShapeOptimizationHandler
kenergy0	FluidGnatShapeOptimizationHandler.h	/^  double kenergy0; $/;"	m	class:FluidGnatShapeOptimizationHandler
kenergy0	FluidMetricShapeOptimizationHandler.h	/^  double kenergy0; $/;"	m	class:FluidMetricShapeOptimizationHandler
kenergy0	FluidRomShapeOptimizationHandler.h	/^  double kenergy0; $/;"	m	class:FluidRomShapeOptimizationHandler
kenergy0	FluidShapeOptimizationHandler.h	/^  double kenergy0; $/;"	m	class:FluidShapeOptimizationHandler
key	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK,class T> struct HASHTABLE_ENTRY_TEMPLATE{HASHTABLE_ENTRY_STATE state;TK key;T data;};$/;"	m	struct:PhysBAM::HASHTABLE_ENTRY_TEMPLATE
key	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK> struct HASHTABLE_ENTRY_TEMPLATE<TK,void>{HASHTABLE_ENTRY_STATE state;TK key;};$/;"	m	struct:PhysBAM::HASHTABLE_ENTRY_TEMPLATE
kirchhoffNodeDistInfo	Domain.h	/^  DistInfo *kirchhoffNodeDistInfo;$/;"	m	class:Domain
kirchhoffNodesList	SubDomain.h	/^  std::set<int> kirchhoffNodesList;$/;"	m	class:SubDomain
kk	SparseMatrix.h	/^  int *kk;                  \/\/ pointer to data, transposed$/;"	m	class:SparseMat
kmeans	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::kmeans() {$/;"	f	class:NonlinearRomDatabaseConstruction
kmeansBoundType	IoData.h	/^  enum KmeansBoundType {TIGHT_BOUNDS = 0, LOOSE_BOUNDS = 1} kmeansBoundType;$/;"	m	struct:ClusteringData	typeref:enum:ClusteringData::KmeansBoundType
kmeansWithBounds	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::kmeansWithBounds() {$/;"	f	class:NonlinearRomDatabaseConstruction
known	LevelSet/LevelSetStructure.h	/^  bool known() {return mode!=-2;}$/;"	f	struct:ClosestPoint
kprimex	IoData.h	/^  double kprimex, kprimey, kprimez;$/;"	m	struct:PorousMedia
kprimey	IoData.h	/^  double kprimex, kprimey, kprimez;$/;"	m	struct:PorousMedia
kprimez	IoData.h	/^  double kprimex, kprimey, kprimez;$/;"	m	struct:PorousMedia
kr	SparseMatrix.h	/^  int *kr;                  \/\/ pointer to rows, transposed$/;"	m	class:SparseMat
krylov	IoData.h	/^  KrylovData krylov;$/;"	m	struct:ROBConstructionData
krylov	IoData.h	/^  NonlinearRomOnlineNonStateData krylov;$/;"	m	struct:NonlinearRomOnlineData
krylov	IoData.h	/^  NonlinearRomOnlineNonStateData krylov;$/;"	m	struct:RelativeProjectionErrorData
krylovBasisCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<std::vector<std::vector<double> > > > krylovBasisCentersDifProduct; \/\/[iCluster][mCenter][pCenter][:]$/;"	m	class:NonlinearRom
krylovBasisName	IoData.h	/^  const char *krylovBasisName;$/;"	m	struct:NonlinearRomFilesData
krylovBasisName	NonlinearRom.h	/^  char* krylovBasisName;$/;"	m	class:NonlinearRom
krylovBasisPrefix	IoData.h	/^  const char *krylovBasisPrefix;$/;"	m	struct:NonlinearRomFilesData
krylovBasisPrefix	NonlinearRom.h	/^  char* krylovBasisPrefix;$/;"	m	class:NonlinearRom
krylovDistanceComparisonInfoName	IoData.h	/^  const char *krylovDistanceComparisonInfoName;$/;"	m	struct:NonlinearRomFilesData
krylovDistanceComparisonInfoName	NonlinearRom.h	/^  char* krylovDistanceComparisonInfoName;$/;"	m	class:NonlinearRom
krylovEnergy	KspBinaryOutput.h	/^  double krylovEnergy;$/;"	m	class:KspBinaryOutput
krylovFreqNewton	KspBinaryOutput.h	/^  int krylovFreqNewton;$/;"	m	class:KspBinaryOutput
krylovFreqTime	KspBinaryOutput.h	/^  int krylovFreqTime;$/;"	m	class:KspBinaryOutput
krylovOutputFreqNewton	IoData.h	/^  int krylovOutputFreqNewton;$/;"	m	struct:ROMOutputData
krylovOutputFreqTime	IoData.h	/^  int krylovOutputFreqTime;$/;"	m	struct:ROMOutputData
krylovPrefix	IoData.h	/^  const char *krylovPrefix;$/;"	m	struct:NonlinearRomFilesData
krylovSingValsName	IoData.h	/^  const char *krylovSingValsName;$/;"	m	struct:NonlinearRomFilesData
krylovSingValsName	NonlinearRom.h	/^  char* krylovSingValsName;$/;"	m	class:NonlinearRom
krylovSnapFile	IoData.h	/^  const char *krylovSnapFile;$/;"	m	struct:InputData
krylovSnapsName	IoData.h	/^  const char *krylovSnapsName;$/;"	m	struct:NonlinearRomFilesData
krylovSnapsName	NonlinearRom.h	/^  char* krylovSnapsName;$/;"	m	class:NonlinearRom
krylovVector	IoData.h	/^  const char *krylovVector;$/;"	m	struct:ROMOutputData
krylovVectorEnergy	IoData.h	/^  double krylovVectorEnergy;$/;"	m	struct:ROMOutputData
ksp	EmbeddedFluidShapeOptimizationHandler.h	/^  KspSolver<DistEmbeddedVec<double,dim>, MatVecProd<dim,dim>, KspPrec<dim>, Communicator> *ksp;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
ksp	FluidShapeOptimizationHandler.h	/^  KspSolver<DistSVec<double,dim>, MatVecProd<dim,dim>, KspPrec<dim>, Communicator> *ksp;$/;"	m	class:FluidShapeOptimizationHandler
ksp	ImplicitCoupledTsDesc.h	/^  KspSolver<DistSVec<double,dim>, MatVecProd<dim,dim>, KspPrec<dim>, Communicator> *ksp;$/;"	m	class:ImplicitCoupledTsDesc
ksp	ImplicitEmbeddedCoupledTsDesc.h	/^  KspSolver<DistEmbeddedVec<double,dim>, MatVecProd<dim,dim>, KspPrec<dim>, Communicator> *ksp;$/;"	m	class:ImplicitEmbeddedCoupledTsDesc
ksp	ImplicitLevelSetTsDesc.h	/^            KspPrec<dim>, Communicator> *ksp;$/;"	m	class:ImplicitLevelSetTsDesc
ksp	ImplicitMultiPhysicsTsDesc.h	/^            KspPrec<dim>, Communicator> *ksp;$/;"	m	class:ImplicitMultiPhysicsTsDesc
ksp	IoData.h	/^  GenericKrylov ksp;$/;"	m	struct:NewtonData
ksp	IoData.h	/^  KspData ksp;$/;"	m	struct:SensitivityAnalysis
ksp	MeshMotionSolver.h	/^  KspSolver<DistSVec<double,3>, StiffMat<double,3>, KspPrec<3>, Communicator> *ksp;$/;"	m	class:TetMeshMotionSolver
ksp	Modal.h	/^    KspSolver<DistSVec<double,dim>, MatVecProd<dim, dim>, KspPrec<dim, double>, Communicator> *ksp;$/;"	m	class:ModalSolver
ksp1	ImplicitEmbeddedSegTsDesc.h	/^  KspSolver<DistEmbeddedVec<double,neq1>, MatVecProd<dim,neq1>, KspPrec<neq1>, Communicator> *ksp1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
ksp1	ImplicitSegTsDesc.h	/^  KspSolver<DistSVec<double,neq1>, MatVecProd<dim,neq1>, KspPrec<neq1>, Communicator> *ksp1;$/;"	m	class:ImplicitSegTsDesc
ksp2	ImplicitEmbeddedSegTsDesc.h	/^  KspSolver<DistEmbeddedVec<double,neq2>, MatVecProd<dim,neq2>, KspPrec<neq2>, Communicator> *ksp2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
ksp2	ImplicitSegTsDesc.h	/^  KspSolver<DistSVec<double,neq2>, MatVecProd<dim,neq2>, KspPrec<neq2>, Communicator> *ksp2;$/;"	m	class:ImplicitSegTsDesc
ksp2	Modal.h	/^    KspSolver<DistSVec<double,dim>, MatVecProd<dim, dim>, KspPrec<dim, double>, Communicator> *ksp2;$/;"	m	class:ModalSolver
ksp3	Modal.h	/^    KspSolver<DistSVec<double,dim>, MatVecProd<dim, dim>, KspPrec<dim, double>, Communicator> *ksp3;$/;"	m	class:ModalSolver
kspBinaryOutput	ImplicitTsDesc.h	/^  KspBinaryOutput<DistSVec<double, dim> > *kspBinaryOutput; $/;"	m	class:ImplicitTsDesc
kspBinaryOutput	KspSolver.h	/^  KspBinaryOutput<VecType> *kspBinaryOutput;$/;"	m	class:KspSolver
kspComp	Modal.h	/^    KspSolver<DistSVec<bcomp,dim>, MatVecProd<dim, dim>, KspPrec<dim, bcomp>, Communicator, bcomp> *kspComp;$/;"	m	class:ModalSolver
kspCompGcr	Modal.h	/^    GcrSolver<DistSVec<bcomp,dim>, MatVecProd<dim, dim>, KspPrec<dim, bcomp>, Communicator, bcomp> *kspCompGcr;$/;"	m	class:ModalSolver
kspConvCriterion	KspSolver.h	/^  KspConvCriterion *kspConvCriterion;$/;"	m	class:KspSolver
kspData	Modal.h	/^    KspData kspData;$/;"	m	class:ModalSolver
kspIndex	KspBinaryOutput.C	/^  int kspIndex; \/\/ index of corresponding krylov Vector$/;"	m	struct:kspSortStruct	file:
kspLS	ImplicitLevelSetTsDesc.h	/^  KspSolver<DistSVec<double,dimLS>, MatVecProdLS<dim,dimLS>, KspPrec<dimLS>, Communicator> *kspLS;$/;"	m	class:ImplicitLevelSetTsDesc
kspLS	ImplicitMultiPhysicsTsDesc.h	/^  KspSolver<DistSVec<double,dimLS>, MatVecProdLS<dim,dimLS>, KspPrec<dimLS>, Communicator> *kspLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
kspSortStruct	KspBinaryOutput.C	/^struct kspSortStruct {$/;"	s	file:
kturb	IoData.h	/^  const char *kturb;$/;"	m	struct:TransientData
ku	SparseMatrix.h	/^  int *ku;                  \/\/ pointer to L factors, transposed$/;"	m	class:SparseMat
lacpy	arpack++/include/lapackc.h	/^inline void lacpy(const char* uplo, const ARint &m, const ARint &n,$/;"	f
laguer	utils/Laguerre.C	/^int laguer(bcomp *a, int degree, bcomp &x, int &its)$/;"	f
lambdaSDisp	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> lambdaSDisp;$/;"	m	class:FluidShapeOptimizationHandler
lambdaU	FluidShapeOptimizationHandler.h	/^  DistSVec<double,dim> lambdaU;$/;"	m	class:FluidShapeOptimizationHandler
lambdaX	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> lambdaX;$/;"	m	class:FluidShapeOptimizationHandler
lapy2	arpack++/include/lapackc.h	/^inline double lapy2(const double &x, const double &y) {$/;"	f
lapy2	arpack++/include/lapackc.h	/^inline float lapy2(const float &x, const float &y) {$/;"	f
largestDimension	DistLeastSquareSolver.h	/^  int largestDimension() const { return largestDimension_; } \/\/ = max(equationCount, unknownCount)$/;"	f	class:DistLeastSquareSolver
largestDimension_	DistLeastSquareSolver.h	/^  int largestDimension_, rhsCount_;$/;"	m	class:DistLeastSquareSolver
last	TsOutput.h	/^    int* last;$/;"	m	struct:TsOutput::__anon29
lastConfig	DistDynamicVMSTerm.h	/^  int          lastConfig;$/;"	m	class:DistDynamicVMSTerm
lastConfig	DistEdgeGrad.h	/^  int lastConfig;$/;"	m	class:DistEdgeGrad
lastConfig	DistExtrapolation.h	/^  int lastConfig;$/;"	m	class:DistExtrapolation
lastConfig	DistNodalGrad.h	/^  int lastConfig;$/;"	m	class:DistNodalGrad
lastConfig	DistVMSLESTerm.h	/^  int lastConfig;$/;"	m	class:DistVMSLESTerm
lastConfig	EdgeGalerkin.h	/^  int lastConfig;$/;"	m	class:EdgeGalerkin
lastConfigSA	DistNodalGrad.h	/^  int lastConfigSA;$/;"	m	class:DistNodalGrad
lastIt	DistDynamicVMSTerm.h	/^  int          lastIt;$/;"	m	class:DistDynamicVMSTerm
lastIt	DistEdgeGrad.h	/^  int lastIt;$/;"	m	class:DistEdgeGrad
lastIt	DistExtrapolation.h	/^  int lastIt;$/;"	m	class:DistExtrapolation
lastIt	DistVMSLESTerm.h	/^  int lastIt;$/;"	m	class:DistVMSLESTerm
lastLSUpdateIteration	MultiPhysicsTsDesc.h	/^  int lastLSUpdateIteration;$/;"	m	class:MultiPhysicsTsDesc
lastPhaseChangeState	HigherOrderFSI.h	/^   void* lastPhaseChangeState;$/;"	m	class:HigherOrderFSI
lastPhaseChangeState	HigherOrderMultiFluid.h	/^   void* lastPhaseChangeState;$/;"	m	class:HigherOrderMultiFluid
lastPhaseChangeValue	OneDimensionalSolver.h	/^  SVec<double,5> lastPhaseChangeValue;$/;"	m	class:OneDimensional
lastTime	ProgrammedBurn.h	/^  double lastTime;$/;"	m	class:ProgrammedBurn
last_alloca_header	tools/alloca.cougar.c	/^static header *last_alloca_header = NULL;	\/* -> last alloca header.  *\/$/;"	v	file:
latest	FSI/CrackingSurface.h	/^  LatestCracking latest;$/;"	m	class:CrackingSurface
lawtype	IoData.h	/^  enum LawType {VELOCITYPOINTS = 0, CONSTANTACCELERATION = 1} lawtype;$/;"	m	struct:RigidMeshMotionData	typeref:enum:RigidMeshMotionData::LawType
layers	IoData.h	/^  int layers;$/;"	m	struct:GappyConstructionData
lda	arpack++/include/arbnsmat.h	/^  int      lda;$/;"	m	class:ARbdNonSymMatrix
lda	arpack++/include/arbsmat.h	/^  int      lda;$/;"	m	class:ARbdSymMatrix
lda	arpack++/include/arlsupm.h	/^    int lda;      \/* leading dimension *\/$/;"	m	struct:__anon50
ldcomplex	arpack++/include/arlcomp.h	/^typedef struct { double r, i; } ldcomplex;$/;"	t	typeref:struct:__anon30
ldr	IoData.h	/^  double idr,ldr;$/;"	m	struct:PorousMedia
leadDim	Communicator.h	/^    int leadDim;$/;"	m	struct:SubRecInfo
leastSquareSolver	AlternatingLeastSquare/als_io.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	m	struct:EmbeddedAlternatingLeastSquareData	typeref:enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
leastSquareSolver	IoData.h	/^    enum LeastSquareSolver {QR = 0, SVD = 1} leastSquareSolver;$/;"	m	struct:EmbeddedAlternatingLeastSquareData	typeref:enum:EmbeddedAlternatingLeastSquareData::LeastSquareSolver
leastSquaresReconstruction	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::leastSquaresReconstruction() {$/;"	f	class:GappyPreprocessing
leastSquaresSolver	ImplicitGnatTsDesc.h	/^  DistLeastSquareSolver leastSquaresSolver;$/;"	m	class:ImplicitGnatTsDesc
leaves	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    int leaves,root;$/;"	m	class:PhysBAM::BOX_HIERARCHY
left	KDTree.h	/^    KDTreeNode* left,*right;$/;"	m	struct:KDTree::KDTreeNode
left	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    KD_TREE_NODE<T>* left;$/;"	m	class:PhysBAM::KD_TREE_NODE
leftTree	IntersectorFRG/Geometry/KDTree.h	/^     KDTree<Obj, dim, CompType> *leftTree, *rightTree;$/;"	m	class:KDTree
len	Communicator.h	/^    int len;$/;"	m	struct:SubRecInfo
len	Communicator.h	/^  int cpu, len;$/;"	m	struct:RecInfo
len	Vector.h	/^  int len;$/;"	m	class:Diff
len	Vector.h	/^  int len;$/;"	m	class:Div
len	Vector.h	/^  int len;$/;"	m	class:Expr
len	Vector.h	/^  int len;$/;"	m	class:InnerProd
len	Vector.h	/^  int len;$/;"	m	class:OuterProd
len	Vector.h	/^  int len;$/;"	m	class:SVec
len	Vector.h	/^  int len;$/;"	m	class:Sum
len	Vector.h	/^  int len;$/;"	m	class:Vec
len	VectorSet.h	/^  const typename VecType::InfoType &len;$/;"	m	class:VecSet
length	Communicator.h	/^    int length;$/;"	m	class:Communication::Window
length	Edge.h	/^  double length(int iedge) const {$/;"	f	class:EdgeSet
length	EmbeddedFluidShapeOptimizationHandler.h	/^  double length;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDES
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDESmean
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKE
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKEmean
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermNS
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSA
length	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSAmean
length	FluidCollocationShapeOptimizationHandler.h	/^  double length;$/;"	m	class:FluidCollocationShapeOptimizationHandler
length	FluidGnatShapeOptimizationHandler.h	/^  double length;$/;"	m	class:FluidGnatShapeOptimizationHandler
length	FluidMetricShapeOptimizationHandler.h	/^  double length;$/;"	m	class:FluidMetricShapeOptimizationHandler
length	FluidRomShapeOptimizationHandler.h	/^  double length;$/;"	m	class:FluidRomShapeOptimizationHandler
length	FluidShapeOptimizationHandler.h	/^  double length;$/;"	m	class:FluidShapeOptimizationHandler
length	IoData.h	/^  double length;$/;"	m	struct:ReferenceStateData
length	IoData.h	/^  double length;$/;"	m	struct:TransientData
length	RefVal.h	/^  double length;$/;"	m	class:RefVal
length	TsOutput.h	/^  double length;$/;"	m	class:TsOutput
lenstr	f77src/printmask.f	/^      integer function lenstr(/;"	f
les	IoData.h	/^  LESModelData les;$/;"	m	struct:TurbulenceClosureData
level	MultiGridKspSolver.h	/^  MultiGridLevel<Scalar>* level;                                                                      $/;"	m	class:MultiGridJacobiPrec
level	MultiGridKspSolver.h	/^  MultiGridLevel<Scalar>* level;$/;"	m	class:MultiGridRASPrec
levelPat	Domain.h	/^  CommPattern<int> *levelPat;$/;"	m	class:Domain
levelSet	MatVecProd.h	/^  LevelSet<dimLS> *levelSet;$/;"	m	class:MatVecProdLS
levelSet	Timer.h	/^		binread, binwrite, levelSet, lsNodalWeightsAndGrad, lsFvTerm,$/;"	e	enum:Timer::TimerIndex
levelSetDerivative	OneDimensionalSolver.C	/^void OneDimensional::levelSetDerivative(double t0, Vec<double>& phi, Vec<double>& k) {$/;"	f	class:OneDimensional
levelSetMap	ExactRiemannSolver.h	/^  int levelSetMap[10][10];$/;"	m	class:ExactRiemannSolver
levelSetMethod	IoData.h	/^                        TRIANGULATED = 4} levelSetMethod;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::LevelSetMethod
levelSetMethod	OneDimensionalSolver.h	/^  int levelSetMethod;$/;"	m	class:OneDimensional
levelSetSign	ExactRiemannSolver.h	/^  double levelSetSign[10][10];$/;"	m	class:ExactRiemannSolver
levelSubDTopo	MultiGridLevel.h	/^    SubDTopo* levelSubDTopo;$/;"	m	class:MultiGridLevel
levelsets	IoData.h	/^  const char *levelsets;$/;"	m	struct:InputData
levelsets	IoData.h	/^  const char *levelsets;$/;"	m	struct:RestartData
levelsets	TsInput.h	/^  char *levelsets;$/;"	m	struct:TsInput
levelsets	TsRestart.h	/^  char *levelsets[3];$/;"	m	class:TsRestart
levenbergMarquardtWeight	ImplicitRomTsDesc.h	/^  double levenbergMarquardtWeight;$/;"	m	class:ImplicitRomTsDesc
levenbergMarquardtWeight	IoData.h	/^  double levenbergMarquardtWeight;$/;"	m	struct:NonlinearRomOnlineData
lift	IoData.h	/^  const char *lift;$/;"	m	struct:TransientData
lift	TsOutput.h	/^  char *lift;$/;"	m	class:TsOutput
limit	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::limit(RecFcn *recFcn, DistSVec<double,3> &X,$/;"	f	class:DistNodalGrad
limitDerivative	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::limitDerivative(RecFcn *recFcn, DistSVec<double,3> &X, DistSVec<double,3> &dX,$/;"	f	class:DistNodalGrad
limitExtrap	HigherOrderFSI.h	/^   bool limitExtrap;$/;"	m	class:HigherOrderFSI
limitExtrap	HigherOrderMultiFluid.h	/^   bool limitExtrap;$/;"	m	class:HigherOrderMultiFluid
limitExtrapolation	HigherOrderFSI.h	/^   bool limitExtrapolation() const { return limitExtrap; }$/;"	f	class:HigherOrderFSI
limitExtrapolation	HigherOrderMultiFluid.h	/^   bool limitExtrapolation() const { return limitExtrap; }$/;"	f	class:HigherOrderMultiFluid
limitHigherOrderExtrapolation	LevelSetTsDesc.h	/^  bool limitHigherOrderExtrapolation;$/;"	m	class:LevelSetTsDesc
limitHigherOrderExtrapolation	MultiPhysicsTsDesc.h	/^  int limitHigherOrderExtrapolation;$/;"	m	class:MultiPhysicsTsDesc
limitPeak	IoData.h	/^  int limitPeak;$/;"	m	struct:ProgrammedBurnData
limiter	IoData.h	/^                EXTENDEDVANALBADA = 5} limiter;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::Limiter
limiterLeft	OneDimensionalSolver.h	/^  int limiterLeft,limiterRight;$/;"	m	class:OneDimensional
limiterRight	OneDimensionalSolver.h	/^  int limiterLeft,limiterRight;$/;"	m	class:OneDimensional
linRecAtInterface	EmbeddedTsDesc.h	/^  bool linRecAtInterface, viscSecOrder;$/;"	m	class:EmbeddedTsDesc
linRecAtInterface	MatVecProd.h	/^    bool linRecAtInterface, viscSecOrder;$/;"	m	struct:MatVecProd::_fsi
linRecAtInterface	MatVecProd.h	/^    bool linRecAtInterface, viscSecOrder;$/;"	m	struct:MatVecProdMultiPhase::_fsi
linRecAtInterface	MultiPhysicsTsDesc.h	/^  bool linRecAtInterface, viscSecOrder;$/;"	m	class:MultiPhysicsTsDesc
lindex	arpack++/include/arunsmat.h	/^  int     lindex;$/;"	m	class:ARumNonSymMatrix
lindex	arpack++/include/arusmat.h	/^  int     lindex;$/;"	m	class:ARumSymMatrix
lineIDMap	MultiGridLevel.h	/^    DistVec<int> *lineIDMap;$/;"	m	class:MultiGridLevel
lineJacobiMatrices	MultiGridSmoothingMatrix.h	/^  BlockTridiagonalMatrix<Scalar,dim>** lineJacobiMatrices;$/;"	m	class:MultiGridSmoothingMatrix
lineLength	MultiGridLevel.h	/^    int lineLength(int iSub, int lineid) { return lineLengths[iSub][lineid]; } $/;"	f	class:MultiGridLevel
lineLengths	MultiGridLevel.h	/^    int** lineLengths;$/;"	m	class:MultiGridLevel
lineLocIDMap	MultiGridLevel.h	/^    DistVec<int> *lineLocIDMap;$/;"	m	class:MultiGridLevel
lineMap	MultiGridLevel.h	/^    DistSVec<int, 2>* lineMap;$/;"	m	class:MultiGridLevel
linePlots	IoData.h	/^  ObjectMap<LinePlot> linePlots;$/;"	m	struct:TransientData
lineSearch	ImplicitRomTsDesc.C	/^double ImplicitRomTsDesc<dim>::lineSearch(DistSVec<double, dim> &Q, Vec<double> &prom, int it, VecSet<DistSVec<double, dim> > &leftProj, double eps, bool &convergeFlag){$/;"	f	class:ImplicitRomTsDesc
lineSearch	IoData.h	/^  LineSearchData lineSearch;$/;"	m	struct:NewtonData
lineSearch	IoData.h	/^  enum LineSearch {LINE_SEARCH_FALSE = 0, LINE_SEARCH_BACKTRACKING = 1, LINE_SEARCH_WOLF = 2} lineSearch;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::LineSearch
line_output	TsOutput.h	/^  struct line_output {$/;"	s	class:TsOutput
line_outputs	TsOutput.h	/^  std::vector<line_output*> line_outputs;$/;"	m	class:TsOutput
linear	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TV linear;$/;"	m	class:PhysBAM::TWIST
linear	RecFcn.h	/^void RecFcn::linear(double Vi, double ddVij, double Vj, double ddVji, $/;"	f	class:RecFcn
linearDerivative	RecFcn.h	/^void RecFcn::linearDerivative(double dVi, double dddVij, double dVj, double dddVji,$/;"	f	class:RecFcn
linearSystemForm	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
linearSystemSolve	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
linear_expansion_sum	utils/Predicate.C	/^int linear_expansion_sum(int elen, REAL *e, int flen, REAL *f, REAL *h)         $/;"	f
linear_expansion_sum_zeroelim	utils/Predicate.C	/^int linear_expansion_sum_zeroelim(int elen, REAL *e, int flen, REAL *f, REAL *h)$/;"	f
linear_solve_LS	AlternatingLeastSquare/als_util.cpp	/^double* linear_solve_LS(double *A, double *b, int nrow, int ncol) {$/;"	f
linear_solve_QR	AlternatingLeastSquare/als_util.cpp	/^double *linear_solve_QR(double *A, double *b, int nrow, int ncol) {$/;"	f
linear_solve_SVD	AlternatingLeastSquare/als_util.cpp	/^double *linear_solve_SVD(double *A, double *b, int nrow, int ncol) {$/;"	f
linearizedData	IoData.h	/^  LinearizedData linearizedData;$/;"	m	class:IoData
lineids	MultiGridLevel.h	/^    std::vector<int>* lineids;$/;"	m	class:MultiGridLevel
link	tools/alloca.cougar.c	/^    long link;			\/* Address of trailer block of previous$/;"	m	struct:stk_trailer	file:
linpackSVD	NonlinearRom.C	/^void NonlinearRom<dim>::linpackSVD(double* tmpMat, int rows, int columns, double*& yVec, double*& singVals, double*& zVec) {$/;"	f	class:NonlinearRom
liquidModel	IoData.h	/^  LiquidModelData liquidModel;$/;"	m	struct:FluidModelData
load	EmbeddedFluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *load;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
load	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> *load;$/;"	m	class:FluidShapeOptimizationHandler
load1DMesh	OneDimensionalSolver.C	/^void OneDimensional::load1DMesh(IoData& ioData,int& numPts,double* &meshPoints) {$/;"	f	class:OneDimensional
loadCluster	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::loadCluster(int closestCluster, bool clusterSwitch, DistSVec<double, dim> &U) {$/;"	f	class:ImplicitRomTsDesc
loadExactInterfaceFile	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::loadExactInterfaceFile(IoData& ioData, const char* file) {$/;"	f	class:LevelSetTsDesc
loadSparseGrid	OneDimensionalSolver.C	/^void OneDimensional::loadSparseGrid(IoData& ioData) {$/;"	f	class:OneDimensional
loc	LevelSetTsDesc.h	/^    double time,loc;$/;"	m	struct:LevelSetTsDesc::exactInterfacePoint
locAlloc	DistTimeState.h	/^  bool locAlloc;$/;"	m	class:DistTimeState
locAlloc	SpaceOperator.h	/^  bool locAlloc;$/;"	m	class:SpaceOperator
locAlloc	Vector.h	/^  bool locAlloc;$/;"	m	class:SVec
locAlloc	Vector.h	/^  bool locAlloc;$/;"	m	class:Vec
locAllocGap	CorotSolver.h	/^  bool locAllocGap;$/;"	m	class:CorotSolver
locError	GappyPreprocessing.h	/^	VecSubDomainData<dim> locError;$/;"	m	class:GappyPreprocessing
locIndex	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int locIndex,globIndex;$/;"	m	class:IntersectorPhysBAM
locNodeId	TsOutput.h	/^    int* locNodeId;$/;"	m	struct:TsOutput::__anon29
locNodeSample	GappyPreprocessing.h	/^	std::vector<int> cpuSample, locSubSample, locNodeSample;$/;"	m	class:GappyPreprocessing
locSampleNodes	SubDomain.h	/^  std::vector<int> locSampleNodes;	\/\/ for Gappy ROM$/;"	m	class:SubDomain
locSendReceive	ParallelRom.h	/^	int *locSendReceive;$/;"	m	class:ParallelRom
locSubDomains	GappyPreprocessing.h	/^  std::vector <int> *locSubDomains;	\/\/ globalNodes[iSampleNode][iNode] is the global node number of the iNode in the iSampleNode island $/;"	m	class:GappyPreprocessing
locSubNum	Communicator.h	/^  int locSubNum(int sub) { return glSubToLocal[sub]; }$/;"	f	class:SubDTopo
locSubNum	InletNode.h	/^        int locSubNum;$/;"	m	class:InletNodeSet
locSubNum	SubDomain.h	/^  int locSubNum;$/;"	m	class:SubDomain
locSubSample	GappyPreprocessing.h	/^	std::vector<int> cpuSample, locSubSample, locNodeSample;$/;"	m	class:GappyPreprocessing
locSubToGlobSub	DistInfo.h	/^  int *locSubToGlobSub;$/;"	m	struct:DistInfo
locToGlobElemMap	SubDomain.h	/^  int *locToGlobElemMap;$/;"	m	class:SubDomain
locToGlobFaceMap	SubDomain.h	/^  int *locToGlobFaceMap;$/;"	m	class:SubDomain
locToGlobMap	MultiGridLevel.h	/^    mutable std::map<int,std::map<int,int> > locToGlobMap;$/;"	m	class:MultiGridLevel
locToGlobMap	MultiGridLevel.h	/^  int* locToGlobMap;$/;"	m	struct:MultigridSubdomain
locToGlobNodeMap	IntersectorFRG/IntersectorFRG.h	/^    int *locToGlobNodeMap;$/;"	m	class:IntersectorFRG
locToGlobNodeMap	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int *locToGlobNodeMap;$/;"	m	class:IntersectorPhysBAM
locToGlobNodeMap	SubDomain.h	/^  int *locToGlobNodeMap;$/;"	m	class:SubDomain
locU	OneDimensionalSolver.C	/^  SVec<double,5>& locU;$/;"	m	class:LevelSetSource	file:
loc_edge	MultiGridLevel.C	/^struct loc_edge {$/;"	s	file:
localColIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::localColIdx(int globalColIdx) const {$/;"	f	class:DistLeastSquareSolver
localCols	DistLeastSquareSolver.h	/^  int localCols()         const { return localCols_;         }$/;"	f	class:DistLeastSquareSolver
localCols_	DistLeastSquareSolver.h	/^  int localRows_, localCols_;$/;"	m	class:DistLeastSquareSolver
localCom	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
localCoord	SubDomainCore.C	/^void SubDomain::localCoord(Vec3D image, int iTet, SVec<double,3> &X, Vec3D& localcoords)$/;"	f	class:SubDomain
localCpuCol	DistLeastSquareSolver.h	/^  int localCpuCol() const { return localCpuCol_; }$/;"	f	class:DistLeastSquareSolver
localCpuCol_	DistLeastSquareSolver.h	/^  int localCpuRow_, localCpuCol_;$/;"	m	class:DistLeastSquareSolver
localCpuRow	DistLeastSquareSolver.h	/^  int localCpuRow() const { return localCpuRow_; }$/;"	f	class:DistLeastSquareSolver
localCpuRow_	DistLeastSquareSolver.h	/^  int localCpuRow_, localCpuCol_;$/;"	m	class:DistLeastSquareSolver
localDBuffer	Communicator.h	/^  T *localDBuffer;$/;"	m	class:CommPattern
localErrors	ErrorHandler.h	/^  int localErrors[SIZE];$/;"	m	struct:ErrorHandler
localFlightDisplacement	IoData.h	/^  const char *localFlightDisplacement;$/;"	m	struct:TransientData
localMatrixLeadDim	DistLeastSquareSolver.h	/^  int localMatrixLeadDim() const { return localMatrixLeadDim_; }$/;"	f	class:DistLeastSquareSolver
localMatrixLeadDim_	DistLeastSquareSolver.h	/^  int localMatrixLeadDim_, localRhsLeadDim_;$/;"	m	class:DistLeastSquareSolver
localNodeId	IoData.h	/^    int localNodeId;$/;"	m	struct:Probes::Node
localNodeMapping	MultiGridLevel.h	/^  int* localNodeMapping;$/;"	m	struct:MultigridSubdomain
localNodes	GappyPreprocessing.h	/^  std::vector <int> *localNodes;	\/\/ globalNodes[iSampleNode][iNode] is the global node number of the iNode in the iSampleNode island $/;"	m	class:GappyPreprocessing
localNumSub	Communicator.h	/^  int localNumSub;$/;"	m	class:SubDTopo
localPod	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::localPod(const char* basisType) {$/;"	f	class:NonlinearRomDatabaseConstruction
localRelProjError	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::localRelProjError() {$/;"	f	class:NonlinearRomDatabaseConstruction
localRelProjErrorSweep	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::localRelProjErrorSweep() {$/;"	f	class:NonlinearRomDatabaseConstruction
localRhsCount	DistLeastSquareSolver.h	/^  int localRhsCount()     const { return localRhsCount_;     }$/;"	f	class:DistLeastSquareSolver
localRhsCount_	DistLeastSquareSolver.h	/^  int localRhsRows_, localSolutionRows_, localRhsCount_;$/;"	m	class:DistLeastSquareSolver
localRhsLeadDim	DistLeastSquareSolver.h	/^  int localRhsLeadDim() const { return localRhsLeadDim_; }$/;"	f	class:DistLeastSquareSolver
localRhsLeadDim_	DistLeastSquareSolver.h	/^  int localMatrixLeadDim_, localRhsLeadDim_;$/;"	m	class:DistLeastSquareSolver
localRhsRankIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::localRhsRankIdx(int globalRankIdx) const {$/;"	f	class:DistLeastSquareSolver
localRhsRowIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::localRhsRowIdx(int globalRowIdx) const {$/;"	f	class:DistLeastSquareSolver
localRhsRows	DistLeastSquareSolver.h	/^  int localRhsRows()      const { return localRhsRows_;      }$/;"	f	class:DistLeastSquareSolver
localRhsRows_	DistLeastSquareSolver.h	/^  int localRhsRows_, localSolutionRows_, localRhsCount_;$/;"	m	class:DistLeastSquareSolver
localRowIdx	DistLeastSquareSolver.C	/^DistLeastSquareSolver::localRowIdx(int globalRowIdx) const {$/;"	f	class:DistLeastSquareSolver
localRows	DistLeastSquareSolver.h	/^  int localRows()         const { return localRows_;         }$/;"	f	class:DistLeastSquareSolver
localRows_	DistLeastSquareSolver.h	/^  int localRows_, localCols_;$/;"	m	class:DistLeastSquareSolver
localSolutionRows	DistLeastSquareSolver.h	/^  int localSolutionRows() const { return localSolutionRows_; }$/;"	f	class:DistLeastSquareSolver
localSolutionRows_	DistLeastSquareSolver.h	/^  int localRhsRows_, localSolutionRows_, localRhsCount_;$/;"	m	class:DistLeastSquareSolver
localSubToGl	Communicator.h	/^  int *localSubToGl;$/;"	m	class:SubDTopo
localSubdomainCount	RestrictionMapping.h	/^  int localSubdomainCount() const { return localSubdomainCount_; }$/;"	f	class:RestrictionMapping
localSubdomainCount_	RestrictionMapping.h	/^  int localSubdomainCount_;$/;"	m	class:RestrictionMapping
local_error	AlternatingLeastSquare/als_lapack.h	/^    double local_error;$/;"	m	class:AlternatingLeastSquare
local_mat_data	AlternatingLeastSquare/als_lapack.h	/^    double *local_mat_data;$/;"	m	class:AlternatingLeastSquare
local_vec_data	AlternatingLeastSquare/als_lapack.h	/^    double *local_vec_data;$/;"	m	class:AlternatingLeastSquare
locationX	IoData.h	/^    double locationX,locationY,locationZ;$/;"	m	struct:Probes::Node
locationY	IoData.h	/^    double locationX,locationY,locationZ;$/;"	m	struct:Probes::Node
locationZ	IoData.h	/^    double locationX,locationY,locationZ;$/;"	m	struct:Probes::Node
locations	OneDimensionalSolver.h	/^    std::vector<Vec3D> locations;$/;"	m	struct:OneDimensional::__anon12
locations	TsOutput.h	/^    std::vector<Vec3D> locations;$/;"	m	struct:TsOutput::__anon29
loctag	OneDimensionalSolver.h	/^  int* loctag;$/;"	m	class:OneDimensional
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline DIAGONAL_MATRIX<T,2> log(const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline DIAGONAL_MATRIX<T,3> log(const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline MATRIX<T,0> log(const MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline MATRIX<T,0,1> log(const MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> log(const MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> log(const SYMMETRIC_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
log	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> log(const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
logMap	SparseGrid.h	/^  LogarithmicMapping **logMap;$/;"	m	class:SparseGrid
log_file	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    FILE* log_file;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
log_file_end_on_separate_line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    bool end_on_separate_line,log_file_end_on_separate_line;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
log_file_needs_indent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.cpp	/^bool LOG_ENTRY::log_file_needs_indent=true;$/;"	m	class:LOG_ENTRY	file:
log_file_needs_indent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    static bool needs_indent,log_file_needs_indent;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
log_file_start_on_separate_line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.cpp	/^bool LOG_ENTRY::log_file_start_on_separate_line=false;$/;"	m	class:LOG_ENTRY	file:
log_file_start_on_separate_line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    static bool start_on_separate_line,log_file_start_on_separate_line;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
log_file_temporary	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool log_file_temporary;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
log_null_class	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^struct log_null_class {$/;"	s	namespace:PhysBAM::LOG_NULL
logfil	arpack++/include/arpackf.h	/^    ARint logfil, ndigit, mgetv0;$/;"	m	struct:XMLARSTR
logical	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
logr1r0	OneDimensionalSourceTerm.h	/^  double* pow_ry_k,*pow_ri_k,*logr1r0;$/;"	m	class:OneDimensionalSourceTerm
lookup_table	VarFcnTait.h	/^  double* lookup_table;$/;"	m	class:VarFcnTait
lowRankApproxMetricEigenvalues	GappyPreprocessing.h	/^  double* lowRankApproxMetricEigenvalues;$/;"	m	class:GappyPreprocessing
lowRankEnergy	IoData.h	/^  double lowRankEnergy;$/;"	m	struct:ApproximatedMetricData
lowRankFactor	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* lowRankFactor; \/\/ low rank factor for approx metric$/;"	m	class:NonlinearRom
lowRankModes	GappyPreprocessing.h	/^  double** lowRankModes;$/;"	m	class:GappyPreprocessing
lriemann	ExactRiemannSolver.h	/^  LocalRiemann **lriemann;$/;"	m	class:ExactRiemannSolver
lriemannGasJwl	SparseGridGeneratorDesc.h	/^  LocalRiemannGfmparGasJWL *lriemannGasJwl;$/;"	m	class:SparseGridGeneratorDesc
lrwork	arpack++/include/arrseig.h	/^  int     lrwork;     \/\/ Dimension of array rwork.$/;"	m	class:ARrcStdEig
ls	IoData.h	/^  SchemeData ls;$/;"	m	struct:SchemesData
ls2phases	FluidSelector.h	/^  map<int,pair<int,int> > ls2phases; \/\/maps each levelset to the pair of fluid Ids for phi<0 and >0.$/;"	m	class:FluidSelector
lsCoeff	ImplicitPGTsDesc.h	/^  double **lsCoeff;$/;"	m	class:ImplicitPGTsDesc
lsFvTerm	Timer.h	/^		binread, binwrite, levelSet, lsNodalWeightsAndGrad, lsFvTerm,$/;"	e	enum:Timer::TimerIndex
lsJac	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
lsKsp	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
lsMethod	LevelSetTsDesc.h	/^  int lsMethod;$/;"	m	class:LevelSetTsDesc
lsMethod	MultiPhysicsTsDesc.h	/^  int lsMethod;$/;"	m	class:MultiPhysicsTsDesc
lsNodalWeightsAndGrad	Timer.h	/^		binread, binwrite, levelSet, lsNodalWeightsAndGrad, lsFvTerm,$/;"	e	enum:Timer::TimerIndex
lsPrecSetup	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
lsSolver	ImplicitPGTsDesc.h	/^	int lsSolver;$/;"	m	class:ImplicitPGTsDesc
lsSolver	IoData.h	/^  enum LSSolver {QR = 0, NORMAL_EQUATIONS = 1, LEVENBERG_MARQUARDT_SVD = 2, PROBABILISTIC_SVD = 3} lsSolver;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::LSSolver
lsSolver	IoData.h	/^  enum LsSolver {QR=0, NORMAL_EQUATIONS=1} lsSolver;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::LsSolver
lscale	DistGeoState.h	/^  double lscale;$/;"	m	class:DistGeoState
lscomplex	arpack++/include/arlcomp.h	/^typedef struct { float r, i; } lscomplex;$/;"	t	typeref:struct:__anon31
lsgrad	LevelSet.h	/^  DistNodalGrad<dimLS, double> *lsgrad;	\/\/ least-square gradient to compute normal at each node$/;"	m	class:LevelSet
lsi	IoData.h	/^  KspData lsi;$/;"	m	struct:KspFluidData
lsreinitialization	Timer.h	/^		eulerFSI, embedforce, walldistance, lsreinitialization, readSnapshotFile,$/;"	e	enum:Timer::TimerIndex
lsub	arpack++/include/arlspdef.h	/^    int     *lsub;    \/* compressed L subscripts *\/$/;"	m	struct:__anon35
lsub	arpack++/include/arlspdef.h	/^    int     *lsub;    \/* compressed L subscripts *\/$/;"	m	struct:__anon36
lsub	arpack++/include/arlspdef.h	/^    int     *lsub;    \/* compressed L subscripts *\/$/;"	m	struct:__anon37
lsub	arpack++/include/arlspdef.h	/^    int     *lsub;    \/* compressed L subscripts *\/$/;"	m	struct:__anon38
ltdouble	KirchhoffIntegrator.C	/^struct ltdouble$/;"	s	file:
lu	DenseMatrixOps.h	/^  static void lu(Scalar *a, Scalar *b, int n) {$/;"	f	class:DenseMatrixOp
ludata	OneDimensionalSourceTerm.h	/^  MyLU* ludata;$/;"	m	class:OneDimensionalSourceTerm
ludec	DenseMatrixOps.h	/^  static void ludec(Scalar *a, int *index, double d, int n)  {$/;"	f	class:DenseMatrixOp
ludfdbksb	DenseMatrixOps.h	/^  static void ludfdbksb(Scalar *a, int *index, Scalar *b, int n) {$/;"	f	class:DenseMatrixOp
lusol	SparseMatrix.C	/^void SparseMat<Scalar,dim>::lusol(SVec<Scalar2,dim> &y, SVec<Scalar2,dim> &x)$/;"	f	class:SparseMat
lusolTR	SparseMatrix.C	/^void SparseMat<Scalar,dim>::lusolTR(SVec<Scalar2,dim> &y, SVec<Scalar2,dim> &x)$/;"	f	class:SparseMat
lusup	arpack++/include/arlspdef.h	/^    double  *lusup;   \/* L supernodes *\/$/;"	m	struct:__anon36
lusup	arpack++/include/arlspdef.h	/^    float  *lusup;   \/* L supernodes *\/$/;"	m	struct:__anon35
lusup	arpack++/include/arlspdef.h	/^    ldcomplex  *lusup;   \/* L supernodes *\/$/;"	m	struct:__anon38
lusup	arpack++/include/arlspdef.h	/^    lscomplex  *lusup;   \/* L supernodes *\/$/;"	m	struct:__anon37
lut_max	VarFcnTait.h	/^  double lut_min,lut_max;$/;"	m	class:VarFcnTait
lut_min	VarFcnTait.h	/^  double lut_min,lut_max;$/;"	m	class:VarFcnTait
lut_size	VarFcnTait.h	/^  int lut_size;$/;"	m	class:VarFcnTait
lvalue	arpack++/include/arunsmat.h	/^  int     lvalue;$/;"	m	class:ARumNonSymMatrix
lvalue	arpack++/include/arusmat.h	/^  int     lvalue;$/;"	m	class:ARumSymMatrix
lworkl	arpack++/include/arrseig.h	/^  int     lworkl;     \/\/ Dimension of array workl.$/;"	m	class:ARrcStdEig
lworksizesvd	f77src/lworksizesvd.f	/^      subroutine lworksizesvd(/;"	s
lworkv	arpack++/include/arrseig.h	/^  int     lworkv;     \/\/ Dimension of array workv.$/;"	m	class:ARrcStdEig
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ID m; \/\/ the current size of the array (buffer_size may be larger for elbow room)$/;"	m	class:PhysBAM::ARRAY
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    typename COPY_CONST<ID>::TYPE m;$/;"	m	class:PhysBAM::ARRAY_VIEW
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    ID m;$/;"	m	class:PhysBAM::CONSTANT_ARRAY
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    ID m;$/;"	m	class:PhysBAM::IDENTITY_ARRAY
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class ID,int d> struct INDIRECT_ARRAY_BASE<VECTOR<ID,d>&>{enum {m=VECTOR<ID,d>::m};};$/;"	e	enum:PhysBAM::INDIRECT_ARRAY_BASE::__anon15
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<int d> struct PROJECTED_ARRAY_BASE<VECTOR<int,d>&>{enum {m=VECTOR<int,d>::m};};$/;"	e	enum:PhysBAM::PROJECTED_ARRAY_BASE::__anon16
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::DIAGONAL_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::DIAGONAL_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    enum WORKAROUND1 {m=m_input,n=n_input,size=n_input*m_input};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    enum WORKAROUND1 {m=0,n=0};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    enum WORKAROUND1 {m=0,n=1};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    enum WORKAROUND1 {m=1,n=1};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    enum WORKAROUND1 {m=1,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    enum WORKAROUND1 {m=3,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    int m,n; \/\/ size of the m by n matrix$/;"	m	class:PhysBAM::MATRIX_MXN
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::SYMMETRIC_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::SYMMETRIC_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    enum WORKAROUND1 {m=T_MATRIX::n,n=T_MATRIX::m};$/;"	e	enum:PhysBAM::TRANSPOSE_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::UPPER_TRIANGULAR_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::UPPER_TRIANGULAR_MATRIX::WORKAROUND1
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    static const int n=624,m=397;$/;"	m	class:PhysBAM::MT19937
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    enum WORKAROUND {dimension=TV::m+T_SPIN::m,m=dimension};$/;"	e	enum:PhysBAM::TWIST::WORKAROUND
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    enum WORKAROUND2 {m=d};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND2
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    enum WORKAROUND2 {m=0};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND2
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    enum WORKAROUND2 {m=1};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND2
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    enum WORKAROUND2 {m=2};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND2
m	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    enum WORKAROUND2 {m=3};$/;"	e	enum:PhysBAM::VECTOR::WORKAROUND2
m	arpack++/include/ardfmat.h	/^  int      m;         \/\/ Number of rows.$/;"	m	class:ARdfMatrix
m	arpack++/include/arhbmat.h	/^  int     m;               \/\/ Number of rows.$/;"	m	class:ARhbMatrix
m	arpack++/include/armat.h	/^  int  m, n;    \/\/ Number of rows and columns.$/;"	m	class:ARMatrix
mX	Modal.h	/^    VecSet< DistSVec<double,3> > mX;$/;"	m	class:ModalSolver
mX	TsOutput.h	/^  VecSet< DistSVec<double,3> > *mX;$/;"	m	class:TsOutput
mach	DynamicLESTerm.h	/^  double mach;$/;"	m	class:DynamicLESTerm
mach	DynamicVMSTerm.h	/^  double mach;$/;"	m	class:DynamicVMSTerm
mach	IoData.h	/^  const char *mach;$/;"	m	struct:TransientData
mach	IoData.h	/^  double mach;$/;"	m	struct:BcsFreeStreamData
mach	IoData.h	/^  double mach;$/;"	m	struct:InitialConditions
mach	IoData.h	/^  double mach;$/;"	m	struct:PreconditionData
mach	IoData.h	/^  double mach;$/;"	m	struct:ReferenceStateData
mach	LocalRiemannDesc.h	/^  double mach;$/;"	m	class:LocalRiemannFluidStructure
mach	PostFcn.h	/^  double mach;$/;"	m	class:PostFcnEuler
mach	RefVal.h	/^  double mach;$/;"	m	class:RefVal
machref	IoData.h	/^  double machref;$/;"	m	struct:SensitivityAnalysis
macroA	MultiGridKspSolver.h	/^  DistMat<Scalar,neq>* macroA;$/;"	m	class:MultiGridMatVecProd
macroCells	DistDynamicVMSTerm.h	/^  DistMacroCellSet  *macroCells;$/;"	m	class:DistDynamicVMSTerm
macroCells	DistMacroCell.h	/^  MacroCellSet*** macroCells;$/;"	m	class:DistMacroCellSet
macroCells	DistVMSLESTerm.h	/^  DistMacroCellSet  *macroCells;$/;"	m	class:DistVMSLESTerm
macroCells	MacroCell.h	/^  MacroCell **macroCells;$/;"	m	class:MacroCellSet
main	tools/loader.C	/^int main(int argc, char **argv)$/;"	f
makeCrossConnect	CommunicatorCore.C	/^SubDTopo::makeCrossConnect()$/;"	f	class:SubDTopo
makeEdgeMasterFlag	SubDomainCore.C	/^void SubDomain::makeEdgeMasterFlag(DistInfo &distInfo, CommPattern<int> &edgeNumPat)$/;"	f	class:SubDomain
makeEdgePair	IntersectorFRG/IntersectorFRG.C	/^EdgePair DistIntersectorFRG::makeEdgePair(int node1, int node2, int triangleNumber) {$/;"	f	class:DistIntersectorFRG
makeEdgePair	IntersectorPhysBAM/IntersectorPhysBAM.C	/^EdgePair DistIntersectorPhysBAM::makeEdgePair(int node1, int node2, int triangleNumber) {$/;"	f	class:DistIntersectorPhysBAM
makeFreqPOD	Modal.C	/^void ModalSolver<dim>::makeFreqPOD(VecSet<DistSVec<double, dim> > &snaps, int nSnaps, int nPOD, bool outputToDisk){$/;"	f	class:ModalSolver
makeLocalPairIndex	CommunicatorCore.C	/^SubDTopo::makeLocalPairIndex(Connectivity *subToSub)$/;"	f	class:SubDTopo
makeMasterFlag	SubDomainCore.C	/^void SubDomain::makeMasterFlag(DistInfo &distInfo)$/;"	f	class:SubDomain
makeNodeMaxIfUnique	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::makeNodeMaxIfUnique(double nodeError, double$/;"	f	class:GappyPreprocessing
makeOldSampledNodeDistInfo	DomainCore.C	/^void Domain::makeOldSampledNodeDistInfo(const std::vector<int> &cpuSample, const std::vector<int> &locSubSample)$/;"	f	class:Domain
makeOldSampledNodeDistInfo	DomainCore.C	/^void Domain::makeOldSampledNodeDistInfo(const std::vector<int> &globalSampleNodesUnion, const boost::unordered_map<int, int> &globalNodeToCpuMap,$/;"	f	class:Domain
makeRotationOwnership	DomainCore.C	/^void Domain::makeRotationOwnership(IoData &ioData)  {$/;"	f	class:Domain
makeSampledNodeDistInfo	DomainCore.C	/^void Domain::makeSampledNodeDistInfo(const std::vector<int> &cpuSample, const std::vector<int> &locSubSample)$/;"	f	class:Domain
makeSampledNodeDistInfo	DomainCore.C	/^void Domain::makeSampledNodeDistInfo(const std::vector<int> &globalSampleNodesUnion, const boost::unordered_map<int, int> &globalNodeToCpuMap,$/;"	f	class:Domain
makeUnique	Domain.C	/^void Domain::makeUnique( std::vector <Scalar> * nodeOrEle, int length) {$/;"	f	class:Domain
makepath	BinFileHandler.h	/^void BinFileHandler::makepath(const char *filename) {$/;"	f	class:BinFileHandler
makerotationownership	FSI/DynamicNodalTransfer.cpp	/^void EmbeddedStructure::makerotationownership(IoData &iod) {$/;"	f	class:EmbeddedStructure
makerotationownership	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::makerotationownership() {$/;"	f	class:DistIntersectorFRG
makerotationownership	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::makerotationownership() {$/;"	f	class:DistIntersectorPhysBAM
map	SparseGrid.h	/^    double map(double value)   { return log(value)\/log(base_); }$/;"	f	class:SparseGrid::LogarithmicMapping
map	parser/Dictionary.h	/^   DictMap map;$/;"	m	class:Dictionary
mapBaseValue	IoData.h	/^  double *mapBaseValue;$/;"	m	struct:SparseGridData
mapBaseValue1	IoData.h	/^  double range1min, range1max, mapBaseValue1; int numDomainDim1;$/;"	m	struct:SparseGridData
mapBaseValue2	IoData.h	/^  double range2min, range2max, mapBaseValue2; int numDomainDim2;$/;"	m	struct:SparseGridData
mapBaseValue3	IoData.h	/^  double range3min, range3max, mapBaseValue3; int numDomainDim3;$/;"	m	struct:SparseGridData
mapBaseValue4	IoData.h	/^  double range4min, range4max, mapBaseValue4; int numDomainDim4;$/;"	m	struct:SparseGridData
mapBaseValue5	IoData.h	/^  double range5min, range5max, mapBaseValue5; int numDomainDim5;$/;"	m	struct:SparseGridData
mapBaseValue6	IoData.h	/^  double range6min, range6max, mapBaseValue6; int numDomainDim6;$/;"	m	struct:SparseGridData
mapFaceFineToCoarse	MultiGridLevel.h	/^    int mapFaceFineToCoarse(int iSub,int i) {$/;"	f	class:MultiGridLevel
mapFineToCoarse	MultiGridLevel.h	/^    int mapFineToCoarse(int iSub,int i) {$/;"	f	class:MultiGridLevel
mapName	GeoSource.h	/^  char *mapName;$/;"	m	class:GeoSource
mapName	IoData.h	/^  const char *mapName;  $/;"	m	struct:NonlinearRomFilesData
mapName	NonlinearRom.h	/^  char* mapName;  $/;"	m	class:NonlinearRom
mapNodeList	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::mapNodeList(int iSub,Aerof_unordered_set<int>::type&  l) {$/;"	f	class:MultiGridLevel
mapObj	parser/Assigner.h	/^    map<int, Target *> *mapObj;$/;"	m	class:SysMapObj
mapSnapToRef	NonlinearRom.h	/^  std::map<std::string,std::string> mapSnapToRef;$/;"	m	class:NonlinearRom
mapTriangleID	FSI/CrackingSurface.cpp	/^int CrackingSurface::mapTriangleID(int id) {$/;"	f	class:CrackingSurface
map_ptr	MvpMatrix.h	/^    AuxilliaryRows* map_ptr;$/;"	m	struct:MvpMat::MvpAuxilliaryIterator
markFaceBelongsToSurface	SubDomainCore.C	/^void SubDomain::markFaceBelongsToSurface(Vec<int> &faceFlag, CommPattern<int> &cpat) {$/;"	f	class:SubDomain
markLenEdges	SubDomain.h	/^  void markLenEdges(DistInfo &distInfo) { distInfo.setLen(locSubNum, edges.size()); }$/;"	f	class:SubDomain
markLenFaceNorms	SubDomain.h	/^  void markLenFaceNorms(DistInfo &distInfo) { distInfo.setLen(locSubNum, faces.sizeNorms()); }$/;"	f	class:SubDomain
markLenFaces	SubDomain.h	/^  void markLenFaces(DistInfo &distInfo) { distInfo.setLen(locSubNum, faces.size()); }$/;"	f	class:SubDomain
markLenInletNodes	SubDomain.h	/^  void markLenInletNodes(DistInfo &distInfo) { distInfo.setLen(locSubNum, inletNodes.size()); }$/;"	f	class:SubDomain
markLenKirchhoffNodes	SubDomainCore.C	/^void SubDomain::markLenKirchhoffNodes(IoData &iod, DistInfo &distInfo)$/;"	f	class:SubDomain
markLenNodes	SubDomain.h	/^  void markLenNodes(DistInfo &distInfo) { distInfo.setLen(locSubNum, nodes.size()); }$/;"	f	class:SubDomain
markLenNull	SubDomain.h	/^  void markLenNull(DistInfo &distInfo) {distInfo.setLen(locSubNum, 0); }$/;"	f	class:SubDomain
mask	EmbeddedAlternatingLeastSquare.h	/^    VecSet<DistSVec<char, dim> > *mask; \/\/<! create by C++ new when needed$/;"	m	class:EmbeddedAlternatingLeastSquare
maskError	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::maskError() {$/;"	f	class:GappyPreprocessing
maskHHVector	DomainCore.C	/^void Domain::maskHHVector(DistVec<double>& hh) {$/;"	f	class:Domain
maskHHVector	SubDomainCore.C	/^void SubDomain::maskHHVector(Vec<double>& hh) {$/;"	f	class:SubDomain
massflowflux3D	FluxFcnDescSG.C	/^void massflowflux3D(int type, VarFcnBase *vf, double* normal, $/;"	f
massflowflux3DDerivative	FluxFcnDescSG.C	/^void massflowflux3DDerivative(int type, VarFcnBase *vf, double* normal, double* dNormal,$/;"	f
master	InletNode.h	/^        bool master;                    \/\/tells if a shared node is the master one for extrapolation (this is$/;"	m	class:InletNode
masterFlag	AgglomeratedFace.h	/^  bool masterFlag;$/;"	m	class:AgglomeratedFace
masterFlag	DistDynamicVMSTerm.h	/^  bool              **masterFlag;$/;"	m	class:DistDynamicVMSTerm
masterFlag	DistInfo.h	/^  bool *masterFlag;$/;"	m	struct:DistInfo
masterFlag	DistVMSLESTerm.h	/^  bool              **masterFlag;$/;"	m	class:DistVMSLESTerm
masterFlag	Edge.h	/^  bool *masterFlag;$/;"	m	class:EdgeSet
masterProcessor	IntersectorPhysBAM/Mpi_Utilities.h	/^static const int masterProcessor=0;$/;"	m	namespace:PHYSBAM_MPI_UTILITIES
mat	arpack++/include/ardnsmat.h	/^  ARdfMatrix<ARTYPE>  mat;$/;"	m	class:ARdsNonSymMatrix
mat	arpack++/include/arlnsmat.h	/^  ARhbMatrix<int, ARTYPE> mat;$/;"	m	class:ARluNonSymMatrix
mat	arpack++/include/arlsmat.h	/^  ARhbMatrix<int, ARTYPE> mat;$/;"	m	class:ARluSymMatrix
mat	arpack++/include/arunsmat.h	/^  ARhbMatrix<int, ARTYPE> mat;$/;"	m	class:ARumNonSymMatrix
mat	arpack++/include/arusmat.h	/^  ARhbMatrix<int, ARTYPE> mat;$/;"	m	class:ARumSymMatrix
matPattern	MultiGridLevel.h	/^    CommPattern<double> * matPattern;$/;"	m	class:MultiGridLevel
matPattern2	MultiGridLevel.h	/^    CommPattern<double> * matPattern2;$/;"	m	class:MultiGridLevel
match	IoData.h	/^  const char *match;$/;"	m	struct:InputData
matchName	GeoSource.h	/^  char *matchName;$/;"	m	class:GeoSource
matchNodes	EmbeddedCorotSolver.h	/^  MatchNodeSet **matchNodes;$/;"	m	class:EmbeddedCorotSolver
matchNodes	GeoSource.h	/^  MatchNodeSet **matchNodes;$/;"	m	class:GeoSource
matchNodes	StructExc.h	/^  MatchNodeSet **matchNodes;$/;"	m	class:StructExc
matchStateFile	IoData.h	/^  const char *matchStateFile;$/;"	m	struct:InputData
matcherFile	FSI/DynamicNodalTransfer.h	/^  char *matcherFile;$/;"	m	class:EmbeddedStructure
matchpressure	IoData.h	/^  const char *matchpressure;$/;"	m	struct:TransientData
matchpressure	TsOutput.h	/^  char *matchpressure;$/;"	m	class:TsOutput
matchstate	IoData.h	/^  const char *matchstate;$/;"	m	struct:TransientData
matchstate	TsOutput.h	/^  char *matchstate;$/;"	m	class:TsOutput
materialMassEnergy	IoData.h	/^  const char *materialMassEnergy;$/;"	m	struct:TransientData
materialVolumes	IoData.h	/^  const char *materialVolumes;$/;"	m	struct:TransientData
material_mass_energy	TsOutput.h	/^  char *material_mass_energy;$/;"	m	class:TsOutput
material_volumes	TsOutput.h	/^  char *material_volumes;$/;"	m	class:TsOutput
matrixBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixBuffer() const {$/;"	f	class:DistLeastSquareSolver
matrixBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixBuffer() {$/;"	f	class:DistLeastSquareSolver
matrixBuffer_	DistLeastSquareSolver.h	/^  SimpleBuffer<Scalar> matrixBuffer_;$/;"	m	class:DistLeastSquareSolver
matrixColBlockSize	DistLeastSquareSolver.h	/^  int matrixColBlockSize() const { return colBlockSize_;    }$/;"	f	class:DistLeastSquareSolver
matrixColBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixColBuffer(int col) const {$/;"	f	class:DistLeastSquareSolver
matrixColBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixColBuffer(int col) {$/;"	f	class:DistLeastSquareSolver
matrixDesc_	DistLeastSquareSolver.h	/^  ArrayDesc matrixDesc_;$/;"	m	class:DistLeastSquareSolver
matrixEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixEntry(int row, int col) const {$/;"	f	class:DistLeastSquareSolver
matrixEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::matrixEntry(int row, int col) {$/;"	f	class:DistLeastSquareSolver
matrixRowBlockSize	DistLeastSquareSolver.h	/^  int matrixRowBlockSize() const { return rowBlockSize_;    }$/;"	f	class:DistLeastSquareSolver
matrix_matrix_elementwise_multiply	AlternatingLeastSquare/als_util.cpp	/^int matrix_matrix_elementwise_multiply(double *A, double *B, int M, int N, double *result){$/;"	f
matrix_multiply	AlternatingLeastSquare/als_util.cpp	/^int matrix_multiply(double *A, double *B, int a, int b, int c, double *result){$/;"	f
matrix_vector_multiply	AlternatingLeastSquare/als_util.cpp	/^int matrix_vector_multiply(double *A, double *b, int nrow, int ncol, double *v) {$/;"	f
max	DESTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:DESTerm
max	DistVector.h	/^DistVec<Scalar>::max() const$/;"	f	class:DistVec
max	DistVector.h	/^void DistSVec<Scalar,dim>::max(Scalar vmax[dim]) const$/;"	f	class:DistSVec
max	DynamicLESTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:DynamicLESTerm
max	DynamicVMSTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:DynamicVMSTerm
max	FemEquationTermDesc.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:FemEquationTermDES
max	ImplicitRiemann.C	9;"	d	file:
max	OneDimensionalSolver.C	/^double max(double a,double b,double c,double d, double e, double f) {$/;"	f
max	OneDimensionalSolver.C	/^double max(double b,double c,double d, double e, double f) {$/;"	f
max	OneDimensionalSolver.C	/^double max(double c,double d, double e, double f) {$/;"	f
max	OneDimensionalSolver.C	/^double max(double d, double e, double f) {$/;"	f
max	OneDimensionalSolver.C	/^double max(double e, double f) {$/;"	f
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a, const T b)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d,const T e)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d,const T e,const T f)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d,const T e,const T f,const T g)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d,const T e,const T f,const T g,const T h)$/;"	f	namespace:PhysBAM
max	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/max.h	/^inline T max(const T a,const T b,const T c,const T d,const T e,const T f,const T g,const T h,const T i)$/;"	f	namespace:PhysBAM
max	SmagorinskyLESTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:SmagorinskyLESTerm
max	VMSLESTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:VMSLESTerm
max	Vector.h	/^  Scalar max() const {$/;"	f	class:SVec
max	Vector.h	/^  Scalar max() const {$/;"	f	class:Vec
max	Vector.h	/^  void max(Scalar vmax[dim]) const {$/;"	f	class:SVec
max	Vector3D.h	/^Vec3D max( const Vec3D& a, const Vec3D& b) {$/;"	f
max	WaleLESTerm.h	/^  double max(double a, double b) { return (a>b) ? a : b; }$/;"	f	class:WaleLESTerm
max	arpack++/include/arbnspen.h	/^  int max(int a, int b) { return (a>b)?a:b; }$/;"	f	class:ARbdNonSymPencil
max	arpack++/include/arbspen.h	/^  int max(int a, int b) { return (a>b)?a:b; }$/;"	f	class:ARbdSymPencil
maxBasisSize	AlternatingLeastSquare/als_io.h	/^    int maxBasisSize;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
maxBasisSize	EmbeddedAlternatingLeastSquare.h	/^    int maxBasisSize;$/;"	m	class:EmbeddedAlternatingLeastSquare
maxBasisSize	IoData.h	/^    int maxBasisSize;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
maxBasisSize	IoData.h	/^  int maxBasisSize;$/;"	m	struct:DataCompressionData
maxClusteredSnapshotsNonlinearApproxMetric	IoData.h	/^  int maxClusteredSnapshotsNonlinearApproxMetric;$/;"	m	struct:GappyConstructionData
maxCpuBlocks	ParallelRom.h	/^	int maxCpuBlocks;	\/\/	number of maximum blocks per cpu for block cyclic decomposition$/;"	m	class:ParallelRom
maxDimGreedyAlgorithm	IoData.h	/^  int maxDimGreedyAlgorithm;	$/;"	m	struct:GappyConstructionData
maxDimension	IoData.h	/^  int maxDimension;$/;"	m	struct:NonlinearRomOnlineData
maxDimension	IoData.h	/^  int maxDimension;$/;"	m	struct:NonlinearRomOnlineNonStateData
maxDimension	IoData.h	/^  int maxDimension;$/;"	m	struct:RelativeProjectionErrorData
maxDimensionJacAction	IoData.h	/^  int maxDimensionJacAction;$/;"	m	struct:GappyConstructionData
maxDimensionKrylov	IoData.h	/^  int maxDimensionKrylov;$/;"	m	struct:GappyConstructionData
maxDimensionResidual	IoData.h	/^  int maxDimensionResidual;$/;"	m	struct:GappyConstructionData
maxDimensionSensitivity	IoData.h	/^  int maxDimensionSensitivity;$/;"	m	struct:GappyConstructionData
maxDimensionState	IoData.h	/^  int maxDimensionState;$/;"	m	struct:GappyConstructionData
maxDistance	IoData.h	/^  double maxDistance; \/\/mesh goes from 0 to maxDistance$/;"	m	struct:OneDimensionalInfo
maxDistance	OneDimensionalSolver.h	/^  double maxDistance;$/;"	m	class:OneDimensional
maxEnergyRetained	IoData.h	/^  double maxEnergyRetained;$/;"	m	struct:DataCompressionData
maxInterpolatedSolutions	IoData.h	/^  int maxInterpolatedSolutions;$/;"	m	struct:InputData
maxItEV	IoData.h	/^  int maxItEV;$/;"	m	struct:LinearizedData
maxIter	IoData.h	/^  int maxIter;$/;"	m	struct:ClusteringData
maxIterAggressive	IoData.h	/^  int maxIterAggressive;$/;"	m	struct:ClusteringData
maxIteration	AlternatingLeastSquare/als_io.h	/^    int maxIteration;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
maxIteration	EmbeddedAlternatingLeastSquare.h	/^    int maxIteration;$/;"	m	class:EmbeddedAlternatingLeastSquare
maxIteration	IoData.h	/^    int maxIteration;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
maxIts	IoData.h	/^  int maxIts;$/;"	m	struct:KspData
maxIts	IoData.h	/^  int maxIts;$/;"	m	struct:LineSearchData
maxIts	IoData.h	/^  int maxIts;$/;"	m	struct:NewtonData
maxIts	IoData.h	/^  int maxIts;$/;"	m	struct:TsData
maxIts	IoData.h	/^  int maxIts;$/;"	m	struct:WallDistanceMethodData
maxIts	TsParameters.h	/^  int maxIts;$/;"	m	class:TsParameters
maxItsLS	ImplicitEmbeddedTsDesc.h	/^  int maxItsLS;$/;"	m	class:ImplicitEmbeddedTsDesc
maxItsLS	ImplicitLevelSetTsDesc.h	/^  int maxItsLS;$/;"	m	class:ImplicitLevelSetTsDesc
maxItsLS	ImplicitMultiPhysicsTsDesc.h	/^  int maxItsLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
maxItsLS	ImplicitRomTsDesc.h	/^  int maxItsLS; $/;"	m	class:ImplicitRomTsDesc
maxItsLS	ImplicitTsDesc.h	/^  int maxItsLS;$/;"	m	class:ImplicitTsDesc
maxItsLS	MeshMotionSolver.h	/^  int maxItsLS;$/;"	m	class:TetMeshMotionSolver
maxItsNewton	ImplicitEmbeddedTsDesc.h	/^  int maxItsNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
maxItsNewton	ImplicitLevelSetTsDesc.h	/^  int maxItsNewton;$/;"	m	class:ImplicitLevelSetTsDesc
maxItsNewton	ImplicitMultiPhysicsTsDesc.h	/^  int maxItsNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
maxItsNewton	ImplicitRomTsDesc.h	/^  int maxItsNewton;$/;"	m	class:ImplicitRomTsDesc
maxItsNewton	ImplicitTsDesc.h	/^  int maxItsNewton;$/;"	m	class:ImplicitTsDesc
maxItsNewton	MeshMotionSolver.h	/^  int maxItsNewton;$/;"	m	class:TetMeshMotionSolver
maxLeaf	IntersectorFRG/Geometry/KDTree.h	/^     int maxLeaf() {$/;"	f	class:KDTree
maxMach	LowMachPrec.h	/^  double maxMach;$/;"	m	class:LowMachPrec
maxNPairs	IntersectorFRG/IntersectorFRG.C	/^  static const int maxNPairs = 100;$/;"	m	class:ClosestTriangle	file:
maxNodesPerSubD	MultiGridLevel.h	/^    int maxNodesPerSubD;$/;"	m	class:MultiGridLevel
maxPoints	IoData.h	/^  int maxPoints;$/;"	m	struct:SparseGridData
maxPoints	SparseGrid.h	/^  int maxPoints;          \/\/ max number of points in the grid$/;"	m	class:SparseGrid
maxRcvData	SubDomain.C	/^void SubDomain::maxRcvData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
maxRcvDataAndCountUpdates	SubDomain.C	/^void SubDomain::maxRcvDataAndCountUpdates(CommPattern<Scalar> &sp, Scalar (*w)[dim],int &nSortedNodes, Vec<int> &sortedNodes)$/;"	f	class:SubDomain
maxSampledNodes	IoData.h	/^  int maxSampledNodes;$/;"	m	struct:GappyConstructionData
maxThread	Malloc.C	/^int maxThread = 16;$/;"	v
maxTime	IoData.h	/^  double maxTime;$/;"	m	struct:TsData
maxTime	TsParameters.h	/^  double maxTime;$/;"	m	class:TsParameters
maxVecStorage	IoData.h	/^  int maxVecStorage;$/;"	m	struct:DataCompressionData
maxWidth	IntersectorFRG/Geometry/KDTree.h	/^     double maxWidth(int dir)$/;"	f	class:KDTree
max_corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T min_corner,max_corner;$/;"	m	class:PhysBAM::INTERVAL
max_corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV min_corner,max_corner;$/;"	m	class:PhysBAM::RANGE
max_distance	OneDimensionalSolver.h	/^    double max_distance;$/;"	m	class:OneDimensional::Veval
max_iterations	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^    int iterations,max_iterations;$/;"	m	class:PhysBAM::ITERATIVE_SOLVER
max_size	ResizeArray.h	/^  int max_size() { return csize; }$/;"	f	class:ResizeArray
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d,const T e)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d,const T e,const T f)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d,const T e,const T f,const T g)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d,const T e,const T f,const T g,const T h)$/;"	f	namespace:PhysBAM
maxabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxabs.h	/^inline T maxabs(const T a,const T b,const T c,const T d,const T e,const T f,const T g,const T h,const T i)$/;"	f	namespace:PhysBAM
maxc	tools/alloca.cougar.c	/^    long maxc;			\/* Amount of contiguous space which would$/;"	m	struct:stk_stat	file:
maxdepth	IntersectorFRG/Geometry/KDTree.h	/^     int maxdepth() {$/;"	f	class:KDTree
maxit	arpack++/include/arrseig.h	/^  int     maxit;      \/\/ Maximum number of Arnoldi update iterations allowed.$/;"	m	class:ARrcStdEig
maxits	KspSolver.h	/^  int maxits;$/;"	m	class:KspSolver
maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^inline T maxmag(const T a,const T b)$/;"	f	namespace:PhysBAM
maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^inline T maxmag(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^inline T maxmag(const T a,const T b,const T c,const T d)$/;"	f	namespace:PhysBAM
maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^inline T maxmag(const T a,const T b,const T c,const T d,const T e)$/;"	f	namespace:PhysBAM
maxmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/maxmag.h	/^inline T maxmag(const T a,const T b,const T c,const T d,const T e,const T f)$/;"	f	namespace:PhysBAM
maxp	LevelSet.C	/^static inline double maxp(double a,double b, double c,double as,double bs,double cs) {$/;"	f	file:
maxs	tools/alloca.cougar.c	/^    long maxs;			\/* Maximum number of stack segments so far.  *\/$/;"	m	struct:stk_stat	file:
maxtime	MeshMotionHandler.h	/^  double maxtime;$/;"	m	class:RigidRollMeshMotionHandler
maxverbose	Communicator.h	/^  int maxverbose;$/;"	m	class:Communicator
mc	MultiGridCoupledTsDesc.h	/^  int mc;$/;"	m	class:MultiGridCoupledTsDesc
mc	MultiGridEmbeddedTsDesc.h	/^  int mc;$/;"	m	class:MultiGridEmbeddedTsDesc
mc	MultiGridSegTsDesc.h	/^  int mc;$/;"	m	class:MultiGridSegTsDesc
mcaitr	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mcapps	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mcaup2	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mcaupd	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mceigt	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mceupd	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mcgets	arpack++/include/arpackf.h	/^    ARint mcaupd, mcaup2, mcaitr, mceigt, mcapps, mcgets, mceupd;$/;"	m	struct:XMLARSTR
mdot	IoData.h	/^  double mdot;$/;"	m	struct:BoundaryData
mds	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
memElems	Elem.h	/^  BlockAlloc memElems;$/;"	m	class:ElemSet
memFaces	Face.h	/^  BlockAlloc memFaces;$/;"	m	class:FaceSet
mem_usage_t	arpack++/include/arlspdef.h	/^} mem_usage_t;$/;"	t	typeref:struct:__anon41
memberFunctionTest	SparseGridGeneratorDesc.h	/^  void memberFunctionTest(double *in, double *res, double *parameters){ $/;"	f	class:SparseGridGeneratorDesc
memberfn_	SparseGrid.h	/^    MemberFunctionType memberfn_;$/;"	m	class:SparseGrid::Functor
mems	TsDesc.h	/^  MeshMotionSolver* mems;$/;"	m	class:TsDesc
merge	CommunicatorMPI.C	/^Communicator *Communicator::merge(bool high)$/;"	f	class:Communicator
merge	ConnectivityCore.C	/^Connectivity::merge(Connectivity *con2)$/;"	f	class:Connectivity
merge	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::merge(DistEmbeddedVec<Scalar,dim1> &y, DistEmbeddedVec<Scalar,dim2> &z)$/;"	f	class:DistEmbeddedVec
merge	DistVector.h	/^DistSVec<Scalar,dim>::merge(DistSVec<Scalar,dim1> &y, DistSVec<Scalar,dim2> &z)$/;"	f	class:DistSVec
mergeFinerInto	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::mergeFinerInto(MultiGridLevel& finer) {$/;"	f	class:MultiGridLevel
meritFunction	ImplicitCollocationTsDesc.C	/^double ImplicitCollocationTsDesc<dim>::meritFunction(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &dQ, DistSVec<double, dim> &F, double stepLength)  {$/;"	f	class:ImplicitCollocationTsDesc
meritFunction	ImplicitGnatTsDesc.C	/^double ImplicitGnatTsDesc<dim>::meritFunction(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &dQ, DistSVec<double, dim> &F, double stepLength)  {$/;"	f	class:ImplicitGnatTsDesc
meritFunction	ImplicitMetricTsDesc.C	/^double ImplicitMetricTsDesc<dim>::meritFunction(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &dQ, DistSVec<double, dim> &F, double stepLength)  {$/;"	f	class:ImplicitMetricTsDesc
meritFunction	ImplicitPGTsDesc.C	/^double ImplicitPGTsDesc<dim>::meritFunction(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &dQ, DistSVec<double, dim> &R, double stepLength)  {$/;"	f	class:ImplicitPGTsDesc
meritFunction	ImplicitRomPostproTsDesc.h	/^  double meritFunction(int, DistSVec<double, dim> &, DistSVec<double, dim> &, DistSVec<double, dim> &, double) {return 0.0;} \/\/ not applicable $/;"	f	class:ImplicitRomPostproTsDesc
meritFunction	IoData.h	/^  enum MeritFunction {ROM_RESIDUAL=0, HDM_RESIDUAL=1} meritFunction;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::MeritFunction
meritFunctionDeriv	ImplicitRomTsDesc.C	/^double ImplicitRomTsDesc<dim>::meritFunctionDeriv(int it, DistSVec<double, dim> &Q, DistSVec<double, dim> &p, DistSVec<double, dim> &R, double currentMerit)  { $/;"	f	class:ImplicitRomTsDesc
mesh	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
meshAssembly	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
meshFile	FSI/DynamicNodalTransfer.h	/^  char *meshFile;$/;"	m	class:EmbeddedStructure
meshKsp	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
meshMetrics	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
meshMotionBCs	Domain.h	/^  BCApplier* meshMotionBCs; \/\/HB$/;"	m	class:Domain
meshMotionBCs	EmbeddedCorotSolver.h	/^  BCApplier* meshMotionBCs;$/;"	m	class:EmbeddedCorotSolver
meshMotionBCs	MeshMotionSolver.h	/^  BCApplier* meshMotionBCs; \/\/HB$/;"	m	class:TetMeshMotionSolver
meshPrecSetup	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
meshVel	VarFcn.h	/^  Vec3D meshVel;$/;"	m	class:VarFcn
mesh_topology_threshold	MultiGridLevel.h	/^    double mesh_topology_threshold;$/;"	m	class:MultiGridLevel
meshderiv	IoData.h	/^  const char* meshderiv;$/;"	m	struct:SensitivityAnalysis
messages	SparseGridCore.C	/^void SparseGrid::messages(const int flag, const int arg) const{$/;"	f	class:SparseGrid
method	DistDynamicVMSTerm.h	/^  int          method;$/;"	m	class:DistDynamicVMSTerm
method	IoData.h	/^  enum Method {DIRECT = 0, ADJOINT = 1} method;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::Method
method	IoData.h	/^  enum Method {NONE = 0, GHOSTFLUID_FOR_POOR = 1, GHOSTFLUID_WITH_RIEMANN} method;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::Method
metis	IoData.h	/^  const char *metis;$/;"	m	struct:InputData
metric	NonlinearRom.h	/^  VecSet< DistSVec<double, dim> >* metric;$/;"	m	class:NonlinearRom
mf	IoData.h	/^  MultiFluidData mf;$/;"	m	class:IoData
mfRiemannNormal	Edge.h	/^  MultifluidRiemannNormal mfRiemannNormal;$/;"	m	class:EdgeSet
mf_phase_change_type	DistTimeState.h	/^  int mf_phase_change_type;$/;"	m	class:DistTimeState
mg	IoData.h	/^  MultiGridData mg;$/;"	m	class:IoData
mgKernel	MultiGridPrec.h	/^  MultiGridKernel<Scalar2>* mgKernel;$/;"	m	class:MultiGridPrec
mgKspSolver	MultiGridCoupledTsDesc.h	/^  MultiGridKspSolver<double,dim,double>* mgKspSolver;$/;"	m	class:MultiGridCoupledTsDesc
mgKspSolver	MultiGridEmbeddedTsDesc.h	/^  MultiGridKspSolver<double,dim,double>* mgKspSolver;$/;"	m	class:MultiGridEmbeddedTsDesc
mgKspSolver1	MultiGridSegTsDesc.h	/^  MultiGridKspSolver<double,neq1,double>* mgKspSolver1;$/;"	m	class:MultiGridSegTsDesc
mgKspSolver2	MultiGridSegTsDesc.h	/^  MultiGridKspSolver<double,neq2,double>* mgKspSolver2;$/;"	m	class:MultiGridSegTsDesc
mgLSS	MultiGridEmbeddedTsDesc.h	/^  DistMultiGridLevelSetStructure** mgLSS;$/;"	m	class:MultiGridEmbeddedTsDesc
mgLevel	MultiGridOperator.h	/^  MultiGridLevel<Scalar>* mgLevel;$/;"	m	class:MultiGridOperator
mgLevel	MultiGridSmoothingMatrix.h	/^  MultiGridLevel<Scalar>* mgLevel,*mgLevelRefined;$/;"	m	class:MultiGridSmoothingMatrix
mgLevelRefined	MultiGridSmoothingMatrix.h	/^  MultiGridLevel<Scalar>* mgLevel,*mgLevelRefined;$/;"	m	class:MultiGridSmoothingMatrix
mgLevelStatus	MultiGridLevel.h	/^    DistVec<int>* mgLevelStatus;$/;"	m	class:MultiGridLevel
mgMethod	MultiGridLevel.h	/^    MultiGridMethod mgMethod;$/;"	m	class:MultiGridLevel
mgMvp	MultiGridCoupledTsDesc.h	/^  MultiGridMvpMatrix<double,dim>* mgMvp;$/;"	m	class:MultiGridCoupledTsDesc
mgMvp	MultiGridEmbeddedTsDesc.h	/^  MultiGridMvpMatrix<double,dim>* mgMvp;$/;"	m	class:MultiGridEmbeddedTsDesc
mgMvp1	MultiGridSegTsDesc.h	/^  MultiGridMvpMatrix<double,neq1>* mgMvp1;$/;"	m	class:MultiGridSegTsDesc
mgMvp2	MultiGridSegTsDesc.h	/^  MultiGridMvpMatrix<double,neq2>* mgMvp2;$/;"	m	class:MultiGridSegTsDesc
mgSpaceOp	MultiGridCoupledTsDesc.h	/^  MultiGridSpaceOperator<double,dim>* mgSpaceOp;$/;"	m	class:MultiGridCoupledTsDesc
mgSpaceOp	MultiGridEmbeddedTsDesc.h	/^  MultiGridSpaceOperator<double,dim>* mgSpaceOp;$/;"	m	class:MultiGridEmbeddedTsDesc
mgSpaceOp	MultiGridSegTsDesc.h	/^  MultiGridSpaceOperator<double,dim>* mgSpaceOp;$/;"	m	class:MultiGridSegTsDesc
mgSubdomains	MultiGridLevel.h	/^    MultigridSubdomain* mgSubdomains;$/;"	m	class:MultiGridLevel
mg_output	IoData.h	/^  int mg_output;$/;"	m	struct:MultiGridData
mg_output	IoData.h	/^  int mg_output;$/;"	m	struct:PcData
mg_smooth_relax	IoData.h	/^  double mg_smooth_relax;$/;"	m	struct:MultiGridData
mg_smooth_relax	IoData.h	/^  double mg_smooth_relax;$/;"	m	struct:PcData
mg_smoother	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2 } mg_smoother;$/;"	m	struct:PcData	typeref:enum:PcData::MGSmoother
mg_smoother	IoData.h	/^  enum MGSmoother { MGJACOBI = 0, MGLINEJACOBI = 1, MGRAS = 2, MGGMRES = 3 } mg_smoother;$/;"	m	struct:MultiGridData	typeref:enum:MultiGridData::MGSmoother
mg_type	IoData.h	/^  enum MGType { MGALGEBRAIC = 0, MGGEOMETRIC = 1} mg_type;$/;"	m	struct:PcData	typeref:enum:PcData::MGType
mgetv0	arpack++/include/arpackf.h	/^    ARint logfil, ndigit, mgetv0;$/;"	m	struct:XMLARSTR
min	DESTerm.h	/^  double min(double a, double b) { return (a<b) ? a : b; }$/;"	f	class:DESTerm
min	DistVector.h	/^DistVec<Scalar>::min() const$/;"	f	class:DistVec
min	DistVector.h	/^void DistSVec<Scalar,dim>::min(Scalar vmin[dim]) const$/;"	f	class:DistSVec
min	FemEquationTermDesc.h	/^  double min(double a, double b) { return (a<b) ? a : b; }$/;"	f	class:FemEquationTermDES
min	LevelSet.C	/^static inline double min(double a,double b, double c, double d, double e, double f) {$/;"	f	file:
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a, const T b)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c,const T d)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c,const T d,const T e)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c,const T d,const T e,const T f)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c,const T d,const T e,const T f,const T g)$/;"	f	namespace:PhysBAM
min	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/min.h	/^inline T min(const T a,const T b,const T c,const T d,const T e,const T f,const T g,const T h)$/;"	f	namespace:PhysBAM
min	ProgrammedBurnCore.C	/^static double min(double a,double b) {$/;"	f	file:
min	Vector.h	/^  Scalar min() const {$/;"	f	class:SVec
min	Vector.h	/^  Scalar min() const {$/;"	f	class:Vec
min	Vector.h	/^  void min(Scalar vmin[dim]) const {$/;"	f	class:SVec
min	Vector3D.h	/^Vec3D min( const Vec3D& a, const Vec3D& b) {$/;"	f
min	arpack++/include/arbnspen.h	/^  int min(int a, int b) { return (a<b)?a:b; }$/;"	f	class:ARbdNonSymPencil
min	arpack++/include/arbspen.h	/^  int min(int a, int b) { return (a<b)?a:b; }$/;"	f	class:ARbdSymPencil
minBasisSize	IoData.h	/^  int minBasisSize;$/;"	m	struct:DataCompressionData
minClusterSize	IoData.h	/^  int minClusterSize;$/;"	m	struct:ClusteringData
minDimGreedyAlgorithm	IoData.h	/^  int minDimGreedyAlgorithm;$/;"	m	struct:GappyConstructionData
minDimension	IoData.h	/^	int minDimension;$/;"	m	struct:NonlinearRomOnlineNonStateData
minDimension	IoData.h	/^  int minDimension;$/;"	m	struct:NonlinearRomOnlineData
minDimension	IoData.h	/^  int minDimension;$/;"	m	struct:RelativeProjectionErrorData
minDimensionJacAction	IoData.h	/^  int minDimensionJacAction;$/;"	m	struct:GappyConstructionData
minDimensionKrylov	IoData.h	/^  int minDimensionKrylov;$/;"	m	struct:GappyConstructionData
minDimensionResidual	IoData.h	/^  int minDimensionResidual;$/;"	m	struct:GappyConstructionData
minDimensionSensitivity	IoData.h	/^  int minDimensionSensitivity;$/;"	m	struct:GappyConstructionData
minDimensionState	IoData.h	/^  int minDimensionState;$/;"	m	struct:GappyConstructionData
minDist	IntersectorFRG/IntersectorFRG.C	/^  double minDist; \/\/!< Signed distance to the surface$/;"	m	class:ClosestTriangle	file:
minFractionOfSampledNodesInTargetRegion	IoData.h	/^  double minFractionOfSampledNodesInTargetRegion;$/;"	m	struct:GappyConstructionData
minFractionOfSampledNodesOnSurfaceInTargetRegion	IoData.h	/^  double minFractionOfSampledNodesOnSurfaceInTargetRegion;$/;"	m	struct:GappyConstructionData
minMach	LowMachPrec.h	/^  double minMach;$/;"	m	class:LowMachPrec
minPoints	IoData.h	/^  int minPoints;$/;"	m	struct:SparseGridData
minPoints	SparseGrid.h	/^  int minPoints;          \/\/ min number of points in the grid$/;"	m	class:SparseGrid
minRcvData	SubDomain.C	/^void SubDomain::minRcvData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
minSampledNodes	IoData.h	/^  int minSampledNodes;$/;"	m	struct:GappyConstructionData
min_corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    T min_corner,max_corner;$/;"	m	class:PhysBAM::INTERVAL
min_corner	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    TV min_corner,max_corner;$/;"	m	class:PhysBAM::RANGE
minabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs(const T a,const T b)$/;"	f	namespace:PhysBAM
minabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
minabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs(const T a,const T b,const T c,const T d)$/;"	f	namespace:PhysBAM
minabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs(const T a,const T b,const T c,const T d,const T e)$/;"	f	namespace:PhysBAM
minabs	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs(const T a,const T b,const T c,const T d,const T e,const T f)$/;"	f	namespace:PhysBAM
minabs_incremental	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minabs.h	/^inline T minabs_incremental(const T a,const T b)$/;"	f	namespace:PhysBAM
minmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minmag.h	/^inline T minmag(const T a,const T b)$/;"	f	namespace:PhysBAM
minmag	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/minmag.h	/^inline T minmag(const T a,const T b,const T c)$/;"	f	namespace:PhysBAM
missing_element_hash	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    static const int missing_element_hash=32138912;$/;"	m	class:PhysBAM::HASH
mkdatname	arpack++/include/arch.h	/^	void mkdatname() {}$/;"	f
mkidxname	arpack++/include/arch.h	/^	void mkidxname() {}$/;"	f
mmapLock	Malloc.C	/^ulock_t mmapLock = 0;$/;"	v
mmh	TsDesc.h	/^  MeshMotionHandler* mmh;$/;"	m	class:TsDesc
mms	FluidCollocationShapeOptimizationHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:FluidCollocationShapeOptimizationHandler
mms	FluidGnatShapeOptimizationHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:FluidGnatShapeOptimizationHandler
mms	FluidMetricShapeOptimizationHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:FluidMetricShapeOptimizationHandler
mms	FluidRomShapeOptimizationHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:FluidRomShapeOptimizationHandler
mms	FluidShapeOptimizationHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:FluidShapeOptimizationHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:AeroMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:DeformingMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:EmbeddedALEMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:HeavingMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:PitchingMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:RigidRollMeshMotionHandler
mms	MeshMotionHandler.h	/^  MeshMotionSolver *mms;$/;"	m	class:SpiralingMeshMotionHandler
mms1	MeshMotionHandler.h	/^  MeshMotionSolver *mms1;$/;"	m	class:AeroMeshMotionHandler
mmsBCs	SubDomain.h	/^  BCondSet *mmsBCs;$/;"	m	class:SubDomain
mnaitr	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mnapps	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mnaup2	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mnaupd	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mneigt	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mneupd	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mngets	arpack++/include/arpackf.h	/^    ARint mnaupd, mnaup2, mnaitr, mneigt, mnapps, mngets, mneupd;$/;"	m	struct:XMLARSTR
mns	FSI/DynamicNodalTransfer.h	/^  MatchNodeSet **mns;$/;"	m	class:EmbeddedStructure
modS_Test	DistDynamicLESTerm.h	/^  DistVec<double> *modS_Test;$/;"	m	class:DistDynamicLESTerm
mode	Communicator.h	/^  Mode mode;$/;"	m	class:CommPattern
mode	FSI/DynamicNodalTransfer.h	/^  int mode;$/;"	m	class:EmbeddedStructure
mode	IntersectorFRG/IntersectorFRG.C	/^  int mode;$/;"	m	class:ClosestTriangle	file:
mode	IoData.h	/^  enum Mode { NORMAL=0, CONVTEST1 = 1, CONVTEST2=2 } mode;$/;"	m	struct:OneDimensionalInfo	typeref:enum:OneDimensionalInfo::Mode
mode	IoData.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::Mode
mode	IoData.h	/^  enum Mode {Recursive = 1, NonRecursive = 2} mode;$/;"	m	struct:DefoMeshMotionData	typeref:enum:DefoMeshMotionData::Mode
mode	LevelSet/LevelSetStructure.h	/^  int mode; \/\/-2: unknown, -1: far from interface, 0: face, 1: edge, 2: vertex.$/;"	m	struct:ClosestPoint
mode	RefVal.h	/^  enum Mode {NON_DIMENSIONAL = 0, DIMENSIONAL = 1} mode;$/;"	m	class:RefVal	typeref:enum:RefVal::Mode
mode	arpack++/include/arrseig.h	/^  int     mode;       \/\/ Indicates the type of the eigenproblem (regular,$/;"	m	class:ARrcStdEig
modeFile	TsOutput.h	/^  char *modeFile;$/;"	m	class:TsOutput
modeNumber	IoData.h	/^  int modeNumber;$/;"	m	struct:LinearizedData
modifiedGhidaglia	TsDesc.h	/^  bool modifiedGhidaglia;$/;"	m	class:TsDesc
modifiedGramSchmidt	Modal.C	/^void ModalSolver<dim>::modifiedGramSchmidt(VecSet<DistSVec<double,dim> > &vectors, double *Rmatrix, int numVecs)$/;"	f	class:ModalSolver
momPat	Domain.h	/^  CommPattern<double> *momPat;$/;"	m	class:Domain
moment	RefVal.h	/^  double moment;$/;"	m	class:RefVal
monitorAvgForceConvergence	TsDesc.C	/^bool TsDesc<dim>::monitorAvgForceConvergence(IoData &ioData, int it, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
monitorConvergence	ImplicitGappyTsDesc.C	/^bool ImplicitGappyTsDesc<dim>::monitorConvergence(int it, DistSVec<double,dim> &U)$/;"	f	class:ImplicitGappyTsDesc
monitorConvergence	ImplicitPGTsDesc.C	/^bool ImplicitPGTsDesc<dim>::monitorConvergence(int it, DistSVec<double,dim> &U)$/;"	f	class:ImplicitPGTsDesc
monitorConvergence	ImplicitRomPostproTsDesc.C	/^bool ImplicitRomPostproTsDesc<dim>::monitorConvergence(int it, DistSVec<double,dim> &U)$/;"	f	class:ImplicitRomPostproTsDesc
monitorConvergence	TsDesc.C	/^bool TsDesc<dim>::monitorConvergence(int it, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
monitorForceConvergence	TsDesc.C	/^bool TsDesc<dim>::monitorForceConvergence(IoData &ioData, int it, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
monitorInitialState	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::monitorInitialState(int it, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
monitorInitialState	ImplicitGappyTsDesc.C	/^void ImplicitGappyTsDesc<dim>::monitorInitialState(int it, DistSVec<double,dim> &U)$/;"	f	class:ImplicitGappyTsDesc
monitorInitialState	ImplicitPGTsDesc.C	/^void ImplicitPGTsDesc<dim>::monitorInitialState(int it, DistSVec<double,dim> &U)$/;"	f	class:ImplicitPGTsDesc
monitorInitialState	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::monitorInitialState(int it, DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
monitorInitialState	TsDesc.C	/^void TsDesc<dim>::monitorInitialState(int it, DistSVec<double,dim> &U)$/;"	f	class:TsDesc
moveMesh	TsDesc.C	/^void TsDesc<dim>::moveMesh(IoData &ioData, GeoSource &geoSource)$/;"	f	class:TsDesc
mp	Edge.h	/^  MapPair *mp;$/;"	m	class:EdgeSet
mppFactor	MeshMotionHandler.h	/^  double mppFactor;$/;"	m	class:AeroMeshMotionHandler
msaitr	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
msapps	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
msaup2	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
msaupd	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
mseigt	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
mseupd	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
msgets	arpack++/include/arpackf.h	/^    ARint msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd;$/;"	m	struct:XMLARSTR
mt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    unsigned int mt[624];$/;"	m	class:PhysBAM::MT19937
mult_local_face_hh	Face.C	/^inline double mult_local_face_hh(T t, double a) {$/;"	f
mult_local_face_hh	Face.C	/^inline double mult_local_face_hh<bcomp>(bcomp t, double a) {$/;"	f
multiFluidInterface	Domain.h	/^  class TriangulatedInterface* multiFluidInterface;$/;"	m	class:Domain	typeref:class:Domain::TriangulatedInterface
multiFluidInterfaceOrder	MultiPhysicsTsDesc.h	/^  int multiFluidInterfaceOrder;$/;"	m	class:MultiPhysicsTsDesc
multiGridLevel	MultiGridKspSolver.h	/^  MultiGridLevel<Scalar>* multiGridLevel;$/;"	m	class:MultiGridMatVecProd
multiGridLevels	MultiGridKernel.h	/^  MultiGridLevel<Scalar> ** multiGridLevels;$/;"	m	class:MultiGridKernel
multiIndex	SparseGrid.h	/^  int **multiIndex;       \/\/ multi-index for each stored subgrid$/;"	m	class:SparseGrid
multiInitialConditions	IoData.h	/^  MultiInitialConditionsData multiInitialConditions;$/;"	m	struct:MultiFluidData
multiPade	SubDomainCore.C	/^void SubDomain::multiPade(bcomp *compMat, int *stepParam, double *deltaFreqCoarse, bcomp *padeMat, bcomp *padeVec, int L, int M, int nPoints, double deltaFreqFine, double freqMidFreq, bcomp *snaps, double *freqCoarse)$/;"	f	class:SubDomain
multiPhaseSpaceOp	LevelSetTsDesc.h	/^  MultiPhaseSpaceOperator<dim,dimLS> *multiPhaseSpaceOp;$/;"	m	class:LevelSetTsDesc
multiPhaseSpaceOp	MultiPhysicsTsDesc.h	/^  MultiPhaseSpaceOperator<dim,dimLS> *multiPhaseSpaceOp;$/;"	m	class:MultiPhysicsTsDesc
multiPointsDeltaFreq	SubDomainCore.C	/^void SubDomain::multiPointsDeltaFreq(int mFreqStart, double *freqCoarse, int nPoints, double* mDeltaFreq, int *midFreq)$/;"	f	class:SubDomain
multiPointsFreq	SubDomainCore.C	/^int SubDomain::multiPointsFreq(int nInterval, int nPoints, double *freqCoarse, int numFreqCoarse, int flag)$/;"	f	class:SubDomain
multiSolnFluxNorm	IoData.h	/^  const char* multiSolnFluxNorm;$/;"	m	struct:TransientData
multiSolutions	IoData.h	/^  const char *multiSolutions;$/;"	m	struct:InputData
multiSolutions	TsInput.h	/^  char *multiSolutions;$/;"	m	struct:TsInput
multiSolutionsParams	IoData.h	/^  const char *multiSolutionsParams; \/\/ ROMs: path to a file listing file paths to solutions (not used) and their corresponding operating point (solutions are assumed to be in the same order as in the multiSolutions file)$/;"	m	struct:InputData
multiStateSnapRefSolution	IoData.h	/^  const char *multiStateSnapRefSolution;$/;"	m	struct:InputData
multiUic	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* multiUic;$/;"	m	class:NonlinearRom
multiUicCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > multiUicCentersDifProduct;$/;"	m	class:NonlinearRom
multiUicMultiUicProducts	NonlinearRom.h	/^  std::vector<std::vector<double> > multiUicMultiUicProducts; \/\/[Ui][Uj] symmetric (lower triangular)$/;"	m	class:NonlinearRom
multiUicMultiUicProductsName	NonlinearRom.h	/^  char* multiUicMultiUicProductsName;$/;"	m	class:NonlinearRom
multiplicity	Communicator.h	/^  static int multiplicity;$/;"	m	class:CommTrace
multiplicity	CommunicatorMPI.C	/^int CommTrace<bool>::multiplicity = 1;$/;"	m	class:CommTrace	file:
multiplicity	CommunicatorMPI.C	/^int CommTrace<char>::multiplicity = 1;$/;"	m	class:CommTrace	file:
multiplicity	CommunicatorMPI.C	/^int CommTrace<double>::multiplicity = 1;$/;"	m	class:CommTrace	file:
multiplicity	CommunicatorMPI.C	/^int CommTrace<float>::multiplicity = 1;$/;"	m	class:CommTrace	file:
multiplicity	CommunicatorMPI.C	/^int CommTrace<int>::multiplicity = 1;$/;"	m	class:CommTrace	file:
multiplicity	CommunicatorMPI.C	/^int CommTrace<std::complex<double> >::multiplicity = 2;$/;"	m	class:CommTrace	file:
multiplicity	IntersectorPhysBAM/Mpi_Utilities.C	/^template <> int CommTrace<pair<int,int> >::multiplicity=2;$/;"	m	class:CommTrace	file:
multiplyByPreconditioner	DistTimeState.C	/^void DistTimeState<dim>::multiplyByPreconditioner(DistSVec<double,dim>& U0, DistSVec<double,dim>& dU)$/;"	f	class:DistTimeState
multiplyByPreconditionerLiquid	DistTimeState.C	/^void DistTimeState<dim>::multiplyByPreconditionerLiquid(DistSVec<double,dim> &U, DistSVec<double,dim> &dU)$/;"	f	class:DistTimeState
multiplyByPreconditionerPerfectGas	DistTimeState.C	/^void DistTimeState<dim>::multiplyByPreconditionerPerfectGas(DistSVec<double,dim>& U0, DistSVec<double,dim>& dU)$/;"	f	class:DistTimeState
multiplyByTimeStep	DistTimeState.C	/^void DistTimeState<dim>::multiplyByTimeStep(DistSVec<double,dim>& dU)$/;"	f	class:DistTimeState
multiplyByTimeStep	DistTimeState.C	/^void DistTimeState<dim>::multiplyByTimeStep(DistSVec<double,dimLS>& dPhi)$/;"	f	class:DistTimeState
multiplyByTimeStep	DistTimeState.C	/^void DistTimeState<dim>::multiplyByTimeStep(DistVec<double>& dU)$/;"	f	class:DistTimeState
multiplyBydVdU	FemEquationTerm.h	/^  void multiplyBydVdU(double V[4], double mat[9], double* res, double scaling) $/;"	f	class:FemEquationTerm
multiplyBydVdU	VarFcn.h	/^  void multiplyBydVdU(double *V, bcomp *vec, bcomp *res, int tag=0) { check(tag); varFcn[tag]->multiplyBydVdU(V,vec,res); }$/;"	f	class:VarFcn
multiplyBydVdU	VarFcn.h	/^  void multiplyBydVdU(double *V, double *vec, double *res, int tag=0) { check(tag); varFcn[tag]->multiplyBydVdU(V,vec,res); }$/;"	f	class:VarFcn
multiplyBydVdU	VarFcnBase.h	/^void VarFcnBase::multiplyBydVdU(double *V, bcomp *vec, bcomp *res) {$/;"	f	class:VarFcnBase
multiplyBydVdU	VarFcnBase.h	/^void VarFcnBase::multiplyBydVdU(double *V, double *vec, double *res) {$/;"	f	class:VarFcnBase
multiplyBydVdU	VarFcnSGKE.h	/^  void multiplyBydVdU(double *, bcomp *, bcomp *) {fprintf(stderr,"ERROR: multiplyBydVdU needs to be implemented...\\n");}$/;"	f	class:VarFcnSGKE
multiplyBydVdU	VarFcnSGKE.h	/^void VarFcnSGKE::multiplyBydVdU(double *V, double *vec, double *res)$/;"	f	class:VarFcnSGKE
multiplyBydVdU	VarFcnSGSA.h	/^  void multiplyBydVdU(double *, bcomp *, bcomp *) {fprintf(stderr,"ERROR: multiplyBydVdU needs to be implemented...\\n");}$/;"	f	class:VarFcnSGSA
multiplyBydVdU	VarFcnSGSA.h	/^void VarFcnSGSA::multiplyBydVdU(double *V, double *vec, double *res)$/;"	f	class:VarFcnSGSA
multiplyBydVdU	VarFcnTaitKE.h	/^void VarFcnTaitKE::multiplyBydVdU(double *V, double *vec, double *res)$/;"	f	class:VarFcnTaitKE
multiplyBydVdU	VarFcnTaitSA.h	/^void VarFcnTaitSA::multiplyBydVdU(double *V, double *vec, double *res)$/;"	f	class:VarFcnTaitSA
multiplyBydVdUT	VarFcn.h	/^  void multiplyBydVdUT(double *V, bcomp *vec, bcomp *res, int tag=0) { check(tag); varFcn[tag]->multiplyBydVdUT(V,vec,res); }$/;"	f	class:VarFcn
multiplyBydVdUT	VarFcn.h	/^  void multiplyBydVdUT(double *V, double *vec, double *res, int tag=0) { check(tag); varFcn[tag]->multiplyBydVdUT(V,vec,res); }$/;"	f	class:VarFcn
multiplyBydVdUT	VarFcnBase.h	/^void VarFcnBase::multiplyBydVdUT(double *V, bcomp *vec, bcomp *res) {$/;"	f	class:VarFcnBase
multiplyBydVdUT	VarFcnBase.h	/^void VarFcnBase::multiplyBydVdUT(double *V, double *vec, double *res) {$/;"	f	class:VarFcnBase
multiplyGAM	Modal.C	/^void ModalSolver<dim>::multiplyGAM(double sReal, double sImag, complex<double> *reigvector, Vec<bcomp> &GAMreigenvector)$/;"	f	class:ModalSolver
multiply_dQdLambda	Modal.C	/^void ModalSolver<dim>::multiply_dQdLambda(double sReal, double sImag, complex<double> *reigvector, Vec<bcomp> &GAMreigenvector)$/;"	f	class:ModalSolver
mutOmu	IoData.h	/^  const char *mutOmu;$/;"	m	struct:TransientData
mutOmu	PostOperator.h	/^  DistVec<double> *mutOmu;$/;"	m	class:PostOperator
mvp	EmbeddedFluidShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
mvp	FluidCollocationShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:FluidCollocationShapeOptimizationHandler
mvp	FluidGnatShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:FluidGnatShapeOptimizationHandler
mvp	FluidMetricShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:FluidMetricShapeOptimizationHandler
mvp	FluidRomShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:FluidRomShapeOptimizationHandler
mvp	FluidShapeOptimizationHandler.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:FluidShapeOptimizationHandler
mvp	ImplicitCoupledTsDesc.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:ImplicitCoupledTsDesc
mvp	ImplicitEmbeddedCoupledTsDesc.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:ImplicitEmbeddedCoupledTsDesc
mvp	ImplicitLevelSetTsDesc.h	/^  MatVecProdMultiPhase<dim,dimLS> *mvp;$/;"	m	class:ImplicitLevelSetTsDesc
mvp	ImplicitMultiPhysicsTsDesc.h	/^  MatVecProdMultiPhase<dim,dimLS> *mvp;$/;"	m	class:ImplicitMultiPhysicsTsDesc
mvp	ImplicitRomTsDesc.h	/^  MatVecProd<dim,dim> *mvp;$/;"	m	class:ImplicitRomTsDesc
mvp	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::Mvp
mvp	IoData.h	/^  enum Mvp {FD = 0, H1 = 1, H2 = 2, H1FD = 3} mvp;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::Mvp
mvp	MeshMotionSolver.h	/^  StiffMat<double,3> *mvp;$/;"	m	class:TetMeshMotionSolver
mvp1	ImplicitEmbeddedSegTsDesc.h	/^  MatVecProd<dim,neq1> *mvp1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
mvp1	ImplicitSegTsDesc.h	/^  MatVecProd<dim,neq1> *mvp1;$/;"	m	class:ImplicitSegTsDesc
mvp2	ImplicitEmbeddedSegTsDesc.h	/^  MatVecProd<dim,neq2> *mvp2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
mvp2	ImplicitSegTsDesc.h	/^  MatVecProd<dim,neq2> *mvp2;$/;"	m	class:ImplicitSegTsDesc
mvpLS	ImplicitLevelSetTsDesc.h	/^  MatVecProdLS<dim,dimLS> *mvpLS;$/;"	m	class:ImplicitLevelSetTsDesc
mvpLS	ImplicitMultiPhysicsTsDesc.h	/^  MatVecProdLS<dim,dimLS> *mvpLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
mvpMat	MultiGridPrec.h	/^  DistMvpMatrix<Scalar2,dim>* mvpMat;$/;"	m	class:MultiGridPrec
mvpMatrices	MultiGridPrec.h	/^  MultiGridMvpMatrix<Scalar2,dim>* mvpMatrices;$/;"	m	class:MultiGridPrec
mvpOp	KspSolver.h	/^  MatVecProdOp *mvpOp;$/;"	m	class:KspSolver
mvpfd	ImplicitSegTsDesc.h	/^  MatVecProd<dim,dim> *mvpfd;$/;"	m	class:ImplicitSegTsDesc
mvpfd1	ImplicitCoupledTsDesc.h	/^  MatVecProd<dim,dim> *mvpfd1;$/;"	m	class:ImplicitCoupledTsDesc
myA	MultiGridMvpMatrix.h	/^  DistMvpMatrix<Scalar,neq>** myA;$/;"	m	class:MultiGridMvpMatrix
myBcData	MultiGridOperator.h	/^  DistBcData<dim>* myBcData;$/;"	m	class:MultiGridOperator
myBurns	ProgrammedBurn.h	/^  std::vector<Burn> myBurns;$/;"	m	class:ProgrammedBurn
myCom	DistExtrapolation.h	/^  Communicator *myCom;$/;"	m	class:DistExtrapolation
myConj	KspSolver.C	/^inline double myConj(double x)  { return x; }$/;"	f
myConj	KspSolver.C	/^inline std::complex<double>  myConj(std::complex<double> x)  { return std::conj(x); }$/;"	f
myExactInterface	LevelSetTsDesc.h	/^  std::vector< exactInterfacePoint > myExactInterface;$/;"	m	class:LevelSetTsDesc
myFaces	AgglomeratedFace.h	/^  AgglomeratedFace* myFaces;$/;"	m	class:AgglomeratedFaceSet
myFineMat	MultiGridPrec.h	/^  DistMat<Scalar2,dim>* myFineMat;$/;"	m	class:MultiGridPrec
myFluidId	LocalRiemann.h	/^    int myFluidId;$/;"	m	struct:LocalRiemannGfmpar::RiemannInvParams
myGeoState	MultiGridLevel.h	/^    DistGeoState* myGeoState;$/;"	m	class:MultiGridLevel
myIoData	DistNodalGrad.h	/^  IoData* myIoData;$/;"	m	class:DistNodalGrad
myIoData	MultiGridLevel.h	/^    IoData* myIoData;$/;"	m	class:MultiGridLevel
myIoDataPtr	ImplicitTsDesc.h	/^  IoData* myIoDataPtr;$/;"	m	class:ImplicitTsDesc
myLevel	LevelSet/MultiGridLevelSetStructure.h	/^    MultiGridLevel<double>* myLevel;$/;"	m	class:MultiGridLevelSetStructure
myLevel	LevelSet/MultiGridLevelSetStructure.h	/^  MultiGridLevel<double>* myLevel;$/;"	m	class:DistMultiGridLevelSetStructure
myMethod	RKIntegrator.h	/^  Method myMethod;$/;"	m	class:RKIntegrator
myNodalGrad	MultiGridOperator.h	/^  DistNodalGrad<dim,Scalar>* myNodalGrad;$/;"	m	class:MultiGridOperator
myNodes	IoData.h	/^  Node myNodes[MAXNODES];$/;"	m	struct:Probes
myOperators	MultiGridSpaceOperator.h	/^  MultiGridOperator<Scalar,dim>** myOperators;$/;"	m	class:MultiGridSpaceOperator
myPx	MultiGridPrec.h	/^  MultiGridDistSVec<Scalar2,dim> xold, myX, myPx, myR;  $/;"	m	class:MultiGridPrec
myR	MultiGridPrec.h	/^  MultiGridDistSVec<Scalar2,dim> xold, myX, myPx, myR;  $/;"	m	class:MultiGridPrec
mySmoothingMode	MultiGridSmoothingMatrix.h	/^  SmoothingMode mySmoothingMode;$/;"	m	class:MultiGridSmoothingMatrix
mySub	LevelSet/MultiGridLevelSetStructure.h	/^    int mySub;$/;"	m	class:MultiGridLevelSetStructure
mySubToSub	Domain.h	/^  Connectivity* mySubToSub;$/;"	m	class:Domain
myTimer	OneDimensionalSolver.h	/^  Timer* myTimer;$/;"	m	class:OneDimensional
myTree	SubDomain.h	/^  RTree<Elem>* myTree;$/;"	m	class:SubDomain
myTriangulatedInterface	LevelSetTsDesc.h	/^  TriangulatedInterface* myTriangulatedInterface;$/;"	m	class:LevelSetTsDesc
myVarFcn	MultiGridOperator.h	/^  VarFcn* myVarFcn;$/;"	m	class:MultiGridOperator
myVecs	MultiGridDistSVec.h	/^  DistSVec<Scalar,dim>** myVecs;$/;"	m	class:MultiGridDistSVec
myX	MultiGridPrec.h	/^  MultiGridDistSVec<Scalar2,dim> xold, myX, myPx, myR;  $/;"	m	class:MultiGridPrec
my_dim	MultiGridLevel.h	/^    int my_dim, neq1,neq2;$/;"	m	class:MultiGridLevel
n	BCApplier.h	/^  double n[3];$/;"	m	struct:ProjData
n	DenseMatrix.h	/^  int n;$/;"	m	class:SymFullM
n	DiagMatrix.h	/^  int n;$/;"	m	class:DiagMat
n	EmbeddedCorotSolver.h	/^  double n[3];$/;"	m	class:EmbeddedCorotSolver
n	IntersectorFRG/IntersectorFRG.C	/^  Vec3D n;$/;"	m	class:ClosestTriangle	file:
n	MultiGridSmoothingMatrix.h	/^  int n;$/;"	m	class:MultiGridSmoothingMatrix
n	MvpMatrix.h	/^  int n;$/;"	m	class:MvpMat
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::DIAGONAL_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::DIAGONAL_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    enum WORKAROUND1 {m=m_input,n=n_input,size=n_input*m_input};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    enum WORKAROUND1 {m=0,n=0};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    enum WORKAROUND1 {m=0,n=1};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    enum WORKAROUND1 {m=1,n=1};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    enum WORKAROUND1 {m=1,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    enum WORKAROUND1 {m=3,n=2};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n,class RW> struct IS_BINARY_IO_SAFE<MATRIX<T,m,n>,RW> {static const bool value=AND<(m>0),(n>0),IS_BINARY_IO_SAFE<T,RW>::value>::value;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    int m,n; \/\/ size of the m by n matrix$/;"	m	class:PhysBAM::MATRIX_MXN
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::SYMMETRIC_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::SYMMETRIC_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    enum WORKAROUND1 {m=T_MATRIX::n,n=T_MATRIX::m};$/;"	e	enum:PhysBAM::TRANSPOSE_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    enum WORKAROUND1 {m=2,n=2};$/;"	e	enum:PhysBAM::UPPER_TRIANGULAR_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    enum WORKAROUND1 {m=3,n=3};$/;"	e	enum:PhysBAM::UPPER_TRIANGULAR_MATRIX::WORKAROUND1
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.h	/^    static const int n=624,m=397;$/;"	m	class:PhysBAM::MT19937
n	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    int n; \/\/ size of the n vector$/;"	m	class:PhysBAM::VECTOR_ND
n	RectangularSparseMatrix.h	/^  int n;                    \/\/ number of unknown blocks$/;"	m	class:RectangularSparseMat
n	SparseMatrix.h	/^  int n;                    \/\/ number of unknown blocks$/;"	m	class:SparseMat
n	arpack++/include/ardfmat.h	/^  int      n;         \/\/ Number of columns.$/;"	m	class:ARdfMatrix
n	arpack++/include/arhbmat.h	/^  int     n;               \/\/ Number of columns.$/;"	m	class:ARhbMatrix
n	arpack++/include/arlspdef.h	/^    int     n;        \/* number of columns in the matrix *\/$/;"	m	struct:__anon35
n	arpack++/include/arlspdef.h	/^    int     n;        \/* number of columns in the matrix *\/$/;"	m	struct:__anon36
n	arpack++/include/arlspdef.h	/^    int     n;        \/* number of columns in the matrix *\/$/;"	m	struct:__anon37
n	arpack++/include/arlspdef.h	/^    int     n;        \/* number of columns in the matrix *\/$/;"	m	struct:__anon38
n	arpack++/include/armat.h	/^  int  m, n;    \/\/ Number of rows and columns.$/;"	m	class:ARMatrix
n	arpack++/include/arrseig.h	/^  int     n;          \/\/ Dimension of the eigenproblem.$/;"	m	class:ARrcStdEig
n1	IntersectorFRG/IntersectorFRG.C	/^  int n1, n2; \/\/!< if both ns are non negative, the best point is on an edge$/;"	m	class:ClosestTriangle	file:
n2	IntersectorFRG/IntersectorFRG.C	/^  int n1, n2; \/\/!< if both ns are non negative, the best point is on an edge$/;"	m	class:ClosestTriangle	file:
n2p	IntersectorFRG/IntersectorFRG.h	/^    map<int,int> n2p; \/\/node Id (index from 0) -> particle Id (index from 0 NOT 1!!!)$/;"	m	class:IntersectorFRG
nAdaptivePoints	SparseGrid.h	/^  int nAdaptivePoints;    \/\/ tracks the number of adaptive points during $/;"	m	class:SparseGrid
nApproxMetricSampleNodes	GappyPreprocessing.h	/^  int nApproxMetricSampleNodes;$/;"	m	class:GappyPreprocessing
nBuffer	NonlinearRom.h	/^  int nBuffer; \/\/ number of buffer vectors added for updates $/;"	m	class:NonlinearRom
nClusters	IoData.h	/^  int nClusters;$/;"	m	struct:NonlinearRomFileSystemData
nClusters	NonlinearRom.h	/^  int nClusters;$/;"	m	class:NonlinearRom
nElems	FSI/DynamicNodalTransfer.h	/^  int nElems, totalElems;$/;"	m	class:EmbeddedStructure
nFirstLayer	IntersectorFRG/IntersectorFRG.h	/^    int nFirstLayer;$/;"	m	class:IntersectorFRG
nFirstLayer	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int nFirstLayer;$/;"	m	class:IntersectorPhysBAM
nFullMeshNodes	NonlinearRom.h	/^  int nFullMeshNodes;$/;"	m	class:NonlinearRom
nGlobalSubDomains	IntersectorPhysBAM/FloodFill.h	/^GLOBAL_SUBD_ID nGlobalSubDomains;$/;"	m	class:FloodFill
nGravity	PostFcn.h	/^  double nGravity[3];$/;"	m	class:PostFcnEuler
nGreedyIt	GappyPreprocessing.h	/^	int nRhsMax, nGreedyIt, handledNodes;$/;"	m	class:GappyPreprocessing
nInfNd	CorotSolver.h	/^  int *nInfNd;     \/\/ number of nodes at infinity per sub$/;"	m	class:CorotSolver
nInterfNd	CorotSolver.h	/^  int *nInterfNd;  \/\/ int nInerfNd[3] ==> number of nodes for sub 3$/;"	m	class:CorotSolver
nInternalNd	CorotSolver.h	/^  int *nInternalNd;$/;"	m	class:CorotSolver
nKrylov	NonlinearRom.h	/^  int nState, nKrylov, nSens;$/;"	m	class:NonlinearRom
nLevels	MultiGridDistSVec.h	/^  int nLevels;$/;"	m	class:MultiGridDistSVec
nLevels	MultiGridKspSolver.h	/^  int nLevels;$/;"	m	class:MultiGridKspSolver
nLevels	MultiGridMvpMatrix.h	/^  int nLevels;$/;"	m	class:MultiGridMvpMatrix
nLevels	MultiGridSmoothingMatrices.h	/^  int nLevels;$/;"	m	class:MultiGridSmoothingMatrices
nLevels	MultiGridSpaceOperator.h	/^  int nLevels;$/;"	m	class:MultiGridSpaceOperator
nLevelset	IoData.h	/^  int nLevelset; \/\/number of level-sets. Currently only consider bubbles.$/;"	m	struct:EmbeddedFramework
nLowRankFactors	NonlinearRom.h	/^  int nLowRankFactors;$/;"	m	class:NonlinearRom
nNodes	FSI/CrackingSurface.h	/^  int nNodes;$/;"	m	struct:PhantomElement
nNodes	FSI/DynamicNodalTransfer.h	/^  int nNodes, totalNodes;$/;"	m	class:EmbeddedStructure
nObj	IntersectorFRG/Geometry/KDTree.h	/^     int nObj;$/;"	m	class:KDTree
nPadeDeriv	Modal.h	/^    int nPadeDeriv;$/;"	m	class:ModalSolver
nPairs	IntersectorFRG/IntersectorFRG.C	/^  int nPairs;$/;"	m	class:ClosestTriangle	file:
nParts	IoData.h	/^  int nParts;$/;"	m	struct:InputData
nPendReq	Communicator.h	/^  int nPendReq;$/;"	m	class:Communicator
nPod	GappyPreprocessing.h	/^	int nPod [2];	\/\/ nPod[0] = nPodRes, nPod[1] = nPodJac$/;"	m	class:GappyPreprocessing
nPod	ImplicitRomTsDesc.h	/^  int nPod;$/;"	m	class:ImplicitRomTsDesc
nPodBasis	GappyPreprocessing.h	/^	int nPodBasis;	\/\/ # of unique pod bases for residual\/jac (either 1 or 2)$/;"	m	class:GappyPreprocessing
nPodJac	ImplicitGnatTsDesc.h	/^  int nPodJac;	\/\/nPodJac specified under ROB{ NumROB2 }$/;"	m	class:ImplicitGnatTsDesc
nPodMax	GappyPreprocessing.h	/^	int nPodMax;$/;"	m	class:GappyPreprocessing
nPodState	GappyPreprocessing.h	/^	int nPodState;$/;"	m	class:GappyPreprocessing
nPoints	IoData.h	/^  int nPoints;$/;"	m	struct:PadeData
nPoints	SparseGrid.h	/^  int nPoints;            \/\/ number of stored points (on the sparse grid)$/;"	m	class:SparseGrid
nPowerIts	IoData.h	/^  int nPowerIts;$/;"	m	struct:DataCompressionData
nPowerIts	IoData.h	/^  int nPowerIts;$/;"	m	struct:GappyConstructionData
nReducedNodes	GappyPreprocessing.h	/^  int numFullNodes, nReducedNodes;	\/\/ number of nodes in full and reduced meshes$/;"	m	class:GappyPreprocessing
nRhs	GappyPreprocessing.h	/^	int nRhs [2];	\/\/ nRhs at a given greedy iteration$/;"	m	class:GappyPreprocessing
nRhsGreedy	GappyPreprocessing.h	/^	int *(nRhsGreedy [2]);$/;"	m	class:GappyPreprocessing
nRhsMax	GappyPreprocessing.h	/^	int nRhsMax, nGreedyIt, handledNodes;$/;"	m	class:GappyPreprocessing
nSampleNodes	GappyPreprocessing.h	/^	int nSampleNodes;	\/\/ number of parent sample globalNodes$/;"	m	class:GappyPreprocessing
nSampleNodes	NonlinearRom.h	/^  int nSampleNodes;$/;"	m	class:NonlinearRom
nSens	NonlinearRom.h	/^  int nState, nKrylov, nSens;$/;"	m	class:NonlinearRom
nSmooth1	MultiGridKernel.h	/^  int nSmooth1,nSmooth2;$/;"	m	class:MultiGridKernel
nSmooth2	MultiGridKernel.h	/^  int nSmooth1,nSmooth2;$/;"	m	class:MultiGridKernel
nSnapShotFiles	EmbeddedAlternatingLeastSquare.h	/^    int nSnapShotFiles;$/;"	m	class:EmbeddedAlternatingLeastSquare
nSnapshotFiles	NonlinearRomDatabaseConstruction.h	/^  int nSnapshotFiles;  \/\/ number of snapshot files; should be the same for all FOM snapshots (state, residual, etc.)$/;"	m	class:NonlinearRomDatabaseConstruction
nSortedNodes	ReinitializeDistanceToWall.h	/^  int* nSortedNodes,*firstCheckedNode;$/;"	m	class:ReinitializeDistanceToWall
nState	NonlinearRom.h	/^  int nState, nKrylov, nSens;$/;"	m	class:NonlinearRom
nStrMode	Modal.h	/^    int nStrMode;$/;"	m	class:ModalSolver
nSubGrids	SparseGrid.h	/^  int nSubGrids;          \/\/ number of stored subgrids$/;"	m	class:SparseGrid
nToken	parser/Dictionary.h	/^   int nToken;$/;"	m	class:Dictionary
nTotCpus	GappyPreprocessing.h	/^	int numLocSub, nTotCpus, thisCPU; $/;"	m	class:GappyPreprocessing
nTotCpus	ParallelRom.h	/^	int nTotCpus;$/;"	m	class:ParallelRom
nTotalNodes	FSI/CrackingSurface.h	/^  int nTotalNodes, nUsedNodes;$/;"	m	class:CrackingSurface
nTotalQuads	FSI/CrackingSurface.h	/^  int nTotalQuads, nUsedQuads;$/;"	m	class:CrackingSurface
nTotalTrias	FSI/CrackingSurface.h	/^  int nTotalTrias, nUsedTrias;$/;"	m	class:CrackingSurface
nTraceOn	arpack++/include/debug.h	/^inline void nTraceOn(const ARint digit, const ARint getv0, const ARint aupd, $/;"	f
nUsedNodes	FSI/CrackingSurface.h	/^  int nTotalNodes, nUsedNodes;$/;"	m	class:CrackingSurface
nUsedQuads	FSI/CrackingSurface.h	/^  int nTotalQuads, nUsedQuads;$/;"	m	class:CrackingSurface
nUsedTrias	FSI/CrackingSurface.h	/^  int nTotalTrias, nUsedTrias;$/;"	m	class:CrackingSurface
nWallNode	LevelSet/LevelSetStructure.h	/^	 void nWallNode(  int i, Vec3D &nWall) { nWall = nWall_node[i]; }$/;"	f	class:LevelSetStructure
nWallWithSI	LevelSet/LevelSetStructure.h	/^	 void nWallWithSI(int n, Vec3D &nWall) { nWall = nWall_SI[n]; }$/;"	f	class:LevelSetStructure
nWall_SI	LevelSet/LevelSetStructure.h	/^	 DistVec<Vec3D> *nWall_SI;$/;"	m	class:DistLevelSetStructure
nWall_SI	LevelSet/LevelSetStructure.h	/^	 Vec<Vec3D> &nWall_SI; \/\/ wall normal at the Wall$/;"	m	class:LevelSetStructure
nWall_node	LevelSet/LevelSetStructure.h	/^	 DistVec<Vec3D> *nWall_node;$/;"	m	class:DistLevelSetStructure
nWall_node	LevelSet/LevelSetStructure.h	/^	 Vec<Vec3D> &nWall_node; \/\/ wall normal at the Wall$/;"	m	class:LevelSetStructure
n_point	Quadrature.h	/^    int n_point;         \/\/ no. of quadrature points$/;"	m	class:Quadrature
name	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    std::string name;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
name	arpack++/include/arhbmat.h	/^  char    name[9];         \/\/ Name.$/;"	m	class:ARhbMatrix
name	parser/Assigner.h	/^   string name;$/;"	m	class:Assigner
name_in	MeshMotionHandler.h	/^  char *name_in;$/;"	m	class:RbmExtractor
name_out1	MeshMotionHandler.h	/^  char *name_out1;$/;"	m	class:RbmExtractor
name_out2	MeshMotionHandler.h	/^  char *name_out2;$/;"	m	class:RbmExtractor
name_registry	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    HASHTABLE<T_NAME,FACTORY_BASE<T_BASE_OBJECT>*> name_registry;$/;"	m	class:PhysBAM::REGISTRY
name_to_id_map	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    HASHTABLE<std::string,ID> name_to_id_map;$/;"	m	class:PhysBAM::ARRAY_COLLECTION
narrowdoublerand	utils/Predicate.C	/^double narrowdoublerand()$/;"	f
narrowfloatrand	utils/Predicate.C	/^float narrowfloatrand()$/;"	f
naupp	arpack++/include/naupp.h	/^inline void naupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,$/;"	f
nblock	BlockAlloc.h	/^    int nblock;$/;"	m	class:BlockAlloc
nblocks	arpack++/include/ardfmat.h	/^  int      nblocks;   \/\/ Number of blocks the matrix contain. $/;"	m	class:ARdfMatrix
ncol	AlternatingLeastSquare/als_lapack.h	/^    int nrow, ncol, dim;$/;"	m	class:AlternatingLeastSquare
ncol	arpack++/include/arlsupm.h	/^	int  ncol;     \/* number of columns *\/$/;"	m	struct:__anon45
ncols	arpack++/include/armat.h	/^  int ncols() { return n; }$/;"	f	class:ARMatrix
ncolumn	DenseMatrix.h	/^   int ncolumn; \/\/ number of columns$/;"	m	class:GenFullM
nconv	arpack++/include/arrseig.h	/^  int     nconv;      \/\/ Number of "converged" Ritz values.$/;"	m	class:ARrcStdEig
ncv	arpack++/include/arrseig.h	/^  int     ncv;        \/\/ Number of Arnoldi vectors generated at each iteration.$/;"	m	class:ARrcStdEig
nd	MapFace.h	/^    int nd[MaxNumNd];$/;"	m	struct:MaxFace
nd2tester	IntersectorFRG/IntersectorFRG.C	/^  map<int,int> nd2tester;$/;"	m	class:ClosestTriangle	file:
nd2tri	IntersectorFRG/IntersectorFRG.C	/^  map<int,int> nd2tri; \/\/needed for the vertex case (only if isConsistent = false)$/;"	m	class:ClosestTriangle	file:
ndType	StiffMatrix.h	/^  int **ndType;$/;"	m	class:StiffMat
ndef	DenseMatrix.h	/^   int ndef;$/;"	m	class:GenFullM
ndiagL	arpack++/include/arbnsmat.h	/^  int      ndiagL;$/;"	m	class:ARbdNonSymMatrix
ndiagU	arpack++/include/arbnsmat.h	/^  int      ndiagU;$/;"	m	class:ARbdNonSymMatrix
ndigit	arpack++/include/arpackf.h	/^    ARint logfil, ndigit, mgetv0;$/;"	m	struct:XMLARSTR
nearInterface	LevelSet/LevelSetStructure.h	/^  bool nearInterface() {return mode!=-1;}$/;"	f	struct:ClosestPoint
nearestName	IoData.h	/^  const char *nearestName;$/;"	m	struct:NonlinearRomFilesData
nearestName	NonlinearRom.h	/^  char* nearestName;$/;"	m	class:NonlinearRom
nearestSnapsToCenters	NonlinearRom.h	/^  VecSet< DistSVec<double, dim> >* nearestSnapsToCenters; \/\/ closest snapshot to each cluster center $/;"	m	class:NonlinearRom
needs_indent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.cpp	/^bool LOG_ENTRY::needs_indent=true;$/;"	m	class:LOG_ENTRY	file:
needs_indent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    static bool needs_indent,log_file_needs_indent;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
negate	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
negotiate	MeshMotionHandler.h	/^  virtual void negotiate() {}$/;"	f	class:MeshMotionHandler
negotiate	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::negotiate()$/;"	f	class:AeroMeshMotionHandler
negotiate	StructExc.C	/^void StructExc::negotiate()$/;"	f	class:StructExc
negotiate	TsDesc.C	/^void TsDesc<dim>::negotiate() $/;"	f	class:TsDesc
negotiateStopping	StructExc.C	/^void StructExc::negotiateStopping(bool* lastIt)$/;"	f	class:StructExc
neiSelectionDistFactor	IoData.h	/^   double neiSelectionDistFactor;$/;"	m	struct:BLMeshMotionData
neighb	SubDomain.h	/^  int *neighb;$/;"	m	class:SubDomain
neighbCPU	Communicator.h	/^  int *neighbCPU;$/;"	m	class:SubDTopo
neighbCPUs	Communicator.h	/^  int *neighbCPUs;$/;"	m	class:CommPattern
neighbor_elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    ARRAY<ARRAY<int> >* neighbor_elements; \/\/ for each simplex, list of simplices sharing at least one node$/;"	m	class:PhysBAM::SIMPLEX_MESH
neighbor_nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    ARRAY<ARRAY<int> >* neighbor_nodes; \/\/ for each node, list of neighboring nodes$/;"	m	class:PhysBAM::SIMPLEX_MESH
neighbors	MultiGridLevel.h	/^  std::map<int, NeighborDomain*> neighbors;$/;"	m	struct:MultigridSubdomain
neighbour	SparseGrid.h	/^  int **neighbour;        \/\/ list of neighbours of a stored subgrid$/;"	m	class:SparseGrid
neq1	MultiGridLevel.h	/^    int my_dim, neq1,neq2;$/;"	m	class:MultiGridLevel
neq2	MultiGridLevel.h	/^    int my_dim, neq1,neq2;$/;"	m	class:MultiGridLevel
nested_visitor	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    T_NESTED_VISITOR nested_visitor;$/;"	m	struct:PhysBAM::BOX_VISITOR_MPI
neupp	arpack++/include/neupp.h	/^inline void neupp(bool rvec, char HowMny, double dr[],$/;"	f
neupp	arpack++/include/neupp.h	/^inline void neupp(bool rvec, char HowMny, float dr[],$/;"	f
nev	arpack++/include/arrseig.h	/^  int     nev;        \/\/ Number of eigenvalues to be computed. 0 < nev < n-1.$/;"	m	class:ARrcStdEig
newID	IoData.h	/^  int oldID,newID;$/;"	m	struct:FluidRemapData
newParameters	SparseGridCore.C	/^void SparseGrid::newParameters(SparseGridData &data, double *param){$/;"	f	class:SparseGrid
newRes	arpack++/include/arrseig.h	/^  bool    newRes;     \/\/ Indicates if a new "resid" vector was created.$/;"	m	class:ARrcStdEig
newVal	arpack++/include/arrseig.h	/^  bool    newVal;     \/\/ Indicates if a new "EigValR" vector was created.$/;"	m	class:ARrcStdEig
newVec	arpack++/include/arrseig.h	/^  bool    newVec;     \/\/ Indicates if a new "EigVec" vector was created.$/;"	m	class:ARrcStdEig
newton	IoData.h	/^  NewtonData<KspData> newton;$/;"	m	struct:DefoMeshMotionData
newton	IoData.h	/^  NewtonData<KspFluidData> newton;$/;"	m	struct:ImplicitData
newtonFreq	IoData.h	/^  int newtonFreq;$/;"	m	struct:NonlinearRomOnlineNonStateData
newtonIt	KspBinaryOutput.h	/^  int* newtonIt;$/;"	m	class:KspBinaryOutput
newtonStepThreshold	IoData.h	/^  double newtonStepThreshold;$/;"	m	struct:NonlinearRomOnlineData
next	GenMatrix.h	/^  virtual bool next(AuxilliaryIterator*) { return false; }$/;"	f	class:GenMat
next	MvpMatrix.h	/^  bool next(typename GenMat<Scalar,dim>::AuxilliaryIterator* genItr) { $/;"	f	class:MvpMat
next	tools/alloca.cougar.c	/^      union hdr *next;		\/* For chaining headers.  *\/$/;"	m	struct:hdr::__anon53	typeref:union:hdr::__anon53::hdr	file:
next_power_of_two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^inline unsigned int next_power_of_two(unsigned int v)$/;"	f	namespace:PhysBAM
next_resize	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int next_resize;$/;"	m	class:PhysBAM::HASHTABLE
next_scope	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    std::set<int> next_scope;$/;"	m	struct:PhysBAM::SubDInterface
ng	GhostPoint.h	/^  int ng; 	\/\/ Number of neighbours in the fluid.$/;"	m	class:GhostPoint
ngrad	DistDynamicVMSTerm.h	/^  DistNodalGrad<dim, double> *ngrad;$/;"	m	class:DistDynamicVMSTerm
ngrad	SpaceOperator.h	/^  DistNodalGrad<dim, double> *ngrad;$/;"	m	class:SpaceOperator
ngradLS	SpaceOperator.h	/^  DistNodalGrad<dimLS, double> *ngradLS;$/;"	m	class:MultiPhaseSpaceOperator
ngradLS_second	SpaceOperator.h	/^  DistNodalGrad<dimLS, double> *ngradLS_second[3];$/;"	m	class:MultiPhaseSpaceOperator
ngraddV	SpaceOperator.h	/^  DistNodalGrad<dim, double> *ngraddV;$/;"	m	class:SpaceOperator
ngravity	DistBcData.h	/^  double ngravity[3]; \/\/!< direction of the gravity$/;"	m	class:DistBcData
ngravity	Extrapolation.h	/^  double ngravity[3];$/;"	m	class:Extrapolation
nlits	KspConvCriterion.h	/^  int nlits;$/;"	m	class:KspConvCriterion
nnd	MapFace.h	/^    int nnd; \/\/ Number of nodes in this face$/;"	m	struct:MaxFace
nnum	BCond.h	/^  int nnum;$/;"	m	struct:BCond
nnz	RectangularSparseMatrix.h	/^  int nnz;                  \/\/ number of non zero blocks$/;"	m	class:RectangularSparseMat
nnz	SparseMatrix.h	/^  int nnz;                  \/\/ number of non zero blocks$/;"	m	class:SparseMat
nnz	arpack++/include/arhbmat.h	/^  int     nnz;             \/\/ Number of nonzero variables.$/;"	m	class:ARhbMatrix
nnz	arpack++/include/arlnsmat.h	/^  int         nnz;$/;"	m	class:ARluNonSymMatrix
nnz	arpack++/include/arlsmat.h	/^  int         nnz;$/;"	m	class:ARluSymMatrix
nnz	arpack++/include/arlsupm.h	/^    int  nnz;	  \/* number of nonzeros in the matrix *\/$/;"	m	struct:__anon46
nnz	arpack++/include/arlsupm.h	/^    int  nnz;	  \/* number of nonzeros in the matrix *\/$/;"	m	struct:__anon47
nnz	arpack++/include/arlsupm.h	/^    int nnz;	  \/* number of nonzeros in the matrix *\/$/;"	m	struct:__anon49
nnz	arpack++/include/arlsupm.h	/^  int  nnz;	     \/* number of nonzeros in the matrix *\/$/;"	m	struct:__anon48
nnz	arpack++/include/arunsmat.h	/^  int     nnz;$/;"	m	class:ARumNonSymMatrix
nnz	arpack++/include/arusmat.h	/^  int     nnz;$/;"	m	class:ARumSymMatrix
noCheckFloodFill	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::noCheckFloodFill(SubDomain& sub, int& nUndecided)$/;"	f	class:IntersectorFRG
nodalForceWeights	PostOperator.h	/^  double nodalForceWeights[2];$/;"	m	class:PostOperator
nodalGrad	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
nodalNormal	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *nodalNormal; \/\/memory allocated only if interpolatedNormal == true$/;"	m	class:DistIntersectorFRG
nodalNormal	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *nodalNormal; \/\/memory allocated only if interpolatedNormal == true$/;"	m	class:DistIntersectorPhysBAM
nodalWeights	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
nodal_output	OneDimensionalSolver.h	/^  } nodal_output;$/;"	m	class:OneDimensional	typeref:struct:OneDimensional::__anon12
nodal_output	TsOutput.h	/^  } nodal_output;$/;"	m	class:TsOutput	typeref:struct:TsOutput::__anon29
nodal_scalars	OneDimensionalSolver.h	/^  char *nodal_scalars[PostFcn::SSIZE];$/;"	m	class:OneDimensional
nodal_scalars	TsOutput.h	/^  char *nodal_scalars[PostFcn::SSIZE];$/;"	m	class:TsOutput
nodal_vectors	OneDimensionalSolver.h	/^  char *nodal_vectors[PostFcn::VSIZE];$/;"	m	class:OneDimensional
nodal_vectors	TsOutput.h	/^  char *nodal_vectors[PostFcn::VSIZE];$/;"	m	class:TsOutput
node	AgglomeratedFace.h	/^  int node;$/;"	m	class:AgglomeratedFace
node	BCApplier.h	/^  int node;$/;"	m	struct:ProjData
node	InletNode.h	/^	int node;				\/\/node number in the subdomain$/;"	m	class:InletNode
node2elem	IntersectorFRG/IntersectorFRG.C	/^  set<int> *node2elem;$/;"	m	class:ClosestTriangle	file:
node2elem	IntersectorFRG/IntersectorFRG.h	/^    set<int> *node2elem;  \/\/structural node to element (triangle) connectivity$/;"	m	class:DistIntersectorFRG
node2node	IntersectorFRG/IntersectorFRG.C	/^  set<int> *node2node;$/;"	m	class:ClosestTriangle	file:
node2node	IntersectorFRG/IntersectorFRG.h	/^    set<int> *node2node;  \/\/structural node to node connectivity$/;"	m	class:DistIntersectorFRG
nodeDistInfo	DistBcData.h	/^  DistInfo& nodeDistInfo,&inletNodeDistInfo,&faceDistInfo;$/;"	m	class:DistBcData
nodeDistInfo	Domain.h	/^  DistInfo *nodeDistInfo;$/;"	m	class:Domain
nodeDistInfo	GappyPreprocessing.h	/^	DistInfo &nodeDistInfo;$/;"	m	class:GappyPreprocessing
nodeDistInfo	MultiGridLevel.h	/^    DistInfo * nodeDistInfo;$/;"	m	class:MultiGridLevel
nodeFaceType	Domain.h	/^  int **nodeFaceType;$/;"	m	class:Domain
nodeFaceType	SubDomain.h	/^  int *nodeFaceType;$/;"	m	class:SubDomain
nodeFlag	SubDomain.h	/^  int **nodeFlag;$/;"	m	class:SubDomain
nodeIdPattern	MultiGridLevel.h	/^    CommPattern<int> * nodeIdPattern;$/;"	m	class:MultiGridLevel
nodeInside	ProgrammedBurnCore.C	/^bool ProgrammedBurn::nodeInside(int tag,int i) {$/;"	f	class:ProgrammedBurn
nodeInside	ProgrammedBurnCore.C	/^bool ProgrammedBurn::nodeInside(int tag,int iSub, int i) {$/;"	f	class:ProgrammedBurn
nodeMap	parser/ParseTree.h	/^    std::map<Token, ParseNode *> nodeMap;$/;"	m	class:ParseTree
nodeNormalCount	MultiGridLevel.h	/^    DistVec<int>* nodeNormalCount;$/;"	m	class:MultiGridLevel
nodeNormals	MultiGridLevel.h	/^    std::list<Vec3D>** nodeNormals;$/;"	m	class:MultiGridLevel
nodeNormalsPattern	MultiGridLevel.h	/^    CommPattern<double> * nodeNormalsPattern;$/;"	m	class:MultiGridLevel
nodeNum	ElemTet.h	/^  int& nodeNum(int i) { return nodeNumTet[i]; }$/;"	f	class:ElemTet
nodeNum	ElemTet.h	/^  int* nodeNum() { return nodeNumTet; }$/;"	f	class:ElemTet
nodeNum	FaceTria.h	/^  int nodeNum(int i) const  { return nodeNumT[i]; }$/;"	f	class:FaceTria
nodeNum	FaceTria.h	/^  int& nodeNum(int i) { return nodeNumT[i]; }$/;"	f	class:FaceTria
nodeNum	FaceTria.h	/^  int* nodeNum() { return nodeNumT; }$/;"	f	class:FaceTria
nodeNum	LevelSet/LevelSetStructure.h	/^	   int nodeNum() const { return *nodep; }$/;"	f	class:LevelSetResult::iterator
nodeNumT	FaceTria.h	/^  int nodeNumT[3];$/;"	m	class:FaceTria
nodeNumTet	ElemTet.h	/^  int nodeNumTet[4];$/;"	m	class:ElemTet
nodeNumTet	FaceTria.h	/^  int nodeNumTet[4];$/;"	m	class:FaceTria
nodeOffset	GappyPreprocessing.h	/^  int *nodeOffset;$/;"	m	class:GappyPreprocessing
nodePosnPattern	MultiGridLevel.h	/^    CommPattern<double> * nodePosnPattern;$/;"	m	class:MultiGridLevel
nodeRanges	SubDomain.h	/^  int (*nodeRanges)[3];$/;"	m	class:SubDomain
nodeRenum	RectangularSparseMatrix.h	/^  compStruct *nodeRenum;    \/\/ unknowns renumbering structure$/;"	m	class:RectangularSparseMat
nodeRenum	SparseMatrix.h	/^  compStruct *nodeRenum;    \/\/ unknowns renumbering structure$/;"	m	class:SparseMat
nodeSet	ProgrammedBurn.h	/^  DistSVec<double,3>* nodeSet;$/;"	m	class:ProgrammedBurn
nodeSet0	ProgrammedBurn.h	/^  SVec<double,1>* nodeSet0;$/;"	m	class:ProgrammedBurn
nodeTag	EmbeddedTsDesc.h	/^  DistVec<int> nodeTag; \/\/ = 1 for fluid #1; = -1 for fluid #2.$/;"	m	class:EmbeddedTsDesc
nodeTag0	EmbeddedTsDesc.h	/^  DistVec<int> nodeTag0; \/\/ node tag for the previous time-step.$/;"	m	class:EmbeddedTsDesc
nodeTag0Copy	EmbeddedTsDesc.h	/^  DistVec<int> *nodeTag0Copy; \/\/ node tag for the previous time-step.$/;"	m	class:EmbeddedTsDesc
nodeTagCopy	EmbeddedTsDesc.h	/^  DistVec<int> *nodeTagCopy; \/\/ = 1 for fluid #1; = -1 for fluid #2.$/;"	m	class:EmbeddedTsDesc
nodeToLookFrom	PolygonReconstructionData.h	/^    int numberOfEdges,nodeToLookFrom;$/;"	m	struct:PolygonReconstructionData
nodeToMacroCellMap	MacroCell.h	/^  int *nodeToMacroCellMap;$/;"	m	class:MacroCellSet
nodeToNodeMaskILU	MultiGridLevel.h	/^    Connectivity** nodeToNodeMaskILU;$/;"	m	class:MultiGridLevel
nodeToNodeMaskILU	SubDomain.h	/^  Connectivity *nodeToNodeMaskJacobian, *nodeToNodeMaskILU;$/;"	m	class:SubDomain
nodeToNodeMaskJacobian	SubDomain.h	/^  Connectivity *nodeToNodeMaskJacobian, *nodeToNodeMaskILU;$/;"	m	class:SubDomain
nodeToSubD	IntersectorFRG/IntersectorFRG.h	/^    Connectivity &nodeToSubD;$/;"	m	class:IntersectorFRG
nodeToSubD	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Connectivity &nodeToSubD;$/;"	m	class:IntersectorPhysBAM
nodeTopology	MultiGridLevel.h	/^    DistVec<Topology>* nodeTopology;$/;"	m	class:MultiGridLevel
nodeTopology	MultiGridLevel.h	/^  Topology* nodeTopology;$/;"	m	struct:MultigridSubdomain
nodeType	DiagMatrix.h	/^  int *nodeType;$/;"	m	class:DiagMat
nodeType	Domain.h	/^  int **nodeType;$/;"	m	class:Domain
nodeType	MultiGridLevel.h	/^    int** nodeType;$/;"	m	class:MultiGridLevel
nodeType	RectangularSparseMatrix.h	/^  int *nodeType;$/;"	m	class:RectangularSparseMat
nodeType	SparseMatrix.h	/^  int *nodeType;$/;"	m	class:SparseMat
nodeType	SubDomain.h	/^  int *nodeType;$/;"	m	class:SubDomain
nodeVecPattern	MultiGridLevel.h	/^    CommPattern<double> * nodeVecPattern;$/;"	m	class:MultiGridLevel
nodeVecPatternEq1	MultiGridLevel.h	/^    CommPattern<double> * nodeVecPatternEq1;$/;"	m	class:MultiGridLevel
nodeVecPatternEq2	MultiGridLevel.h	/^    CommPattern<double> * nodeVecPatternEq2;$/;"	m	class:MultiGridLevel
nodeVolPattern	MultiGridLevel.h	/^    CommPattern<double> * nodeVolPattern;$/;"	m	class:MultiGridLevel
nodeVolumes	MultiGridLevel.h	/^  double* nodeVolumes;$/;"	m	struct:MultigridSubdomain
node_id	MultiGridLevel.C	/^  int node_id;$/;"	m	struct:agg_face	file:
node_index	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    int node_index;$/;"	m	class:PhysBAM::KD_TREE_NODE
node_on_boundary	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    ARRAY<bool>* node_on_boundary; \/\/ whether or not a node is on the boundary$/;"	m	class:PhysBAM::TRIANGLE_MESH
nodep	LevelSet/LevelSetStructure.h	/^	   int *nodep;$/;"	m	class:LevelSetResult::iterator
nodes	Elem.h	/^  void nodes(int *nd) { for(int j=0; j<numNodes(); ++j) nd[j] = nodeNum(j); }$/;"	f	class:Elem
nodes	FSI/CrackingSurface.h	/^  int *nodes;$/;"	m	struct:PhantomElement
nodes	Face.h	/^  int* nodes(int* d = NULL) {  $/;"	f	class:Face
nodes	SubDomain.h	/^  NodeSet &nodes;$/;"	m	class:SubDomain
nodesPerBlock	ParallelRom.h	/^	int nodesPerBlock;$/;"	m	class:ParallelRom
nodesToHandle	GappyPreprocessing.h	/^	int *nodesToHandle;	\/\/ how many globalNodes are handled at each greedy iteration$/;"	m	class:GappyPreprocessing
nodesToMCNodes	SubDomain.h	/^  Connectivity** nodesToMCNodes;$/;"	m	class:SubDomain
nodesXYZ	GappyPreprocessing.h	/^  std::vector <double> *(nodesXYZ [3]);	\/\/ nodesXYZ[iXYZ][iSampleNode][iNode] is the iXYZ coordinate of the iNode in the iSampleNode island$/;"	m	class:GappyPreprocessing::std
nodesXYZmap	GappyPreprocessing.h	/^  boost::unordered_map<int, StaticArray <double, 3> > nodesXYZmap;	\/\/ key: global node #, values: x, y, z$/;"	m	class:GappyPreprocessing
nonDimensionalizeAllEquationsOfState	IoDataCore.C	/^void IoData::nonDimensionalizeAllEquationsOfState(){$/;"	f	class:IoData
nonDimensionalizeAllInitialConditions	IoDataCore.C	/^void IoData::nonDimensionalizeAllInitialConditions(){$/;"	f	class:IoData
nonDimensionalizeFluidModel	IoDataCore.C	/^void IoData::nonDimensionalizeFluidModel(FluidModelData &fluidModel){$/;"	f	class:IoData
nonDimensionalizeForcedMotion	IoDataCore.C	/^void IoData:: nonDimensionalizeForcedMotion(){$/;"	f	class:IoData
nonDimensionalizeInitialConditions	IoDataCore.C	/^void IoData::nonDimensionalizeInitialConditions(InitialConditions &initialConditions){$/;"	f	class:IoData
nonDimensionalizeOneDimensionalProblem	IoDataCore.C	/^void IoData:: nonDimensionalizeOneDimensionalProblem(){$/;"	f	class:IoData
nonDimensionalizeThermalCondModel	IoDataCore.C	/^void IoData::nonDimensionalizeThermalCondModel(ThermalCondModelData &tm){$/;"	f	class:IoData
nonDimensionalizeViscosityModel	IoDataCore.C	/^void IoData::nonDimensionalizeViscosityModel(ViscosityModelData &vm){$/;"	f	class:IoData
nonOverlapSize	DistVector.h	/^DistSVec<Scalar,dim>::nonOverlapSize() const$/;"	f	class:DistSVec
none	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
nonlinearRomPostpro	TsParameters.h	/^  bool nonlinearRomPostpro;$/;"	m	class:TsParameters
norm	DenseMatrix.C	/^GenFullM<Scalar>::norm()$/;"	f	class:GenFullM
norm	DenseMatrix.C	/^double SymFullM<Scalar>::norm()$/;"	f	class:SymFullM
norm	DiagMatrix.h	/^  double norm() {return a.norm();}$/;"	f	class:DiagMat
norm	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::norm()$/;"	f	class:DistEmbeddedVec
norm	DistVector.h	/^  double norm()  { return sqrt(*this * *this); }$/;"	f	class:DistVec
norm	DistVector.h	/^DistSVec<Scalar,dim>::norm()$/;"	f	class:DistSVec
norm	GenMatrix.h	/^  virtual double norm() { fprintf(stderr, "No Implementation of GenMat::norm\\n"); return 0; }$/;"	f	class:GenMat
norm	MultiGridSmoothingMatrix.h	/^  double norm() {return a.norm();}$/;"	f	class:MultiGridSmoothingMatrix
norm	MvpMatrix.h	/^  double norm() {return a.norm();}$/;"	f	class:MvpMat
norm	RectangularSparseMatrix.h	/^  double norm() {return a.norm();}$/;"	f	class:RectangularSparseMat
norm	SparseMatrix.h	/^  double norm() {return a.norm();}$/;"	f	class:SparseMat
norm	Vector.h	/^  double norm()  {$/;"	f	class:SVec
norm	Vector.h	/^  double norm() const {$/;"	f	class:Vec
norm	Vector3D.h	/^  double norm() { return(sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])); }$/;"	f	struct:Vec3D
normNum	Face.h	/^  int normNum;$/;"	m	class:Face
normVel	LevelSet/LevelSetStructure.h	/^  Vec3D normVel; \/\/NOTE: this is the velocity, NOT normal velocity.$/;"	m	struct:LevelSetResult
normal	AgglomeratedFace.h	/^  Vec3D normal;$/;"	m	class:AgglomeratedFace
normal	MultiGridLevel.C	/^  Vec3D normal;$/;"	m	struct:agg_face	file:
normal	MultiGridLevel.C	/^  Vec3D normal;$/;"	m	struct:loc_edge	file:
normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    TV normal;$/;"	m	class:PhysBAM::LINE_2D
normal	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    TV normal;$/;"	m	class:PhysBAM::PLANE
normalizeSnaps	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	m	struct:SnapshotsData	typeref:enum:SnapshotsData::NormalizeSnaps
normalizeSnaps	IoData.h	/^  enum NormalizeSnaps {NORMALIZE_FALSE = 0, NORMALIZE_TRUE = 1} normalizeSnaps;$/;"	m	struct:StateSnapshotsData	typeref:enum:StateSnapshotsData::NormalizeSnaps
normals	CurvatureDetection.h	/^  DistSVec<double,6>* normals;$/;"	m	class:CurvatureDetection
normals	IoData.h	/^                IMPLICIT_CURRENT_CFG = 6, IMPLICIT_LATEST_CFG = 7, EXPLICIT_RK2 = 8} normals;$/;"	m	struct:DGCLData	typeref:enum:DGCLData::Normals
normals	SpaceOperator.h	/^  DistSVec<double, dimLS>* normals[3]; $/;"	m	class:MultiPhaseSpaceOperator
normgap	MatchNode.h	/^  double *normgap;$/;"	m	class:MatchNodeSet
normsq	Vector3D.h	/^  double normsq() { return(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); }$/;"	f	struct:Vec3D
notAllActive	Edge.C	/^bool notAllActive(Elem& elem, int idxFace, LevelSetStructure& LSS) {$/;"	f
now	tools/alloca.cougar.c	/^    long now;			\/* Current total stack size.  *\/$/;"	m	struct:stk_stat	file:
nriter_	LocalRiemannDesc.h	/^  int nriter_;$/;"	m	class:LocalRiemannGfmparGasGas
nriter_	LocalRiemannDesc.h	/^  int nriter_;$/;"	m	class:LocalRiemannGfmparTaitTait
nrm2	arpack++/include/blas1c.h	/^inline double nrm2(const ARint &n, const arcomplex<double> dx[],$/;"	f
nrm2	arpack++/include/blas1c.h	/^inline double nrm2(const ARint &n, const double dx[], const ARint &incx) {$/;"	f
nrm2	arpack++/include/blas1c.h	/^inline float nrm2(const ARint &n, const arcomplex<float> dx[], $/;"	f
nrm2	arpack++/include/blas1c.h	/^inline float nrm2(const ARint &n, const float dx[], const ARint &incx) {$/;"	f
nrow	AlternatingLeastSquare/als_lapack.h	/^    int nrow, ncol, dim;$/;"	m	class:AlternatingLeastSquare
nrow	DenseMatrix.h	/^   int nrow;	\/\/ number of rows$/;"	m	class:GenFullM
nrow	arpack++/include/arlsupm.h	/^	int  nrow;     \/* number of rows *\/$/;"	m	struct:__anon45
nrows	arpack++/include/armat.h	/^  int nrows() { return m; }$/;"	f	class:ARMatrix
ns	ImplicitEmbeddedTsDesc.h	/^  NewtonSolver<ImplicitEmbeddedTsDesc<dim> > *ns;$/;"	m	class:ImplicitEmbeddedTsDesc
ns	ImplicitLevelSetTsDesc.h	/^  NewtonSolver<ImplicitLevelSetTsDesc<dim,dimLS> > *ns;$/;"	m	class:ImplicitLevelSetTsDesc
ns	ImplicitMultiPhysicsTsDesc.h	/^  NewtonSolver<ImplicitMultiPhysicsTsDesc<dim,dimLS> > *ns;$/;"	m	class:ImplicitMultiPhysicsTsDesc
ns	ImplicitTsDesc.h	/^  NewtonSolver<ImplicitTsDesc<dim> > *ns;$/;"	m	class:ImplicitTsDesc
ns	IoData.h	/^  KspData ns;$/;"	m	struct:KspFluidData
ns	IoData.h	/^  SchemeData ns;$/;"	m	struct:SchemesData
ns	MeshMotionSolver.h	/^  NewtonSolver<TetMeshMotionSolver> *ns;$/;"	m	class:TetMeshMotionSolver
nsdiag	arpack++/include/arbsmat.h	/^  int      nsdiag;$/;"	m	class:ARbdSymMatrix
nsuper	arpack++/include/arlsupm.h	/^  int  nsuper;       \/* number of supernodes, minus 1 *\/$/;"	m	struct:__anon48
nullAssigner	IoDataCore.C	/^RootClassAssigner *nullAssigner = new RootClassAssigner;$/;"	v
nullReq	CommunicatorMPI.C	/^static MPI_Request nullReq;$/;"	v	file:
nullStat	CommunicatorMPI.C	/^static MPI_Status nullStat;$/;"	v	file:
nullify	DistVector.h	/^  void nullify() $/;"	f	class:DistVec
nullifyPointers	DistVector.h	/^  void nullifyPointers() $/;"	f	class:DistVec
num	Connectivity.h	/^Connectivity::num(int n) const { return (n >= size) ? 0 : pointer[n+1] - pointer[n];  }$/;"	f	class:Connectivity
num	ConnectivityCore.C	/^Connectivity::num(int nd, int *mask)$/;"	f	class:Connectivity
num	IoData.h	/^  static const int num = 10;$/;"	m	struct:RigidMeshMotionData
num	IoData.h	/^  static const int num = 10;$/;"	m	struct:SchemeFixData
num	IoData.h	/^  static const int num = 11;$/;"	m	struct:PadeData
numBC	BCond.h	/^  int numBC;$/;"	m	class:BCondSet
numBcNodes	SubDomain.h	/^  int *numBcNodes;$/;"	m	class:SubDomain
numBlocks	RectangularSparseMatrix.h	/^  int numBlocks() const { return n; }$/;"	f	class:RectangularSparseMat
numBlocks	SparseMatrix.h	/^  int numBlocks() const { return n; }$/;"	f	class:SparseMat
numBlur	ImplicitLevelSetTsDesc.h	/^  int numBlur;$/;"	m	class:ImplicitLevelSetTsDesc
numCPU	Communicator.h	/^  int numCPU;$/;"	m	class:Communicator
numCPU	Communicator.h	/^  int numCPU;\/\/ number of CPUs$/;"	m	class:SubDTopo
numCPU	GeoSource.h	/^  int numGlobSub, numCPU, numClusters;$/;"	m	class:GeoSource
numCPUs	Communicator.h	/^  int numCPUs;$/;"	m	class:CommPattern
numCalcVec	KspSolver.h	/^  int numCalcVec;                                                                                                                  $/;"	m	class:GcrSolver
numCh	Communicator.h	/^  int numCh(){ return numChannels; }$/;"	f	class:CommPattern
numChannels	Communicator.h	/^  int numChannels() { return numPairs; }$/;"	f	class:SubDTopo
numChannels	Communicator.h	/^  int numChannels;$/;"	m	class:CommPattern
numClusNodes	SubDomain.h	/^  int numClusNodes;$/;"	m	class:SubDomain
numClusters	GeoSource.h	/^  int numGlobSub, numCPU, numClusters;$/;"	m	class:GeoSource
numCol	DenseMatrix.h	/^   int numCol() { return ncolumn; }$/;"	f	class:GenFullM
numComp	Connectivity.h	/^  int numComp; \/\/ number of components$/;"	m	struct:compStruct
numConnect	Connectivity.h	/^Connectivity::numConnect() { return numtarget; }$/;"	f	class:Connectivity
numCrackedElements	FSI/CrackingSurface.h	/^  int numCrackedElements() {return phantoms.size();}$/;"	f	class:CrackingSurface
numDivideNormals	SubDomainCore.C	/^void SubDomain::numDivideNormals(Vec<Vec3D>& inletNodeNorm, Vec<int>& numFaceNeighb)$/;"	f	class:SubDomain
numDomainDim	IoData.h	/^  int *numDomainDim;$/;"	m	struct:SparseGridData
numDomainDim1	IoData.h	/^  double range1min, range1max, mapBaseValue1; int numDomainDim1;$/;"	m	struct:SparseGridData
numDomainDim2	IoData.h	/^  double range2min, range2max, mapBaseValue2; int numDomainDim2;$/;"	m	struct:SparseGridData
numDomainDim3	IoData.h	/^  double range3min, range3max, mapBaseValue3; int numDomainDim3;$/;"	m	struct:SparseGridData
numDomainDim4	IoData.h	/^  double range4min, range4max, mapBaseValue4; int numDomainDim4;$/;"	m	struct:SparseGridData
numDomainDim5	IoData.h	/^  double range5min, range5max, mapBaseValue5; int numDomainDim5;$/;"	m	struct:SparseGridData
numDomainDim6	IoData.h	/^  double range6min, range6max, mapBaseValue6; int numDomainDim6;$/;"	m	struct:SparseGridData
numEdges	Edge.h	/^  int numEdges;$/;"	m	class:EdgeSet
numEdges	ElemTet.h	/^  int numEdges() { return 6; }$/;"	f	class:ElemTet
numEdges	MultiGridSmoothingMatrix.h	/^  int numEdges;$/;"	m	class:MultiGridSmoothingMatrix
numEdges	MvpMatrix.h	/^  int numEdges;$/;"	m	class:MvpMat
numEdges	SubDomain.h	/^  int numEdges() { return(edges.size()); }$/;"	f	class:SubDomain
numEigen	GappyPreprocessing.h	/^  int numEigen;$/;"	m	class:GappyPreprocessing
numElem_	SparseGrid.h	/^    int numElem_;$/;"	m	class:SparseGrid::Heap
numElems	Elem.h	/^  int numElems;$/;"	m	class:ElemSet
numElems	SubDomain.h	/^  int numElems() { return(elems.size()); }$/;"	f	class:SubDomain
numElems	TriangulatedInterface.h	/^  int numElems;$/;"	m	class:TriangulatedInterface
numFaceNeighb	DistGeoState.h	/^  DistVec<int> *numFaceNeighb; 	   \/\/number of faces connected to an inletnode, $/;"	m	class:DistGeoState
numFaceNeighb	GeoState.h	/^  Vec<int> &numFaceNeighb;$/;"	m	class:GeoState
numFaceNorms	Face.h	/^  int numFaceNorms;$/;"	m	class:FaceSet
numFaces	AgglomeratedFace.h	/^  int numFaces;$/;"	m	class:AgglomeratedFaceSet
numFaces	ElemTet.h	/^  int numFaces() { return 4; }$/;"	f	class:ElemTet
numFaces	Face.h	/^  int numFaces;$/;"	m	class:FaceSet
numFaces	InletNode.h	/^	int numFaces;			\/\/# of faces connected to the node$/;"	m	class:InletNode
numFaces	SubDomain.h	/^  int numFaces() { return(faces.size()); }$/;"	f	class:SubDomain
numFluid	EmbeddedTsDesc.h	/^  const int numFluid;   \/\/numFluid = 1 (for fluid-fullbody)$/;"	m	class:EmbeddedTsDesc
numFluid	LevelSet/LevelSetStructure.h	/^    int numFluid;$/;"	m	class:DistLevelSetStructure
numFluid	MultiPhysicsTsDesc.h	/^  const int numFluid;$/;"	m	class:MultiPhysicsTsDesc
numFluidPhases	TsOutput.h	/^  int numFluidPhases; \/\/excludes "ghost" solids$/;"	m	class:TsOutput
numFreq	IoData.h	/^  static const int numFreq = 20;$/;"	m	struct:LinearizedData
numFullNodes	GappyPreprocessing.h	/^  int numFullNodes, nReducedNodes;	\/\/ number of nodes in full and reduced meshes$/;"	m	class:GappyPreprocessing
numGlobNode	Domain.h	/^	int numGlobNode;$/;"	m	class:Domain
numGlobSub	DistInfo.h	/^  int numGlobSub;$/;"	m	struct:DistInfo
numGlobSub	DistVector.h	/^  int numGlobSub() const { return distInfo.numGlobSub; }$/;"	f	class:DistSVec
numGlobSub	DistVector.h	/^  int numGlobSub() const { return distInfo.numGlobSub; }$/;"	f	class:DistVec
numGlobSub	GeoSource.h	/^  int numGlobSub, numCPU, numClusters;$/;"	m	class:GeoSource
numIncrements	IoData.h	/^   int numIncrements;$/;"	m	struct:BLMeshMotionData
numIncrements	IoData.h	/^  int numIncrements;$/;"	m	struct:DefoMeshMotionData
numInletNodes	InletNode.h	/^	int numInletNodes;$/;"	m	class:InletNodeSet
numInputs	IoData.h	/^  int numInputs;$/;"	m	struct:SparseGridData
numKrylovVecsOutputPrevNewtonIt	Domain.h	/^  int numKrylovVecsOutputPrevNewtonIt;$/;"	m	class:Domain
numLayers	IoData.h	/^   int numLayers;$/;"	m	struct:BLMeshMotionData
numLevels	MultiGridKernel.h	/^  int numLevels() const { return num_levels; }$/;"	f	class:MultiGridKernel
numLines	MultiGridLevel.h	/^    int* numLines;$/;"	m	class:MultiGridLevel
numLines	MultiGridSmoothingMatrix.h	/^  int numLines;$/;"	m	class:MultiGridSmoothingMatrix
numLocSub	BCApplier.h	/^    int numLocSub;$/;"	m	class:BCApplier
numLocSub	CorotSolver.h	/^  int numLocSub;$/;"	m	class:CorotSolver
numLocSub	CurvatureDetection.h	/^  int numLocSub;$/;"	m	class:CurvatureDetection
numLocSub	DistBcData.h	/^  int numLocSub;$/;"	m	class:DistBcData
numLocSub	DistDynamicLESTerm.h	/^  int               numLocSub;$/;"	m	class:DistDynamicLESTerm
numLocSub	DistDynamicVMSTerm.h	/^  int          numLocSub;$/;"	m	class:DistDynamicVMSTerm
numLocSub	DistEdgeGrad.h	/^  int numLocSub;$/;"	m	class:DistEdgeGrad
numLocSub	DistExactRiemannSolver.h	/^  int numLocSub;$/;"	m	class:DistExactRiemannSolver
numLocSub	DistExtrapolation.h	/^  int numLocSub;$/;"	m	class:DistExtrapolation
numLocSub	DistGeoState.h	/^  int numLocSub;$/;"	m	class:DistGeoState
numLocSub	DistInfo.h	/^  int numLocSub;$/;"	m	struct:DistInfo
numLocSub	DistMacroCell.h	/^  int numLocSub;$/;"	m	class:DistMacroCellSet
numLocSub	DistMatrix.h	/^  int numLocSub;$/;"	m	class:DistMat
numLocSub	DistMvpMatrix.h	/^  int numLocSub;$/;"	m	class:DistMvpMatrix
numLocSub	DistNodalGrad.h	/^  int numLocSub;$/;"	m	class:DistNodalGrad
numLocSub	DistTimeState.h	/^  int numLocSub;$/;"	m	class:DistTimeState
numLocSub	DistVMSLESTerm.h	/^  int numLocSub;$/;"	m	class:DistVMSLESTerm
numLocSub	DistVector.h	/^  int numLocSub() const { return distInfo.numLocSub; }$/;"	f	class:DistSVec
numLocSub	DistVector.h	/^  int numLocSub() const { return distInfo.numLocSub; }$/;"	f	class:DistVec
numLocSub	Domain.h	/^  int numLocSub;$/;"	m	class:Domain
numLocSub	EdgeGalerkin.h	/^  int numLocSub;$/;"	m	class:EdgeGalerkin
numLocSub	EmbeddedCorotSolver.h	/^  int numLocSub;$/;"	m	class:EmbeddedCorotSolver
numLocSub	EmbeddedFluidShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
numLocSub	FluidCollocationShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:FluidCollocationShapeOptimizationHandler
numLocSub	FluidGnatShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:FluidGnatShapeOptimizationHandler
numLocSub	FluidMetricShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:FluidMetricShapeOptimizationHandler
numLocSub	FluidRomShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:FluidRomShapeOptimizationHandler
numLocSub	FluidShapeOptimizationHandler.h	/^  int numLocSub;$/;"	m	class:FluidShapeOptimizationHandler
numLocSub	GappyPreprocessing.h	/^	int numLocSub, nTotCpus, thisCPU; $/;"	m	class:GappyPreprocessing
numLocSub	GeoSource.h	/^  int numLocSub, cpuNum, numLocThreads;$/;"	m	class:GeoSource
numLocSub	KspPrec.h	/^  int numLocSub; \/\/BUG omp$/;"	m	class:IluPrec
numLocSub	KspPrec.h	/^  int numLocSub; \/\/BUG omp$/;"	m	class:JacobiPrec
numLocSub	LevelSet.h	/^  int numLocSub;$/;"	m	class:LevelSet
numLocSub	LevelSet/LevelSetStructure.h	/^    int numLocSub;$/;"	m	class:DistLevelSetStructure
numLocSub	LevelSet/MultiGridLevelSetStructure.h	/^  int numLocSub;$/;"	m	class:DistMultiGridLevelSetStructure
numLocSub	MatVecProd.h	/^  int numLocSub; \/\/BUG omp$/;"	m	class:MatVecProdH1
numLocSub	MatVecProd.h	/^  int numLocSub; \/\/BUG omp$/;"	m	class:MatVecProdH2
numLocSub	MatVecProd.h	/^  int numLocSub;$/;"	m	class:MatVecProd_dRdX
numLocSub	MatVecProd.h	/^  int numLocSub;$/;"	m	struct:dRdXoperators
numLocSub	MultiGridKernel.h	/^  const int num_levels, agglom_size, numLocSub;$/;"	m	class:MultiGridKernel
numLocSub	MultiGridKspSolver.h	/^  int numLocSub;$/;"	m	class:MultiGridKspSolver
numLocSub	MultiGridLevel.h	/^    int numLocSub;$/;"	m	class:MultiGridLevel
numLocSub	MultiGridSmoothingMatrices.h	/^  int numLocSub;$/;"	m	class:MultiGridSmoothingMatrices
numLocSub	PostOperator.h	/^  int numLocSub;$/;"	m	class:PostOperator
numLocSub	StiffMatrix.h	/^  int numLocSub; \/\/BUG omp$/;"	m	class:StiffMat
numLocSub	StructExc.h	/^  int numLocSub;$/;"	m	class:StructExc
numLocThreads	DistInfo.h	/^  int numLocThreads;$/;"	m	struct:DistInfo
numLocThreads	GeoSource.h	/^  int numLocSub, cpuNum, numLocThreads;$/;"	m	class:GeoSource
numLriemann	ExactRiemannSolver.h	/^  int numLriemann;$/;"	m	class:ExactRiemannSolver
numMacroCells	MacroCell.h	/^  int numMacroCells;$/;"	m	class:MacroCellSet
numMasters	EmbeddedAlternatingLeastSquare.h	/^    std::vector<int> numMasters; \/\/<! numMasters[i] = #{master nodes} in subdomain i$/;"	m	class:EmbeddedAlternatingLeastSquare
numNeighb	SubDomain.h	/^  int numNeighb;$/;"	m	class:SubDomain
numNeighbCPUs	Communicator.h	/^  int numNeighbCPUs;$/;"	m	class:CommPattern
numNodeRanges	SubDomain.h	/^  int numNodeRanges;$/;"	m	class:SubDomain
numNodes	DistMvpMatrix.h	/^  int* numNodes;$/;"	m	class:DistMvpMatrix
numNodes	ElemTet.h	/^  int numNodes() { return 4; }$/;"	f	class:ElemTet
numNodes	FaceTria.h	/^  int numNodes() { return 3; }$/;"	f	class:FaceTria
numNodes	MatchNode.h	/^  int numNodes, totalSize;$/;"	m	class:MatchNodeSet
numNodes	MultiGridLevel.h	/^    int* numNodes;$/;"	m	class:MultiGridLevel
numNodes	MultiGridLevel.h	/^  int numNodes;$/;"	m	struct:MultigridSubdomain
numNodes	OneDimensionalSolver.h	/^    int numNodes;$/;"	m	struct:OneDimensional::__anon12
numNodes	SubDomain.h	/^  int numNodes() { return(nodes.size()); }$/;"	f	class:SubDomain
numNodes	TriangulatedInterface.h	/^  int numNodes;$/;"	m	class:TriangulatedInterface
numNodes	TsOutput.h	/^    int numNodes;$/;"	m	struct:TsOutput::__anon29
numNonZeroBlocks	DiagMatrix.h	/^  int numNonZeroBlocks() const { return n; }$/;"	f	class:DiagMat
numNonZeroBlocks	MultiGridSmoothingMatrix.h	/^  int numNonZeroBlocks() const { return a.size(); }$/;"	f	class:MultiGridSmoothingMatrix
numNonZeroBlocks	MvpMatrix.h	/^  int numNonZeroBlocks() const { return a.size(); }$/;"	f	class:MvpMat
numNonZeroBlocks	RectangularSparseMatrix.h	/^  int numNonZeroBlocks() const { return nnz; }$/;"	f	class:RectangularSparseMat
numNonZeroBlocks	SparseMatrix.h	/^  int numNonZeroBlocks() const { return nnz; }$/;"	f	class:SparseMat
numNonZeroP	ConnectivityCore.C	/^Connectivity::numNonZeroP()$/;"	f	class:Connectivity
numNorms	FaceTria.h	/^  int numNorms() { return 1; }$/;"	f	class:FaceTria
numOfFluids	IntersectorFRG/IntersectorFRG.h	/^    int numOfFluids()                                            {return distIntersector.numOfFluids();}$/;"	f	class:IntersectorFRG
numOfFluids	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int numOfFluids() {return distIntersector.numOfFluids();}$/;"	f	class:IntersectorPhysBAM
numOfFluids	LevelSet/LevelSetStructure.h	/^    int numOfFluids() {return numFluid;}$/;"	f	class:DistLevelSetStructure
numOfFluids	LevelSet/MultiGridLevelSetStructure.C	/^int MultiGridLevelSetStructure::numOfFluids() {$/;"	f	class:MultiGridLevelSetStructure
numOffDiagEntries	SubDomain.h	/^  int numOffDiagEntries;$/;"	m	class:SubDomain
numOutputs	IoData.h	/^  int numOutputs;$/;"	m	struct:SparseGridData
numPOD	IoData.h	/^  int numPOD;$/;"	m	struct:LinearizedData
numPairs	Communicator.h	/^  int numPairs;$/;"	m	class:SubDTopo
numPhase	IoData.h	/^  int numPhase;$/;"	m	struct:EquationsData
numPhase	TsDesc.h	/^  int numPhase;$/;"	m	class:TsDesc
numPhases	FluidSelector.h	/^  int numPhases;$/;"	m	class:FluidSelector
numPhases	VarFcn.h	/^  int numPhases;$/;"	m	class:VarFcn
numPhases_	FluxFcn.h	/^  int numPhases_;$/;"	m	class:FluxFcn
numPoints	IoData.h	/^  int numPoints; \/\/mesh has numPoints elements$/;"	m	struct:OneDimensionalInfo
numPoints	IoData.h	/^  int numPoints;$/;"	m	struct:LinePlot
numPoints	OneDimensionalSolver.h	/^    int numPoints;$/;"	m	class:OneDimensional::Veval
numPoints	OneDimensionalSolver.h	/^  int numPoints;$/;"	m	class:OneDimensional
numPoints	TsOutput.h	/^    int numPoints;$/;"	m	struct:TsOutput::line_output
numRealTriangles	FSI/CrackingSurface.h	/^  int numRealTriangles;$/;"	m	class:CrackingSurface
numResJacMat	ImplicitGnatTsDesc.h	/^  int numResJacMat ;	\/\/ number of matrices for A and B (1 if they use the same)$/;"	m	class:ImplicitGnatTsDesc
numResJacMat	NonlinearRom.h	/^  int numResJacMat;$/;"	m	class:NonlinearRom
numResidualsOutputCurrentNewtonIt	Domain.h	/^  int numResidualsOutputCurrentNewtonIt;$/;"	m	class:Domain
numRow	DenseMatrix.h	/^   int numRow() { return nrow;    }$/;"	f	class:GenFullM
numSampledEdges	Edge.h	/^  int numSampledEdges, numTwoLayerEdges;$/;"	m	class:EdgeSet
numSampledElems	Elem.h	/^	int numSampledElems;$/;"	m	class:ElemSet
numSampledFaces	Face.h	/^  int numSampledFaces;$/;"	m	class:FaceSet
numSampledNodes	SubDomain.h	/^  int numSampledNodes;$/;"	m	class:SubDomain
numShapeVariables	IoData.h	/^  int numShapeVariables;$/;"	m	struct:SensitivityAnalysis
numSharedEdges	MultiGridLevel.h	/^    int** numSharedEdges;$/;"	m	class:MultiGridLevel
numSharedEdges	SubDomain.h	/^  int *numSharedEdges;$/;"	m	class:SubDomain
numSmooths_post	MultiGridCoupledTsDesc.h	/^  int numSmooths_pre[6],numSmooths_post[6];$/;"	m	class:MultiGridCoupledTsDesc
numSmooths_post	MultiGridEmbeddedTsDesc.h	/^  int numSmooths_pre[10],numSmooths_post[10];$/;"	m	class:MultiGridEmbeddedTsDesc
numSmooths_post	MultiGridKernel.C	/^static int numSmooths_post[] = {0,0,0,0,0,0,0,0,0,0,0};$/;"	v	file:
numSmooths_post	MultiGridSegTsDesc.h	/^  int numSmooths_pre[6],numSmooths_post[6];$/;"	m	class:MultiGridSegTsDesc
numSmooths_pre	MultiGridCoupledTsDesc.h	/^  int numSmooths_pre[6],numSmooths_post[6];$/;"	m	class:MultiGridCoupledTsDesc
numSmooths_pre	MultiGridEmbeddedTsDesc.h	/^  int numSmooths_pre[10],numSmooths_post[10];$/;"	m	class:MultiGridEmbeddedTsDesc
numSmooths_pre	MultiGridKernel.C	/^static int numSmooths_pre[] = {0,500,0,1000,0,0,0,0,0,0};$/;"	v	file:
numSmooths_pre	MultiGridKernel.C	/^static int numSmooths_pre[] = {1,2,3,3,3,3,3,3,3,3,3,3};$/;"	v	file:
numSmooths_pre	MultiGridSegTsDesc.h	/^  int numSmooths_pre[6],numSmooths_post[6];$/;"	m	class:MultiGridSegTsDesc
numSnapsForApproxMetric	GappyPreprocessing.h	/^  int numSnapsForApproxMetric;$/;"	m	class:GappyPreprocessing
numSnapshots	EmbeddedAlternatingLeastSquare.h	/^    int numSnapshots; \/\/<! total number of snapshots across all files, set when read state mask$/;"	m	class:EmbeddedAlternatingLeastSquare
numSparseGrids_	SparseGridCluster.h	/^  int numSparseGrids_;$/;"	m	class:SparseGridCluster
numStElems	FSI/DynamicNodalTransfer.h	/^        int  numStElems() {return structure.nElems;}$/;"	f	class:DynamicNodalTransfer
numStElems	IntersectorFRG/IntersectorFRG.h	/^    int numStNodes, numStElems;$/;"	m	class:DistIntersectorFRG
numStElems	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int numStNodes, numStElems;$/;"	m	class:DistIntersectorPhysBAM
numStNodes	EmbeddedCorotSolver.h	/^  int numStNodes;$/;"	m	class:EmbeddedCorotSolver
numStNodes	FSI/DynamicNodalTransfer.h	/^        int  numStNodes() {return structure.nNodes;}$/;"	f	class:DynamicNodalTransfer
numStNodes	IntersectorFRG/IntersectorFRG.h	/^    int numStNodes, numStElems;$/;"	m	class:DistIntersectorFRG
numStNodes	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int numStNodes, numStElems;$/;"	m	class:DistIntersectorPhysBAM
numSteps	IoData.h	/^  int numSteps;$/;"	m	struct:LinearizedData
numStrCPU	StructExc.h	/^  int numStrCPU;$/;"	m	class:StructExc
numStrModes	IoData.h	/^  int numStrModes;$/;"	m	struct:LinearizedData
numStrNodes	StructExc.h	/^  int (*numStrNodes)[2];$/;"	m	class:StructExc
numStructNodes	EmbeddedTsDesc.h	/^  int numStructNodes;$/;"	m	class:EmbeddedTsDesc
numStructNodes	FSI/DynamicNodalTransfer.h	/^  int numStructNodes() {return nNodes;}$/;"	f	class:EmbeddedStructure
numStructNodes	MultiPhysicsTsDesc.h	/^  int numStructNodes;$/;"	m	class:MultiPhysicsTsDesc
numSubCells	MacroCell.h	/^  int numSubCells;$/;"	m	class:MacroCell
numSurf	PostOperator.h	/^  int numSurf;$/;"	m	class:PostOperator
numSurfHF	PostOperator.h	/^  int numSurfHF;$/;"	m	class:PostOperator
numTets	InletNode.h	/^	int numTets;			\/\/# of tets connected to the node$/;"	m	class:InletNode
numTimings	Timer.h	/^  int numTimings;$/;"	m	class:Timer
numTotalCells	MacroCell.h	/^  int numTotalCells;$/;"	m	class:MacroCellSet
numTriangle	TriangulatedSurface.h	/^  int numTriangle;  \/\/Node: This is used for both coords-list and node# list. $/;"	m	class:TriangulatedSurface
numTwoLayerEdges	Edge.h	/^  int numSampledEdges, numTwoLayerEdges;$/;"	m	class:EdgeSet
numValues_	SimpleBuffer.h	/^  size_t numValues_;$/;"	m	class:SimpleBuffer
numVec	KspSolver.h	/^  int numVec;$/;"	m	class:GcrSolver
numVec	KspSolver.h	/^  int numVec;$/;"	m	class:GmresSolver
numVec	VectorSet.h	/^  int numVec;$/;"	m	class:VecSet
numVectors	IoData.h	/^  int numVectors;$/;"	m	struct:KspData
numVectors	RefVector.h	/^  int numVectors() const {return 1;}	\/\/ always 1 vector$/;"	f	class:RefVec
numVectors	VectorSet.h	/^  int numVectors() const { return numVec; }$/;"	f	class:VecSet
num_fine_sweeps	IoData.h	/^  int num_fine_sweeps;$/;"	m	struct:MultiGridData
num_fine_sweeps	IoData.h	/^  int num_fine_sweeps;$/;"	m	struct:PcData
num_finesweeps	MultiGridSolver.h	/^  int num_finesweeps;$/;"	m	class:MultiGridSolver
num_levels	MultiGridKernel.h	/^  const int num_levels, agglom_size, numLocSub;$/;"	m	class:MultiGridKernel
num_multigrid_levels	IoData.h	/^  int num_multigrid_levels;$/;"	m	struct:MultiGridData
num_multigrid_levels	IoData.h	/^  int num_multigrid_levels;$/;"	m	struct:PcData
num_multigrid_smooth1	IoData.h	/^  int num_multigrid_smooth1,num_multigrid_smooth2;$/;"	m	struct:MultiGridData
num_multigrid_smooth1	IoData.h	/^  int num_multigrid_smooth1,num_multigrid_smooth2;$/;"	m	struct:PcData
num_multigrid_smooth2	IoData.h	/^  int num_multigrid_smooth1,num_multigrid_smooth2;$/;"	m	struct:MultiGridData
num_multigrid_smooth2	IoData.h	/^  int num_multigrid_smooth1,num_multigrid_smooth2;$/;"	m	struct:PcData
num_postsmooth	MultiGridSolver.h	/^  int num_presmooth,num_postsmooth;$/;"	m	class:MultiGridSolver
num_presmooth	MultiGridSolver.h	/^  int num_presmooth,num_postsmooth;$/;"	m	class:MultiGridSolver
number	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    int number; \/\/ total length$/;"	m	class:PhysBAM::ARRAY_COLLECTION
numberEdges	DomainCore.C	/^void Domain::numberEdges()$/;"	f	class:Domain
numberEdges	ElemCore.C	/^void Elem::numberEdges(EdgeSet &edges)$/;"	f	class:Elem
numberEdges	FaceCore.C	/^void Face::numberEdges(EdgeSet &edges)$/;"	f	class:Face
numberEdges	SubDomainCore.C	/^int SubDomain::numberEdges()$/;"	f	class:SubDomain
numberOfBurns	ProgrammedBurn.h	/^  bool numberOfBurns() { return myBurns.size(); }$/;"	f	class:ProgrammedBurn
numberOfEdges	PolygonReconstructionData.h	/^    int numberOfEdges,nodeToLookFrom;$/;"	m	struct:PolygonReconstructionData
numberOfTabulations	IoData.h	/^  int numberOfTabulations;$/;"	m	struct:SparseGridData
numberRealTriangles	FSI/CrackingSurface.h	/^  int numberRealTriangles() { $/;"	f	class:CrackingSurface
number_nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.h	/^    int number_nodes; \/\/ number of nodes in the mesh$/;"	m	class:PhysBAM::SIMPLEX_MESH
number_of_entries	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    int number_of_entries;$/;"	m	class:PhysBAM::HASHTABLE
number_of_extrema	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    int number_of_extrema;$/;"	m	class:PhysBAM::CUBIC
numericILU	SparseMatrix.C	/^void SparseMat<Scalar,dim>::numericILU(int *marker)$/;"	f	class:SparseMat
numtarget	Connectivity.h	/^  int numtarget;      \/\/ size of target, number of Connections$/;"	m	class:Connectivity
nutilde	IoData.h	/^  double nutilde;$/;"	m	struct:BcsFreeStreamData
nutilde	IoData.h	/^  double nutilde;$/;"	m	struct:BoundaryData
nutilde	RefVal.h	/^  double nutilde;$/;"	m	class:RefVal
nutturb	IoData.h	/^  const char *nutturb;$/;"	m	struct:TransientData
nvec	Communicator.h	/^    int nvec;$/;"	m	struct:SubRecInfo
nvpts	MeshMotionHandler.h	/^  int nvpts;$/;"	m	class:RigidMeshMotionHandler
nx	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
nx	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
nx	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:RotationData
nx	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SurfaceData
nx	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SymmetryData
ny	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
ny	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
ny	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:RotationData
ny	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SurfaceData
ny	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SymmetryData
nz	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
nz	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz;$/;"	m	struct:PlaneData
nz	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:RotationData
nz	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SurfaceData
nz	IoData.h	/^  double nx, ny, nz;$/;"	m	struct:SymmetryData
nzeros	arpack++/include/arlnsmat.h	/^  int nzeros() { return nnz; }$/;"	f	class:ARluNonSymMatrix
nzeros	arpack++/include/arlsmat.h	/^  int nzeros() { return nnz; }$/;"	f	class:ARluSymMatrix
nzeros	arpack++/include/arunsmat.h	/^  int nzeros() { return nnz; }$/;"	f	class:ARumNonSymMatrix
nzeros	arpack++/include/arusmat.h	/^  int nzeros() { return nnz; }$/;"	f	class:ARumSymMatrix
nzlmax	arpack++/include/arlspdef.h	/^    int     nzlmax;   \/* current max size of lsub *\/$/;"	m	struct:__anon35
nzlmax	arpack++/include/arlspdef.h	/^    int     nzlmax;   \/* current max size of lsub *\/$/;"	m	struct:__anon36
nzlmax	arpack++/include/arlspdef.h	/^    int     nzlmax;   \/* current max size of lsub *\/$/;"	m	struct:__anon37
nzlmax	arpack++/include/arlspdef.h	/^    int     nzlmax;   \/* current max size of lsub *\/$/;"	m	struct:__anon38
nzlumax	arpack++/include/arlspdef.h	/^    int     nzlumax;  \/*    "    "    "     lusup *\/$/;"	m	struct:__anon35
nzlumax	arpack++/include/arlspdef.h	/^    int     nzlumax;  \/*    "    "    "     lusup *\/$/;"	m	struct:__anon36
nzlumax	arpack++/include/arlspdef.h	/^    int     nzlumax;  \/*    "    "    "     lusup *\/$/;"	m	struct:__anon37
nzlumax	arpack++/include/arlspdef.h	/^    int     nzlumax;  \/*    "    "    "     lusup *\/$/;"	m	struct:__anon38
nzumax	arpack++/include/arlspdef.h	/^    int     nzumax;   \/*    "    "    "      ucol *\/$/;"	m	struct:__anon35
nzumax	arpack++/include/arlspdef.h	/^    int     nzumax;   \/*    "    "    "      ucol *\/$/;"	m	struct:__anon36
nzumax	arpack++/include/arlspdef.h	/^    int     nzumax;   \/*    "    "    "      ucol *\/$/;"	m	struct:__anon37
nzumax	arpack++/include/arlspdef.h	/^    int     nzumax;   \/*    "    "    "      ucol *\/$/;"	m	struct:__anon38
nzval	arpack++/include/arlsupm.h	/^    void *nzval;  \/* array of size lda*ncol to represent a dense matrix *\/$/;"	m	struct:__anon50
nzval	arpack++/include/arlsupm.h	/^    void *nzval;  \/* pointer to array of nonzero values, packed by column *\/$/;"	m	struct:__anon46
nzval	arpack++/include/arlsupm.h	/^    void *nzval;  \/* pointer to array of nonzero values, packed by column *\/$/;"	m	struct:__anon49
nzval	arpack++/include/arlsupm.h	/^    void *nzval;  \/* pointer to array of nonzero values, packed by row *\/$/;"	m	struct:__anon47
nzval	arpack++/include/arlsupm.h	/^  void *nzval;       \/* pointer to array of nonzero values, packed by column *\/$/;"	m	struct:__anon48
nzval_colptr	arpack++/include/arlsupm.h	/^  int  *nzval_colptr;\/* pointer to array of beginning of columns in nzval[] *\/$/;"	m	struct:__anon48
o3derrboundA	utils/Predicate.C	/^REAL o3derrboundA, o3derrboundB, o3derrboundC;$/;"	v
o3derrboundB	utils/Predicate.C	/^REAL o3derrboundA, o3derrboundB, o3derrboundC;$/;"	v
o3derrboundC	utils/Predicate.C	/^REAL o3derrboundA, o3derrboundB, o3derrboundC;$/;"	v
obj	IntersectorFRG/Geometry/KDTree.h	/^     Obj *obj; \/\/ Non zero if this is a terminal leaf.$/;"	m	class:KDTree
obj	RTree.h	/^    T* obj;$/;"	m	struct:RTree::Node
objA	arpack++/include/argnsym.h	/^  ARFB    *objA;      \/\/ Object that has MultAx as a member function.$/;"	m	class:ARNonSymGenEig
objA	arpack++/include/argsym.h	/^  ARFB    *objA;      \/\/ Object that has MultAx as a member function.$/;"	m	class:ARSymGenEig
objB	arpack++/include/argeig.h	/^  ARFB    *objB;      \/\/ Object that has MultBx as a member function.$/;"	m	class:ARGenEig
objOP	arpack++/include/arseig.h	/^  ARFOP   *objOP;     \/\/ Object that has MultOPx as a member function.$/;"	m	class:ARStdEig
object	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    T* object;$/;"	m	struct:PhysBAM::LOG_REAL::__anon18::INITIALIZATION_HELPER	file:
object_	SparseGrid.h	/^    T &object_;$/;"	m	class:SparseGrid::Functor
objectiveFunctionValue	AlternatingLeastSquare/als_lapack.cpp	/^double AlternatingLeastSquare::objectiveFunctionValue() {$/;"	f	class:AlternatingLeastSquare
obtainMacroCell	DistMacroCell.h	/^  MacroCellSet* obtainMacroCell (int iSub, int scopeDepth) { return macroCells[iSub][scopeDepth];}$/;"	f	class:DistMacroCellSet
occluded_node0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<bool> *occluded_node0;\/\/ previous occluded node status$/;"	m	class:DistIntersectorPhysBAM
occluded_node0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<bool> &occluded_node0;\/\/<! occluded node status at the previous time-step.$/;"	m	class:IntersectorPhysBAM
offDiagMatPat	DistMatrix.h	/^  CommPattern<Scalar> *offDiagMatPat;$/;"	m	class:DistMat
offDiagMatPattern	MultiGridLevel.h	/^    CommPattern<double> * offDiagMatPattern;$/;"	m	class:MultiGridLevel
offWallNode	Domain.h	/^  int **offWallNode;$/;"	m	class:Domain
offWallNode	SubDomain.h	/^  int *offWallNode;$/;"	m	class:SubDomain
offset	Connectivity.h	/^  int offset(int i) { return pointer[i]; } \/\/ Begining of ith part$/;"	f	class:Connectivity
offset	ConnectivityCore.C	/^Connectivity::offset(int i, int j)$/;"	f	class:Connectivity
oldID	IoData.h	/^  int oldID,newID;$/;"	m	struct:FluidRemapData
oldSampledNodeDistInfo	Domain.h	/^  DistInfo *oldSampledNodeDistInfo;$/;"	m	class:Domain
oldV	DistExactRiemannSolver.h	/^  DistSVec<double,dim> *oldV;$/;"	m	class:DistExactRiemannSolver
omega	FSI/DynamicNodalTransfer.h	/^  double omega;$/;"	m	class:EmbeddedStructure
omega	ImplicitRiemann.C	/^  double omega,entropy;$/;"	m	struct:JwlInfo	file:
omega	IoData.h	/^  double omega; \/\/ = specificHeatRatio-1.0$/;"	m	struct:JWLModelData
omega	IoData.h	/^  double omega;$/;"	m	struct:RotationData
omega	MeshMotionHandler.h	/^  double omega;$/;"	m	class:DeformingMeshMotionHandler
omega	MeshMotionHandler.h	/^  double omega;$/;"	m	class:HeavingMeshMotionHandler
omega	MeshMotionHandler.h	/^  double omega;$/;"	m	class:PitchingMeshMotionHandler
omega	MeshMotionHandler.h	/^  double omega;$/;"	m	class:SpiralingMeshMotionHandler
omega	ProgrammedBurnCore.C	/^	double A1,A2,R1,R2,omega;$/;"	m	class:ProgrammedBurn_CJ::JWLEOS	file:
omega	VarFcnJwl.h	/^  double omega;$/;"	m	class:VarFcnJwl
omegap1	VarFcnJwl.h	/^  double omegap1;$/;"	m	class:VarFcnJwl
oneDimensionalInfo	IoData.h	/^  OneDimensionalInfo oneDimensionalInfo;$/;"	m	class:IoData
oneDimensionalInput	IoData.h	/^  ObjectMap< OneDimensionalInputData > oneDimensionalInput;$/;"	m	struct:InputData
oneDimensionalSolution	IoData.h	/^  const char *oneDimensionalSolution;$/;"	m	struct:InputData
oneDtoThreeD	LocalRiemann.h	/^void LocalRiemannGfmpar::oneDtoThreeD(const double* dWidWi3, const double* dWidWj3,$/;"	f	class:LocalRiemannGfmpar
one_fourth_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_fourth_pi=.25*pi;$/;"	m	namespace:PhysBAM
one_minus_cos_x_over_x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	/^inline T one_minus_cos_x_over_x(const T x) \/\/ (1-cos(x))\/x$/;"	f	namespace:PhysBAM
one_minus_cos_x_over_x_squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	/^inline T one_minus_cos_x_over_x_squared(const T x) \/\/ (1-cos(x))\/x^2$/;"	f	namespace:PhysBAM
one_ninth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_ninth=1.\/9;$/;"	m	namespace:PhysBAM
one_over_four_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_over_four_pi=.25\/pi;$/;"	m	namespace:PhysBAM
one_over_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_over_pi=1.\/pi;$/;"	m	namespace:PhysBAM
one_over_root_three	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_over_root_three=1.\/sqrt(3.);$/;"	m	namespace:PhysBAM
one_over_root_two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_over_root_two=1.\/sqrt(2.);$/;"	m	namespace:PhysBAM
one_over_two_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_over_two_pi=.5\/pi;$/;"	m	namespace:PhysBAM
one_sixth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_sixth=1.\/6;$/;"	m	namespace:PhysBAM
one_sixth_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_sixth_pi=1.\/6*pi;$/;"	m	namespace:PhysBAM
one_sixtieth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_sixtieth=1.\/60;$/;"	m	namespace:PhysBAM
one_third	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_third=1.\/3;$/;"	m	namespace:PhysBAM
one_twelfth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_twelfth=1.\/12;$/;"	m	namespace:PhysBAM
one_twenty_fourth	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_twenty_fourth=1.\/24;$/;"	m	namespace:PhysBAM
one_twenty_seventh	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double one_twenty_seventh=1.\/27;$/;"	m	namespace:PhysBAM
oned	OneDimensionalSolver.h	/^    OneDimensionalInputData* oned;$/;"	m	class:OneDimensional::Veval
onefourth	DynamicLESTerm.h	/^  double onefourth;$/;"	m	class:DynamicLESTerm
onefourth	DynamicVMSTerm.h	/^  double onefourth;$/;"	m	class:DynamicVMSTerm
onefourth	SmagorinskyLESTerm.h	/^  double onefourth;$/;"	m	class:SmagorinskyLESTerm
onefourth	VMSLESTerm.h	/^  double onefourth;$/;"	m	class:VMSLESTerm
onefourth	WaleLESTerm.h	/^  double onefourth;$/;"	m	class:WaleLESTerm
onesixth	WaleLESTerm.h	/^  double onesixth;$/;"	m	class:WaleLESTerm
onethird	DynamicLESTerm.h	/^  double onethird;$/;"	m	class:DynamicLESTerm
onethird	DynamicVMSTerm.h	/^  double onethird;$/;"	m	class:DynamicVMSTerm
onethird	SmagorinskyLESTerm.h	/^  double onethird;$/;"	m	class:SmagorinskyLESTerm
onethird	VMSLESTerm.h	/^  double onethird;$/;"	m	class:VMSLESTerm
onethird	WaleLESTerm.h	/^  double onethird;$/;"	m	class:WaleLESTerm
onlineMatrices	GappyPreprocessing.h	/^  double **(onlineMatrices [2]);	\/\/ dimension: (nSampleNode*dim) x nPod[1]$/;"	m	class:GappyPreprocessing
onlyInletOutletBC	GappyPreprocessing.h	/^	bool onlyInletOutletBC;$/;"	m	class:GappyPreprocessing
ooPrandtl	ThermalCondFcn.h	/^  double ooPrandtl;$/;"	m	class:ConstantPrandtlThermalCondFcn
ooR	DynamicLESTerm.h	/^  double ooR;$/;"	m	class:DynamicLESTerm
ooTurbPrandtl	ThermalCondFcn.h	/^  double ooTurbPrandtl;$/;"	m	class:ConstantPrandtlThermalCondFcn
oocv2	DESTerm.h	/^  double oocv2;$/;"	m	class:DESTerm
oocv2	SpalartAllmarasTerm.h	/^  double oocv2;$/;"	m	class:SATerm
oogamma1	DynamicLESTerm.h	/^  double oogamma1;$/;"	m	class:DynamicLESTerm
oogamma1	DynamicVMSTerm.h	/^  double oogamma1;$/;"	m	class:DynamicVMSTerm
oogamma1	MacroCell.h	/^  double oogamma1;$/;"	m	class:MacroCell
oogamma1	SmagorinskyLESTerm.h	/^  double oogamma1;$/;"	m	class:SmagorinskyLESTerm
oogamma1	VMSLESTerm.h	/^  double oogamma1;$/;"	m	class:VMSLESTerm
oogamma1	WaleLESTerm.h	/^  double oogamma1;$/;"	m	class:WaleLESTerm
oolscale	DistGeoState.h	/^  double oolscale;$/;"	m	class:DistGeoState
oolscale	GeoSource.h	/^  double oolscale;$/;"	m	class:GeoSource
oolscale	MeshMotionHandler.h	/^  double oolscale;$/;"	m	class:MeshMotionHandler
oolscale	StructExc.h	/^  double oolscale;$/;"	m	class:StructExc
oorey	DESTerm.h	/^  double oorey;$/;"	m	class:DESTerm
oorey	SpalartAllmarasTerm.h	/^  double oorey;$/;"	m	class:SATerm
ooreynolds	NavierStokesTerm.h	/^  double ooreynolds;$/;"	m	class:NavierStokesTerm
ooreynoldsKE	KEpsilonTerm.h	/^  double ooreynoldsKE;$/;"	m	class:KEpsilonTerm
ooreynolds_mu	NavierStokesTerm.h	/^  double ooreynolds_mu;$/;"	m	class:NavierStokesTerm
ooreynolds_mu	ViscoFcn.h	/^  double ooreynolds_mu;$/;"	m	class:ViscoFcn
oosigma	DESTerm.h	/^  double oosigma;$/;"	m	class:DESTerm
oosigma	SpalartAllmarasTerm.h	/^  double oosigma;$/;"	m	class:SATerm
ootempscale	StructExc.h	/^  double ootempscale;$/;"	m	class:StructExc
ootscale	StructExc.h	/^  double ootscale;$/;"	m	class:StructExc
oovkcst2	DESTerm.h	/^  double oovkcst2;$/;"	m	class:DESTerm
oovkcst2	SpalartAllmarasTerm.h	/^  double oovkcst2;$/;"	m	class:SATerm
oovscale	StructExc.h	/^  double oovscale;$/;"	m	class:StructExc
opcw3_pow	DESTerm.h	/^  double opcw3_pow;$/;"	m	class:DESTerm
opcw3_pow	SpalartAllmarasTerm.h	/^  double opcw3_pow;$/;"	m	class:SATerm
openAsciiFiles	TsOutput.C	/^void TsOutput<dim>::openAsciiFiles()$/;"	f	class:TsOutput
openFileForWriting	SubDomain.C	/^void SubDomain::openFileForWriting(const char *prefix, int no)$/;"	f	class:SubDomain
operAdd	Domain.h	/^class operAdd {$/;"	c
operMax	Domain.h	/^class operMax {$/;"	c
operMin	Domain.h	/^class operMin {$/;"	c
operateRcvData	SubDomain.C	/^void SubDomain::operateRcvData(CommPattern<Scalar> &sp, Scalar (*w)[dim], const OpType &oper)$/;"	f	class:SubDomain
operator !	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^    bool operator!() const$/;"	f	struct:PhysBAM::ONE
operator !	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    bool operator!() const$/;"	f	struct:PhysBAM::ZERO
operator !=	LevelSet/LevelSetStructure.h	/^	   bool operator !=(const iterator &it) const {$/;"	f	class:LevelSetResult::iterator
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool operator!=(const T_ARRAY1& v) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    bool operator!=(const ARRAY_COLLECTION& collection) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator!=(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    bool operator!=(const PAIR& p) const$/;"	f	class:PhysBAM::PAIR
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    bool operator!=(const TRIPLE& t) const$/;"	f	class:PhysBAM::TRIPLE
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool operator!=(const ARRAY_BASE& v) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool operator!=(const INTERVAL& r) const$/;"	f	class:PhysBAM::INTERVAL
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool operator!=(const RANGE<TV>& r) const$/;"	f	class:PhysBAM::RANGE
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    bool operator!=(const ZERO) const$/;"	f	struct:PhysBAM::ZERO
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    bool operator!=(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    bool operator!=(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    bool operator!=(const FRAME& f) const$/;"	f	class:PhysBAM::FRAME
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    bool operator!=(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    bool operator!=(const MATRIX_MXN& A) const$/;"	f	class:PhysBAM::MATRIX_MXN
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    bool operator!=(const QUATERNION& q) const$/;"	f	class:PhysBAM::QUATERNION
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    bool operator!=(const ROTATION<TV>& r) const$/;"	f	class:PhysBAM::ROTATION
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    bool operator!=(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    bool operator!=(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    bool operator!=(const DERIVED& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    bool operator!=(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    bool operator!=(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    bool operator!=(const POINT_CLOUD<TV>& particles) const$/;"	f	class:PhysBAM::POINT_CLOUD
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    bool operator!=(const COMPLEX<T>& c) const$/;"	f	class:PhysBAM::COMPLEX
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    bool operator!=(const TWIST& v) const$/;"	f	class:PhysBAM::TWIST
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool operator!=(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    bool operator!=(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool operator!=(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool operator!=(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator !=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool operator!=(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator %	DenseMatrix.C	/^GenFullM<Scalar> SymFullM<Scalar>::operator%(GenFullM<Scalar> &m)$/;"	f	class:SymFullM
operator %	DenseMatrix.C	/^GenFullM<Scalar>::operator%(GenFullM &m)$/;"	f	class:GenFullM
operator ()	AutoDiff/SpaceDerivatives.h	/^    int operator() (const Eigen::Matrix<T,InputsAtCompileTime,1>& _q,$/;"	f	class:SpatialView
operator ()	AutoDiff/SpaceDerivatives.h	/^    int operator() (const Eigen::Matrix<T,InputsAtCompileTime,1>& q,$/;"	f	class:SpatialView
operator ()	AutoDiff/SpaceDerivatives.h	/^    operator() (const Eigen::Matrix<Scalar,Base::NumberOfGeneralizedCoordinates,1>& q, Scalar t)$/;"	f	class:JacobianVectorProduct
operator ()	AutoDiff/SpaceDerivatives.h	/^    operator() (const Eigen::Matrix<Scalar,InputNumberOfRows,InputNumberOfColumns>& q, Scalar t) {$/;"	f	class:FirstPartialSpaceDerivatives
operator ()	AutoDiff/SpaceDerivatives.h	/^    operator() (const Eigen::Matrix<Scalar,NumberOfGeneralizedCoordinates,1>& q, Scalar t)$/;"	f	class:Jacobian
operator ()	AutoDiff/roeturkeljac5.h	/^    Eigen::Matrix<Scalar,5,1> operator() (const Eigen::Matrix<Scalar,5,1>& ug, Scalar)$/;"	f	class:RoeTurkelFlux5Function
operator ()	DistBcData.h	/^  BcData<dim> &operator() (int i) const { return *subBcData[i]; }$/;"	f	class:DistBcData
operator ()	DistEdgeGrad.h	/^  EdgeGrad<dim>& operator() (int i) const { return *subEdgeGrad[i]; }$/;"	f	class:DistEdgeGrad
operator ()	DistExactRiemannSolver.h	/^  ExactRiemannSolver<dim> &operator() (int i) $/;"	f	class:DistExactRiemannSolver
operator ()	DistExtrapolation.h	/^  Extrapolation<dim>& operator() (int i) const { return *subExtrapolation[i]; }$/;"	f	class:DistExtrapolation
operator ()	DistGeoState.h	/^  GeoState &operator() (int i) const { return *subGeoState[i]; }$/;"	f	class:DistGeoState
operator ()	DistMvpMatrix.h	/^GenMat<Scalar,dim>& DistMvpMatrix<Scalar,dim>::operator() (int iSub) {$/;"	f	class:DistMvpMatrix
operator ()	DistNodalGrad.h	/^  NodalGrad<dim, Scalar> &operator() (int i) const { return *subNodalGrad[i]; }$/;"	f	class:DistNodalGrad
operator ()	DistTimeState.h	/^  TimeState<dim> &operator() (int i) const { return *subTimeState[i]; }$/;"	f	class:DistTimeState
operator ()	DistVector.h	/^  SVec<Scalar,dim> &operator() (int i) const { return *subVec[i]; }$/;"	f	class:DistSVec
operator ()	DistVector.h	/^  Vec<Scalar> &operator() (int i) const { return *subVec[i]; }$/;"	f	class:DistVec
operator ()	IntersectorFRG/Geometry/KDTree.h	/^    bool operator()(const Obj &o1, const Obj &o2) const$/;"	f	class:DirComp
operator ()	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::operator()(int subNum) const {$/;"	f	class:DistIntersectorFRG
operator ()	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::operator()(int subNum) const {$/;"	f	class:DistIntersectorPhysBAM
operator ()	KirchhoffIntegrator.C	/^  bool operator()(const double a, const double b) const$/;"	f	struct:ltdouble
operator ()	KspPrec.h	/^  GenMat<Scalar,dim> &operator() (int i) { return *A[i]; }$/;"	f	class:IluPrec
operator ()	KspPrec.h	/^  GenMat<Scalar,dim> &operator() (int i) { return *A[i]; }$/;"	f	class:JacobiPrec
operator ()	LevelSet/MultiGridLevelSetStructure.C	/^operator()(int subNum) const {$/;"	f	class:DistMultiGridLevelSetStructure
operator ()	MatVecProd.h	/^  GenMat<Scalar,dim> &operator() (int i) { return *A[i]; }$/;"	f	class:MatVecProdH2
operator ()	MatVecProd.h	/^  GenMat<Scalar,neq> &operator() (int i) { return *A[i]; }$/;"	f	class:MatVecProdH1
operator ()	MatVecProd.h	/^  GenMat<double,dim> &operator() (int i) { return *A[i]; }$/;"	f	class:MatVecProdH1MultiPhase
operator ()	MatVecProd.h	/^  GenMat<double,dimLS> &operator() (int i) { return *A[i]; }$/;"	f	class:MatVecProdLS
operator ()	MultiGridDistSVec.h	/^  DistSVec<Scalar,dim>& operator()(int i) { return *myVecs[i]; }$/;"	f	class:MultiGridDistSVec
operator ()	MultiGridMvpMatrix.h	/^  DistMvpMatrix<Scalar,neq>& operator()(int i) { return *myA[i]; }$/;"	f	class:MultiGridMvpMatrix
operator ()	MultiGridPrec.C	/^operator() (int i) {$/;"	f	class:MultiGridPrec
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^template<class TV> typename TV::SCALAR IMPLICIT_OBJECT<TV>::operator()(const TV& location) const {PHYSBAM_FUNCTION_IS_NOT_DEFINED();}$/;"	f	class:IMPLICIT_OBJECT
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    T& operator()(const ID i)$/;"	f	class:PhysBAM::ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    const T& operator()(const ID i) const$/;"	f	class:PhysBAM::ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T& operator()(const ID i)$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    const T& operator()(const ID i) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^    const T_DIFFERENCE operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_DIFFERENCE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^    const T_PRODUCT operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_LEFT_MULTIPLE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^    const ELEMENT operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_NEGATION
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^    const T_SUM operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_PLUS_SCALAR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^    const T_PRODUCT operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_PRODUCT
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^    const T_SUM operator()(const INDEX i) const$/;"	f	class:PhysBAM::ARRAY_SUM
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    T& operator()(const ID i)$/;"	f	class:PhysBAM::ARRAY_VIEW
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    const T& operator()(const ID i) const$/;"	f	class:PhysBAM::ARRAY_VIEW
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^    const T& operator()(const ID i) const$/;"	f	class:PhysBAM::CONSTANT_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^    ID operator()(const ID i) const$/;"	f	class:PhysBAM::IDENTITY_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    CONST_RESULT_TYPE operator()(const ID i) const$/;"	f	class:PhysBAM::INDIRECT_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    RESULT_TYPE operator()(const ID i)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    RESULT_CONST operator()(const INDEX i) const$/;"	f	class:PhysBAM::PROJECTED_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    T_FIELD& operator()(T_STRUCT& element) const$/;"	f	struct:PhysBAM::FIELD_PROJECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    const T_FIELD& operator()(const T_STRUCT& element) const$/;"	f	struct:PhysBAM::FIELD_PROJECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    template<class T_ARRAY> const typename T_ARRAY::ELEMENT& operator()(const T_ARRAY& array) const$/;"	f	struct:PhysBAM::INDEX_PROJECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    template<class T_ARRAY> typename T_ARRAY::ELEMENT& operator()(T_ARRAY& array) const$/;"	f	struct:PhysBAM::INDEX_PROJECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    typename IF<IS_CONST<T_ARRAY>::value,RESULT_CONST,RESULT_NONCONST>::TYPE operator()(const INDEX i)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    bool operator()(const T& x1,const T& x2) const$/;"	f	struct:PhysBAM::FIELD_COMPARE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    bool operator()(const int index1,const int index2) const$/;"	f	struct:PhysBAM::INDIRECT_COMPARE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/SORT.h	/^    template<class T_ARRAY> bool operator()(const T_ARRAY& a1,const T_ARRAY& a2) const$/;"	f	struct:PhysBAM::LEXICOGRAPHIC_COMPARE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        bool operator()(int i){return (*points)(i)[axis]<=split_value;}};$/;"	f	class:PhysBAM::KD_TREE::Partition_Helper_Less_Equal
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        bool operator()(int i){return (*points)(i)[axis]<split_value;}};$/;"	f	class:PhysBAM::KD_TREE::Partition_Helper_Less
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T& operator()(const TV_INT& index)$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    T& operator()(const int i,const int j,const int ij)$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    const T& operator()(const TV_INT& index) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    const T& operator()(const int i,const int j,const int ij) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^    T& operator()(const int i,T& a,T& b){assert(1<=i&&i<=2);T* choices[]={0,&a,&b};return *choices[i];}$/;"	f	struct:PhysBAM::choice_helper
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/choice.h	/^    T& operator()(const int i,T& a,T& b,T& c){assert(1<=i&&i<=3);T* choices[]={0,&a,&b,&c};return *choices[i];}$/;"	f	struct:PhysBAM::choice_helper
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    T& operator()(const int i,const int j=0)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    const T& operator()(const int i,const int j=0) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    T& operator()(const int i,const int j=0)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    const T& operator()(const int i,const int j=0) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    T& operator()(const int i,const int j=1)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    const T& operator()(const int i,const int j=1) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    T& operator()(const int i,const int j=1)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    const T& operator()(const int i,const int j=1) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::MATRIX_MXN
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::MATRIX_MXN
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T& operator()(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    const T& operator()(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T& operator()(int i,int j)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    const T& operator()(int i,int j) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T& operator()(const int i,const int j)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    const T& operator()(const int i,const int j) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^operator()()$/;"	f	class:PhysBAM::MT19937
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR_BASE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const SCALAR operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_DIFFERENCE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const SCALAR operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_NEGATION
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const SCALAR operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_SCALE
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    const SCALAR operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_SUM
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    T& operator()(const int i)$/;"	f	class:PhysBAM::VECTOR_ND
operator ()	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    const T& operator()(const int i) const$/;"	f	class:PhysBAM::VECTOR_ND
operator ()	SparseGrid.h	/^    void operator()(double *argin, double *argout, double *argparameters){$/;"	f	class:SparseGrid::Functor
operator ()	StiffMatrix.h	/^  GenMat<Scalar,dim> &operator() (int i) { return *A[i]; }$/;"	f	class:StiffMat
operator *	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator*(Scalar b, const Taylor2<Scalar, nvar> &a) {$/;"	f
operator *	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator*(const Taylor2<Scalar, nvar> &a, Scalar b) {$/;"	f
operator *	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator*(const Taylor2<Scalar, nvar> &a, const Taylor2<Scalar, nvar> &b) {$/;"	f
operator *	DenseMatrix.C	/^GenFullM<Scalar> SymFullM<Scalar>::operator*(GenFullM<Scalar> &m)$/;"	f	class:SymFullM
operator *	DenseMatrix.C	/^GenFullM<Scalar>::operator*(GenFullM &m)$/;"	f	class:GenFullM
operator *	DenseMatrix.C	/^SymFullM<Scalar> SymFullM<Scalar>::operator*(SymFullM &m)$/;"	f	class:SymFullM
operator *	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator*(const DistEmbeddedVec<Scalar,dim> &x)$/;"	f	class:DistEmbeddedVec
operator *	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator*(const EmbeddedExpr<T, Scalar> &expr)$/;"	f	class:DistEmbeddedVec
operator *	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator*(const Scalar y)$/;"	f	class:DistEmbeddedVec
operator *	DistEmbeddedVector.h	/^EmbeddedScaleExpr<EmbeddedExpr<T,Scalar>,Scalar> operator * (const EmbeddedExpr<T,Scalar>& x,$/;"	f
operator *	DistEmbeddedVector.h	/^EmbeddedScaleExpr<EmbeddedExpr<T,Scalar>,Scalar> operator * (const Scalar& a,$/;"	f
operator *	DistVector.h	/^DistSVec<Scalar,dim>::operator*(const DistSVec<Scalar,dim> &x)$/;"	f	class:DistSVec
operator *	DistVector.h	/^DistSVec<Scalar,dim>::operator*(const Expr<T, Scalar> &expr)$/;"	f	class:DistSVec
operator *	DistVector.h	/^DistSVec<Scalar,dim>::operator*(const Scalar y)$/;"	f	class:DistSVec
operator *	DistVector.h	/^DistVec<Scalar>::operator*(const DistVec<Scalar> &x)$/;"	f	class:DistVec
operator *	DistVector.h	/^DistVec<Scalar>::operator*(const Expr<T, Scalar> &expr)$/;"	f	class:DistVec
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^operator*(const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array,const T1& c)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^operator*(const T1& c,const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^operator*(const ARRAY_BASE<T1,T_ARRAY1,typename T_ARRAY1::INDEX>& array1,const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY1::INDEX>& array2)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL operator*(const T a) const$/;"	f	class:PhysBAM::INTERVAL
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^template<class T> inline INTERVAL<T> operator*(const typename T::SCALAR a,const INTERVAL<T>& interval)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^operator*(const int x,const INT_INVERSE y)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^    ONE operator*(const ONE) const$/;"	f	struct:PhysBAM::ONE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^template<class T> inline const T& operator*(const ONE,const T& x)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^template<class T> inline const T& operator*(const T& x,const ONE)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> operator*(const T a) const$/;"	f	class:PhysBAM::RANGE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^template<class TV> inline RANGE<TV> operator*(const typename TV::SCALAR a,const RANGE<TV>& box)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator*(const ZERO) const$/;"	f	struct:PhysBAM::ZERO
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline ZERO operator*(const T&,const ZERO)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline ZERO operator*(const ZERO,const T&)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator*(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    VECTOR<T,2> operator*(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline DIAGONAL_MATRIX<T,2> operator*(const T a,const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator*(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    VECTOR<T,3> operator*(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline DIAGONAL_MATRIX<T,3> operator*(const T a,const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME operator*(const FRAME& f) const$/;"	f	class:PhysBAM::FRAME
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    TV operator*(const TV& v) const$/;"	f	class:PhysBAM::FRAME
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,n> operator*(const DIAGONAL_MATRIX<T,n>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,n> operator*(const SYMMETRIC_MATRIX<T,n>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX<T,m,p> operator*(const MATRIX<T,n,p>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    VECTOR<T,m> operator*(const VECTOR<T,n>& y) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^inline MATRIX<T,m,n> operator*(const T a,const MATRIX<T,m,n>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator*(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    VECTOR<T,0> operator*(const VECTOR<T,0>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline MATRIX<T,0> operator*(const T a,const MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator*(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    VECTOR<T,0> operator*(const VECTOR<T,0>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline MATRIX<T,0,1> operator*(const T a,const MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator*(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    VECTOR<T,1> operator*(const VECTOR<T,1>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> operator*(const T a,const MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator*(const MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    VECTOR<T,1> operator*(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^inline MATRIX<T,1,2> operator*(const T a,const MATRIX<T,1,2>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator*(const DIAGONAL_MATRIX<T,2>& A) const \/\/ 4 mults$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator*(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator*(const SYMMETRIC_MATRIX<T,2>& A) const \/\/ 8 mults, 4 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator*(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 6 mults, 2 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    VECTOR<T,2> operator*(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const DIAGONAL_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const T a,const MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline VECTOR<T,2> operator*(const VECTOR<T,2>& v,const MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator*(const DIAGONAL_MATRIX<T,2>& A) const \/\/ 6 mults$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator*(const MATRIX<T,2>& A) const \/\/ 12 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator*(const SYMMETRIC_MATRIX<T,2>& A) const \/\/ 12 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator*(const T a) const \/\/ 6 mults$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator*(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 9 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    VECTOR<T,3> operator*(const VECTOR<T,2>& v) const \/\/ 6 mults, 3 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline MATRIX<T,3,2> operator*(const MATRIX<T,3>& B,const MATRIX<T,3,2>& A) \/\/ 18 mults, 12 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline MATRIX<T,3,2> operator*(const SYMMETRIC_MATRIX<T,3>& A,const MATRIX<T,3,2>& B) \/\/ 18 mults, 12 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline MATRIX<T,3,2> operator*(const T a,const MATRIX<T,3,2>& A) \/\/ 6 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline MATRIX<T,3,2> operator*(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const MATRIX<T,3,2>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline VECTOR<T,3> operator*(const VECTOR<T,2>& v,const MATRIX<T,3,2>& A) \/\/ 6 mults, 3 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.cpp	/^operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator*(const DIAGONAL_MATRIX<T,3>& A) const \/\/ 9 mults$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator*(const MATRIX& A) const \/\/ 27 mults, 18 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator*(const SYMMETRIC_MATRIX<T,3>& A) const \/\/ 27 mults, 18 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator*(const UPPER_TRIANGULAR_MATRIX<T,3>& A) const \/\/ 18 mults, 9 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    VECTOR<T,3> operator*(const VECTOR<T,3>& v) const \/\/ 9 mults, 6 adds$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator*(const DIAGONAL_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator*(const SYMMETRIC_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator*(const T a,const MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator*(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline VECTOR<T,3> operator*(const VECTOR<T,3>& v,const MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.cpp	/^operator*(const MATRIX& A) const$/;"	f	class:MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    VECTOR<T,4> operator*(const VECTOR<T,4>& v) const$/;"	f	class:PhysBAM::MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^inline MATRIX<T,4> operator*(const T a,const MATRIX<T,4>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator*(const UPPER_TRIANGULAR_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,DIAGONAL_MATRIX<T,d> >::TYPE operator*(const DIAGONAL_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,SYMMETRIC_MATRIX<T,d> >::TYPE operator*(const SYMMETRIC_MATRIX<T,d>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,T_MATRIX1>::TYPE operator*(const MATRIX_BASE<T,T_MATRIX1>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    typename PRODUCT<T_MATRIX,typename VECTOR_TYPE<T_VECTOR>::TYPE>::TYPE operator*(const VECTOR_BASE<T,T_VECTOR>& y) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^typename PRODUCT<DIAGONAL_MATRIX<T,d>,T_MATRIX>::TYPE operator*(const DIAGONAL_MATRIX<T,d>& A,const MATRIX_BASE<T,T_MATRIX>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^typename PRODUCT<SYMMETRIC_MATRIX<T,d>,T_MATRIX>::TYPE operator*(const SYMMETRIC_MATRIX<T,d>& A,const MATRIX_BASE<T,T_MATRIX>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^inline MATRIX_MXN<T> operator*(const T a,const MATRIX_MXN<T>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator*(const QUATERNION& q) const \/\/ 16 mult and 13 add\/sub$/;"	f	class:PhysBAM::QUATERNION
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator*(const T a) const$/;"	f	class:PhysBAM::QUATERNION
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^inline QUATERNION<T> operator*(const T a,const QUATERNION<T>& q)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    QUATERNION<T> operator*(const QUATERNION<T>& w) const$/;"	f	class:PhysBAM::ROTATION
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION<TV> operator*(const ROTATION<TV>& r) const$/;"	f	class:PhysBAM::ROTATION
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    VECTOR<T,2> operator*(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const SYMMETRIC_MATRIX<T,2>& A,const MATRIX<T,2>& B) \/\/ 8 mults, 4 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const SYMMETRIC_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 8 mults, 4 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline MATRIX<T,2> operator*(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 6 mults, 2 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> operator*(const T a,const SYMMETRIC_MATRIX<T,2>& A) \/\/ 4 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator*(const DIAGONAL_MATRIX<T,2>& A) const \/\/ 4 mults$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator*(const UPPER_TRIANGULAR_MATRIX<T,2>& A) const \/\/ 6 mults, 2 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^template<class T> inline MATRIX<T,2> operator*(const DIAGONAL_MATRIX<T,2>& D,const SYMMETRIC_MATRIX<T,2>& A) \/\/ 4 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX<T,3> operator*(const SYMMETRIC_MATRIX& A) const \/\/ 27 mults, 18 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    VECTOR<T,3> operator*(const VECTOR<T,3>& v) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> operator*(const T a,const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator*(const DIAGONAL_MATRIX<T,3>& A) const \/\/ 9 mults$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator*(const DIAGONAL_MATRIX<T,3>& D,const SYMMETRIC_MATRIX<T,3>& A) \/\/ 9 mults, $/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator*(const UPPER_TRIANGULAR_MATRIX<T,3>& A) const \/\/ 18 mults, 9 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator*(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B) \/\/ 18 mults, 9 adds$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator*(const T a) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    typename PRODUCT<DERIVED,TM>::TYPE operator*(const TM& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^operator*(const TM1& A,const TRANSPOSE_MATRIX<TM2>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^operator*(const typename TM::SCALAR& a,const TRANSPOSE_MATRIX<TM>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const DIAGONAL_MATRIX<T,2>& A) const \/\/ 3 mults$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const UPPER_TRIANGULAR_MATRIX& A) const \/\/ 4 mults, 1 add$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    VECTOR<T,2> operator*(const VECTOR<T,2>& v) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator*(const DIAGONAL_MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B) \/\/ 3 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator*(const T a,const UPPER_TRIANGULAR_MATRIX<T,2>& A) \/\/ 3 mults$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    MATRIX_MXN<T> operator*(const MATRIX_MXN<T>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const DIAGONAL_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator*(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    VECTOR<T,3> operator*(const VECTOR<T,3>& v) const \/\/ 6 mults, 3 adds$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator*(const DIAGONAL_MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator*(const T a,const UPPER_TRIANGULAR_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator*(const COMPLEX<T>& c) const$/;"	f	class:PhysBAM::COMPLEX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator*(const T a) const$/;"	f	class:PhysBAM::COMPLEX
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^inline COMPLEX<T> operator*(const T a,const COMPLEX<T>& c)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST operator*(const T a) const$/;"	f	class:PhysBAM::TWIST
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> inline TWIST<TV> operator*(const typename TV::SCALAR a,const TWIST<TV>& v)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR operator*(const INT_INVERSE a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR operator*(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator*(const T&) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator*(const VECTOR&) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^operator*(const T&,const VECTOR<T,0>& v)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator*(const INT_INVERSE a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator*(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator*(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^operator*(const T& a,const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator*(const INT_INVERSE a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator*(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator*(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^operator*(const T& a,const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator*(const INT_INVERSE a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator*(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator*(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^operator*(const T& a,const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator*(const T& c,const VECTOR_BASE<T,T_VECTOR2>& array)$/;"	f	namespace:PhysBAM
operator *	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator*(const VECTOR_BASE<T,T_VECTOR2>& array,const T& c)$/;"	f	namespace:PhysBAM
operator *	Vector.h	/^     typename ProdRes<Scalar,Res>::ResType> operator*(Scalar y, const Vec<Res> &v)$/;"	f
operator *	Vector.h	/^    typename ProdRes<complex<double>,S2>::ResType > operator*(complex<double> y, const Expr<T, S2> &x)$/;"	f
operator *	Vector.h	/^    typename ProdRes<double,S2>::ResType > operator*(double y, const Expr<T, S2> &x)$/;"	f
operator *	Vector.h	/^SVec<Scalar,dim>::operator*(const Expr<T, Scalar> &expr) $/;"	f	class:SVec
operator *	Vector.h	/^SVec<Scalar,dim>::operator*(const SVec<Scalar,dim> &y) $/;"	f	class:SVec
operator *	Vector.h	/^Vec<Scalar>::operator*(const Expr<T, Scalar> &expr)$/;"	f	class:Vec
operator *	Vector.h	/^Vec<Scalar>::operator*(const Vec<Scalar> &y) $/;"	f	class:Vec
operator *	Vector.h	/^operator*(Scalar y, const SVec<Res,dim> &v)$/;"	f
operator *	Vector3D.h	/^Vec3D operator*(const Vec3D &v,double c )$/;"	f
operator *	Vector3D.h	/^Vec3D operator*(double c, const Vec3D &v)$/;"	f
operator *	Vector3D.h	/^double Vec3D::operator*(const Vec3D &v2) const$/;"	f	class:Vec3D
operator *=	DenseMatrix.C	/^GenFullM<Scalar>::operator*=(const Scalar c)$/;"	f	class:GenFullM
operator *=	DenseMatrix.C	/^void SymFullM<Scalar>::operator*=(const Scalar c)$/;"	f	class:SymFullM
operator *=	DiagMatrix.h	/^  DiagMat<Scalar,dim> &operator*= (const Scalar x) { a *= x; return *this; }$/;"	f	class:DiagMat
operator *=	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator*=(const Scalar y)$/;"	f	class:DistEmbeddedVec
operator *=	DistVector.h	/^DistSVec<Scalar,dim>::operator*=(const DistSVec<Scalar,dim> &y)$/;"	f	class:DistSVec
operator *=	DistVector.h	/^DistSVec<Scalar,dim>::operator*=(const DistVec<Scalar> &y)$/;"	f	class:DistSVec
operator *=	DistVector.h	/^DistSVec<Scalar,dim>::operator*=(const Scalar y)$/;"	f	class:DistSVec
operator *=	DistVector.h	/^DistVec<Scalar>::operator*=(const T y)$/;"	f	class:DistVec
operator *=	MultiGridSmoothingMatrix.h	/^  MultiGridSmoothingMatrix<Scalar,dim> &operator*= (const Scalar x) { a *= x; return *this; }$/;"	f	class:MultiGridSmoothingMatrix
operator *=	MvpMatrix.h	/^  MvpMat<Scalar,dim> &operator*= (const Scalar x)  { $/;"	f	class:MvpMat
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator*=(const ARRAY_BASE<T2,T_ARRAY_T2,ID>& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator*=(const SCALAR& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator*=(const ARRAY_BASE<T2,ARRAYS_ND_BASE,TV_INT>& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    operator*=(const T2 a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL& operator*=(const T a)$/;"	f	class:PhysBAM::INTERVAL
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Inverse.h	/^operator*=(int& x,const INT_INVERSE y)$/;"	f	namespace:PhysBAM
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^template<class T> inline T& operator*=(T& x,const ONE)$/;"	f	namespace:PhysBAM
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV>& operator*=(const T a)$/;"	f	class:PhysBAM::RANGE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator*=(const T&)$/;"	f	struct:PhysBAM::ZERO
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator*=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator*=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    FRAME& operator*=(const FRAME& f)$/;"	f	class:PhysBAM::FRAME
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator*=(const MATRIX<T,2>& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator*=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::MATRIX_BASE
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION& operator*=(const QUATERNION& q)$/;"	f	class:PhysBAM::QUATERNION
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION& operator*=(const T a)$/;"	f	class:PhysBAM::QUATERNION
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    ROTATION<TV>& operator*=(const ROTATION<TV>& r)$/;"	f	class:PhysBAM::ROTATION
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED& operator*=(const T a)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator*=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator*=(const T a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator*=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T>& operator*=(const COMPLEX<T>& c)$/;"	f	class:PhysBAM::COMPLEX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T>& operator*=(const T a)$/;"	f	class:PhysBAM::COMPLEX
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST& operator*=(const T a)$/;"	f	class:PhysBAM::TWIST
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator*=(const T&)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator*=(const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator*=(const INT_INVERSE a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator*=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator*=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator*=(const INT_INVERSE a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator*=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator*=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator*=(const INT_INVERSE a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator*=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator*=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR,class T_VECTOR2> T_VECTOR& operator*=(VECTOR_BASE<T,T_VECTOR>& v,const VECTOR_BASE<T,T_VECTOR2>& w)$/;"	f	namespace:PhysBAM
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> T_VECTOR& operator*=(VECTOR_BASE<T,T_VECTOR>& v,const INT_INVERSE& a)$/;"	f	namespace:PhysBAM
operator *=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> T_VECTOR& operator*=(VECTOR_BASE<T,T_VECTOR>& v,const T& a)$/;"	f	namespace:PhysBAM
operator *=	RectangularSparseMatrix.h	/^  RectangularSparseMat<Scalar,dim,dim2> &operator*= (const Scalar x) { a *= x; return *this; }$/;"	f	class:RectangularSparseMat
operator *=	SparseMatrix.h	/^  SparseMat<Scalar,dim> &operator*= (const Scalar x) { a *= x; return *this; }$/;"	f	class:SparseMat
operator *=	Vector.h	/^SVec<Scalar,dim>::operator*=(const Scalar y)$/;"	f	class:SVec
operator *=	Vector.h	/^Vec<Scalar>::operator*=(const T y)$/;"	f	class:Vec
operator *=	Vector3D.h	/^Vec3D &Vec3D::operator*=(double cst)$/;"	f	class:Vec3D
operator +	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator+(Scalar b, const Taylor2<Scalar, nvar> &a) {$/;"	f
operator +	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator+(const Taylor2<Scalar, nvar> &a, Scalar b) {$/;"	f
operator +	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator+(const Taylor2<Scalar, nvar> &a, const Taylor2<Scalar, nvar> &b) {$/;"	f
operator +	DistEmbeddedVector.h	/^EmbeddedSumExpr<EmbeddedExpr<T1,Scalar>, EmbeddedExpr<T2,Scalar>,Scalar> operator + (const EmbeddedExpr<T1,Scalar>& x,$/;"	f
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^operator+(const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array,const T1& c)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^operator+(const T1& c,const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^operator+(const ARRAY_BASE<T1,T_ARRAY1,typename T_ARRAY2::INDEX>& array1,const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array2)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator+(T i) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL operator+(const INTERVAL& r) const$/;"	f	class:PhysBAM::INTERVAL
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^inline INTERVAL<T> operator+(const T& a,const INTERVAL<T>& b)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> operator+(const RANGE<TV>& r) const$/;"	f	class:PhysBAM::RANGE
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^inline RANGE<TV> operator+(const TV& a,const RANGE<TV>& b)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator+(const ZERO) const$/;"	f	struct:PhysBAM::ZERO
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline const T& operator+(const T& x,const ZERO)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline const T& operator+(const ZERO,const T& x)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator+(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    MATRIX<T,2> operator+(const MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline DIAGONAL_MATRIX<T,2> operator+(const T a,const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline MATRIX<T,2> operator+(const MATRIX<T,2>& A,const DIAGONAL_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator+(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    MATRIX<T,3> operator+(const MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline DIAGONAL_MATRIX<T,3> operator+(const T a,const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline MATRIX<T,3> operator+(const MATRIX<T,3>& A,const DIAGONAL_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline MATRIX<T,0> operator+(const T a,const MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline MATRIX<T,0,1> operator+(const T a,const MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> operator+(const T a,const MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator+(const SYMMETRIC_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator+(const T a,const MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator+(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator+(const MATRIX& A) const \/\/ 6 adds$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator+(const SYMMETRIC_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator+(const T a,const MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator+(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX operator+(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator+(const MATRIX_BASE<T,T_MATRIX1>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator+(const QUATERNION& q) const$/;"	f	class:PhysBAM::QUATERNION
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator+(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> operator+(const T a,const SYMMETRIC_MATRIX<T,2>& A) \/\/ 2 adds$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator+(const DIAGONAL_MATRIX<T,2>& A) const \/\/ 2 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator+(const DIAGONAL_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 2 adds$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator+(const SYMMETRIC_MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator+(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator+(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> operator+(const T a,const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator+(const DIAGONAL_MATRIX<T,3>& A) const \/\/ 3 adds$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator+(const DIAGONAL_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B) \/\/ 3 adds$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator+(const SYMMETRIC_MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator+(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator+(const DERIVED& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const DIAGONAL_MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator+(const DIAGONAL_MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator+(const T a,const UPPER_TRIANGULAR_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const DIAGONAL_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator+(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator+(const DIAGONAL_MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator+(const T a,const UPPER_TRIANGULAR_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator+(const COMPLEX<T>& c) const$/;"	f	class:PhysBAM::COMPLEX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator+(const T& a) const$/;"	f	class:PhysBAM::COMPLEX
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST operator+(const TWIST& v) const$/;"	f	class:PhysBAM::TWIST
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR operator+(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^operator+(const T& a,const VECTOR<T,d>& v)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator+(const T&) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator+(const VECTOR&) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^operator+(const T&,const VECTOR<T,0>& v)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator+(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator+(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^operator+(const T& a,const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator+(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator+(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^operator+(const T& a,const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator+(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator+(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^operator+(const T& a,const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
operator +	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator+(const VECTOR_BASE<T1,T_VECTOR1>& array1,const VECTOR_BASE<T2,T_VECTOR2>& array2)$/;"	f	namespace:PhysBAM
operator +	ResizeArray.h	/^Type *ResizeArray<Type>::operator+(int i) {$/;"	f	class:ResizeArray
operator +	Vector.h	/^operator+(const Expr<T, Scalar> &x, const SVec<Scalar,dim> &v)$/;"	f
operator +	Vector.h	/^operator+(const Expr<T, Scalar> &x, const Vec<Scalar> &v)$/;"	f
operator +	Vector.h	/^operator+(const Expr<T1, Scalar> &x1, const Expr<T2, Scalar> &x2)$/;"	f
operator +	Vector.h	/^operator+(const SVec<Scalar,dim> &v, const Expr<T, Scalar> &x)$/;"	f
operator +	Vector.h	/^operator+(const SVec<Scalar,dim> &v1, const SVec<Scalar,dim> &v2)$/;"	f
operator +	Vector.h	/^operator+(const Vec<Scalar> &v, const Expr<T, Scalar> &x)$/;"	f
operator +	Vector.h	/^operator+(const Vec<Scalar> &v1, const Vec<Scalar> &v2)$/;"	f
operator +	Vector3D.h	/^Vec3D Vec3D::operator+(const Vec3D &v2) const$/;"	f	class:Vec3D
operator ++	LevelSet/LevelSetStructure.h	/^	   iterator & operator++() { xip++; nodep++; return (*this); }$/;"	f	class:LevelSetResult::iterator
operator ++	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator++()$/;"	f	class:PhysBAM::ELEMENT_ID
operator ++	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator++(int)$/;"	f	class:PhysBAM::ELEMENT_ID
operator +=	DenseMatrix.C	/^void GenFullM<Scalar>::operator+=(const GenFullM<Scalar> &m)$/;"	f	class:GenFullM
operator +=	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator+=(const DistEmbeddedVec<Scalar,dim> &y)$/;"	f	class:DistEmbeddedVec
operator +=	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator+=(const EmbeddedExpr<T, Scalar> &expr)$/;"	f	class:DistEmbeddedVec
operator +=	DistVector.h	/^DistSVec<Scalar,dim>::operator+=(const DistSVec<Scalar,dim> &y)$/;"	f	class:DistSVec
operator +=	DistVector.h	/^DistSVec<Scalar,dim>::operator+=(const Expr<T, Scalar> &expr)$/;"	f	class:DistSVec
operator +=	DistVector.h	/^DistSVec<Scalar,dim>::operator+=(const Scalar y)$/;"	f	class:DistSVec
operator +=	DistVector.h	/^DistVec<Scalar>::operator+=(const DistVec<Scalar> &v2)$/;"	f	class:DistVec
operator +=	DistVector.h	/^DistVec<Scalar>::operator+=(const Expr<T, Scalar> &expr)$/;"	f	class:DistVec
operator +=	GhostPoint.h	/^GhostPoint<dim> & operator+=(const GhostPoint<dim> &GP) $/;"	f	class:GhostPoint
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator+=(const ARRAY_BASE<T,T_ARRAY1,ID>& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator+=(const T& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID& operator+=(T i)$/;"	f	class:PhysBAM::ELEMENT_ID
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator+=(const ARRAY_BASE& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator+=(const T& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL& operator+=(const INTERVAL& r)$/;"	f	class:PhysBAM::INTERVAL
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV>& operator+=(const RANGE<TV>& r)$/;"	f	class:PhysBAM::RANGE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator+=(const ZERO)$/;"	f	struct:PhysBAM::ZERO
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator+=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator+=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator+=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator+=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator+=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator+=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator+=(const MATRIX_BASE<T,T_MATRIX1>& A)$/;"	f	class:PhysBAM::MATRIX_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator+=(const SYMMETRIC_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator+=(const T a)$/;"	f	class:PhysBAM::MATRIX_BASE
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION& operator+=(const QUATERNION& q)$/;"	f	class:PhysBAM::QUATERNION
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator+=(const SYMMETRIC_MATRIX& A)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator+=(const SYMMETRIC_MATRIX& A)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator+=(const DERIVED& A)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator+=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator+=(const T& a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator+=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T>& operator+=(const COMPLEX<T>& c)$/;"	f	class:PhysBAM::COMPLEX
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST& operator+=(const TWIST& v)$/;"	f	class:PhysBAM::TWIST
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator+=(const T&)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator+=(const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator+=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator+=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator+=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator+=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator+=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator+=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR,class T_VECTOR2> T_VECTOR& operator+=(VECTOR_BASE<T,T_VECTOR>& v,const VECTOR_BASE<T,T_VECTOR2>& w)$/;"	f	namespace:PhysBAM
operator +=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> T_VECTOR& operator+=(VECTOR_BASE<T,T_VECTOR>& v,const T& a)$/;"	f	namespace:PhysBAM
operator +=	Vector.h	/^SVec<Scalar,dim>::operator+=(const Expr<T, Scalar> &expr)$/;"	f	class:SVec
operator +=	Vector.h	/^SVec<Scalar,dim>::operator+=(const SVec<Scalar,dim> &y)$/;"	f	class:SVec
operator +=	Vector.h	/^Vec<Scalar>::operator+=(const Expr<T, Scalar> &expr)$/;"	f	class:Vec
operator +=	Vector.h	/^Vec<Scalar>::operator+=(const Vec<Scalar> &y)$/;"	f	class:Vec
operator +=	Vector3D.h	/^Vec3D &Vec3D::operator+=(const Vec3D &v2)$/;"	f	class:Vec3D
operator +=	Vector3D.h	/^Vec3D &Vec3D::operator+=(const double &c)$/;"	f	class:Vec3D
operator -	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator-(Scalar b, const Taylor2<Scalar, nvar> &a) {$/;"	f
operator -	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator-(const Taylor2<Scalar, nvar> &a, Scalar b) {$/;"	f
operator -	AutoDiff/Taylor.h	/^Taylor2<Scalar, nvar> operator-(const Taylor2<Scalar, nvar> &a, const Taylor2<Scalar, nvar> &b) {$/;"	f
operator -	DistEmbeddedVector.h	/^EmbeddedDiffExpr<EmbeddedExpr<T1,Scalar>,EmbeddedExpr<T2,Scalar>,Scalar> operator - (const EmbeddedExpr<T1,Scalar>& x,$/;"	f
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^operator-(const ARRAY_BASE<T1,T_ARRAY1,typename T_ARRAY1::INDEX>& array1,const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array2)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^operator-(const ARRAY_BASE<T,T_ARRAY,typename T_ARRAY::INDEX>& array)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^operator-(const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array,const T1& c)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator-() const$/;"	f	class:PhysBAM::ELEMENT_ID
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator-(T i) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL operator-() const$/;"	f	class:PhysBAM::INTERVAL
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL operator-(const INTERVAL& r) const$/;"	f	class:PhysBAM::INTERVAL
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^inline INTERVAL<T> operator-(const T& a,const INTERVAL<T>& b)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> operator-() const$/;"	f	class:PhysBAM::RANGE
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> operator-(const RANGE<TV>& r) const$/;"	f	class:PhysBAM::RANGE
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^inline RANGE<TV> operator-(const TV& a,const RANGE<TV>& b)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator-() const$/;"	f	struct:PhysBAM::ZERO
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator-(const ZERO) const$/;"	f	struct:PhysBAM::ZERO
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline T operator-(const ZERO,const T& x)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^template<class T> inline const T& operator-(const T& x,const ZERO)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator-() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator-(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    MATRIX<T,2> operator-(const MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline DIAGONAL_MATRIX<T,2> operator-(const T a,const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline MATRIX<T,2> operator-(const MATRIX<T,2>& A,const DIAGONAL_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator-() const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator-(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    MATRIX<T,3> operator-(const MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline DIAGONAL_MATRIX<T,3> operator-(const T a,const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline MATRIX<T,3> operator-(const MATRIX<T,3>& A,const DIAGONAL_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline MATRIX<T,0> operator-(const T a,const MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline MATRIX<T,0,1> operator-(const T a,const MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline MATRIX<T,1> operator-(const T a,const MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator-(const SYMMETRIC_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator-(const T a,const MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline MATRIX<T,2> operator-(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator-(const MATRIX& A) const \/\/ 6 adds$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator-(const SYMMETRIC_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator-(const T a,const MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline MATRIX<T,3> operator-(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX operator-(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator-() const$/;"	f	class:PhysBAM::MATRIX_BASE
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator-(const MATRIX_BASE<T,T_MATRIX1>& A) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator-() const$/;"	f	class:PhysBAM::QUATERNION
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator-(const QUATERNION& q) const$/;"	f	class:PhysBAM::QUATERNION
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator-() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator-(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline SYMMETRIC_MATRIX<T,2> operator-(const T a,const SYMMETRIC_MATRIX<T,2>& A) \/\/ 2 adds$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator-(const DIAGONAL_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B) \/\/ 2 adds$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator-(const SYMMETRIC_MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^operator-(const UPPER_TRIANGULAR_MATRIX<T,2>& A,const SYMMETRIC_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator-() const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator-(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline SYMMETRIC_MATRIX<T,3> operator-(const T a,const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator-(const DIAGONAL_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B) \/\/ 3 adds$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator-(const SYMMETRIC_MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^operator-(const UPPER_TRIANGULAR_MATRIX<T,3>& A,const SYMMETRIC_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator-() const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator-(const DERIVED& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator-() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const DIAGONAL_MATRIX<T,2>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator-(const DIAGONAL_MATRIX<T,2>& A,const UPPER_TRIANGULAR_MATRIX<T,2>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline UPPER_TRIANGULAR_MATRIX<T,2> operator-(const T a,const UPPER_TRIANGULAR_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator-() const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const DIAGONAL_MATRIX<T,3>& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator-(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator-(const DIAGONAL_MATRIX<T,3>& A,const UPPER_TRIANGULAR_MATRIX<T,3>& B)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline UPPER_TRIANGULAR_MATRIX<T,3> operator-(const T a,const UPPER_TRIANGULAR_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator-(const COMPLEX<T>& c) const$/;"	f	class:PhysBAM::COMPLEX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator-(const T a) const$/;"	f	class:PhysBAM::COMPLEX
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST operator-()$/;"	f	class:PhysBAM::TWIST
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST operator-(const TWIST& v) const$/;"	f	class:PhysBAM::TWIST
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR operator-(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^operator-(const T& a,const VECTOR<T,d>& v)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator-() const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator-(const T&) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator-(const VECTOR&) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^operator-(const T&,const VECTOR<T,0>& v)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator-() const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator-(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator-(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^operator-(const T& a,const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator-() const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator-(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator-(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^operator-(const T& a,const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator-() const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator-(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator-(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^operator-(const T& a,const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator-(const VECTOR_BASE<T,T_VECTOR>& array)$/;"	f	namespace:PhysBAM
operator -	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator-(const VECTOR_BASE<T1,T_VECTOR1>& array1,const VECTOR_BASE<T2,T_VECTOR2>& array2)$/;"	f	namespace:PhysBAM
operator -	Vector.h	/^operator-(const Expr<T, Scalar> &x, const SVec<Scalar,dim> &v)$/;"	f
operator -	Vector.h	/^operator-(const Expr<T, Scalar> &x, const Vec<Scalar> &v)$/;"	f
operator -	Vector.h	/^operator-(const Expr<T1, Scalar> &x1, const Expr<T2, Scalar> &x2)$/;"	f
operator -	Vector.h	/^operator-(const SVec<Scalar,dim> &v, const Expr<T, Scalar> &x)$/;"	f
operator -	Vector.h	/^operator-(const SVec<Scalar,dim> &v1, const SVec<Scalar,dim> &v2)$/;"	f
operator -	Vector.h	/^operator-(const Vec<Scalar> &v, const Expr<T, Scalar> &x)$/;"	f
operator -	Vector.h	/^operator-(const Vec<Scalar> &v1, const Vec<Scalar> &v2)$/;"	f
operator -	Vector3D.h	/^Vec3D Vec3D::operator-() const$/;"	f	class:Vec3D
operator -	Vector3D.h	/^Vec3D Vec3D::operator-(const Vec3D &v2) const$/;"	f	class:Vec3D
operator --	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator--()$/;"	f	class:PhysBAM::ELEMENT_ID
operator --	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID operator--(int)$/;"	f	class:PhysBAM::ELEMENT_ID
operator -=	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator-=(const DistEmbeddedVec<Scalar,dim> &y)$/;"	f	class:DistEmbeddedVec
operator -=	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator-=(const EmbeddedExpr<T, Scalar> &expr)$/;"	f	class:DistEmbeddedVec
operator -=	DistVector.h	/^DistSVec<Scalar,dim>::operator-=(const DistSVec<Scalar,dim> &y)$/;"	f	class:DistSVec
operator -=	DistVector.h	/^DistSVec<Scalar,dim>::operator-=(const Expr<T, Scalar> &expr)$/;"	f	class:DistSVec
operator -=	DistVector.h	/^DistVec<Scalar>::operator-=(const DistVec<Scalar> &v2)$/;"	f	class:DistVec
operator -=	DistVector.h	/^DistVec<Scalar>::operator-=(const Expr<T, Scalar> &expr)$/;"	f	class:DistVec
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator-=(const ARRAY_BASE<T,T_ARRAY1,ID>& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator-=(const T& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    ID& operator-=(T i)$/;"	f	class:PhysBAM::ELEMENT_ID
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator-=(const ARRAY_BASE& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator-=(const T& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL& operator-=(const INTERVAL& r)$/;"	f	class:PhysBAM::INTERVAL
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV>& operator-=(const RANGE<TV>& r)$/;"	f	class:PhysBAM::RANGE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator-=(const ZERO)$/;"	f	struct:PhysBAM::ZERO
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator-=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator-=(const DIAGONAL_MATRIX& A)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator-=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator-=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator-=(const MATRIX_BASE<T,T_MATRIX1>& A)$/;"	f	class:PhysBAM::MATRIX_BASE
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION& operator-=(const QUATERNION& q)$/;"	f	class:PhysBAM::QUATERNION
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator-=(const SYMMETRIC_MATRIX& A)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator-=(const SYMMETRIC_MATRIX& A)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator-=(const DERIVED& A)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator-=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator-=(const T& a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator-=(const UPPER_TRIANGULAR_MATRIX& A)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    COMPLEX<T> operator-=(const COMPLEX<T>& c)$/;"	f	class:PhysBAM::COMPLEX
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    TWIST& operator-=(const TWIST& v)$/;"	f	class:PhysBAM::TWIST
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator-=(const T&)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator-=(const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator-=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator-=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator-=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator-=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator-=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator-=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR,class T_VECTOR2> T_VECTOR& operator-=(VECTOR_BASE<T,T_VECTOR>& v,const VECTOR_BASE<T,T_VECTOR2>& w)$/;"	f	namespace:PhysBAM
operator -=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> T_VECTOR& operator-=(VECTOR_BASE<T,T_VECTOR>& v,const T& a)$/;"	f	namespace:PhysBAM
operator -=	Vector.h	/^SVec<Scalar,dim>::operator-=(const Expr<T, Scalar> &expr)$/;"	f	class:SVec
operator -=	Vector.h	/^SVec<Scalar,dim>::operator-=(const SVec<Scalar,dim> &y)$/;"	f	class:SVec
operator -=	Vector.h	/^Vec<Scalar>::operator-=(const Expr<T, Scalar> &expr)$/;"	f	class:Vec
operator -=	Vector.h	/^Vec<Scalar>::operator-=(const Vec<Scalar> &y)$/;"	f	class:Vec
operator -=	Vector3D.h	/^Vec3D &Vec3D::operator-=(const Vec3D &v2)$/;"	f	class:Vec3D
operator -=	Vector3D.h	/^Vec3D &Vec3D::operator-=(const double &c)$/;"	f	class:Vec3D
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^operator\/(const ARRAY_BASE<T2,T_ARRAY2,typename T_ARRAY2::INDEX>& array,const T1& c)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL operator\/(const T a) const$/;"	f	class:PhysBAM::INTERVAL
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^template<class T> inline const T& operator\/(const T& x,const ONE)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV> operator\/(const T a) const$/;"	f	class:PhysBAM::RANGE
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator\/(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator\/(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX operator\/(const T a) const \/\/ 6 mults, 1 div$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION operator\/(const T a) const$/;"	f	class:PhysBAM::QUATERNION
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED operator\/(const T a) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX operator\/(const T a) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR operator\/(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^operator\/(const T& a,const VECTOR<T,d>& v)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator\/(const T&) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR operator\/(const VECTOR&) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^operator\/(const T&,const VECTOR<T,0>& v)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator\/(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR operator\/(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^operator\/(const T& a,const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator\/(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR operator\/(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^operator\/(const T& a,const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator\/(const T& a) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR operator\/(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^operator\/(const T& a,const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
operator /	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^operator\/(const VECTOR_BASE<T,T_VECTOR2>& array,const T& c)$/;"	f	namespace:PhysBAM
operator /	Vector.h	/^operator\/(const Expr<T, Scalar> &x, const Vec<Scalar> &v)$/;"	f
operator /	Vector.h	/^operator\/(const Expr<T1, Scalar> &x1, const Expr<T2, Scalar> &x2)$/;"	f
operator /	Vector.h	/^operator\/(const Vec<Scalar> &v, const Expr<T, Scalar> &x)$/;"	f
operator /	Vector.h	/^operator\/(const Vec<Scalar> &v1, const Vec<Scalar> &v2)$/;"	f
operator /	Vector3D.h	/^Vec3D Vec3D::operator\/(double cst)  const$/;"	f	class:Vec3D
operator /=	DistVector.h	/^DistSVec<Scalar, dim>::operator\/=(const Scalar y)$/;"	f	class:DistSVec
operator /=	DistVector.h	/^DistSVec<Scalar,dim>::operator\/=(const DistVec<Scalar> &y)$/;"	f	class:DistSVec
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator\/=(const ARRAY_BASE<T2,T_ARRAY_T2,ID>& v)$/;"	f	class:PhysBAM::ARRAY_BASE
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator\/=(const SCALAR& a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator\/=(const T2 a)$/;"	f	class:PhysBAM::ARRAY_BASE
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    INTERVAL& operator\/=(const T a)$/;"	f	class:PhysBAM::INTERVAL
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^template<class T> inline T& operator\/=(T& x,const ONE)$/;"	f	namespace:PhysBAM
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    RANGE<TV>& operator\/=(const T a)$/;"	f	class:PhysBAM::RANGE
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    ZERO operator\/=(const T&)$/;"	f	struct:PhysBAM::ZERO
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    DIAGONAL_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    DIAGONAL_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::MATRIX_BASE
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    QUATERNION& operator\/=(const T a)$/;"	f	class:PhysBAM::QUATERNION
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    SYMMETRIC_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    SYMMETRIC_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED& operator\/=(const T a)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    UPPER_TRIANGULAR_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    UPPER_TRIANGULAR_MATRIX& operator\/=(const T a)$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator\/=(const T&)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator\/=(const VECTOR&)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator\/=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator\/=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator\/=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator\/=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator\/=(const T& a)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator\/=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR,class T_VECTOR2> T_VECTOR& operator\/=(VECTOR_BASE<T,T_VECTOR>& v,const VECTOR_BASE<T,T_VECTOR2>& w)$/;"	f	namespace:PhysBAM
operator /=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T,class T_VECTOR> T_VECTOR& operator\/=(VECTOR_BASE<T,T_VECTOR>& v,const T& a)$/;"	f	namespace:PhysBAM
operator /=	Vector.h	/^Vec<Scalar>::operator\/=(const T y)$/;"	f	class:Vec
operator /=	Vector3D.h	/^Vec3D &Vec3D::operator\/=(double cst)$/;"	f	class:Vec3D
operator <	Communicator.h	/^    bool operator < (const CPair &x) const$/;"	f	struct:SubDTopo::CPair
operator <	Face.h	/^  bool operator<(Face &f)  {$/;"	f	class:Face
operator <	GappyPreprocessing.h	/^		bool operator<(const StaticArray &other) const{ $/;"	f	class:StaticArray
operator <	KspBinaryOutput.C	/^  bool operator<(const kspSortStruct& a) const {$/;"	f	struct:kspSortStruct
operator <	MapFace.h	/^    bool operator<(const MaxFace &f) const {$/;"	f	struct:MaxFace
operator <	MatchNode.C	/^  bool operator<(const MatchNode &node) const { return index[0] < node.index[0]; }$/;"	f	struct:MatchNode
operator <	NonlinearRomDatabaseConstruction.C	/^  bool operator<(const sortStruct& a) const {$/;"	f	struct:sortStruct
operator <	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator<(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator <	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    bool operator<(const PAIR& p) const$/;"	f	class:PhysBAM::PAIR
operator <	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^inline bool operator<(const double x,const ZERO)$/;"	f	namespace:PhysBAM
operator <	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^inline bool operator<(const float x,const ZERO)$/;"	f	namespace:PhysBAM
operator <	SubDomain.h	/^  bool operator<(const EdgeDef &e) const$/;"	f	struct:EdgeDef
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^template<class TV> std::ostream &operator<<(std::ostream &output,const RAY<TV> &ray)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^template<class T> std::ostream &operator<<(std::ostream &output,const SEGMENT_2D<T> &segment)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/TRIANGLE_3D.h	/^template<class T> std::ostream& operator<<(std::ostream& output,const TRIANGLE_3D<T>& triangle)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^inline std::ostream& operator<<(std::ostream& output,const ARRAY_BASE<T,T_ARRAY,ID>& a)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    log_null_class& operator<<(std::ostream& (*)(std::ostream&)){return *this;}$/;"	f	struct:PhysBAM::LOG_NULL::log_null_class
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    template<class T> log_null_class& operator<<(const T&){return *this;}$/;"	f	struct:PhysBAM::LOG_NULL::log_null_class
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^inline std::ostream& operator<<(std::ostream& output_stream,const DIAGONAL_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline std::ostream& operator<<(std::ostream& output_stream,const DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,class T_MATRIX> inline std::ostream& operator<<(std::ostream& output_stream,const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^inline std::ostream& operator<<(std::ostream& output,const QUATERNION<T>& q)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^inline std::ostream& operator<< (std::ostream& output_stream,const SYMMETRIC_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^inline std::ostream& operator<< (std::ostream& output_stream,const SYMMETRIC_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^inline std::ostream& operator<<(std::ostream& output_stream,const UPPER_TRIANGULAR_MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^inline std::ostream& operator<<(std::ostream& output_stream,const UPPER_TRIANGULAR_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^std::ostream& operator<<(std::ostream& output,const HASHTABLE<K,T>& hashtable)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Data_Structures/READ_WRITE_HASHTABLE.h	/^std::ostream& operator<<(std::ostream& output,const HASHTABLE<K,void>& hashtable)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^template<class TV> inline std::ostream& operator<<(std::ostream& output,const TWIST<TV>& v)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline std::ostream& operator<<(std::ostream& output_stream,R (*func)(A))$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline std::ostream& operator<<(std::ostream& output_stream,R (*func)(A,B))$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline std::ostream& operator<<(std::ostream& output_stream,R (*func)(A,B,C))$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE_FUNCTIONS.h	/^inline std::ostream& operator<<(std::ostream& output_stream,R (*func)(A,B,C,D))$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_BASE.h	/^operator<<(std::ostream& output,const VECTOR_BASE<T,T_VECTOR>& a)$/;"	f	namespace:PhysBAM
operator <<	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^template<class T> std::ostream& operator<<(std::ostream& output,const VECTOR<T,3>& point)$/;"	f	namespace:PhysBAM
operator <=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator<=(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator =	DenseMatrix.C	/^GenFullM<Scalar>::operator=(const GenFullM<Scalar> &m)$/;"	f	class:GenFullM
operator =	DenseMatrix.C	/^GenFullM<Scalar>::operator=(const Scalar c)$/;"	f	class:GenFullM
operator =	DenseMatrix.C	/^void SymFullM<Scalar>::operator=(const Scalar c)$/;"	f	class:SymFullM
operator =	DenseMatrix.C	/^void SymFullM<Scalar>::operator=(const SymFullM<Scalar> &m)$/;"	f	class:SymFullM
operator =	DiagMatrix.h	/^  DiagMat<Scalar,dim> &operator= (const Scalar x) { a = x; return *this; }$/;"	f	class:DiagMat
operator =	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator=(const DistEmbeddedVec<Scalar,dim> &y)$/;"	f	class:DistEmbeddedVec
operator =	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator=(const EmbeddedExpr<T, Scalar> &expr)$/;"	f	class:DistEmbeddedVec
operator =	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::operator=(const Scalar y)$/;"	f	class:DistEmbeddedVec
operator =	DistMvpMatrix.h	/^DistMat<Scalar,dim> & DistMvpMatrix<Scalar,dim>::operator= (const Scalar s) {$/;"	f	class:DistMvpMatrix
operator =	DistVector.h	/^DistSVec<Scalar,dim>::operator=(const DistSVec<Scalar,dim> &y)$/;"	f	class:DistSVec
operator =	DistVector.h	/^DistSVec<Scalar,dim>::operator=(const DistVec<Scalar> &y)$/;"	f	class:DistSVec
operator =	DistVector.h	/^DistSVec<Scalar,dim>::operator=(const Expr<T, Scalar> &expr)$/;"	f	class:DistSVec
operator =	DistVector.h	/^DistSVec<Scalar,dim>::operator=(const Scalar y)$/;"	f	class:DistSVec
operator =	DistVector.h	/^DistVec<Scalar>::operator=(const DistVec<Scalar> &v2)$/;"	f	class:DistVec
operator =	DistVector.h	/^DistVec<Scalar>::operator=(const Expr<T, Scalar> &expr)$/;"	f	class:DistVec
operator =	DistVector.h	/^DistVec<Scalar>::operator=(const Scalar& y)$/;"	f	class:DistVec
operator =	DistVector.h	/^DistVec<Scalar>::operator=(const T y)$/;"	f	class:DistVec
operator =	GappyPreprocessing.h	/^		StaticArray& operator=(const StaticArray &other){ for (int i=0; i<size; ++i) a[i] = other.a[i]; return *this;}$/;"	f	class:StaticArray
operator =	GappyPreprocessing.h	/^	SubDomainData& operator=(double (*b)[dim] ) {$/;"	f	struct:SubDomainData
operator =	GhostPoint.h	/^GhostPoint<dim> & operator=(const GhostPoint<dim> &GP) $/;"	f	class:GhostPoint
operator =	KspPrec.C	/^DistMat<Scalar,dim> &IluPrec<Scalar,dim, Scalar2>::operator= (const Scalar x)$/;"	f	class:IluPrec
operator =	KspPrec.C	/^DistMat<Scalar,dim> &JacobiPrec<Scalar,dim, Scalar2>::operator= (const Scalar x)$/;"	f	class:JacobiPrec
operator =	MatVecProd.C	/^DistMat<Scalar,dim> &MatVecProdH2<dim,Scalar,neq>::operator= (const Scalar x)$/;"	f	class:MatVecProdH2
operator =	MatVecProd.C	/^DistMat<Scalar,neq> &MatVecProdH1<dim,Scalar,neq>::operator= (const Scalar x)$/;"	f	class:MatVecProdH1
operator =	MatVecProd.C	/^DistMat<double,dim> &MatVecProdH1MultiPhase<dim,dimLS>::operator= (const double x)$/;"	f	class:MatVecProdH1MultiPhase
operator =	MatVecProd.C	/^DistMat<double,dimLS> &MatVecProdLS<dim,dimLS>::operator= (const double x)$/;"	f	class:MatVecProdLS
operator =	MultiGridPrec.C	/^operator= (const Scalar2 s) {$/;"	f	class:MultiGridPrec
operator =	MultiGridSmoothingMatrix.h	/^  MultiGridSmoothingMatrix<Scalar,dim> &operator= (const Scalar x) { a = x; return *this; }$/;"	f	class:MultiGridSmoothingMatrix
operator =	MvpMatrix.h	/^  MvpMat<Scalar,dim> &operator= (const Scalar x) { $/;"	f	class:MvpMat
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ARRAY& operator=(const ARRAY& source)$/;"	f	class:PhysBAM::ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ARRAY& operator=(const T_ARRAY& source)$/;"	f	class:PhysBAM::ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator=(const ARRAY_BASE& source)$/;"	f	class:PhysBAM::ARRAY_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    T_ARRAY& operator=(const T_ARRAY1& source)$/;"	f	class:PhysBAM::ARRAY_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW& operator=(const ARRAY_VIEW& source)$/;"	f	class:PhysBAM::ARRAY_VIEW
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    ARRAY_VIEW& operator=(const T_ARRAY2& source)$/;"	f	class:PhysBAM::ARRAY_VIEW
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    INDIRECT_ARRAY& operator=(const INDIRECT_ARRAY& source)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^    INDIRECT_ARRAY& operator=(const T_OTHER_ARRAY& source)$/;"	f	class:PhysBAM::INDIRECT_ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    PROJECTED_ARRAY operator=(const PROJECTED_ARRAY& source)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^    PROJECTED_ARRAY operator=(const T_ARRAY2& source)$/;"	f	class:PhysBAM::PROJECTED_ARRAY
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    ARRAY_BASE& operator=(const T_ARRAY2& source)$/;"	f	class:PhysBAM::ARRAY_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX& operator=(const MATRIX& A)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    MATRIX& operator=(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    MATRIX& operator=(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    MATRIX& operator=(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    MATRIX& operator=(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    MATRIX& operator=(const MATRIX& matrix)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    MATRIX& operator=(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    MATRIX& operator=(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    MATRIX& operator=(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    MATRIX& operator=(const MATRIX& matrix_input)$/;"	f	class:PhysBAM::MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    MATRIX_BASE& operator=(const MATRIX_BASE&) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    T_MATRIX& operator=(const T_MATRIX&) const$/;"	f	class:PhysBAM::MATRIX_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T>& operator=(const DIAGONAL_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T>& operator=(const MATRIX_BASE<T,T_MATRIX>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T>& operator=(const MATRIX_MXN<T>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    MATRIX_MXN<T>& operator=(const SYMMETRIC_MATRIX<T,d>& A)$/;"	f	class:PhysBAM::MATRIX_MXN
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    DERIVED& operator=(const TRANSPOSE_MATRIX& M)$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR& operator=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    VECTOR& operator=(const VECTOR_BASE<T,T_VECTOR>& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    operator=(const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    VECTOR& operator=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    VECTOR& operator=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    operator=(const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    VECTOR& operator=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    operator=(const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    VECTOR& operator=(const VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    operator=(const T_VECTOR& v)$/;"	f	class:PhysBAM::VECTOR
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    VECTOR_BASE& operator=(const VECTOR_BASE&) const$/;"	f	class:PhysBAM::VECTOR_BASE
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    VECTOR_ND& operator=(const VECTOR_BASE<T,T_VECTOR>& vector)$/;"	f	class:PhysBAM::VECTOR_ND
operator =	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    VECTOR_ND& operator=(const VECTOR_ND& source)$/;"	f	class:PhysBAM::VECTOR_ND
operator =	RectangularSparseMatrix.h	/^  RectangularSparseMat<Scalar,dim,dim2> &operator= (const Scalar x) { a = x; return *this; }$/;"	f	class:RectangularSparseMat
operator =	SparseMatrix.h	/^  SparseMat<Scalar,dim> &operator= (const Scalar x) { a = x; return *this; }$/;"	f	class:SparseMat
operator =	StiffMatrix.C	/^DistMat<Scalar,dim> &StiffMat<Scalar,dim>::operator= (const Scalar x)$/;"	f	class:StiffMat
operator =	Vector.h	/^SVec<Scalar,dim>::operator=(const Expr<T, Scalar> &expr)$/;"	f	class:SVec
operator =	Vector.h	/^SVec<Scalar,dim>::operator=(const SVec<Scalar,dim> &y)$/;"	f	class:SVec
operator =	Vector.h	/^SVec<Scalar,dim>::operator=(const Scalar y)$/;"	f	class:SVec
operator =	Vector.h	/^Vec<Scalar>::operator=(const Expr<T, Scalar> &expr)$/;"	f	class:Vec
operator =	Vector.h	/^Vec<Scalar>::operator=(const T y)$/;"	f	class:Vec
operator =	Vector.h	/^Vec<Scalar>::operator=(const Vec<Scalar> &y)$/;"	f	class:Vec
operator =	Vector3D.h	/^Vec3D &Vec3D::operator=(const Vec3D &v2)$/;"	f	class:Vec3D
operator =	Vector3D.h	/^Vec3D &Vec3D::operator=(const double v2)$/;"	f	class:Vec3D
operator =	arpack++/include/arbgcomp.h	/^operator=(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
operator =	arpack++/include/arbgnsym.h	/^operator=(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
operator =	arpack++/include/arbgsym.h	/^operator=(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
operator =	arpack++/include/arbnsmat.h	/^operator=(const ARbdNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARbdNonSymMatrix
operator =	arpack++/include/arbnspen.h	/^operator=(const ARbdNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARbdNonSymPencil
operator =	arpack++/include/arbscomp.h	/^operator=(const ARluCompStdEig<ARFLOAT>& other)$/;"	f	class:ARluCompStdEig
operator =	arpack++/include/arbsmat.h	/^operator=(const ARbdSymMatrix<ARTYPE>& other)$/;"	f	class:ARbdSymMatrix
operator =	arpack++/include/arbsnsym.h	/^operator=(const ARluNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymStdEig
operator =	arpack++/include/arbspen.h	/^operator=(const ARbdSymPencil<ARTYPE>& other)$/;"	f	class:ARbdSymPencil
operator =	arpack++/include/arbssym.h	/^operator=(const ARluSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluSymStdEig
operator =	arpack++/include/ardgcomp.h	/^operator=(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
operator =	arpack++/include/ardgnsym.h	/^operator=(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
operator =	arpack++/include/ardgsym.h	/^operator=(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
operator =	arpack++/include/ardnsmat.h	/^operator=(const ARdsNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARdsNonSymMatrix
operator =	arpack++/include/ardnspen.h	/^operator=(const ARdsNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARdsNonSymPencil
operator =	arpack++/include/ardscomp.h	/^operator=(const ARluCompStdEig<ARFLOAT>& other)$/;"	f	class:ARluCompStdEig
operator =	arpack++/include/ardsmat.h	/^operator=(const ARdsSymMatrix<ARTYPE>& other)$/;"	f	class:ARdsSymMatrix
operator =	arpack++/include/ardsnsym.h	/^operator=(const ARluNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymStdEig
operator =	arpack++/include/ardspen.h	/^operator=(const ARdsSymPencil<ARTYPE>& other)$/;"	f	class:ARdsSymPencil
operator =	arpack++/include/ardssym.h	/^operator=(const ARluSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluSymStdEig
operator =	arpack++/include/argcomp.h	/^operator=(const ARCompGenEig<ARFLOAT, ARFOP, ARFB>& other)$/;"	f	class:ARCompGenEig
operator =	arpack++/include/argeig.h	/^operator=(const ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>& other)$/;"	f	class:ARGenEig
operator =	arpack++/include/argnsym.h	/^operator=(const ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>& other)$/;"	f	class:ARNonSymGenEig
operator =	arpack++/include/argsym.h	/^operator=(const ARSymGenEig<ARFLOAT, ARFOP, ARFB>& other)$/;"	f	class:ARSymGenEig
operator =	arpack++/include/arlgcomp.h	/^operator=(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
operator =	arpack++/include/arlgnsym.h	/^operator=(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
operator =	arpack++/include/arlgsym.h	/^operator=(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
operator =	arpack++/include/arlnsmat.h	/^operator=(const ARluNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARluNonSymMatrix
operator =	arpack++/include/arlnspen.h	/^operator=(const ARluNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARluNonSymPencil
operator =	arpack++/include/arlscomp.h	/^operator=(const ARluCompStdEig<ARFLOAT>& other)$/;"	f	class:ARluCompStdEig
operator =	arpack++/include/arlsmat.h	/^operator=(const ARluSymMatrix<ARTYPE>& other)$/;"	f	class:ARluSymMatrix
operator =	arpack++/include/arlsnsym.h	/^operator=(const ARluNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymStdEig
operator =	arpack++/include/arlspen.h	/^operator=(const ARluSymPencil<ARTYPE>& other)$/;"	f	class:ARluSymPencil
operator =	arpack++/include/arlssym.h	/^operator=(const ARluSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluSymStdEig
operator =	arpack++/include/arrgcomp.h	/^operator=(const ARrcCompGenEig<ARFLOAT>& other)$/;"	f	class:ARrcCompGenEig
operator =	arpack++/include/arrgeig.h	/^operator=(const ARrcGenEig<ARFLOAT, ARTYPE>& other)$/;"	f	class:ARrcGenEig
operator =	arpack++/include/arrgnsym.h	/^operator=(const ARrcNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARrcNonSymGenEig
operator =	arpack++/include/arrgsym.h	/^operator=(const ARrcSymGenEig<ARFLOAT>& other)$/;"	f	class:ARrcSymGenEig
operator =	arpack++/include/arrscomp.h	/^operator=(const ARrcCompStdEig<ARFLOAT>& other)$/;"	f	class:ARrcCompStdEig
operator =	arpack++/include/arrseig.h	/^operator=(const ARrcStdEig<ARFLOAT, ARTYPE>& other)$/;"	f	class:ARrcStdEig
operator =	arpack++/include/arrsnsym.h	/^operator=(const ARrcNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARrcNonSymStdEig
operator =	arpack++/include/arrssym.h	/^operator=(const ARrcSymStdEig<ARFLOAT>& other)$/;"	f	class:ARrcSymStdEig
operator =	arpack++/include/arscomp.h	/^operator=(const ARCompStdEig<ARFLOAT, ARFOP>& other)$/;"	f	class:ARCompStdEig
operator =	arpack++/include/arseig.h	/^operator=(const ARStdEig<ARFLOAT, ARTYPE, ARFOP>& other)$/;"	f	class:ARStdEig
operator =	arpack++/include/arsnsym.h	/^operator=(const ARNonSymStdEig<ARFLOAT, ARFOP>& other)$/;"	f	class:ARNonSymStdEig
operator =	arpack++/include/arssym.h	/^operator=(const ARSymStdEig<ARFLOAT, ARFOP>& other)$/;"	f	class:ARSymStdEig
operator =	arpack++/include/arugcomp.h	/^operator=(const ARluCompGenEig<ARFLOAT>& other)$/;"	f	class:ARluCompGenEig
operator =	arpack++/include/arugnsym.h	/^operator=(const ARluNonSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymGenEig
operator =	arpack++/include/arugsym.h	/^operator=(const ARluSymGenEig<ARFLOAT>& other)$/;"	f	class:ARluSymGenEig
operator =	arpack++/include/arunsmat.h	/^operator=(const ARumNonSymMatrix<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARumNonSymMatrix
operator =	arpack++/include/arunspen.h	/^operator=(const ARumNonSymPencil<ARTYPE, ARFLOAT>& other)$/;"	f	class:ARumNonSymPencil
operator =	arpack++/include/aruscomp.h	/^operator=(const ARluCompStdEig<ARFLOAT>& other)$/;"	f	class:ARluCompStdEig
operator =	arpack++/include/arusmat.h	/^operator=(const ARumSymMatrix<ARTYPE>& other)$/;"	f	class:ARumSymMatrix
operator =	arpack++/include/arusnsym.h	/^operator=(const ARluNonSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluNonSymStdEig
operator =	arpack++/include/aruspen.h	/^operator=(const ARumSymPencil<ARTYPE>& other)$/;"	f	class:ARumSymPencil
operator =	arpack++/include/arussym.h	/^operator=(const ARluSymStdEig<ARFLOAT>& other)$/;"	f	class:ARluSymStdEig
operator ==	Communicator.h	/^    bool operator == (const CPair &x) const$/;"	f	struct:SubDTopo::CPair
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    bool operator==(const T_ARRAY1& v) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    bool operator==(const ARRAY_COLLECTION& collection) const$/;"	f	class:PhysBAM::ARRAY_COLLECTION
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator==(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    bool operator==(const PAIR& p) const$/;"	f	class:PhysBAM::PAIR
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    bool operator==(const TRIPLE& t) const$/;"	f	class:PhysBAM::TRIPLE
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Grids_Uniform_Arrays/ARRAYS_ND_BASE.h	/^    bool operator==(const ARRAY_BASE& v) const$/;"	f	class:PhysBAM::ARRAY_BASE
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^    bool operator==(const INTERVAL& r) const$/;"	f	class:PhysBAM::INTERVAL
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ONE.h	/^    bool operator==(const ONE) const$/;"	f	struct:PhysBAM::ONE
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^    bool operator==(const RANGE<TV>& r) const$/;"	f	class:PhysBAM::RANGE
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^    bool operator==(const ZERO) const$/;"	f	struct:PhysBAM::ZERO
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    bool operator==(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    bool operator==(const DIAGONAL_MATRIX& A) const$/;"	f	class:PhysBAM::DIAGONAL_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    bool operator==(const FRAME& f) const$/;"	f	class:PhysBAM::FRAME
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X2.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^    bool operator==(const MATRIX& A) const$/;"	f	class:PhysBAM::MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    bool operator==(const MATRIX_MXN& A) const$/;"	f	class:PhysBAM::MATRIX_MXN
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    bool operator==(const QUATERNION& q) const$/;"	f	class:PhysBAM::QUATERNION
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    bool operator==(const ROTATION<TV>& r) const$/;"	f	class:PhysBAM::ROTATION
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    bool operator==(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    bool operator==(const SYMMETRIC_MATRIX& A) const$/;"	f	class:PhysBAM::SYMMETRIC_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    bool operator==(const DERIVED& A) const$/;"	f	class:PhysBAM::TRANSPOSE_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    bool operator==(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    bool operator==(const UPPER_TRIANGULAR_MATRIX& A) const$/;"	f	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    bool operator==(const POINT_CLOUD<TV>& particles) const$/;"	f	class:PhysBAM::POINT_CLOUD
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    bool operator==(const COMPLEX<T>& c) const$/;"	f	class:PhysBAM::COMPLEX
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^    bool operator==(const TWIST& v) const$/;"	f	class:PhysBAM::TWIST
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    bool operator==(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    bool operator==(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    bool operator==(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    bool operator==(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator ==	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    bool operator==(const VECTOR& v) const$/;"	f	class:PhysBAM::VECTOR
operator >	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator>(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator >	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    bool operator>(const PAIR& p) const$/;"	f	class:PhysBAM::PAIR
operator >	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^inline bool operator>(const double x,const ZERO)$/;"	f	namespace:PhysBAM
operator >	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/ZERO.h	/^inline bool operator>(const float x,const ZERO)$/;"	f	namespace:PhysBAM
operator >=	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    bool operator>=(const ID id) const$/;"	f	class:PhysBAM::ELEMENT_ID
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^inline std::istream& operator>>(std::istream& input_stream,DIAGONAL_MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X0.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,0>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_0X1.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,0,1>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_1X1.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,1>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_2X2.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,2>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X2.h	/^inline std::istream& operator>>(std::istream& input,MATRIX<T,3,2>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_3X3.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,3>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_4X4.h	/^inline std::istream& operator>>(std::istream& input_stream,MATRIX<T,4>& A)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^inline std::istream& operator>>(std::istream& input,QUATERNION<T>& q)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Matrices_And_Vectors/READ_WRITE_TWIST.h	/^template<class TV> inline std::istream& operator>>(std::istream& input,TWIST<TV>& v)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR.h	/^template<class T,int d> std::istream& operator>>(std::istream& input,VECTOR<T,d>& v)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_0D.h	/^operator>>(std::istream& input,VECTOR<T,0>&)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_1D.h	/^operator>>(std::istream& input,VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_2D.h	/^operator>>(std::istream& input,VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_3D.h	/^operator>>(std::istream& input,VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
operator >>	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Vectors/READ_WRITE_VECTOR_ND.h	/^template<class T> inline std::istream& operator>>(std::istream& input_stream,VECTOR_ND<T>& v)$/;"	f	namespace:PhysBAM
operator MaxFace	Face.h	/^  operator MaxFace() { return MaxFace(numNodes(), nodeNum()); }$/;"	f	class:Face
operator SAFE_BOOL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^    operator SAFE_BOOL() const \/\/ allow conversion to bool without allowing conversion to T$/;"	f	class:PhysBAM::ELEMENT_ID
operator []	AgglomeratedFace.h	/^  AgglomeratedFace& operator [] (int i) { return myFaces[i]; }$/;"	f	class:AgglomeratedFaceSet
operator []	BCond.h	/^  BCond &operator[](int i) const { return bcs[i]; }$/;"	f	class:BCondSet
operator []	Connectivity.h	/^Connectivity::operator[](int i) const { return target +pointer[i] ; }$/;"	f	class:Connectivity
operator []	Connectivity.h	/^Connectivity::operator[](int i) { return target +pointer[i] ; }$/;"	f	class:Connectivity
operator []	DenseMatrix.h	/^GenFullM<Scalar>::operator[](int i) const$/;"	f	class:GenFullM
operator []	DenseMatrix.h	/^SymFullM<Scalar>::operator[](int i) const$/;"	f	class:SymFullM
operator []	DistVector.h	/^  Vec<Scalar>* operator[] (int i) const { return subVec[i]; }$/;"	f	class:DistVec
operator []	Elem.h	/^  Elem &operator[](int i) const { return *elems[i]; }$/;"	f	class:ElemSet
operator []	Elem.h	/^  int &operator[](int i) { return nodeNum(i); }  $/;"	f	class:Elem
operator []	Face.h	/^  Face &operator[](int i) { return *faces[i]; }$/;"	f	class:FaceSet
operator []	Face.h	/^  int operator[](int i) { return nodeNum(i); }  $/;"	f	class:Face
operator []	GappyPreprocessing.h	/^		Scalar& operator[] (int i){ return a[i];}$/;"	f	class:StaticArray
operator []	GappyPreprocessing.h	/^		VecSet< DistSVec<double,dim> >& operator [](int i) { return *(a[i]); };$/;"	f	class:VecSetArray
operator []	GappyPreprocessing.h	/^		const Scalar &operator[] (int i) const{ return a[i];}$/;"	f	class:StaticArray
operator []	GappyPreprocessing.h	/^	double * operator [](int i) {return a[i];};$/;"	f	struct:SubDomainData
operator []	GappyPreprocessing.h	/^	std::vector< SubDomainData<dim> > &operator [](int i) {return a[i];};$/;"	f	struct:VecSubDomainData
operator []	InletNode.h	/^  	InletNode &operator[] (int i) const { return inletNodes[i]; }$/;"	f	class:InletNodeSet
operator []	InletNode.h	/^  	int &operator[] (int i) const {return tets[i]; }$/;"	f	class:InletNode
operator []	MacroCell.h	/^  MacroCell &operator[](int i) const { return *(macroCells[i]); }$/;"	f	class:MacroCellSet
operator []	MacroCell.h	/^  int& operator[](int i) { return subCells[i]; }$/;"	f	class:MacroCell
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    T& operator[](const int i)$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    const T& operator[](const int i) const$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    T& operator[](const int)$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_0D.h	/^    const T& operator[](const int) const$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T& operator[](const int i)$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    const T& operator[](const int i) const$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T& operator[](const int i)$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    const T& operator[](const int i) const$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T& operator[](const int i)$/;"	f	class:PhysBAM::VECTOR
operator []	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    const T& operator[](const int i) const$/;"	f	class:PhysBAM::VECTOR
operator []	RefVector.h	/^  VecType &operator[] (int i) {return refVec;}$/;"	f	class:RefVec
operator []	RefVector.h	/^  const VecType &operator[] (int i) const {return refVec;}$/;"	f	class:RefVec
operator []	ResizeArray.h	/^Type &ResizeArray<Type>::operator[](int i) {$/;"	f	class:ResizeArray
operator []	SimpleBuffer.h	/^  Scalar & operator[](size_t n) { return values_[n]; }$/;"	f	class:SimpleBuffer
operator []	SimpleBuffer.h	/^  const Scalar & operator[](size_t n) const { return values_[n]; }$/;"	f	class:SimpleBuffer
operator []	SparseGrid.h	/^    int &operator[](int i) const {return elem_[i];}$/;"	f	class:SparseGrid::Heap
operator []	Vector.h	/^  Res operator[](int i) const { return y*a[i]; }$/;"	f	class:OuterProd
operator []	Vector.h	/^  Scalar operator[] (int i) const { return x[i]; }$/;"	f	class:Expr
operator []	Vector.h	/^  Scalar operator[](int i) const { return a[i]*b[i]; }$/;"	f	class:InnerProd
operator []	Vector.h	/^  Scalar operator[](int i) const { return a[i]+b[i]; }$/;"	f	class:Sum
operator []	Vector.h	/^  Scalar operator[](int i) const { return a[i]-b[i]; }$/;"	f	class:Diff
operator []	Vector.h	/^  Scalar operator[](int i) const { return a[i]\/b[i]; }$/;"	f	class:Div
operator []	Vector.h	/^  inline Scalar &operator[](int i) { return v[i]; }$/;"	f	class:Vec
operator []	Vector.h	/^  inline Scalar *operator[] (int i) { return v[i]; }$/;"	f	class:SVec
operator []	Vector.h	/^  inline const Scalar &operator[](int i) const { return v[i]; }$/;"	f	class:Vec
operator []	Vector.h	/^  inline const Scalar *operator[] (int i) const { return v[i]; }$/;"	f	class:SVec
operator []	Vector3D.h	/^  double &operator[](int i) { return v[i]; }$/;"	f	struct:Vec3D
operator []	Vector3D.h	/^  double operator[](int i) const { return v[i]; }$/;"	f	struct:Vec3D
operator []	VectorSet.h	/^   SubVecType &operator[] (int i) { return (*vs)[i](subIdx); }$/;"	f	class:SubVecSet
operator []	VectorSet.h	/^  VecType &operator[] (int i) const { return vecSet[i]; }$/;"	f	class:VecSet
operator ^	DenseMatrix.C	/^GenFullM<Scalar>::operator^(GenFullM<Scalar> &m)$/;"	f	class:GenFullM
operator ^	Vector3D.h	/^Vec3D Vec3D::operator^(const Vec3D &v2) const$/;"	f	class:Vec3D
operator delete	BlockAlloc.C	/^void operator delete(void *p, BlockAlloc &block)$/;"	f
operator delete	CommunicatorMPI.C	/^void operator delete(void *p, Communicator &) {$/;"	f
operator delete	Malloc.C	/^void operator delete(void *p)$/;"	f
operator delete[]	CommunicatorMPI.C	/^void operator delete[](void *p, Communicator &) {$/;"	f
operator double*	Vector3D.h	/^  operator double*() { return v; }$/;"	f	struct:Vec3D
operator int *	Elem.h	/^  operator int *() { return nodeNum(); }$/;"	f	class:Elem
operator int *	Face.h	/^  operator int *() { return nodeNum(); }$/;"	f	class:Face
operator new	BlockAlloc.C	/^void * operator new(size_t nbyte, BlockAlloc &block)$/;"	f
operator new	CommunicatorMPI.C	/^void* operator new(size_t size, Communicator &) {$/;"	f
operator new	Malloc.C	/^void * operator new(size_t size)$/;"	f
operator new[]	CommunicatorMPI.C	/^void* operator new[](size_t size, Communicator &) {$/;"	f
ops	arpack++/include/arlutil.h	/^    flops_t *ops;         \/* operation count at various phases *\/$/;"	m	struct:__anon52
optFlag	DistGeoState.h	/^  int optFlag;$/;"	m	class:DistGeoState
optPressureDim	IoData.h	/^  enum OptimalPressureDimensionality {NON_DIMENSIONAL=0, DIMENSIONAL=1,NONE=2} optPressureDim;$/;"	m	struct:InputData	typeref:enum:InputData::OptimalPressureDimensionality
optPressureDimensional	TsOutput.h	/^  bool optPressureDimensional;$/;"	m	class:TsOutput
optimalPressureDim	IoData.h	/^  const char *optimalPressureDim;$/;"	m	struct:InputData
optimalPressureFile	IoData.h	/^  const char *optimalPressureFile;$/;"	m	struct:InputData
orcmu	WallFcn.h	/^  double orcmu;$/;"	m	class:WallFcnKE
order	Connectivity.h	/^  int *order;  \/\/ order of the nodes -> order[new] = old$/;"	m	struct:compStruct
order	OneDimensionalSourceTerm.h	/^  int order;$/;"	m	class:OneDimensionalSourceTerm
order	Quadrature.h	/^    int order;          \/\/ order$/;"	m	class:Quadrature
order	SpaceOperator.h	/^  int order;$/;"	m	class:SpaceOperator
order	SubDomain.h	/^  void order()$/;"	f	struct:EdgeDef
order	arpack++/include/arlnsmat.h	/^  int         order;$/;"	m	class:ARluNonSymMatrix
order	arpack++/include/arlsmat.h	/^  int         order;$/;"	m	class:ARluSymMatrix
orderOfAccuracy	EmbeddedTsDesc.h	/^  int orderOfAccuracy; \/\/ consistent with the reconstruction type for space$/;"	m	class:EmbeddedTsDesc
orderOfAccuracy	MultiPhysicsTsDesc.h	/^  int orderOfAccuracy; \/\/ consistent with the reconstruction type for space$/;"	m	class:MultiPhysicsTsDesc
orderVector	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::orderVector(SVec<Scalar2,dim3> &x)$/;"	f	class:RectangularSparseMat
orderVector	SparseMatrix.C	/^void SparseMat<Scalar,dim>::orderVector(SVec<Scalar2,dim> &x)$/;"	f	class:SparseMat
ordered_loop_nodes	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.h	/^    ARRAY<ARRAY<int> >* ordered_loop_nodes;  \/\/ an ordered list of adjacent nodes for each connected component that is a simple loop (useful for boundaries)$/;"	m	class:PhysBAM::SEGMENT_MESH
orient2d	utils/Predicate.C	/^REAL orient2d(REAL *pa, REAL *pb, REAL *pc)$/;"	f
orient2dadapt	utils/Predicate.C	/^REAL orient2dadapt(REAL *pa, REAL *pb, REAL *pc, REAL detsum)$/;"	f
orient2dexact	utils/Predicate.C	/^REAL orient2dexact(REAL *pa, REAL *pb, REAL *pc)$/;"	f
orient2dfast	utils/Predicate.C	/^REAL orient2dfast(REAL *pa, REAL *pb, REAL *pc)$/;"	f
orient2dslow	utils/Predicate.C	/^REAL orient2dslow(REAL *pa, REAL *pb, REAL *pc)$/;"	f
orient3d	utils/Predicate.C	/^REAL orient3d(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
orient3dadapt	utils/Predicate.C	/^REAL orient3dadapt(REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL permanent)$/;"	f
orient3dexact	utils/Predicate.C	/^REAL orient3dexact(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
orient3dfast	utils/Predicate.C	/^REAL orient3dfast(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
orient3dslow	utils/Predicate.C	/^REAL orient3dslow(REAL *pa, REAL *pb, REAL *pc, REAL *pd)$/;"	f
originDistInfo	RestrictionMapping.h	/^  const DistInfo & originDistInfo() const { return originDistInfo_; }$/;"	f	class:RestrictionMapping
originDistInfo_	RestrictionMapping.h	/^  const DistInfo & originDistInfo_;$/;"	m	class:RestrictionMapping
originToRestricted_	RestrictionMapping.h	/^  std::vector<NumberingMap> originToRestricted_;$/;"	m	class:RestrictionMapping
originalSnapshotLocation	NonlinearRom.h	/^  std::vector<snapID> originalSnapshotLocation;$/;"	m	class:NonlinearRom
out	SparseGrid.h	/^  int dim, out;           \/\/ number of inputs and outputs$/;"	m	class:SparseGrid
outFile	EmbeddedFluidShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
outFile	FluidCollocationShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:FluidCollocationShapeOptimizationHandler
outFile	FluidGnatShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:FluidGnatShapeOptimizationHandler
outFile	FluidMetricShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:FluidMetricShapeOptimizationHandler
outFile	FluidRomShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:FluidRomShapeOptimizationHandler
outFile	FluidShapeOptimizationHandler.h	/^  FILE* outFile;$/;"	m	class:FluidShapeOptimizationHandler
outOfRange	SparseGridCore.C	/^bool SparseGrid::outOfRange(double *coord) const{$/;"	f	class:SparseGrid
outVar	IoData.h	/^  bool inVar[SIZE], outVar[SIZE]; $/;"	m	struct:BoundaryData
outfile	OneDimensionalSolver.h	/^  char *outfile;$/;"	m	class:OneDimensional
outlet	IoData.h	/^  BcsFreeStreamData outlet;$/;"	m	struct:BcsData
outletState	OneDimensionalSolver.h	/^    double boundaryStateL[5],boundaryStateR[5],outletState[5];$/;"	m	class:OneDimensional::Veval
output	IoData.h	/^  OutputData output;$/;"	m	class:IoData
output	IoData.h	/^  const char *output;$/;"	m	struct:CFLData
output	IoData.h	/^  const char *output;$/;"	m	struct:KspData
output	IoData.h	/^  const char *output;$/;"	m	struct:NewtonData
output	IoData.h	/^  const char *output;$/;"	m	struct:TsData
output	KspSolver.h	/^  FILE *output;$/;"	m	class:KspSolver
output	MatVecProd.h	/^  TsOutput<dim>* output;$/;"	m	class:MatVecProdFD
output	MultiGridKernel.h	/^  int output;$/;"	m	class:MultiGridKernel
output	TsDesc.h	/^  TsOutput<dim> *output;$/;"	m	class:TsDesc
output	TsParameters.h	/^  char *output;$/;"	m	class:TsParameters
output2DVTK	OneDimensionalSolver.C	/^void OneDimensional::output2DVTK() {$/;"	f	class:OneDimensional
outputApproxMetricLowRankFactorFullCoords	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputApproxMetricLowRankFactorFullCoords(const char* type, int iCluster) {$/;"	f	class:GappyPreprocessing
outputApproxMetricLowRankFactorReducedCoords	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputApproxMetricLowRankFactorReducedCoords(const char* type, int iCluster) {$/;"	f	class:GappyPreprocessing
outputApproxSnapsReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputApproxSnapsReduced(int iCluster) {$/;"	f	class:GappyPreprocessing
outputBasis	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::outputBasis(const VecSet<DistSVec<double, dim> >& U) {$/;"	f	class:EmbeddedAlternatingLeastSquare
outputCenterNorms	NonlinearRom.C	/^void NonlinearRom<dim>::outputCenterNorms(std::vector<std::vector<double> > &vec) {$/;"	f	class:NonlinearRom
outputClusterCentersReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputClusterCentersReduced() {$/;"	f	class:GappyPreprocessing
outputClusteredBasis	NonlinearRom.C	/^void NonlinearRom<dim>::outputClusteredBasis(int iCluster, int nTotSnaps, const char* basisType) {$/;"	f	class:NonlinearRom
outputClusteredInfoASCII	NonlinearRom.C	/^void NonlinearRom<dim>::outputClusteredInfoASCII(int iCluster, const char* type, std::vector<double>* vec1,$/;"	f	class:NonlinearRom
outputClusteredReferenceState	NonlinearRom.C	/^void NonlinearRom<dim>::outputClusteredReferenceState(int iCluster, DistSVec<double, dim>& ref) {$/;"	f	class:NonlinearRom
outputClusteredSnapshots	NonlinearRom.C	/^void NonlinearRom<dim>::outputClusteredSnapshots(const char* snapType)  { $/;"	f	class:NonlinearRom
outputConvergenceInfo	KspSolver.h	/^  bool outputConvergenceInfo;$/;"	m	class:GmresSolver
outputCsDynamicLES	DomainCore.C	/^void Domain::outputCsDynamicLES(DynamicLESTerm *dles, DistVec<double> &ctrlVol,$/;"	f	class:Domain
outputCsDynamicLES	SubDomainCore.C	/^void SubDomain::outputCsDynamicLES(DynamicLESTerm *dles, SVec<double,2> &Cs,$/;"	f	class:SubDomain
outputCsValues	DynamicLESTerm.C	/^double DynamicLESTerm::outputCsValues(double tetVol, double Cs[4], SVec<double,3> &X, int nodeNum[4])$/;"	f	class:DynamicLESTerm
outputDisplacementReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputDisplacementReduced() {$/;"	f	class:GappyPreprocessing
outputForces	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::outputForces(IoData &ioData, bool* lastIt, int it, int itSc, int itNl,$/;"	f	class:EmbeddedTsDesc
outputForces	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::outputForces(IoData &ioData, bool* lastIt, int it, int itSc, int itNl,$/;"	f	class:LevelSetTsDesc
outputForces	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::outputForces(IoData &ioData, bool* lastIt, int it, int itSc, int itNl,$/;"	f	class:MultiPhysicsTsDesc
outputForces	TsDesc.C	/^void TsDesc<dim>::outputForces(IoData &ioData, bool* lastIt, int it, int itSc, int itNl, $/;"	f	class:TsDesc
outputInitialConditionReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputInitialConditionReduced() {$/;"	f	class:GappyPreprocessing
outputKrylovStep	Domain.h	/^  int outputKrylovStep;  $/;"	m	class:Domain
outputKrylovStep	IoData.h	/^  int outputKrylovStep;$/;"	m	struct:RestartParametersData
outputKrylovStep	TimeData.h	/^  int outputKrylovStep;$/;"	m	class:TimeData
outputLocalReferenceStateReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputLocalReferenceStateReduced(int iCluster) {$/;"	f	class:GappyPreprocessing
outputLocalStateBasisReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputLocalStateBasisReduced(int iCluster) {$/;"	f	class:GappyPreprocessing
outputMatchStateReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputMatchStateReduced() {$/;"	f	class:GappyPreprocessing
outputMatrix	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::outputMatrix(char *fn, VecSet< DistSVec<double, dim> > &A){$/;"	f	class:ImplicitEmbeddedRomTsDesc
outputModalDisp	Modal.C	/^ModalSolver<dim>::outputModalDisp(double *delU, double *delY, double sdt, int cnt,$/;"	f	class:ModalSolver
outputMultiSolutionsReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputMultiSolutionsReduced() {$/;"	f	class:GappyPreprocessing
outputNewton	ImplicitEmbeddedTsDesc.h	/^  FILE *outputNewton;$/;"	m	class:ImplicitEmbeddedTsDesc
outputNewton	ImplicitLevelSetTsDesc.h	/^  FILE *outputNewton;$/;"	m	class:ImplicitLevelSetTsDesc
outputNewton	ImplicitMultiPhysicsTsDesc.h	/^  FILE *outputNewton;$/;"	m	class:ImplicitMultiPhysicsTsDesc
outputNewton	ImplicitTsDesc.h	/^  FILE *outputNewton;$/;"	m	class:ImplicitTsDesc
outputNewton	MeshMotionSolver.h	/^  FILE *outputNewton;$/;"	m	class:TetMeshMotionSolver
outputNewtonIt	Domain.h	/^  int outputNewtonIt;$/;"	m	class:Domain
outputNewtonResidualStep	Domain.h	/^  int outputNewtonResidualStep;$/;"	m	class:Domain
outputNewtonResidualStep	IoData.h	/^  int outputNewtonResidualStep;$/;"	m	struct:RestartParametersData
outputNewtonResidualStep	TimeData.h	/^  int outputNewtonResidualStep;$/;"	m	class:TimeData
outputNewtonStateStep	Domain.h	/^  int outputNewtonStateStep;$/;"	m	class:Domain
outputNewtonStateStep	IoData.h	/^  int outputNewtonStateStep;$/;"	m	struct:RestartParametersData
outputNewtonStateStep	TimeData.h	/^  int outputNewtonStateStep;$/;"	m	class:TimeData
outputNewtonTag	Domain.h	/^  double outputNewtonTag;$/;"	m	class:Domain
outputNewtonTag	IoData.h	/^  double outputNewtonTag;$/;"	m	struct:RestartParametersData
outputNewtonTag	TimeData.h	/^  int outputNewtonTag;$/;"	m	class:TimeData
outputOnlineMatrices	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputOnlineMatrices(int iCluster) {$/;"	f	class:GappyPreprocessing
outputOnlineMatrices	SurfMeshGen.h	/^	void outputOnlineMatrices() { ;}$/;"	f	class:SurfMeshGen
outputOnlineMatricesFull	GappyPreprocessing.h	/^  bool outputOnlineMatricesFull, outputOnlineMatricesSample;$/;"	m	class:GappyPreprocessing
outputOnlineMatricesGeneral	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputOnlineMatricesGeneral(int iCluster, int numNodes,$/;"	f	class:GappyPreprocessing
outputOnlineMatricesSample	GappyPreprocessing.h	/^  bool outputOnlineMatricesFull, outputOnlineMatricesSample;$/;"	m	class:GappyPreprocessing
outputOnlySpatialResidual	IoData.h	/^  enum OutputOnlySpatialResidual {OUTPUT_ONLY_SPATIAL_RES_OFF = 0, OUTPUT_ONLY_SPATIAL_RES_ON = 1} outputOnlySpatialResidual;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::OutputOnlySpatialResidual
outputOnlySpatialResidual	MeshMotionSolver.h	/^  bool outputOnlySpatialResidual() {return false;}$/;"	f	class:TetMeshMotionSolver
outputOnlySpatialResidual	TsDesc.h	/^  bool outputOnlySpatialResidual() {return outputOnlySpatialResidualBool;}$/;"	f	class:TsDesc
outputOnlySpatialResidualBool	TsDesc.h	/^  bool outputOnlySpatialResidualBool;$/;"	m	class:TsDesc
outputPODVectors	Modal.C	/^void ModalSolver<dim>::outputPODVectors(ARluSymStdEig<double> &podEigProb,$/;"	f	class:ModalSolver
outputPODVectors	Modal.C	/^void ModalSolver<dim>::outputPODVectors(VecSet<DistSVec<double, dim> > &podVecs, $/;"	f	class:ModalSolver
outputPositionVectorToDisk	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::outputPositionVectorToDisk(DistSVec<double,dim> &U) $/;"	f	class:EmbeddedTsDesc
outputPositionVectorToDisk	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::outputPositionVectorToDisk(DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
outputPositionVectorToDisk	TsDesc.C	/^void TsDesc<dim>::outputPositionVectorToDisk(DistSVec<double,dim> &U)$/;"	f	class:TsDesc
outputProbes	OneDimensionalSolver.C	/^void OneDimensional::outputProbes(double time,int iteration) {$/;"	f	class:OneDimensional
outputReduced3DSVec	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputReduced3DSVec(const DistSVec<double,3> &distSVec, FILE* myOutFile, double tag) {$/;"	f	class:GappyPreprocessing
outputReducedBases	IoData.h	/^  enum OutputReducedBases {OUTPUT_REDUCED_BASES_FALSE = 0, OUTPUT_REDUCED_BASES_TRUE = 1} outputReducedBases;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::OutputReducedBases
outputReducedSVec	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputReducedSVec(const DistSVec<double,dim> &distSVec, FILE* myOutFile, double tag) {$/;"	f	class:GappyPreprocessing
outputReducedToFullNodes	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputReducedToFullNodes() {$/;"	f	class:GappyPreprocessing
outputReducedVec	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputReducedVec(const DistVec<double> &distVec, FILE* outFile , int iVector) {$/;"	f	class:GappyPreprocessing
outputSampleNodes	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputSampleNodes(int iCluster) {$/;"	f	class:GappyPreprocessing
outputSampleNodes	SurfMeshGen.h	/^	void outputSampleNodes() { ;}$/;"	f	class:SurfMeshGen
outputSampleNodesGeneral	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputSampleNodesGeneral(const std::vector<int> &sampleNodes, const char *outSampleNodeFile) {$/;"	f	class:GappyPreprocessing
outputShapeDerivativeReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputShapeDerivativeReduced() {$/;"	f	class:GappyPreprocessing
outputTimeIt	Domain.h	/^  int outputTimeIt;$/;"	m	class:Domain
outputToDisk	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::outputToDisk(IoData &ioData, bool* lastIt, int it, int itSc, int itNl,$/;"	f	class:EmbeddedTsDesc
outputToDisk	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::outputToDisk(IoData &ioData, bool* lastIt, int it,$/;"	f	class:LevelSetTsDesc
outputToDisk	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::outputToDisk(IoData &ioData, bool* lastIt, int it,$/;"	f	class:MultiPhysicsTsDesc
outputToDisk	TsDesc.C	/^void TsDesc<dim>::outputToDisk(IoData &ioData, bool* lastIt, int it, int itSc, int itNl, $/;"	f	class:TsDesc
outputTopFile	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputTopFile(int iCluster) {$/;"	f	class:GappyPreprocessing
outputVector	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::outputVector(char *fn, DistSVec<double, dim> &b){$/;"	f	class:ImplicitEmbeddedRomTsDesc
outputWallDistanceReduced	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::outputWallDistanceReduced() {$/;"	f	class:GappyPreprocessing
outputdiff	IoData.h	/^  int outputdiff;$/;"	m	struct:MultiFluidData
overflows	tools/alloca.cougar.c	/^    long overflows;		\/* Number of stack overflow ($STKOFEN) calls.  *\/$/;"	m	struct:stk_stat	file:
overhead	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    double overhead;$/;"	m	class:PhysBAM::TIMER
overwriteNonlinearSnaps	IoData.h	/^  enum OverwriteNonlinearSnaps {OVERWRITE_OFF = 0, OVERWRITE_ON = 1} overwriteNonlinearSnaps;$/;"	m	struct:ROMOutputData	typeref:enum:ROMOutputData::OverwriteNonlinearSnaps
owned	MultiGridLevel.C	/^  bool owned;$/;"	m	struct:loc_edge	file:
ownedNodes	MultiGridLevel.h	/^  std::vector<int> ownedNodes;$/;"	m	struct:MultigridSubdomain
owned_elements	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.h	/^    ARRAY<ID> owned_elements;$/;"	m	class:PhysBAM::ARRAY_COLLECTION
ownsCommPatterns	DistMatrix.h	/^  bool ownsCommPatterns;$/;"	m	class:DistMat
ownsData	FluidSelector.h	/^  bool ownsData;$/;"	m	class:FluidSelector
ownsData	MultiGridLevel.h	/^    bool ownsData;$/;"	m	class:MultiGridLevel
owns_data	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    bool owns_data; \/\/ whether or not we own x$/;"	m	class:PhysBAM::VECTOR_ND
p	FluidCollocationShapeOptimizationHandler.h	/^  DistSVec<double,3> p;$/;"	m	class:FluidCollocationShapeOptimizationHandler
p	FluidGnatShapeOptimizationHandler.h	/^  DistSVec<double,3> p;$/;"	m	class:FluidGnatShapeOptimizationHandler
p	FluidMetricShapeOptimizationHandler.h	/^  DistSVec<double,3> p;$/;"	m	class:FluidMetricShapeOptimizationHandler
p	FluidRomShapeOptimizationHandler.h	/^  DistSVec<double,3> p;$/;"	m	class:FluidRomShapeOptimizationHandler
p	FluidShapeOptimizationHandler.h	/^  DistSVec<double,3> p;$/;"	m	class:FluidShapeOptimizationHandler
p	KspSolver.h	/^  VecSet<VecType> p, Ap;$/;"	m	class:GcrSolver
p	KspSolver.h	/^  VecType r, Ap, y, p;$/;"	m	class:CgSolver
p1	ExplicitEmbeddedTsDesc.h	/^  DistVec<double> p1;$/;"	m	class:ExplicitEmbeddedTsDesc
p1	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> p1;$/;"	m	class:ExplicitLevelSetTsDesc
p1	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> p1;$/;"	m	class:ExplicitMultiPhysicsTsDesc
p2	ExplicitEmbeddedTsDesc.h	/^  DistVec<double> p2;$/;"	m	class:ExplicitEmbeddedTsDesc
p2	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> p2;$/;"	m	class:ExplicitLevelSetTsDesc
p2	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> p2;$/;"	m	class:ExplicitMultiPhysicsTsDesc
p3	ExplicitEmbeddedTsDesc.h	/^  DistVec<double> p3;$/;"	m	class:ExplicitEmbeddedTsDesc
p3	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> p3;$/;"	m	class:ExplicitLevelSetTsDesc
p3	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> p3;$/;"	m	class:ExplicitMultiPhysicsTsDesc
p4	ExplicitEmbeddedTsDesc.h	/^  DistVec<double> p4;$/;"	m	class:ExplicitEmbeddedTsDesc
p4	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> p4;$/;"	m	class:ExplicitLevelSetTsDesc
p4	ExplicitMultiPhysicsTsDesc.h	/^  DistSVec<double,dimLS> p4;$/;"	m	class:ExplicitMultiPhysicsTsDesc
pData	GenMatrix.h	/^    Scalar* pData;$/;"	m	struct:GenMat::AuxilliaryIterator
pEdgeMapping	MultiGridLevel.h	/^    DistVec<int>* pEdgeMapping;$/;"	m	class:MultiGridLevel
pGeoSource	Domain.h	/^  GeoSource* pGeoSource;$/;"	m	class:Domain
pIntersector	TriangulatedInterface.h	/^  class DistIntersectorPhysBAM* pIntersector;$/;"	m	class:TriangulatedInterface	typeref:class:TriangulatedInterface::DistIntersectorPhysBAM
pKernel	MultiGridCoupledTsDesc.h	/^  MultiGridKernel<double>* pKernel;$/;"	m	class:MultiGridCoupledTsDesc
pKernel	MultiGridDistSVec.h	/^  MultiGridKernel<Scalar>* pKernel;$/;"	m	class:MultiGridDistSVec
pKernel	MultiGridEmbeddedTsDesc.h	/^  MultiGridKernel<double>* pKernel;$/;"	m	class:MultiGridEmbeddedTsDesc
pKernel	MultiGridKspSolver.h	/^  MultiGridKernel<Scalar>* pKernel;$/;"	m	class:MultiGridKspSolver
pKernel	MultiGridMvpMatrix.h	/^  MultiGridKernel<Scalar>* pKernel;$/;"	m	class:MultiGridMvpMatrix
pKernel	MultiGridSegTsDesc.h	/^  MultiGridKernel<double>* pKernel;$/;"	m	class:MultiGridSegTsDesc
pKernel	MultiGridSmoothingMatrices.h	/^  MultiGridKernel<Scalar>* pKernel;$/;"	m	class:MultiGridSmoothingMatrices
pKernel	MultiGridSpaceOperator.h	/^  MultiGridKernel<Scalar>* pKernel;$/;"	m	class:MultiGridSpaceOperator
pMatrices	MultiGridSmoothingMatrices.h	/^  MultiGridSmoothingMatrix<Scalar,dim>*** pMatrices;$/;"	m	class:MultiGridSmoothingMatrices
pNodeMapping	MultiGridLevel.h	/^    DistVec<int>* pNodeMapping;$/;"	m	class:MultiGridLevel
p_	VarFcnTait.h	/^  double p_;$/;"	m	class:VarFcnTait
package	IntersectorFRG/IntersectorFRG.h	/^    set<int> *package;$/;"	m	class:IntersectorFRG
package	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    std::set<int> *package;$/;"	m	class:IntersectorPhysBAM
pad	DistVector.h	/^DistSVec<Scalar,dim>::pad(DistSVec<Scalar,dim1> &y)$/;"	f	class:DistSVec
pad_size	tools/alloca.cougar.c	/^    long pad_size;		\/* Stack pad size.  *\/$/;"	m	struct:stk_stat	file:
padding	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct NO_TYPE {char padding[8];};$/;"	m	struct:PhysBAM::NO_TYPE
pade	IoData.h	/^  PadeData pade;$/;"	m	struct:LinearizedData
padeReconst	IoData.h	/^  enum PadeReconstruction {TRUE = 1, FALSE = 0} padeReconst;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::PadeReconstruction
padeReconstr	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
padeReconstruction	Domain.C	/^void Domain::padeReconstruction(VecSet<DistSVec<double, dim> >&snapsCoarse, VecSet<DistSVec<double, dim> >&snaps, int *stepParam, double *freqCoarse, double deltaFreq, int nStrMode, int L, int M, int nPoints)$/;"	f	class:Domain
padeReconstruction	SubDomain.C	/^void SubDomain::padeReconstruction(SVec<double, dim> **dataCoarse, SVec<double, dim> **data, int *stepParam, double *freqCoarse, double deltaFreqFine, int nStrMode,int L, int M, int nPoints)$/;"	f	class:SubDomain
padeSolution	SubDomainCore.C	/^void SubDomain::padeSolution(bcomp *padeVec, int *stepParam, double midFreq, int nPoints, int L, int M, double deltaFreq, int nSteps, bcomp *snaps, int* nWrittenSnaps, int flag, double freqMin, double freqMax)$/;"	f	class:SubDomain
pairing	FSI/DynamicNodalTransfer.h	/^  std::map<int,int> pairing;$/;"	m	class:EmbeddedStructure
panel_histo	arpack++/include/arlutil.h	/^    int     *panel_histo; \/* histogram of panel size distribution *\/$/;"	m	struct:__anon52
panel_size	arpack++/include/arlspdef.h	/^    int panel_size;$/;"	m	struct:__anon39
panel_size	arpack++/include/arlspdef.h	/^    int panel_size;$/;"	m	struct:__anon40
parallelALS	ParallelRomExtension.cpp	/^void ParallelRomExtension<dim>::parallelALS(const Mat1 &snap, const Mat2 &mask, Mat1 &UT, int maxIts) {$/;"	f	class:ParallelRomExtension
parallelLSMultiRHS	ParallelRom.C	/^void ParallelRom<dim>::parallelLSMultiRHS(const VecContainer1 &A,$/;"	f	class:ParallelRom
parallelLSMultiRHSClean	ParallelRom.C	/^void ParallelRom<dim>::parallelLSMultiRHSClean() {$/;"	f	class:ParallelRom
parallelLSMultiRHSGap	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::parallelLSMultiRHSGap(int iPodBasis, double **lsCoeff) {$/;"	f	class:GappyPreprocessing
parallelLSMultiRHSInit	ParallelRom.C	/^void ParallelRom<dim>::parallelLSMultiRHSInit(const VecContainer1 &A, const VecContainer2 &B, int _nA) {$/;"	f	class:ParallelRom
parallelPseudoInverse	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::parallelPseudoInverse(int iPodBasis) {$/;"	f	class:GappyPreprocessing
parallelRom	GappyPreprocessing.h	/^	std::vector< ParallelRom<dim> *> parallelRom;	\/\/ object for all parallel operations$/;"	m	class:GappyPreprocessing
parallelRom	ImplicitPGTsDesc.h	/^  ParallelRom<dim> *parallelRom;$/;"	m	class:ImplicitPGTsDesc
parallelSVD	ParallelRom.C	/^void ParallelRom<dim>::parallelSVD(VecContainer1 &snaps, VecContainer2 &Utrue,$/;"	f	class:ParallelRom
parameters	IoData.h	/^  const char *parameters;  \/\/ ROMs: operating point for the current simulation (interpolates multiSolutionsParams to find an IC);$/;"	m	struct:InputData
parameters	SparseGrid.h	/^  double *parameters;$/;"	m	class:SparseGrid
parametricDistanceExponent	IoData.h	/^  double parametricDistanceExponent;$/;"	m	struct:InputData
parent	LevelSet/MultiGridLevelSetStructure.h	/^    LevelSetStructure* parent;$/;"	m	class:MultiGridLevelSetStructure
parent	LevelSet/MultiGridLevelSetStructure.h	/^  DistLevelSetStructure* parent;$/;"	m	class:DistMultiGridLevelSetStructure
parent	MultiGridLevel.h	/^    MultiGridLevel* parent;$/;"	m	class:MultiGridLevel
parent	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    LOG_ENTRY* parent;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
parents	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    ARRAY<int> parents;$/;"	m	class:PhysBAM::BOX_HIERARCHY
parents	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    mutable ARRAY<ID,ID> parents;$/;"	m	class:PhysBAM::UNION_FIND
part	arpack++/include/arbnspen.h	/^  char                               part;$/;"	m	class:ARbdNonSymPencil
part	arpack++/include/ardnspen.h	/^  char                               part;$/;"	m	class:ARdsNonSymPencil
part	arpack++/include/arlnspen.h	/^  char                               part;$/;"	m	class:ARluNonSymPencil
part	arpack++/include/arlspen.h	/^  char                   part;$/;"	m	class:ARluSymPencil
part	arpack++/include/arrgnsym.h	/^  char part;$/;"	m	class:ARrcNonSymGenEig
part	arpack++/include/arunspen.h	/^  char                               part;$/;"	m	class:ARumNonSymPencil
particle	IntersectorFRG/IntersectorFRG.h	/^    list<int> particle; \/\/particles in the scope$/;"	m	class:IntersectorFRG
particles	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    GEOMETRY_PARTICLES<TV>& particles;$/;"	m	class:PhysBAM::PhysBAMInterface
particles	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    GEOMETRY_PARTICLES<VECTOR<T,3> >& particles;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
partitionAndSowerForGappy	NonlinearRom.C	/^void NonlinearRom<dim>::partitionAndSowerForGappy(bool surfaceMeshConstruction) {$/;"	f	class:NonlinearRom
pc	EmbeddedFluidShapeOptimizationHandler.h	/^  KspPrec<dim> *pc;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
pc	FluidShapeOptimizationHandler.h	/^  KspPrec<dim> *pc;$/;"	m	class:FluidShapeOptimizationHandler
pc	ImplicitCoupledTsDesc.h	/^  KspPrec<dim> *pc;$/;"	m	class:ImplicitCoupledTsDesc
pc	ImplicitEmbeddedCoupledTsDesc.h	/^  KspPrec<dim> *pc;$/;"	m	class:ImplicitEmbeddedCoupledTsDesc
pc	ImplicitLevelSetTsDesc.h	/^  KspPrec<dim> *pc;$/;"	m	class:ImplicitLevelSetTsDesc
pc	ImplicitMultiPhysicsTsDesc.h	/^  KspPrec<dim> *pc;$/;"	m	class:ImplicitMultiPhysicsTsDesc
pc	ImplicitPGTsDesc.h	/^  KspPrec<dim> *pc;$/;"	m	class:ImplicitPGTsDesc
pc	IoData.h	/^  PcData pc;$/;"	m	struct:KspData
pc	MeshMotionSolver.h	/^  KspPrec<3> *pc;$/;"	m	class:TetMeshMotionSolver
pc	Modal.h	/^    KspPrec<dim, double> *pc;$/;"	m	class:ModalSolver
pc	RecFcnDesc.h	/^  double pc,rhoc,vc;$/;"	m	class:RecFcnExtendedVanAlbada
pc1	ImplicitEmbeddedSegTsDesc.h	/^  KspPrec<neq1> *pc1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
pc1	ImplicitSegTsDesc.h	/^  KspPrec<neq1> *pc1;$/;"	m	class:ImplicitSegTsDesc
pc2	ImplicitEmbeddedSegTsDesc.h	/^  KspPrec<neq2> *pc2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
pc2	ImplicitSegTsDesc.h	/^  KspPrec<neq2> *pc2;$/;"	m	class:ImplicitSegTsDesc
pcComplex	Modal.h	/^    KspPrec<dim, bcomp> *pcComplex;$/;"	m	class:ModalSolver
pcLS	ImplicitLevelSetTsDesc.h	/^  KspPrec<dimLS> *pcLS;$/;"	m	class:ImplicitLevelSetTsDesc
pcLS	ImplicitMultiPhysicsTsDesc.h	/^  KspPrec<dimLS> *pcLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
pcOp	KspSolver.h	/^  PrecOp *pcOp;$/;"	m	class:KspSolver
pcol	arpack++/include/arhbmat.h	/^  ARINT*  pcol;            \/\/ Column pointers.$/;"	m	class:ARhbMatrix
pcol	arpack++/include/arlnsmat.h	/^  int*        pcol;$/;"	m	class:ARluNonSymMatrix
pcol	arpack++/include/arlsmat.h	/^  int*        pcol;$/;"	m	class:ARluSymMatrix
pcol	arpack++/include/arunsmat.h	/^  int*    pcol;$/;"	m	class:ARumNonSymMatrix
pcol	arpack++/include/arusmat.h	/^  int*    pcol;$/;"	m	class:ARumSymMatrix
pendReq	Communicator.h	/^  ResizeArray<MPI_Request> pendReq;$/;"	m	class:Communicator
percentOverlap	IoData.h	/^  double percentOverlap;$/;"	m	struct:ClusteringData
performPostProForState	TsDesc.C	/^void TsDesc<dim>::performPostProForState(DistSVec<double,dim> &outVec, int tmpIt)$/;"	f	class:TsDesc
periTri	IntersectorFRG/IntersectorFRG.C	/^  int periTri[maxNPairs];$/;"	m	class:ClosestTriangle	file:
permc	arpack++/include/arlnsmat.h	/^  int*        permc;$/;"	m	class:ARluNonSymMatrix
permc	arpack++/include/arlnspen.h	/^  int*                               permc;$/;"	m	class:ARluNonSymPencil
permc	arpack++/include/arlsmat.h	/^  int*        permc;$/;"	m	class:ARluSymMatrix
permc	arpack++/include/arlspen.h	/^  int*                   permc;$/;"	m	class:ARluSymPencil
permr	arpack++/include/arlnsmat.h	/^  int*        permr;$/;"	m	class:ARluNonSymMatrix
permr	arpack++/include/arlnspen.h	/^  int*                               permr;$/;"	m	class:ARluNonSymPencil
permr	arpack++/include/arlsmat.h	/^  int*        permr;$/;"	m	class:ARluSymMatrix
permr	arpack++/include/arlspen.h	/^  int*                   permr;$/;"	m	class:ARluSymPencil
permutation_oned	OneDimensionalSourceTerm.h	/^const static int permutation_oned[] = {1,-1,1,-1,1,-1,1,-1};$/;"	v
permute	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::permute(int *perm)$/;"	f	class:RectangularSparseMat
permute	SparseMatrix.C	/^void SparseMat<Scalar,dim>::permute(int *perm)$/;"	f	class:SparseMat
perturbed	IoData.h	/^  const char *perturbed;$/;"	m	struct:InputData
pgData	ProgrammedBurn.h	/^    ProgrammedBurnData* pgData;$/;"	m	struct:ProgrammedBurn::Burn
phantomNodes	FSI/CrackingSurface.h	/^  std::map<int,int> phantomNodes; \/\/Note: "phantomNodes" are NOT equivalent to "nodes of phantomQuads"!$/;"	m	struct:LatestCracking
phantomQuads	FSI/CrackingSurface.h	/^  std::set<int> phantomQuads;$/;"	m	struct:LatestCracking
phantoms	FSI/CrackingSurface.h	/^  std::map<int,PhantomElement*> phantoms; \/\/size: number of cracked (quad) elements$/;"	m	class:CrackingSurface
phaseChangeAlg	EmbeddedTsDesc.h	/^  int phaseChangeAlg;	 \/\/ = 0. use averaged value, given phaseChangeChocie==0$/;"	m	class:EmbeddedTsDesc
phaseChangeAlg	IoData.h	/^  enum PhaseChangeAlgorithm {AVERAGE = 0, LEAST_SQUARES = 1, AUTO = 2} phaseChangeAlg;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::PhaseChangeAlgorithm
phaseChangeAlg	MultiPhysicsTsDesc.h	/^  int phaseChangeAlg;	 \/\/ = 0. use averaged value, given phaseChangeChocie==0$/;"	m	class:MultiPhysicsTsDesc
phaseChangeChoice	EmbeddedTsDesc.h	/^  int phaseChangeChoice; \/\/ = 0. use nodal values.$/;"	m	class:EmbeddedTsDesc
phaseChangeChoice	MultiPhysicsTsDesc.h	/^  int phaseChangeChoice; \/\/ = 0. use nodal values.$/;"	m	class:MultiPhysicsTsDesc
phaseChangeType	LevelSetTsDesc.h	/^  int phaseChangeType;$/;"	m	class:LevelSetTsDesc
phaseChangeType	MultiPhysicsTsDesc.h	/^  int phaseChangeType;$/;"	m	class:MultiPhysicsTsDesc
phaseChangeType_	DistExactRiemannSolver.h	/^  MultiFluidData::TypePhaseChange phaseChangeType_;$/;"	m	class:DistExactRiemannSolver
phaseChangeType_	LocalRiemann.h	/^  MultiFluidData::TypePhaseChange phaseChangeType_;$/;"	m	class:LocalRiemannGfmpar
phi	DistNodalGrad.h	/^  DistSVec<Scalar,dim> *phi;$/;"	m	class:DistNodalGrad
phi	FSI/CrackingSurface.h	/^  double *phi;$/;"	m	struct:PhantomElement
phiVecPat	Domain.h	/^  CommPattern<double> *phiVecPat;$/;"	m	class:Domain
philevel	IoData.h	/^  const char *philevel;$/;"	m	struct:TransientData
philevel2	IoData.h	/^  const char *philevel2;$/;"	m	struct:TransientData
physInterface	IntersectorFRG/IntersectorFRG.h	/^    PhysBAMInterface<double> *physInterface;$/;"	m	class:IntersectorFRG
physInterface	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    PhysBAMInterface<double> *physInterface;$/;"	m	class:DistIntersectorPhysBAM
pi	Modal.h	/^    double pi;$/;"	m	class:ModalSolver
pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double pi=4*atan(1.);$/;"	m	namespace:PhysBAM
pi_squared	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double pi_squared=pi*pi;$/;"	m	namespace:PhysBAM
piercing	IntersectorFRG/IntersectorFRG.C	/^double ClosestTriangle::piercing(Vec3D x0, int tria, double xi[3])$/;"	f	class:ClosestTriangle
piercing	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::piercing(Vec3D x0, int tria, double xi[3])$/;"	f	class:IntersectorPhysBAM
pinfty	PostFcn.h	/^  double pinfty;$/;"	m	class:PostFcnEuler
placeNonStateSnapshotsInClusters	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::placeNonStateSnapshotsInClusters(const char* snapType) {$/;"	f	class:NonlinearRomDatabaseConstruction
plancks_constant	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double plancks_constant=6.6260755e-34; \/\/ J*s$/;"	m	namespace:PhysBAM
planeMap	IoData.h	/^  ObjectMap<PlaneData>  planeMap;$/;"	m	struct:MultiInitialConditionsData
pmin	IoData.h	/^  double pmin;$/;"	m	struct:FluidModelData
pmin	VarFcnBase.h	/^  double rhomin,pmin;$/;"	m	class:VarFcnBase
pmmh	TsOutput.h	/^  PitchingMeshMotionHandler *pmmh;$/;"	m	class:TsOutput
pname	VarFcn.h	/^  const char * pname(int dim, int tag=0) const{ return varFcn[tag]->pname[dim]; }$/;"	f	class:VarFcn
pname	VarFcnBase.h	/^  const char** pname;$/;"	m	class:VarFcnBase
pod	GappyPreprocessing.h	/^	VecSetArray<dim> pod;	\/\/ pod bases for residual and jacobian$/;"	m	class:GappyPreprocessing
pod	ImplicitRomTsDesc.h	/^  VecSet<DistSVec<double, dim> > pod;$/;"	m	class:ImplicitRomTsDesc
pod	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
podConstr	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
podFile	IoData.h	/^  const char *podFile;$/;"	m	struct:InputData
podFile	IoData.h	/^  const char *podFile;$/;"	m	struct:TransientData
podFile	TsInput.h	/^  char *podFile;$/;"	m	struct:TsInput
podHat	GappyPreprocessing.h	/^	VecSetArray<dim> podHat;	\/\/ restricted pod bases $/;"	m	class:GappyPreprocessing
podHatJac	GappyPreprocessing.h	/^	SetOfVec podHatRes, podHatJac;$/;"	m	class:GappyPreprocessing
podHatPseudoInv	GappyPreprocessing.h	/^  double **(podHatPseudoInv [2]);	\/\/ each dimension: (nSampleNode*dim) x nPod[i]$/;"	m	class:GappyPreprocessing
podHatRes	GappyPreprocessing.h	/^	SetOfVec podHatRes, podHatJac;$/;"	m	class:GappyPreprocessing
podJac	GappyPreprocessing.h	/^	SetOfVec podRes, podJac;$/;"	m	class:GappyPreprocessing
podMethod	IoData.h	/^  enum PODMethod {SCALAPACK_SVD = 0, PROBABILISTIC_SVD = 1, R_SVD = 2,  Eig = 3} podMethod;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::PODMethod
podMethod	Modal.h	/^    int podMethod;$/;"	m	class:ModalSolver
podRes	GappyPreprocessing.h	/^	SetOfVec podRes, podJac;$/;"	m	class:GappyPreprocessing
podTpod	GappyPreprocessing.h	/^  double **podTpod;	\/\/ stores phiJ^T * phiR$/;"	m	class:GappyPreprocessing
pointMap	IoData.h	/^  ObjectMap<PointData>  pointMap;$/;"	m	struct:MultiInitialConditionsData
pointToPointDistance	Extrapolation.C	/^double pointToPointDistance(Vec3D a, Vec3D b)$/;"	f
pointer	Connectivity.h	/^  int *pointer;       \/\/ pointer to target$/;"	m	class:Connectivity
pointer	tools/alloca.cougar.c	/^typedef char *pointer;$/;"	t	file:
pointer	tools/alloca.cougar.c	/^typedef void *pointer;$/;"	t	file:
points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less
points	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less_Equal
poly	IntersectorFRG/IntersectorFRG.h	/^    DistVec<bool> *poly; \/\/true if a node lies in n>2 subdomains (not used!)$/;"	m	class:DistIntersectorFRG
pool	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    POINTER_POOL<KD_TREE_NODE<T> > pool;$/;"	m	class:PhysBAM::KD_TREE
pools	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    ARRAY<T*> pools;$/;"	m	class:PhysBAM::POINTER_POOL
pop	SparseGridCore.C	/^int SparseGrid::Heap::pop(const double *value){$/;"	f	class:SparseGrid::Heap
populateGhostJacobian	Domain.C	/^void Domain::populateGhostJacobian(DistVec<GhostPoint<dim>*> *ghostPoints, $/;"	f	class:Domain
populateGhostJacobian	SubDomain.C	/^void SubDomain::populateGhostJacobian(Vec<GhostPoint<dim>*> &ghostPoints,SVec<double,dim> &U,$/;"	f	class:SubDomain
populateGhostPoints	Domain.C	/^void Domain::populateGhostPoints(DistVec<GhostPoint<dim>*> *ghostPoints, DistSVec<double,3> &X, $/;"	f	class:Domain
populateGhostPoints	SpaceOperator.C	/^void SpaceOperator<dim>::populateGhostPoints(DistVec<GhostPoint<dim>*> *ghostPoints, $/;"	f	class:SpaceOperator
populateGhostPoints	SpaceOperator.h	/^  void populateGhostPoints(DistVec<GhostPoint<dim>*> *ghostPoints,DistSVec<double,neq> &U,VarFcn *varFcn,DistLevelSetStructure *distLSS,DistVec<int> &tag) {$/;"	f	class:SpaceOperator
populateGhostPoints	SubDomain.C	/^void SubDomain::populateGhostPoints(Vec<GhostPoint<dim>*> &ghostPoints, SVec<double,3> &X, $/;"	f	class:SubDomain
populateGhostPointsForNavierStokes	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::populateGhostPointsForNavierStokes(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
porosity	IntersectorFRG/IntersectorFRG.h	/^    double *porosity;$/;"	m	class:DistIntersectorFRG
porosity	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double *porosity;$/;"	m	class:DistIntersectorPhysBAM
porosity	IoData.h	/^  double porosity;$/;"	m	struct:BoundaryData
porosity	LevelSet/LevelSetStructure.h	/^  double porosity;$/;"	m	struct:LevelSetResult
porousMedia	IoData.h	/^  PorousMedia   porousMedia;$/;"	m	struct:VolumeData
posFile	MeshMotionHandler.h	/^  char *posFile;$/;"	m	class:AeroMeshMotionHandler
positions	IoData.h	/^  const char *positions;$/;"	m	struct:DeformingData
positions	IoData.h	/^  const char *positions;$/;"	m	struct:InputData
positions	IoData.h	/^  const char *positions;$/;"	m	struct:RestartData
positions	TsInput.h	/^  char *positions;$/;"	m	struct:TsInput
positions	TsRestart.h	/^  char *positions[3];$/;"	m	class:TsRestart
postFcn	PostOperator.h	/^  PostFcn *postFcn;$/;"	m	class:PostOperator
postMultiplyBydUdV	VarFcn.h	/^  void postMultiplyBydUdV(double *V, bcomp *mat, bcomp *res, int tag=0) { check(tag); varFcn[tag]->postMultiplyBydUdV(V,mat,res); }$/;"	f	class:VarFcn
postMultiplyBydUdV	VarFcn.h	/^  void postMultiplyBydUdV(double *V, double *mat, double *res, int tag=0) { check(tag); varFcn[tag]->postMultiplyBydUdV(V,mat,res); }$/;"	f	class:VarFcn
postMultiplyBydUdV	VarFcnBase.h	/^void VarFcnBase::postMultiplyBydUdV(double *V, bcomp *mat, bcomp *res) {$/;"	f	class:VarFcnBase
postMultiplyBydUdV	VarFcnBase.h	/^void VarFcnBase::postMultiplyBydUdV(double *V, double *mat, double *res) {$/;"	f	class:VarFcnBase
postMultiplyBydUdV	VarFcnSGKE.h	/^  void postMultiplyBydUdV(double *, bcomp *, bcomp *) {fprintf(stderr,"ERROR: postMultiplyBydUdV needs to be implemented...\\n");}$/;"	f	class:VarFcnSGKE
postMultiplyBydUdV	VarFcnSGKE.h	/^void VarFcnSGKE::postMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGKE
postMultiplyBydUdV	VarFcnSGSA.h	/^  void postMultiplyBydUdV(double *, bcomp *, bcomp *) {fprintf(stderr,"ERROR: postMultiplyBydUdV needs to be implemented...\\n");}$/;"	f	class:VarFcnSGSA
postMultiplyBydUdV	VarFcnSGSA.h	/^void VarFcnSGSA::postMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGSA
postMultiplyBydUdV	VarFcnTaitKE.h	/^void VarFcnTaitKE::postMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitKE
postMultiplyBydUdV	VarFcnTaitSA.h	/^void VarFcnTaitSA::postMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitSA
postMultiplyBydVdU	VarFcn.h	/^  void postMultiplyBydVdU(double *V, double *mat, double *res, int tag=0) { check(tag); varFcn[tag]->postMultiplyBydVdU(V,mat,res); }$/;"	f	class:VarFcn
postMultiplyBydVdU	VarFcnBase.h	/^void VarFcnBase::postMultiplyBydVdU(double *V, double *mat, double *res) {$/;"	f	class:VarFcnBase
postMultiplyBydVdU	VarFcnSGKE.h	/^void VarFcnSGKE::postMultiplyBydVdU(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGKE
postMultiplyBydVdU	VarFcnSGSA.h	/^void VarFcnSGSA::postMultiplyBydVdU(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGSA
postMultiplyBydVdU	VarFcnTaitKE.h	/^void VarFcnTaitKE::postMultiplyBydVdU(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitKE
postMultiplyBydVdU	VarFcnTaitSA.h	/^void VarFcnTaitSA::postMultiplyBydVdU(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitSA
postOp	GappyPreprocessing.h	/^  PostOperator<dim> *postOp;$/;"	m	class:GappyPreprocessing
postOp	Modal.h	/^    PostOperator<dim> *postOp;$/;"	m	class:ModalSolver
postOp	TsDesc.h	/^  PostOperator<dim> *postOp;$/;"	m	class:TsDesc
postOp	TsOutput.h	/^  PostOperator<dim> *postOp;$/;"	m	class:TsOutput
postProProjectedStates	IoData.h	/^  enum PostProProjectedStates {POST_PRO_OFF = 0, POST_PRO_ON = 1} postProProjectedStates;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::PostProProjectedStates
postProStep	ImplicitRomPostproTsDesc.C	/^void ImplicitRomPostproTsDesc<dim>::postProStep(DistSVec<double, dim> &U, int totalTimeSteps)  {$/;"	f	class:ImplicitRomPostproTsDesc
postProStep	ImplicitRomTsDesc.h	/^  virtual void postProStep(DistSVec<double,dim> &, int) {};	\/\/ by default, do not do post processing$/;"	f	class:ImplicitRomTsDesc
pow	DistVector.h	/^DistVec<Scalar> & DistVec<Scalar>::pow(const DistVec<Scalar> &v2, double exp)$/;"	f	class:DistVec
pow	VarFcnTait.h	/^  inline double pow(double a, double b) const {$/;"	f	class:VarFcnTait
pow_ri_k	OneDimensionalSourceTerm.h	/^  double* pow_ry_k,*pow_ri_k,*logr1r0;$/;"	m	class:OneDimensionalSourceTerm
pow_ry_k	OneDimensionalSourceTerm.h	/^  double* pow_ry_k,*pow_ri_k,*logr1r0;$/;"	m	class:OneDimensionalSourceTerm
power	IoData.h	/^   double power;$/;"	m	struct:BLMeshMotionData
power	RefVal.h	/^  double power;$/;"	m	class:RefVal
powerScaling	IoData.h	/^  double powerScaling;$/;"	m	struct:AeroelasticData
power_of_two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^inline bool power_of_two(const unsigned int v)$/;"	f	namespace:PhysBAM
prandtl	IoData.h	/^  double prandtl;$/;"	m	struct:ThermalCondModelData
prandtl	WallFcn.h	/^  double prandtl;$/;"	m	class:WallFcn
prandtlTurbulent	IoData.h	/^  double prandtlTurbulent;$/;"	m	struct:TurbulenceClosureData
preMultiplyBydUdV	VarFcn.h	/^  void preMultiplyBydUdV(double *V, double *mat, double *res, int tag=0) { check(tag); varFcn[tag]->preMultiplyBydUdV(V,mat,res); }$/;"	f	class:VarFcn
preMultiplyBydUdV	VarFcnBase.h	/^void VarFcnBase::preMultiplyBydUdV(double *V, double *mat, double *res) {$/;"	f	class:VarFcnBase
preMultiplyBydUdV	VarFcnSGKE.h	/^void VarFcnSGKE::preMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGKE
preMultiplyBydUdV	VarFcnSGSA.h	/^void VarFcnSGSA::preMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnSGSA
preMultiplyBydUdV	VarFcnTaitKE.h	/^void VarFcnTaitKE::preMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitKE
preMultiplyBydUdV	VarFcnTaitSA.h	/^void VarFcnTaitSA::preMultiplyBydUdV(double *V, double *mat, double *res)$/;"	f	class:VarFcnTaitSA
preProcess	Modal.C	/^void ModalSolver<dim>::preProcess()  {$/;"	f	class:ModalSolver
prec	IoData.h	/^  PreconditionData prec;$/;"	m	class:IoData
prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 2} prec;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::Prec
prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1, SAME_AS_PROBLEM = 3 } prec;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::Prec
prec	IoData.h	/^  enum Prec {NON_PRECONDITIONED = 0, PRECONDITIONED = 1} prec;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::Prec
prec	IoData.h	/^  enum Prec {NO_PREC = 0, PREC = 1} prec;$/;"	m	struct:TsData	typeref:enum:TsData::Prec
prec	LocalRiemannDesc.h	/^  bool prec;$/;"	m	class:LocalRiemannFluidStructure
prec	LowMachPrec.h	/^  int prec;$/;"	m	class:LowMachPrec
precompute	RecFcn.h	/^void RecFcn::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcn
precompute	RecFcnDesc.h	/^void RecFcnConstant<5>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
precompute	RecFcnDesc.h	/^void RecFcnConstant<dim>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnConstant
precompute	RecFcnDesc.h	/^void RecFcnLinear<5>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinear
precompute	RecFcnDesc.h	/^void RecFcnLinear<dim>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinear
precompute	RecFcnDesc.h	/^void RecFcnLinearConstant<6>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearConstant
precompute	RecFcnDesc.h	/^void RecFcnLinearConstant<7>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearConstant
precompute	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<6>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearVanAlbada
precompute	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<7>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnLinearVanAlbada
precompute	RecFcnDesc.h	/^void RecFcnVanAlbada<5>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
precompute	RecFcnDesc.h	/^void RecFcnVanAlbada<dim>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbada
precompute	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<6>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbadaConstant
precompute	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<7>::precompute(double* Vi, double* ddVij, double* Vj, double* ddVji,$/;"	f	class:RecFcnVanAlbadaConstant
precomputeDerivative	RecFcn.h	/^void RecFcn::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcn
precomputeDerivative	RecFcnDesc.h	/^void RecFcnConstant<5>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
precomputeDerivative	RecFcnDesc.h	/^void RecFcnConstant<dim>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnConstant
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinear<5>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinear
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinear<dim>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinear
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinearConstant<6>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearConstant
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinearConstant<7>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearConstant
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<6>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearVanAlbada
precomputeDerivative	RecFcnDesc.h	/^void RecFcnLinearVanAlbada<7>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnLinearVanAlbada
precomputeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<5>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
precomputeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbada<dim>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbada
precomputeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<6>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbadaConstant
precomputeDerivative	RecFcnDesc.h	/^void RecFcnVanAlbadaConstant<7>::precomputeDerivative(double* Vi, double* dVi, double* ddVij, double* dddVij, double* Vj, double* dVj, double* ddVji, double* dddVji,$/;"	f	class:RecFcnVanAlbadaConstant
precomputeRec	SubDomain.C	/^ void SubDomain::precomputeRec(RecFcn *recFcn, SVec<double,3> &X,$/;"	f	class:SubDomain
preconstant	RecFcn.h	/^void RecFcn::preconstant(double& aij, double& aji, double& bij, double& bji)$/;"	f	class:RecFcn
preconstantDerivative	RecFcn.h	/^void RecFcn::preconstantDerivative(double& daij, double& daji, double& dbij, double& dbji)$/;"	f	class:RecFcn
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:InputData
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:NonlinearRomDirectoriesData
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:Probes
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:ROMOutputData
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:RestartData
prefix	IoData.h	/^  const char *prefix;$/;"	m	struct:TransientData
prelinear	RecFcn.h	/^void RecFcn::prelinear(double& aij, double& aji, double& bij, double& bji)$/;"	f	class:RecFcn
prelinearDerivative	RecFcn.h	/^void RecFcn::prelinearDerivative(double& daij, double& daji, double& dbij, double& dbji)$/;"	f	class:RecFcn
preproForArbitraryUniformIC	NonlinearRomDatabaseConstruction.h	/^  bool preproForArbitraryUniformIC;$/;"	m	class:NonlinearRomDatabaseConstruction
preproForInterpolatedIC	NonlinearRomDatabaseConstruction.h	/^  bool preproForInterpolatedIC;$/;"	m	class:NonlinearRomDatabaseConstruction
preprocessForApproxUpdates	IoData.h	/^  enum PreprocessForApproxUpdates {APPROX_UPDATES_FALSE = 0, APPROX_UPDATES_TRUE = 1} preprocessForApproxUpdates;$/;"	m	struct:BasisUpdatesData	typeref:enum:BasisUpdatesData::PreprocessForApproxUpdates
preprocessForDistanceComparisons	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::preprocessForDistanceComparisons() {$/;"	f	class:NonlinearRomDatabaseConstruction
preprocessForDistanceComparisonsIncrements	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::preprocessForDistanceComparisonsIncrements() {$/;"	f	class:NonlinearRomDatabaseConstruction
preprocessForDistanceComparisonsStandard	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::preprocessForDistanceComparisonsStandard() {$/;"	f	class:NonlinearRomDatabaseConstruction
preprocessForExactBasisUpdates	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::preprocessForExactBasisUpdates() {$/;"	f	class:NonlinearRomDatabaseConstruction
preprocessForExactUpdates	IoData.h	/^  enum PreprocessForExactUpdates {EXACT_UPDATES_FALSE = 0, EXACT_UPDATES_TRUE = 1} preprocessForExactUpdates;$/;"	m	struct:BasisUpdatesData	typeref:enum:BasisUpdatesData::PreprocessForExactUpdates
preprocessForNoUpdates	IoData.h	/^  enum PreprocessForNoUpdates {NO_UPDATES_FALSE = 0, NO_UPDATES_TRUE = 1} preprocessForNoUpdates;$/;"	m	struct:BasisUpdatesData	typeref:enum:BasisUpdatesData::PreprocessForNoUpdates
preprocessForProjections	IoData.h	/^  enum PreprocessForProjections {PROJECTIONS_FALSE = 0, PROJECTIONS_TRUE = 1} preprocessForProjections;$/;"	m	struct:BasisUpdatesData	typeref:enum:BasisUpdatesData::PreprocessForProjections
preprocessForSimpleUpdates	IoData.h	/^  enum PreprocessForSimpleUpdates {SIMPLE_UPDATES_FALSE = 0, SIMPLE_UPDATES_TRUE = 1} preprocessForSimpleUpdates;$/;"	m	struct:BasisUpdatesData	typeref:enum:BasisUpdatesData::PreprocessForSimpleUpdates
pressFlag	IoData.h	/^  bool pressFlag;$/;"	m	struct:SensitivityAnalysis
pressInfty	PostOperator.h	/^  double pressInfty;$/;"	m	class:PostOperator
pressure	IoData.h	/^  const char *pressure;$/;"	m	struct:LinePlot
pressure	IoData.h	/^  const char *pressure;$/;"	m	struct:Probes
pressure	IoData.h	/^  const char *pressure;$/;"	m	struct:TransientData
pressure	IoData.h	/^  double pressure;$/;"	m	struct:AeroelasticData
pressure	IoData.h	/^  double pressure;$/;"	m	struct:BcsFreeStreamData
pressure	IoData.h	/^  double pressure;$/;"	m	struct:BoundaryData
pressure	IoData.h	/^  double pressure;$/;"	m	struct:InitialConditions
pressure	IoData.h	/^  double pressure;$/;"	m	struct:ReferenceStateData
pressure	RefVal.h	/^  double pressure;$/;"	m	class:RefVal
pressure1	IoData.h	/^  double density1, velocity1, pressure1,temperature1;$/;"	m	struct:OneDimensionalInfo
pressure2	IoData.h	/^  double density2, velocity2, pressure2,temperature2;$/;"	m	struct:OneDimensionalInfo
pressureConstant	IoData.h	/^  double pressureConstant;$/;"	m	struct:GasModelData
pressureEqGasDensity	LocalRiemannDesc.h	/^double LocalRiemannGfmparGasJWL::pressureEqGasDensity(const double gasDensity, const double gasPressure,$/;"	f	class:LocalRiemannGfmparGasJWL
pressurecoefficient	IoData.h	/^  const char *pressurecoefficient;$/;"	m	struct:TransientData
prevOutputState	ImplicitTsDesc.h	/^  DistSVec<double,dim> *prevOutputState;$/;"	m	class:ImplicitTsDesc
prevanalbada	RecFcn.h	/^void RecFcn::prevanalbada(double Vi, double ddVij, double Vj, double ddVji,$/;"	f	class:RecFcn
prevanalbadaDerivative	RecFcn.h	/^void RecFcn::prevanalbadaDerivative(double Vi, double dVi, double ddVij, double dddVij, double Vj, double dVj, double ddVji, double dddVji,$/;"	f	class:RecFcn
primitiveToCharacteristicVariations	VarFcn.h	/^  void primitiveToCharacteristicVariations(double n[3], double *V, double *dV, double *dW, int tag=0) { check(tag); varFcn[tag]->primitiveToCharacteristicVariations(n,V,dV,dW); }$/;"	f	class:VarFcn
primitiveToCharacteristicVariations	VarFcnBase.h	/^  virtual void primitiveToCharacteristicVariations(double n[3], double *V, double *dV, double *dW){$/;"	f	class:VarFcnBase
primitiveToCharacteristicVariations	VarFcnJwl.h	/^void VarFcnJwl::primitiveToCharacteristicVariations(double n[3], double *V, $/;"	f	class:VarFcnJwl
primitiveToCharacteristicVariations	VarFcnSGEuler.h	/^void VarFcnSGEuler::primitiveToCharacteristicVariations(double n[3], double *V, $/;"	f	class:VarFcnSGEuler
primitiveToCharacteristicVariations	VarFcnTait.h	/^void VarFcnTait::primitiveToCharacteristicVariations(double n[3], double *V, $/;"	f	class:VarFcnTait
primitiveToConservative	LevelSet.C	/^void LevelSet<dimLS>::primitiveToConservative(DistSVec<double,dimLS> &Prim, DistSVec<double,dimLS> &Cons,$/;"	f	class:LevelSet
primitiveToConservative	VarFcn.h	/^  void primitiveToConservative(double *V, double *U, int tag=0) { check(tag); varFcn[tag]->primitiveToConservative(V,U); }$/;"	f	class:VarFcn
primitiveToConservative	VarFcn.h	/^void VarFcn::primitiveToConservative(DistSVec<double,dim> &V, DistSVec<double,dim> &U, $/;"	f	class:VarFcn
primitiveToConservative	VarFcn.h	/^void VarFcn::primitiveToConservative(DistSVec<double,dim> &V, DistSVec<double,dim> &U, DistVec<int> *tag)$/;"	f	class:VarFcn
primitiveToConservative	VarFcn.h	/^void VarFcn::primitiveToConservative(SVec<double,dim> &V, SVec<double,dim> &U, Vec<int> *tag)$/;"	f	class:VarFcn
primitiveToConservative	VarFcnJwl.h	/^void VarFcnJwl::primitiveToConservative(double *V, double *U) {$/;"	f	class:VarFcnJwl
primitiveToConservative	VarFcnSGEuler.h	/^void VarFcnSGEuler::primitiveToConservative(double *V, double *U)$/;"	f	class:VarFcnSGEuler
primitiveToConservative	VarFcnSGKE.h	/^void VarFcnSGKE::primitiveToConservative(double *V, double *U)$/;"	f	class:VarFcnSGKE
primitiveToConservative	VarFcnSGSA.h	/^void VarFcnSGSA::primitiveToConservative(double *V, double *U)$/;"	f	class:VarFcnSGSA
primitiveToConservative	VarFcnTait.h	/^void VarFcnTait::primitiveToConservative(double *V, double *U) {$/;"	f	class:VarFcnTait
primitiveToConservative	VarFcnTaitKE.h	/^void VarFcnTaitKE::primitiveToConservative(double *V, double *U) {$/;"	f	class:VarFcnTaitKE
primitiveToConservative	VarFcnTaitSA.h	/^void VarFcnTaitSA::primitiveToConservative(double *V, double *U) {$/;"	f	class:VarFcnTaitSA
primitiveToConservativeDerivative	VarFcn.h	/^  void primitiveToConservativeDerivative(double *V, double *dV, double *U, double *dU, int tag=0) { check(tag); varFcn[tag]->primitiveToConservativeDerivative(V,dV,U,dU); }$/;"	f	class:VarFcn
primitiveToConservativeDerivative	VarFcn.h	/^void VarFcn::primitiveToConservativeDerivative(DistSVec<double,dim> &V, DistSVec<double,dim> &dV, DistSVec<double,dim> &U, DistSVec<double,dim> &dU, DistVec<int> *tag)$/;"	f	class:VarFcn
primitiveToConservativeDerivative	VarFcn.h	/^void VarFcn::primitiveToConservativeDerivative(SVec<double,dim> &V, SVec<double,dim> &dV, SVec<double,dim> &U, SVec<double,dim> &dU, Vec<int> *tag)$/;"	f	class:VarFcn
primitiveToConservativeDerivative	VarFcnBase.h	/^  virtual void primitiveToConservativeDerivative(double *V, double *dV, double *U, double *dU) {$/;"	f	class:VarFcnBase
primitiveToConservativeDerivative	VarFcnSGEuler.h	/^void VarFcnSGEuler::primitiveToConservativeDerivative(double *V, double *dV, double *U, double *dU)$/;"	f	class:VarFcnSGEuler
primitiveToConservativeDerivative	VarFcnSGKE.h	/^void VarFcnSGKE::primitiveToConservativeDerivative(double *V, double *dV, double *U, double *dU)$/;"	f	class:VarFcnSGKE
primitiveToConservativeDerivative	VarFcnSGSA.h	/^void VarFcnSGSA::primitiveToConservativeDerivative(double *V, double *dV, double *U, double *dU)$/;"	f	class:VarFcnSGSA
print	AlternatingLeastSquare/als_util.cpp	/^void print(double *mat, int nrow, int ncol){$/;"	f
print	AlternatingLeastSquare/als_util.cpp	/^void print(unsigned char *mat, int nrow, int ncol){$/;"	f
print	BCApplierCore.C	/^BCApplier::print()$/;"	f	class:BCApplier
print	BCond.C	/^void BCondSet::print()$/;"	f	class:BCondSet
print	ConnectivityCore.C	/^Connectivity::print(FILE *f)$/;"	f	class:Connectivity
print	DenseMatrix.C	/^GenFullM<Scalar>::print(const char *msg)$/;"	f	class:GenFullM
print	DenseMatrix.C	/^void SymFullM<Scalar>::print(const char *msg)$/;"	f	class:SymFullM
print	DistInfo.h	/^  void print(char* mssg=0) const $/;"	f	struct:DistInfo
print	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::print(FILE *fp)$/;"	f	class:RectangularSparseMat
print	SparseMatrix.C	/^void SparseMat<Scalar,dim>::print(FILE *fp)$/;"	f	class:SparseMat
print	Timer.C	/^void Timer::print(Timer *str, FILE *fp)$/;"	f	class:Timer
print	Vector.h	/^  void print(const char *msg = "") const {$/;"	f	class:Vec
print	Vector.h	/^  void print(const char *msg = "") { $/;"	f	class:SVec
print	Vector3D.h	/^  void print(const char *msg = "") { fprintf(stdout, "%s(%e %e %e)\\n", msg, v[0], v[1], v[2]); }$/;"	f	struct:Vec3D
print	VectorSet.h	/^  void print(const char *msg = "") {$/;"	f	class:VecSet
printAllMatrix	Domain.C	/^void Domain::printAllMatrix(DistMat<Scalar, neq> &A, int it)$/;"	f	class:Domain
printAllMatrix	SpaceOperator.C	/^void SpaceOperator<dim>::printAllMatrix(DistMat<Scalar,neq> &A, int it)$/;"	f	class:SpaceOperator
printAllMatrix	SubDomain.C	/^void SubDomain::printAllMatrix(GenMat<Scalar,neq> &A, int it)$/;"	f	class:SubDomain
printAllVariable	Domain.C	/^void Domain::printAllVariable(DistVec<int> &X, DistSVec<double,dim>&V, int it)$/;"	f	class:Domain
printAllVariable	SpaceOperator.C	/^void SpaceOperator<dim>::printAllVariable(DistSVec<double,3> &X, DistSVec<double,dim> &U, int it){$/;"	f	class:SpaceOperator
printAllVariable	SubDomain.C	/^void SubDomain::printAllVariable(Vec<int> &X, SVec<double,dim> &U, int numSub, int it)$/;"	f	class:SubDomain
printDebug	IoDataCore.C	/^void IoData::printDebug(){$/;"	f	class:IoData
printDebug	NonlinearRom.C	/^void NonlinearRom<dim>::printDebug(int iDebug) {$/;"	f	class:NonlinearRom
printDelRatios	DistDynamicVMSTerm.C	/^void DistDynamicVMSTerm<dim>:: printDelRatios(DistVec<double> &ctrlVol)$/;"	f	class:DistDynamicVMSTerm
printDistVecBool	DomainCore.C	/^void Domain::printDistVecBool(DistVec<bool> &X, bool status)$/;"	f	class:Domain
printDistVecBool	SubDomainCore.C	/^void SubDomain::printDistVecBool(Vec<bool> &X, int numSub, bool status)$/;"	f	class:SubDomain
printElementStatistics	DomainCore.C	/^void Domain::printElementStatistics()$/;"	f	class:Domain
printError	ErrorHandler.h	/^  void printError(int type=ALL){$/;"	f	struct:ErrorHandler
printErrorIndicatorOutput	Modal.C	/^void ModalSolver<dim>::printErrorIndicatorOutput(double errorIndicator, const char* output)$/;"	f	class:ModalSolver
printFirstElementIn_a	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::printFirstElementIn_a()$/;"	f	class:RectangularSparseMat
printFirstLayer	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::printFirstLayer(SubDomain& sub, SVec<double,3>&X, int TYPE)$/;"	f	class:IntersectorFRG
printFirstLayer	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::printFirstLayer(SubDomain& sub, SVec<double,3>&X, int TYPE) {$/;"	f	class:IntersectorPhysBAM
printFluidId	FluidSelectorCore.C	/^void FluidSelector::printFluidId(){$/;"	f	class:FluidSelector
printGhostPoint	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::printGhostPoint(){$/;"	f	class:ImplicitEmbeddedRomTsDesc
printGhostPoint	ImplicitEmbeddedTsDesc.h	/^    virtual void printGhostPoint() {}$/;"	f	class:ImplicitEmbeddedTsDesc
printInfo	FSI/CrackingSurface.cpp	/^void CrackingSurface::printInfo(char* filename)$/;"	f	class:CrackingSurface
printInfo	SubDomainCore.C	/^void SubDomain::printInfo(FILE *fp)$/;"	f	class:SubDomain
printInletVariable	Domain.C	/^void Domain::printInletVariable(DistSVec<double,dim>&V)$/;"	f	class:Domain
printInletVariable	InletNode.C	/^void InletNodeSet::printInletVariable(SVec<double,dim> &V, Connectivity* sharedInletNodes)$/;"	f	class:InletNodeSet
printInletVariable	SubDomain.C	/^void SubDomain::printInletVariable(SVec<double,dim> &V)$/;"	f	class:SubDomain
printInvalidElement	ElemTetCore.C	/^void ElemTet::printInvalidElement(int numInvElem, double lscale, int i, int *nodeMap, $/;"	f	class:ElemTet
printMacroCells	SubDomainCore.C	/^void printMacroCells(Connectivity &cToN)$/;"	f
printNodalDebug	MeshMotionSolver.h	/^  void printNodalDebug(int globNodeId, int identifier, DistSVec<double,3> *U, DistVec<int> *Id=0, DistVec<int> *Id0=0) {}$/;"	f	class:TetMeshMotionSolver
printNodalDebug	TsDesc.C	/^void TsDesc<dim>::printNodalDebug(int globNodeId, int identifier, DistSVec<double,dim> *U, DistVec<int> *Id, DistVec<int> *Id0)$/;"	f	class:TsDesc
printParam	KspSolver.h	/^  void printParam() { ioOp->fprintf(stderr, " solver params: %d maxits, %e eps\\n", maxits, eps);  }$/;"	f	class:KspSolver
printPhi	Domain.C	/^void Domain::printPhi(DistSVec<double,3> &X, DistSVec<double,dimLS> &Phi, int it)$/;"	f	class:Domain
printPhi	SubDomain.C	/^void SubDomain::printPhi(SVec<double, 3> &X, SVec<double,dimLS> &Phi, int it)$/;"	f	class:SubDomain
printPoint	SubDomainCore.C	/^void SubDomain::printPoint(int Ni, SVec<double,3> &X, Vec3D &xWall, V6NodeData & NSdata, $/;"	f	class:SubDomain
printRotMat	CorotSolver.C	/^void CorotSolver::printRotMat(double mat[3][3])$/;"	f	class:CorotSolver
printRotMat	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::printRotMat(double mat[3][3])$/;"	f	class:EmbeddedCorotSolver
printRow	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::printRow(int i, int *locToGlobNodeMap, FILE *fp)$/;"	f	class:RectangularSparseMat
printRow	SparseMatrix.C	/^void SparseMat<Scalar,dim>::printRow(int i, int *locToGlobNodeMap, FILE *fp)$/;"	f	class:SparseMat
printToFile	SparseGridCore.C	/^void SparseGrid::Heap::printToFile(FILE *file) const{$/;"	f	class:SparseGrid::Heap
printToFile	SparseGridCore.C	/^void SparseGrid::printToFile(const double *refIn, const double *refOut, const char *filename) const{$/;"	f	class:SparseGrid
printVariable	Domain.C	/^void Domain::printVariable(DistSVec<double,dim>&V, VarFcn *vf)$/;"	f	class:Domain
printVariable	InletNode.C	/^void InletNodeSet::printVariable(SVec<double,dim> &V, Connectivity* sharedInletNodes, VarFcn *vf)$/;"	f	class:InletNodeSet
printVariable	SpaceOperator.C	/^void SpaceOperator<dim>::printVariable(DistSVec<double,dim> &U){$/;"	f	class:SpaceOperator
printVariable	SubDomain.C	/^void SubDomain::printVariable(SVec<double,dim> &V, VarFcn *vf)$/;"	f	class:SubDomain
printf	CommunicatorMPI.C	/^void Communicator::printf(int verbose, const char *format, ...)$/;"	f	class:Communicator
printf	MeshMotionSolver.C	/^void TetMeshMotionSolver::printf(int verbose, const char *format, ...)$/;"	f	class:TetMeshMotionSolver
printf	TsDesc.C	/^void TsDesc<dim>::printf(int verbose, const char *format, ...)$/;"	f	class:TsDesc
prismMap	IoData.h	/^  ObjectMap<PrismData>  prismMap;$/;"	m	struct:MultiInitialConditionsData
private_instance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^LOG_CLASS* private_instance=0;$/;"	m	namespace:PhysBAM::LOG_REAL::__anon18	file:
probDesc	MultiGridSolver.h	/^  ProblemDescriptor *probDesc;$/;"	m	class:MultiGridSolver
probDesc	NewtonSolver.h	/^  ProblemDescriptor *probDesc;$/;"	m	class:NewtonSolver
probDesc	TsSolver.h	/^  ProblemDescriptor *probDesc;$/;"	m	class:TsSolver
probabilisticLSMultiRHS	NonlinearRom.C	/^void NonlinearRom<dim>::probabilisticLSMultiRHS(VecSet< DistSVec<double, dim> >& LHS, VecSet< DistSVec<double, dim> >& RHS,$/;"	f	class:NonlinearRom
probabilisticLSMultiRHSGap	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::probabilisticLSMultiRHSGap(int iPodBasis, double **lsCoeff) {$/;"	f	class:GappyPreprocessing
probabilisticSVD	NonlinearRom.C	/^void NonlinearRom<dim>::probabilisticSVD(VecSet< DistSVec<double, dim> >& Utrue, std::vector<double>& singularValues, FullM& Vtrue,$/;"	f	class:NonlinearRom
probabilisticSVDWrapper	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::probabilisticSVDWrapper(VecSet< DistSVec<double, dim> >*& snapshots, VecSet< DistSVec<double, dim> > &Utrue,$/;"	f	class:NonlinearRomDatabaseConstruction
probes	IoData.h	/^  Probes probes;$/;"	m	struct:TransientData
problem	IoData.h	/^  ProblemData problem;$/;"	m	class:IoData
problemMode	IoData.h	/^  enum ProblemMode { MULTIFLUID=0, FSI=1} problemMode;$/;"	m	struct:OneDimensionalInfo	typeref:enum:OneDimensionalInfo::ProblemMode
problemMode	OneDimensionalSolver.h	/^  ProblemMode problemMode;$/;"	m	class:OneDimensional
problemSizeIs	DistLeastSquareSolver.C	/^DistLeastSquareSolver::problemSizeIs(int eqnCount, int unknownCount, int rhsCount) {$/;"	f	class:DistLeastSquareSolver
problemType	TsDesc.h	/^  bool* problemType;$/;"	m	class:TsDesc
processInputFile	tools/loader.C	/^int processInputFile(char *name, int *&size, int *&argc1, char ***&argv1)$/;"	f
processInputLine	tools/loader.C	/^int processInputLine(int argc, char **argv, int *&size, int *&argc1, char ***&argv1)$/;"	f
processReceivedForce	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::processReceivedForce()$/;"	f	class:EmbeddedStructure
processSignal	Main.C	/^extern "C" void processSignal(int num)$/;"	f
processors1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    const ARRAY<char> &processors1,&processors2; \/\/ entries are 2*has_ours + has_greater $/;"	m	struct:PhysBAM::BOX_VISITOR_MPI
processors2	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    const ARRAY<char> &processors1,&processors2; \/\/ entries are 2*has_ours + has_greater $/;"	m	struct:PhysBAM::BOX_VISITOR_MPI
productOfBasisAndCenterDifferences	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::productOfBasisAndCenterDifferences(int iCluster, const char* basisType) {$/;"	f	class:NonlinearRomDatabaseConstruction
productOfVectorAndCenterDifferences	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::productOfVectorAndCenterDifferences(int iCluster, const char* vecType) {$/;"	f	class:NonlinearRomDatabaseConstruction
progBurnIgnited	LevelSetTsDesc.h	/^  bool progBurnIgnited;$/;"	m	class:LevelSetTsDesc
progBurnIgnitionTime	LevelSetTsDesc.h	/^  double currentTime,progBurnIgnitionTime;$/;"	m	class:LevelSetTsDesc
programmedBurn	Edge.h	/^  ProgrammedBurn* programmedBurn;$/;"	m	class:EdgeSet
programmedBurn	FluidSelector.h	/^  ProgrammedBurn* programmedBurn;$/;"	m	class:FluidSelector
programmedBurn	IoData.h	/^  ProgrammedBurnData programmedBurn;$/;"	m	struct:OneDimensionalInfo
programmedBurn	IoData.h	/^  ProgrammedBurnData programmedBurn;$/;"	m	struct:PointData
programmedBurn	IoData.h	/^  ProgrammedBurnData programmedBurn;$/;"	m	struct:PrismData
programmedBurn	IoData.h	/^  ProgrammedBurnData programmedBurn;$/;"	m	struct:SphereData
programmedBurn	LevelSetTsDesc.h	/^  ProgrammedBurn* programmedBurn;$/;"	m	class:LevelSetTsDesc
programmedBurn	MultiPhysicsTsDesc.h	/^  ProgrammedBurn* programmedBurn;$/;"	m	class:MultiPhysicsTsDesc
programmedBurn	OneDimensionalSolver.h	/^  ProgrammedBurn* programmedBurn;$/;"	m	class:OneDimensional
programmedBurnIsUsed	OneDimensionalSolver.h	/^  bool programmedBurnIsUsed;$/;"	m	class:OneDimensional
programmedBurnShockSensor	IoData.h	/^  double programmedBurnShockSensor;$/;"	m	struct:TsData
programmedBurnStopPercentDistance	OneDimensionalSolver.h	/^  double programmedBurnStopPercentDistance;$/;"	m	class:OneDimensional
proj	BCApplier.h	/^    list<ProjData> *proj;$/;"	m	class:BCApplier
projError	NonlinearRomDatabaseConstruction.h	/^  RelativeProjectionErrorData* projError;$/;"	m	class:NonlinearRomDatabaseConstruction
projError	Timer.h	/^		clustering, pod, distCalcsPrepro, exactUpdatesPrepro, projError, mds, 	$/;"	e	enum:Timer::TimerIndex
projErrorLog	NonlinearRomDatabaseConstruction.h	/^  VecSet<Vec<double> >* projErrorLog;$/;"	m	class:NonlinearRomDatabaseConstruction
projErrorName	IoData.h	/^  const char *projErrorName;$/;"	m	struct:NonlinearRomFilesData
projErrorName	NonlinearRom.h	/^  char* projErrorName;$/;"	m	class:NonlinearRom
projErrorSnapFile	IoData.h	/^  const char *projErrorSnapFile;$/;"	m	struct:InputData
projVectorTmp	ImplicitRomTsDesc.h	/^  double *projVectorTmp; \/\/ temporary vector for projectVector$/;"	m	class:ImplicitRomTsDesc
project	IntersectorFRG/IntersectorFRG.C	/^double ClosestTriangle::project(Vec3D x0, int tria, double& xi1, double& xi2) const$/;"	f	class:ClosestTriangle
project	IntersectorPhysBAM/IntersectorPhysBAM.C	/^double IntersectorPhysBAM::project(Vec3D x0, int tria, double& xi1, double& xi2) const$/;"	f	class:IntersectorPhysBAM
projectIncrementalSnaps	IoData.h	/^  enum ProjectIncrementalSnapshots {PROJECT_INCREMENTAL_SNAPS_FALSE = 0, PROJECT_INCREMENTAL_SNAPS_TRUE = 1} projectIncrementalSnaps;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::ProjectIncrementalSnapshots
projectStateOntoROB	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::projectStateOntoROB(DistSVec<double, dim> &U) {$/;"	f	class:ImplicitEmbeddedRomTsDesc
projectStateOntoROB	ImplicitEmbeddedTsDesc.h	/^    virtual void projectStateOntoROB(DistSVec<double, dim> &U) {}$/;"	f	class:ImplicitEmbeddedTsDesc
projectSwitchStateOntoAffineSubspace	IoData.h	/^  enum ProjectSwitchStateOntoAffineSubspace {PROJECT_OFF = 0, PROJECT_ON = 1} projectSwitchStateOntoAffineSubspace;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::ProjectSwitchStateOntoAffineSubspace
projectSwitchStateOntoAffineSubspace	NonlinearRom.h	/^  virtual void projectSwitchStateOntoAffineSubspace(int, int, DistSVec<double, dim> &, Vec<double> &) {};$/;"	f	class:NonlinearRom
projectSwitchStateOntoAffineSubspace	NonlinearRomOnlineII.C	/^void NonlinearRomOnlineII<dim>::projectSwitchStateOntoAffineSubspace(int iCluster, int prevCluster, DistSVec<double, dim> &U, Vec<double> &UromCurrentROB) {$/;"	f	class:NonlinearRomOnlineII
projectSwitchStateOntoAffineSubspace	NonlinearRomOnlineIII.C	/^void NonlinearRomOnlineIII<dim>::projectSwitchStateOntoAffineSubspace(int currentCluster, int prevCluster, $/;"	f	class:NonlinearRomOnlineIII
projectVector	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::projectVector(VecSet<DistSVec<double, dim> > &mat, DistSVec<double,dim> &vec, Vec<double> &buffer) {$/;"	f	class:ImplicitEmbeddedRomTsDesc
projectVector	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::projectVector(VecSet<DistSVec<double, dim> > &leftProj, DistSVec<double,dim> &fullV, Vec<double> &romV)  {$/;"	f	class:ImplicitRomTsDesc
projection	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::projection(Vec3D x0, int tria, double& xi1, double& xi2, double& dist)$/;"	f	class:IntersectorFRG
projection	IoData.h	/^  enum Projection {PETROV_GALERKIN = 0, GALERKIN = 1} projection;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::Projection
prolong_relax_factor	IoData.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	struct:MultiGridData
prolong_relax_factor	MultiGridCoupledTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridCoupledTsDesc
prolong_relax_factor	MultiGridEmbeddedTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridEmbeddedTsDesc
prolong_relax_factor	MultiGridKernel.h	/^  double prolong_relax_factor;$/;"	m	class:MultiGridKernel
prolong_relax_factor	MultiGridSegTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridSegTsDesc
propagateInfoAlongEdges	SubDomainCore.C	/^void SubDomain::propagateInfoAlongEdges(Vec<double>& tag)$/;"	f	class:SubDomain
prtout	TsOutput.h	/^  double frequency_dt, prtout;$/;"	m	class:TsOutput
prtout	TsRestart.h	/^  double frequency_dt, prtout;$/;"	m	class:TsRestart
pscale	StructExc.h	/^  double pscale;$/;"	m	class:StructExc
psensor	IoData.h	/^  const char *psensor;$/;"	m	struct:TransientData
pseudoFastMarchingMethod	Domain.C	/^void Domain::pseudoFastMarchingMethod(DistVec<int> &Tag, DistSVec<double,3> &X, $/;"	f	class:Domain
pseudoFastMarchingMethod	SubDomain.C	/^void SubDomain::pseudoFastMarchingMethod(Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:SubDomain
pseudoFastMarchingMethodInitialization	Edge.C	/^void EdgeSet::pseudoFastMarchingMethodInitialization(SVec<double,3>& X,$/;"	f	class:EdgeSet
pseudoInv	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
pseudoInvRhs	GappyPreprocessing.h	/^  SetOfVec pseudoInvRhs;$/;"	m	class:GappyPreprocessing
pseudoInverseMaskedSnapsTrans	GappyPreprocessing.h	/^  SetOfVec pseudoInverseMaskedSnapsTrans;$/;"	m	class:GappyPreprocessing
pseudoInverseNodes	IoData.h	/^  int pseudoInverseNodes;$/;"	m	struct:GappyConstructionData
pseudoInverseSolver	IoData.h	/^  enum PseudoInverseSolver {PSEUDO_INVERSE_SCALAPACK = 0, PSEUDO_INVERSE_LINPACK = 1} pseudoInverseSolver;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::PseudoInverseSolver
psplotmask	f77src/printmask.f	/^      subroutine psplotmask(/;"	s
pspltm	f77src/printmask.f	/^      subroutine pspltm(/;"	s
pstiff	DistTimeState.h	/^  double pstiff;$/;"	m	class:DistTimeState
pt	IoData.h	/^  PitchingData pt;$/;"	m	struct:ForcedData
pt_max	IoData.h	/^  double pt_max;$/;"	m	struct:ClippingData
pt_min	IoData.h	/^  double pt_min;$/;"	m	struct:ClippingData
ptmax	DynamicLESTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicLESTerm
ptmax	DynamicVMSTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicVMSTerm
ptmin	DynamicLESTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicLESTerm
ptmin	DynamicVMSTerm.h	/^  double csmax, ptmin, ptmax;$/;"	m	class:DynamicVMSTerm
ptr	Connectivity.h	/^  int *ptr() { return pointer; }$/;"	f	class:Connectivity
ptr	Edge.h	/^  int (*ptr)[2];$/;"	m	class:EdgeSet
ptr	MemoryPool.h	/^  ResizeArray<void *> ptr;$/;"	m	class:MemoryPool
ptr	parser/Assigner.h	/^    T *ptr;$/;"	m	class:ClassDouble
ptr	parser/Assigner.h	/^    T *ptr;$/;"	m	class:ClassInt
ptr	parser/Assigner.h	/^    T *ptr;$/;"	m	class:ClassToken
ptr	parser/Assigner.h	/^   int *ptr;$/;"	m	class:SysTokenObj
ptr	parser/Assigner.h	/^  T *ptr;$/;"	m	class:ClassArray
ptr	parser/Assigner.h	/^  T *ptr;$/;"	m	class:ClassStr
ptr	parser/ParseTree.h	/^  T *ptr;$/;"	m	class:ClassParseTree
ptr_ii	RectangularSparseMatrix.h	/^  Vec<int> ptr_ii;          \/\/ pointer to diagonal elmenents$/;"	m	class:RectangularSparseMat
ptr_ii	SparseMatrix.h	/^  Vec<int> ptr_ii;          \/\/ pointer to diagonal elmenents$/;"	m	class:SparseMat
ptr_ij	RectangularSparseMatrix.h	/^  Vec<int> ptr_ij;          \/\/ pointer to off diagonal elements$/;"	m	class:RectangularSparseMat
ptr_ij	SparseMatrix.h	/^  Vec<int> ptr_ij;          \/\/ pointer to off diagonal elements$/;"	m	class:SparseMat
ptr_ji	RectangularSparseMatrix.h	/^  Vec<int> ptr_ji;          \/\/ pointer to off diagonal elements$/;"	m	class:RectangularSparseMat
ptr_ji	SparseMatrix.h	/^  Vec<int> ptr_ji;          \/\/ pointer to off diagonal elements$/;"	m	class:SparseMat
pttrf	arpack++/include/lapackc.h	/^inline void pttrf(const ARint &n, double d[], double e[], ARint &info) {$/;"	f
pttrf	arpack++/include/lapackc.h	/^inline void pttrf(const ARint &n, float d[], float e[], ARint &info) {$/;"	f
pttrs	arpack++/include/lapackc.h	/^inline void pttrs(const ARint &n, const ARint &nrhs,$/;"	f
purelyPhantom	FSI/CrackingSurface.cpp	/^bool CrackingSurface::purelyPhantom(int trId)$/;"	f	class:CrackingSurface
purelyPhantomPhysBAM	FSI/CrackingSurface.cpp	/^bool CrackingSurface::purelyPhantomPhysBAM(int trId)$/;"	f	class:CrackingSurface
purelyPhantomPhysBAM	PhysBAM_Interface/LOCAL_LEVELSET.h	/^  virtual bool purelyPhantomPhysBAM(int trId) {$/;"	f	class:LocalLevelSet
put	Communicator.C	/^  void Window<Scalar>::put(Scalar *a, int locOff, int size, int prNum, int remOff) {$/;"	f	class:Communication::Window
q	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^    QUATERNION<T> q;$/;"	m	class:PhysBAM::ROTATION
qOrder	IoData.h	/^  int qOrder; \/\/ order of quadrature rule used for EMBEDDED_SURFACE forceAlg$/;"	m	struct:EmbeddedFramework
qloc	Quadrature.h	/^    double (*qloc)[3]; \/\/ location of quadrature points$/;"	m	class:Quadrature
qr	NonlinearRom.C	/^void NonlinearRom<dim>::qr(VecSet< DistSVec<double, dim> >* Q, std::vector<std::vector<double> >* RT, bool testQR) {$/;"	f	class:NonlinearRom
quad2tria	FSI/CrackingSurface.h	/^  int (*quad2tria)[2]; \/\/size: nTotalQuads$/;"	m	class:CrackingSurface
queryAuxilliaryRow	MvpMatrix.h	/^  Scalar* queryAuxilliaryRow(AuxilliaryRows& A, int i, int j) {$/;"	f	class:MvpMat
queryGhostGhostElem_ij	GenMatrix.h	/^  virtual Scalar* queryGhostGhostElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
queryGhostGhostElem_ij	MvpMatrix.h	/^  Scalar* queryGhostGhostElem_ij(int i,int j) {$/;"	f	class:MvpMat
queryGhostNodeElem_ij	GenMatrix.h	/^  virtual Scalar* queryGhostNodeElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
queryGhostNodeElem_ij	MvpMatrix.h	/^  Scalar* queryGhostNodeElem_ij(int i,int j) {$/;"	f	class:MvpMat
queryRealNodeElem_ij	GenMatrix.h	/^  virtual Scalar* queryRealNodeElem_ij(int i,int j) { return NULL; }$/;"	f	class:GenMat
queryRealNodeElem_ij	MvpMatrix.h	/^  Scalar* queryRealNodeElem_ij(int i,int j) {$/;"	f	class:MvpMat
queryTimeStep	MultiGridOperator.C	/^double MultiGridOperator<Scalar,dim>::queryTimeStep(int iSub, int i) {$/;"	f	class:MultiGridOperator
r	Extrapolation.h	/^  double r;$/;"	m	struct:ExtrapolationNodeData
r	IoData.h	/^  double cen_x, cen_y, cen_z, nx, ny, nz, r, L;$/;"	m	struct:CylinderData
r	IoData.h	/^  double r;$/;"	m	struct:SFixData
r	KspSolver.h	/^  VecType dx, r;$/;"	m	class:RichardsonSolver
r	KspSolver.h	/^  VecType r, Ap, y, p;$/;"	m	class:CgSolver
r	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
r	KspSolver.h	/^  VecType w, r;$/;"	m	class:GmresSolver
r	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    ROTATION<TV> r; \/\/ defaults to 1$/;"	m	class:PhysBAM::FRAME
r	V6NodeData.h	/^  double r;$/;"	m	struct:V6NodeData
r	arpack++/include/arlcomp.h	/^typedef struct { double r, i; } ldcomplex;$/;"	m	struct:__anon30
r	arpack++/include/arlcomp.h	/^typedef struct { float r, i; } lscomplex;$/;"	m	struct:__anon31
r0	IoData.h	/^  double r0;$/;"	m	struct:CFixData
r1	IoData.h	/^  double r1;$/;"	m	struct:CFixData
r8_huge	Dunavant.C	/^double r8_huge ( )$/;"	f
r8_nint	Dunavant.C	/^int r8_nint ( double x )$/;"	f
rMatrixFile	IoData.h	/^  const char *rMatrixFile;$/;"	m	struct:TransientData
rSVD	NonlinearRom.C	/^void NonlinearRom<dim>::rSVD(VecSet< DistSVec<double, dim> >& Utrue, std::vector<double>& singularValues, FullM& Vtrue, bool testSVD) {$/;"	f	class:NonlinearRom
rSVDWrapper	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::rSVDWrapper(VecSet< DistSVec<double, dim> >*& snapshots, VecSet< DistSVec<double, dim> > &Utrue,$/;"	f	class:NonlinearRomDatabaseConstruction
rTol	NonlinearRom.h	/^  double rTol;$/;"	m	class:NonlinearRom
rV	VarFcnBase.h	/^  virtual void rV(IoData &iod) { pmin = iod.eqs.fluidModel.pmin; }$/;"	f	class:VarFcnBase
rad	OneDimensionalSolver.h	/^    double rad;$/;"	m	class:OneDimensional::Veval
radius	IoData.h	/^  double cen_x, cen_y, cen_z, radius;$/;"	m	struct:SphereData
randMatDimension	IoData.h	/^  int randMatDimension;$/;"	m	struct:DataCompressionData
randMatDimension	IoData.h	/^  int randMatDimension;$/;"	m	struct:GappyConstructionData
randMatDimension	IoData.h	/^  int randMatDimension;$/;"	m	struct:NonlinearRomOnlineData
randVec	DistVector.h	/^DistSVec<Scalar,dim>::randVec()$/;"	f	class:DistSVec
random_number_generator	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.h	/^    GENERATOR random_number_generator;$/;"	m	class:PhysBAM::RANDOM_NUMBERS
range	IoData.h	/^  Range *range;$/;"	m	struct:SparseGridData
range	SparseGrid.h	/^  Range *range;           \/\/ range of the tabulation (min and max in each dir)$/;"	m	class:SparseGrid
range1max	IoData.h	/^  double range1min, range1max, mapBaseValue1; int numDomainDim1;$/;"	m	struct:SparseGridData
range1min	IoData.h	/^  double range1min, range1max, mapBaseValue1; int numDomainDim1;$/;"	m	struct:SparseGridData
range2max	IoData.h	/^  double range2min, range2max, mapBaseValue2; int numDomainDim2;$/;"	m	struct:SparseGridData
range2min	IoData.h	/^  double range2min, range2max, mapBaseValue2; int numDomainDim2;$/;"	m	struct:SparseGridData
range3max	IoData.h	/^  double range3min, range3max, mapBaseValue3; int numDomainDim3;$/;"	m	struct:SparseGridData
range3min	IoData.h	/^  double range3min, range3max, mapBaseValue3; int numDomainDim3;$/;"	m	struct:SparseGridData
range4max	IoData.h	/^  double range4min, range4max, mapBaseValue4; int numDomainDim4;$/;"	m	struct:SparseGridData
range4min	IoData.h	/^  double range4min, range4max, mapBaseValue4; int numDomainDim4;$/;"	m	struct:SparseGridData
range5max	IoData.h	/^  double range5min, range5max, mapBaseValue5; int numDomainDim5;$/;"	m	struct:SparseGridData
range5min	IoData.h	/^  double range5min, range5max, mapBaseValue5; int numDomainDim5;$/;"	m	struct:SparseGridData
range6max	IoData.h	/^  double range6min, range6max, mapBaseValue6; int numDomainDim6;$/;"	m	struct:SparseGridData
range6min	IoData.h	/^  double range6min, range6max, mapBaseValue6; int numDomainDim6;$/;"	m	struct:SparseGridData
rank	AlternatingLeastSquare/als_lapack.h	/^    int rank;$/;"	m	class:AlternatingLeastSquare
ranks	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/UNION_FIND.h	/^    ARRAY<T_RANK,ID> ranks; $/;"	m	class:PhysBAM::UNION_FIND
rapidDensityThreshold	IoData.h	/^  double rapidDensityThreshold;$/;"	m	struct:TsData
rapidPressureThreshold	IoData.h	/^  double rapidPressureThreshold;$/;"	m	struct:TsData
rapiddchangecutoff	TsParameters.h	/^  int rapiddchangecutoff;$/;"	m	class:TsParameters
rapidpchangecutoff	TsParameters.h	/^  int rapidpchangecutoff;$/;"	m	class:TsParameters
rarefactionGAS	LocalRiemann.h	/^void LocalRiemannGfmpar::rarefactionGAS(double phi,$/;"	f	class:LocalRiemannGfmpar
rarefactionJWL	LocalRiemann.h	/^int LocalRiemannGfmpar::rarefactionJWL(double phi,$/;"	f	class:LocalRiemannGfmpar
rarefactionJWLderivs	LocalRiemann.h	/^int LocalRiemannGfmpar::rarefactionJWLderivs(double phi,$/;"	f	class:LocalRiemannGfmpar
rarefactionTAIT	LocalRiemann.h	/^void LocalRiemannGfmpar::rarefactionTAIT(double phi,$/;"	f	class:LocalRiemannGfmpar
ratioTimesPhi	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dimLS> ratioTimesPhi;$/;"	m	class:ExplicitLevelSetTsDesc
ratioTimesU	ExplicitLevelSetTsDesc.h	/^  DistSVec<double,dim> ratioTimesU;$/;"	m	class:ExplicitLevelSetTsDesc
ratioTimesU	ExplicitTsDesc.h	/^  DistSVec<double,dim> ratioTimesU;$/;"	m	class:ExplicitTsDesc
ray	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY.h	/^    RAY<TV>& ray;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY
ray	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION.h	/^    RAY<TV>& ray;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT_ON_A_RAY_SECONDARY_INTERPOLATION
rcvChannel	MultiGridLevel.h	/^    inline int rcvChannel(int glSub,int neighb) const {$/;"	f	class:MultiGridLevel
rcvChannel	SubDomain.h	/^  int *rcvChannel;$/;"	m	class:SubDomain
rcvConnect	Communicator.h	/^  Connectivity *rcvConnect;$/;"	m	class:CommPattern
rcvEdgeData	SubDomainCore.C	/^void SubDomain::rcvEdgeData(CommPattern<double> &edgePat, double *edgeData)$/;"	f	class:SubDomain
rcvEdgeInfo	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::rcvEdgeInfo(CommPattern<int> &edgeNumPat,int mySub,int dim)$/;"	f	class:MultiGridLevel
rcvEdgeInfo	SubDomainCore.C	/^void SubDomain::rcvEdgeInfo(CommPattern<int> &edgeNumPat)$/;"	f	class:SubDomain
rcvGhostStates	SubDomain.C	/^void SubDomain::rcvGhostStates(CommPattern<double> &sp, Vec<GhostPoint<dim>*> &ghostPoints, int shift)$/;"	f	class:SubDomain
rcvGhostTags	SubDomain.C	/^void SubDomain::rcvGhostTags(CommPattern<int> &sp, Vec<GhostPoint<dim>*> &ghostPoints)$/;"	f	class:SubDomain
rcvGhostWeights	SubDomain.C	/^void SubDomain::rcvGhostWeights(CommPattern<double> &sp, Vec<GhostPoint<dim>*> &ghostPoints, int shift)$/;"	f	class:SubDomain
rcvNormals	SubDomainCore.C	/^void SubDomain::rcvNormals(CommPattern<double> &edgePat, Vec3D *edgeNorm,$/;"	f	class:SubDomain
rcvNumGhostStates	SubDomain.C	/^void SubDomain::rcvNumGhostStates(CommPattern<int> &sp, Vec<GhostPoint<dim>*> &ghostPoints, VarFcn *varFcn)$/;"	f	class:SubDomain
re	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/COMPLEX.h	/^    T re,im;$/;"	m	class:PhysBAM::COMPLEX
reFlagRealNodes	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::reFlagRealNodes(SVec<double,3>& X, Vec<bool> &ISactive_bk)$/;"	f	class:IntersectorFRG
reFlagRealNodes	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::reFlagRealNodes(SVec<double,3>& X, Vec<bool> *bk_isActive)$/;"	f	class:IntersectorPhysBAM
reSolve	DenseMatrix.C	/^GenFullM<Scalar>::reSolve(double *x)$/;"	f	class:GenFullM
reSolve	DenseMatrix.C	/^void SymFullM<Scalar>::reSolve(double *x)$/;"	f	class:SymFullM
read	BCond.C	/^void BCondSet::read(BinFileHandler &file)$/;"	f	class:BCondSet
read	BinFileHandler.h	/^void BinFileHandler::read(Scalar *p, int nobjs)$/;"	f	class:BinFileHandler
read	ElemCore.C	/^int ElemSet::read(BinFileHandler &file, int numRanges, int (*ranges)[2], int *elemMap,$/;"	f	class:ElemSet
read	FaceCore.C	/^int FaceSet::read(BinFileHandler &file, int numRanges, int (*ranges)[2], int *map)$/;"	f	class:FaceSet
read	MatchNodeCore.C	/^void MatchNodeSet::read(BinFileHandler &file, int numRanges, int (*ranges)[2]) $/;"	f	class:MatchNodeSet
read	Node.C	/^int NodeSet::read(BinFileHandler &file, int numRanges, int (*ranges)[2], $/;"	f	class:NodeSet
read1DSolution	OneDimensionalSolver.C	/^void OneDimensional::read1DSolution(IoData& iod, DistSVec<double,dimp>& Up, $/;"	f	class:OneDimensional
read1DSolution	OneDimensionalSolver.h	/^  static void read1DSolution(IoData& iod, const char* filename, DistSVec<double,dimp>& Up, $/;"	f	class:OneDimensional
readAllClusteredOfflineQuantities	NonlinearRom.C	/^void NonlinearRom<dim>::readAllClusteredOfflineQuantities() {$/;"	f	class:NonlinearRom
readAllClusteredOnlineQuantities	NonlinearRom.C	/^void NonlinearRom<dim>::readAllClusteredOnlineQuantities() {$/;"	f	class:NonlinearRom
readApproxMetricStateLowRankFactor	NonlinearRom.C	/^void NonlinearRom<dim>::readApproxMetricStateLowRankFactor(const char* sampledOrFull) {$/;"	f	class:NonlinearRom
readBasisFiles	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::readBasisFiles(VecSet<DistSVec<double, dim> >& U) {$/;"	f	class:EmbeddedAlternatingLeastSquare
readCenterNorms	NonlinearRom.C	/^void NonlinearRom<dim>::readCenterNorms() {$/;"	f	class:NonlinearRom
readClosestCenterInfoModelII	NonlinearRomOnlineII.C	/^void NonlinearRomOnlineII<dim>::readClosestCenterInfoModelII() {$/;"	f	class:NonlinearRomOnlineII
readClosestCenterInfoModelIII	NonlinearRomOnlineIII.C	/^void NonlinearRomOnlineIII<dim>::readClosestCenterInfoModelIII() {$/;"	f	class:NonlinearRomOnlineIII
readClusterCenters	NonlinearRom.C	/^void NonlinearRom<dim>::readClusterCenters(const char* centersType) {$/;"	f	class:NonlinearRom
readClusteredBasis	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredBasis(int iCluster, const char* basisType, bool relProjError) {$/;"	f	class:NonlinearRom
readClusteredColumnSumsV	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredColumnSumsV(int iCluster, const char* basisType) {$/;"	f	class:NonlinearRom
readClusteredGappyMatrix	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredGappyMatrix(int iCluster, const char* matrixType) {$/;"	f	class:NonlinearRom
readClusteredInfoASCII	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredInfoASCII(int iCluster, const char* type, std::vector<double>* vec1,$/;"	f	class:NonlinearRom
readClusteredNonlinearMetric	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredNonlinearMetric(int iCluster) {$/;"	f	class:NonlinearRom
readClusteredOnlineQuantities	NonlinearRom.h	/^  virtual void readClusteredOnlineQuantities(int) {};$/;"	f	class:NonlinearRom
readClusteredOnlineQuantities	NonlinearRomOnlineII.C	/^void NonlinearRomOnlineII<dim>::readClusteredOnlineQuantities(int iCluster) {$/;"	f	class:NonlinearRomOnlineII
readClusteredOnlineQuantities	NonlinearRomOnlineIII.C	/^void NonlinearRomOnlineIII<dim>::readClusteredOnlineQuantities(int iCluster) {$/;"	f	class:NonlinearRomOnlineIII
readClusteredReferenceState	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredReferenceState(int iCluster, const char* refType) {$/;"	f	class:NonlinearRom
readClusteredSampleNodes	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredSampleNodes(int iCluster, const char* sampledOrFull, bool deleteExistingRestrictionMapping) {$/;"	f	class:NonlinearRom
readClusteredSnapshots	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredSnapshots(int iCluster, bool preprocess, const char *basisType, int first, int last, bool snapshotsAlreadyStored) {$/;"	f	class:NonlinearRom
readClusteredUpdateInfo	NonlinearRom.C	/^void NonlinearRom<dim>::readClusteredUpdateInfo(int iCluster, const char* basisType) {$/;"	f	class:NonlinearRom
readCmdFile	IoDataCore.C	/^void IoData::readCmdFile()$/;"	f	class:IoData
readCmdLine	IoDataCore.C	/^void IoData::readCmdLine(int argc, char** argv)$/;"	f	class:IoData
readConnectivityInfo	GeoSource.C	/^void GeoSource::readConnectivityInfo(Communicator *com)$/;"	f	class:GeoSource
readCpuToSub	GeoSource.C	/^void GeoSource::readCpuToSub()$/;"	f	class:GeoSource
readCrackingData	FSI/CrackingSurface.cpp	/^readCrackingData(std::ifstream& restart_file) {$/;"	f	class:PhantomElement
readCrackingData	FSI/CrackingSurface.cpp	/^void CrackingSurface::readCrackingData(std::ifstream& restart_file) {$/;"	f	class:CrackingSurface
readCrackingData	FSI/DynamicNodalTransfer.cpp	/^void DynamicNodalTransfer::readCrackingData(std::ifstream& restart_file) {$/;"	f	class:DynamicNodalTransfer
readCrackingData	FSI/DynamicNodalTransfer.cpp	/^void EmbeddedStructure::readCrackingData(std::ifstream& restart_file){$/;"	f	class:EmbeddedStructure
readDistanceComparisonInfo	NonlinearRom.C	/^void NonlinearRom<dim>::readDistanceComparisonInfo(const char* updateType) {$/;"	f	class:NonlinearRom
readEigenValuesAndVectors	DomainCore.C	/^void Domain::readEigenValuesAndVectors(const char *eigFile, double &realEigV, double &imagEigV, double &normalizationTerm, int &iEV, $/;"	f	class:Domain
readExactUpdateInfo	NonlinearRom.C	/^void NonlinearRom<dim>::readExactUpdateInfo() {$/;"	f	class:NonlinearRom
readFromFile	SparseGridClusterCore.C	/^void SparseGridCluster::readFromFile(const int numFiles, $/;"	f	class:SparseGridCluster
readFromFile	SparseGridCore.C	/^void SparseGrid::Heap::readFromFile(FILE *file){$/;"	f	class:SparseGrid::Heap
readFromFile	SparseGridCore.C	/^void SparseGrid::readFromFile(const double *refIn, const double *refOut, $/;"	f	class:SparseGrid
readGreedyData	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::readGreedyData(int iCluster, bool& breakloop) {$/;"	f	class:GappyPreprocessing
readICFromDisk	TsDesc.C	/^void TsDesc<dim>::readICFromDisk(char * solnFile, int iData, int nData, DistSVec<double,dim> &U) {$/;"	f	class:TsDesc
readInitialCondition	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::readInitialCondition() {$/;"	f	class:NonlinearRomDatabaseConstruction
readInterpMatrix	DomainCore.C	/^void Domain::readInterpMatrix(const char *interpMatrixFile, int &dimInterpMat, FullM &interpMat) { \/\/ for Gappy Pod$/;"	f	class:Domain
readInterpNode	DomainCore.C	/^void Domain::readInterpNode(const char *interpNodeFile, int &nIntNodes, int *&globalSubSet, int *&locNodeSet) { \/\/ for Gappy Pod$/;"	f	class:Domain
readMultiVecASCII	NonlinearRom.C	/^void NonlinearRom<dim>::readMultiVecASCII(char* path, std::vector<double>* vec1,$/;"	f	class:NonlinearRom
readNearestSnapsToCenters	NonlinearRom.C	/^void NonlinearRom<dim>::readNearestSnapsToCenters() {$/;"	f	class:NonlinearRom
readNonClusteredUpdateInfo	NonlinearRom.C	/^void NonlinearRom<dim>::readNonClusteredUpdateInfo(const char* sampledOrFull) {$/;"	f	class:NonlinearRom
readPodVecs	Modal.C	/^void ModalSolver<dim>::readPodVecs(VecSet<DistSVec<Scalar, dim> > &podVecs,$/;"	f	class:ModalSolver
readProjectionInfo	NonlinearRom.C	/^void NonlinearRom<dim>::readProjectionInfo() {$/;"	f	class:NonlinearRom
readReducedNodes	ReducedMeshShapeChanger.C	/^void ReducedMeshShapeChanger<dim>::readReducedNodes(const char *reducedNodeFileName)  {$/;"	f	class:ReducedMeshShapeChanger
readReferenceState	NonlinearRom.C	/^void NonlinearRom<dim>::readReferenceState() {$/;"	f	class:NonlinearRom
readReferenceStateFiles	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::readReferenceStateFiles(DistSVec<double, dim>& U) {$/;"	f	class:EmbeddedAlternatingLeastSquare
readRestartFileNames	TsRestartCore.C	/^void TsRestart::readRestartFileNames(const char* fn,$/;"	f	class:TsRestart
readSampleNodes	NonlinearRom.C	/^void NonlinearRom<dim>::readSampleNodes(int iCluster, const char* sampledOrFull, bool deleteExistingRestrictionMapping) {$/;"	f	class:NonlinearRom
readSnapshotFile	Timer.h	/^		eulerFSI, embedforce, walldistance, lsreinitialization, readSnapshotFile,$/;"	e	enum:Timer::TimerIndex
readSnapshotFiles	NonlinearRom.C	/^int NonlinearRom<dim>::readSnapshotFiles(const char* snapType, bool preprocess) {$/;"	f	class:NonlinearRom
readSnapshotsFilesHelper	EmbeddedAlternatingLeastSquare.C	/^int EmbeddedAlternatingLeastSquare<dim>::readSnapshotsFilesHelper(char *keyword, bool preprocess) {$/;"	f	class:EmbeddedAlternatingLeastSquare
readStateMaskFile	EmbeddedAlternatingLeastSquare.C	/^int EmbeddedAlternatingLeastSquare<dim>::readStateMaskFile() {$/;"	f	class:EmbeddedAlternatingLeastSquare
readTagFromFile	Domain.C	/^bool Domain::readTagFromFile(const char *prefix, int step, double *tag, int *numSteps)$/;"	f	class:Domain
readTagFromFile	SubDomain.C	/^double SubDomain::readTagFromFile(const char *prefix, int no, int *neq, int *nsol)$/;"	f	class:SubDomain
readVectorFromFile	Domain.C	/^bool Domain::readVectorFromFile(const char *prefix, int step, double *tag,$/;"	f	class:Domain
readVectorFromFile	SubDomain.C	/^void SubDomain::readVectorFromFile(const char *prefix, int no, Vec<Scalar> &U) {$/;"	f	class:SubDomain
readVectorFromFile	SubDomain.C	/^void SubDomain::readVectorFromFile(const char *prefix, int no, int neq,$/;"	f	class:SubDomain
readWriteTopFile	ReducedMeshShapeChanger.C	/^void ReducedMeshShapeChanger<dim>::readWriteTopFile(const char *inputTopFileName)  {$/;"	f	class:ReducedMeshShapeChanger
real	DistEmbeddedVector.h	/^    Scalar real(int iSub,int i,int k) const { return a*x.real(iSub,i,k); }$/;"	f	class:EmbeddedScaleExpr
real	DistEmbeddedVector.h	/^    Scalar real(int iSub,int i,int k) const { return x.real(iSub,i,k) + y.real(iSub,i,k) ; }$/;"	f	class:EmbeddedSumExpr
real	DistEmbeddedVector.h	/^    Scalar real(int iSub,int i,int k) const { return x.real(iSub,i,k) - y.real(iSub,i,k) ; }$/;"	f	class:EmbeddedDiffExpr
real	DistEmbeddedVector.h	/^    Scalar real(int iSub,int i,int k) const { return x.real(iSub,i,k); }$/;"	f	class:EmbeddedExpr
real	DistEmbeddedVector.h	/^  DistSVec<Scalar,dim>& real() { return realVec; }$/;"	f	class:DistEmbeddedVec
real	DistEmbeddedVector.h	/^  Scalar real(int iSub,int i,int k) const { return realVec.subData(iSub)[i][k]; }$/;"	f	class:DistEmbeddedVec
realAuxilliaryRows	MvpMatrix.h	/^  AuxilliaryRows realAuxilliaryRows;$/;"	m	class:MvpMat
realVec	DistEmbeddedVector.h	/^  DistSVec<Scalar,dim> realVec,ghostVec;$/;"	m	class:DistEmbeddedVec
rebind	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^   struct rebind$/;"	s	struct:PhysBAM::IS_CONVERTIBLE_IMPL_SELECT
rebuildPhysBAMInterface	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::rebuildPhysBAMInterface(Vec3D *Xs, int nsNodes, int (*sElem)[3], int nsElems)$/;"	f	class:IntersectorFRG
recConstant	MultiGridSpaceOperator.h	/^  RecFcnConstant<dim> recConstant;$/;"	m	class:MultiGridSpaceOperator
recData	Communicator.C	/^CommPattern<T>::recData(int channel)$/;"	f	class:CommPattern
recFcn	OneDimensionalSolver.h	/^  RecFcn* recFcn, *recFcnLS;$/;"	m	class:OneDimensional
recFcn	SpaceOperator.h	/^  RecFcn *recFcn;$/;"	m	class:SpaceOperator
recFcnAA	SpaceOperator.h	/^  RecFcn *recFcnAA;$/;"	m	class:SpaceOperator
recFcnCon	MatVecProd.h	/^  RecFcnConstant<dim> *recFcnCon;$/;"	m	class:MatVecProdFD
recFcnLS	OneDimensionalSolver.h	/^  RecFcn* recFcn, *recFcnLS;$/;"	m	class:OneDimensional
recFcnLS	SpaceOperator.h	/^  RecFcn *recFcnLS;$/;"	m	class:MultiPhaseSpaceOperator
recFcnSA	SpaceOperator.h	/^  RecFcn *recFcnSA;$/;"	m	class:SpaceOperator
recFrom	Communicator.C	/^RecInfo Communicator::recFrom(int cpu, int tag, Scalar *buffer, int len)$/;"	f	class:Communicator
recFrom	Communicator.C	/^RecInfo Communicator::recFrom(int tag, Scalar *buffer, int len)$/;"	f	class:Communicator
recParity	StructExc.h	/^  int recParity;$/;"	m	class:StructExc
receiveBoundaryPositionSensitivityVector	TsDesc.C	/^void TsDesc<dim>::receiveBoundaryPositionSensitivityVector(DistSVec<double,3> &dXdSb, bool applyScale)$/;"	f	class:TsDesc
recompute	IntersectorFRG/IntersectorFRG.C	/^int DistIntersectorFRG::recompute(double dtf, double dtfLeft, double dts, bool findStatus, bool retry) $/;"	f	class:DistIntersectorFRG
recompute	IntersectorPhysBAM/IntersectorPhysBAM.C	/^int DistIntersectorPhysBAM::recompute(double dtf, double dtfLeft, double dts, bool findStatus, bool retry) $/;"	f	class:DistIntersectorPhysBAM
recompute	LevelSet/MultiGridLevelSetStructure.C	/^recompute() {$/;"	f	class:MultiGridLevelSetStructure
recompute	LevelSet/MultiGridLevelSetStructure.C	/^recompute(double dtf, double dtfLeft, double dts, bool findStatus, bool retry) {$/;"	f	class:DistMultiGridLevelSetStructure
recomputeConnectedTopology	RestrictionMapping.C	/^void RestrictionMapping<dim>::recomputeConnectedTopology() {$/;"	f	class:RestrictionMapping
recomputeDistanceCloseNodes	Elem.C	/^void ElemSet::recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemSet
recomputeDistanceCloseNodes	Elem.h	/^  void recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:Elem
recomputeDistanceCloseNodes	Elem.h	/^  void recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemDummy
recomputeDistanceCloseNodes	Elem.h	/^  void recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemWrapper_dim
recomputeDistanceCloseNodes	ElemTet.C	/^void ElemTet::recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:ElemTet
recomputeDistanceCloseNodes	SubDomain.C	/^void SubDomain::recomputeDistanceCloseNodes(int lsdim, Vec<int> &Tag, SVec<double,3> &X,$/;"	f	class:SubDomain
recomputeDistanceToInterface	ElemTet.C	/^void ElemTet::recomputeDistanceToInterface(int type, SVec<double,3> &X, int reorder[4],$/;"	f	class:ElemTet
recomputeFunction	ImplicitEmbeddedRomTsDesc.h	/^    void recomputeFunction(DistSVec<double, dim> &Q, DistSVec<double, dim> &rhs){ super::recomputeFunction(Q, rhs); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
recomputeFunction	ImplicitEmbeddedTsDesc.C	/^void ImplicitEmbeddedTsDesc<dim>::recomputeFunction(DistSVec<double,dim> &Q,$/;"	f	class:ImplicitEmbeddedTsDesc
recomputeFunction	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::recomputeFunction(DistSVec<double,dim> &Q,$/;"	f	class:ImplicitLevelSetTsDesc
recomputeFunction	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::recomputeFunction(DistSVec<double,dim> &Q,$/;"	f	class:ImplicitMultiPhysicsTsDesc
recomputeFunction	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::recomputeFunction(DistSVec<double,dim> &Q,$/;"	f	class:ImplicitTsDesc
recomputeFunction	MeshMotionSolver.h	/^  void recomputeFunction(DistSVec<double,3> &, DistSVec<double,3> &) {}$/;"	f	class:TetMeshMotionSolver
recomputeIntersections	EmbeddedTsDesc.h	/^  bool recomputeIntersections;$/;"	m	class:EmbeddedTsDesc
recomputeIntersections	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::recomputeIntersections()$/;"	f	class:ExplicitMultiPhysicsTsDesc
recomputeRHS	Domain.C	/^void Domain::recomputeRHS(VarFcn* vf, DistSVec<double,dim> &V, DistSVec<double,dim> &rhs,$/;"	f	class:Domain
recomputeRHS	Domain.C	/^void Domain::recomputeRHS(VarFcn* vf, DistSVec<double,dim> &V, DistVec<int> &fluidId,$/;"	f	class:Domain
recomputeRHS	InletNode.C	/^void InletNodeSet::recomputeRHS(VarFcn* vf, Extrapolation<dim>* xpol, ElemSet &elems, SVec<double,dim>&V,$/;"	f	class:InletNodeSet
recomputeRHS	SpaceOperator.C	/^void SpaceOperator<dim>::recomputeRHS(DistSVec<double,3> &X, DistSVec<double,dim> &U,$/;"	f	class:SpaceOperator
recomputeRHS	SubDomain.C	/^void SubDomain::recomputeRHS(VarFcn* vf, SVec<double,dim>& V, SVec<double,dim>& rhs,$/;"	f	class:SubDomain
recomputeRHS	SubDomain.C	/^void SubDomain::recomputeRHS(VarFcn* vf, SVec<double,dim>& V, Vec<int> &fluidId,$/;"	f	class:SubDomain
recomputeResidual	Domain.C	/^double Domain::recomputeResidual(DistSVec<double,dim> &F, DistSVec<double,dim> &Finlet)$/;"	f	class:Domain
recomputeResidual	ImplicitEmbeddedRomTsDesc.h	/^    void recomputeResidual(DistSVec<double, dim> &F, DistSVec<double, dim> &Finlet) { super::recomputeResidual(F, Finlet); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
recomputeResidual	InletNode.C	/^void InletNodeSet::recomputeResidual(SVec<double,dim> &F,SVec<double,dim> &Finlet)$/;"	f	class:InletNodeSet
recomputeResidual	MeshMotionSolver.h	/^  double recomputeResidual(DistSVec<double,3> &, DistSVec<double,3> &) { return 0.0; }$/;"	f	class:TetMeshMotionSolver
recomputeResidual	SpaceOperator.C	/^double SpaceOperator<dim>::recomputeResidual(DistSVec<double,dim> &F, DistSVec<double,dim> &Finlet)$/;"	f	class:SpaceOperator
recomputeResidual	SubDomain.C	/^void SubDomain::recomputeResidual(SVec<double,dim> &F, SVec<double,dim> &Finlet)$/;"	f	class:SubDomain
recomputeResidual	TsDesc.C	/^double TsDesc<dim>::recomputeResidual(DistSVec<double,dim> &F, DistSVec<double,dim> &Finlet)$/;"	f	class:TsDesc
reconstruct	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruct;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::Reconstruction
reconstruct	RTree.h	/^	  void reconstruct(SVec<double,3>& X,T** objects, int num) $/;"	f	class:RTree
reconstruction	IoData.h	/^  enum Reconstruction {CONSTANT = 0, EXACT_RIEMANN = 1} reconstruction;$/;"	m	struct:BcsWallData	typeref:enum:BcsWallData::Reconstruction
reconstruction	IoData.h	/^  enum Reconstruction {CONSTANT = 0, LINEAR = 1} reconstruction;$/;"	m	struct:SchemeData	typeref:enum:SchemeData::Reconstruction
reconstructionAA	SpaceOperator.h	/^  int reconstructionAA;$/;"	m	class:SpaceOperator
reconstructionSA	SpaceOperator.h	/^  int reconstructionSA;$/;"	m	class:SpaceOperator
reduce	GhostPoint.h	/^  void reduce()$/;"	f	class:GhostPoint
reduceError	ErrorHandler.h	/^  void reduceError(){ $/;"	f	struct:ErrorHandler
reduceGhostPoints	SubDomain.C	/^void SubDomain::reduceGhostPoints(Vec<GhostPoint<dim>*> &ghostPoints, SVec<double,3> &X)$/;"	f	class:SubDomain
reducedBasis	ImplicitEmbeddedRomTsDesc.h	/^    VecSet<DistSVec<double, dim> > reducedBasis;$/;"	m	class:ImplicitEmbeddedRomTsDesc
reducedCoords	IoData.h	/^  const char *reducedCoords;  \/\/ generalized coords$/;"	m	struct:ROMOutputData
reducedCoords	IoData.h	/^  const char *reducedCoords;$/;"	m	struct:InputData
reducedCoordsFile	ImplicitRomPostproTsDesc.h	/^	FILE *reducedCoordsFile;	\/\/ file of reduced coordinates$/;"	m	class:ImplicitRomPostproTsDesc
reducedCoordsFile	NonlinearRom.h	/^  FILE* reducedCoordsFile;$/;"	m	class:NonlinearRom
reducedDimension	EmbeddedAlternatingLeastSquare.h	/^    int reducedDimension;$/;"	m	class:EmbeddedAlternatingLeastSquare
reducedDimension	ImplicitEmbeddedRomTsDesc.h	/^    int reducedDimension;$/;"	m	class:ImplicitEmbeddedRomTsDesc
reducedEigState	IoData.h	/^  const char *reducedEigState;$/;"	m	struct:InputData
reducedJacobian	ImplicitEmbeddedRomTsDesc.h	/^    VecSet<DistSVec<double, dim> > reducedJacobian;$/;"	m	class:ImplicitEmbeddedRomTsDesc
reducedNewtonDirection	ImplicitEmbeddedRomTsDesc.h	/^    Vec<double> reducedNewtonDirection;$/;"	m	class:ImplicitEmbeddedRomTsDesc
reducedSampleNodeRankMap	GappyPreprocessing.h	/^	boost::unordered_map<int, int > globalSampleNodeRankMap, reducedSampleNodeRankMap;$/;"	m	class:GappyPreprocessing
reducedSampleNodes	GappyPreprocessing.h	/^	std::vector<int> globalSampleNodes, reducedSampleNodes;$/;"	m	class:GappyPreprocessing
ref	IoData.h	/^  ReferenceStateData ref;$/;"	m	class:IoData
refLength	IoData.h	/^  double refLength;$/;"	m	struct:LinearizedData
refLengthSq	PostOperator.h	/^  double refLengthSq;$/;"	m	class:PostOperator
refStateCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > refStateCentersDifProduct;$/;"	m	class:NonlinearRom
refStateName	IoData.h	/^  const char *refStateName;$/;"	m	struct:NonlinearRomFilesData
refStateName	NonlinearRom.h	/^  char* refStateName;$/;"	m	class:NonlinearRom
refTime	DistTimeState.h	/^  double refTime;$/;"	m	class:DistTimeState
refVal	DistTimeState.h	/^  RefVal *refVal;$/;"	m	class:DistTimeState
refVal	OneDimensionalSolver.h	/^  RefVal refVal;$/;"	m	class:OneDimensional
refVal	TsDesc.h	/^  RefVal *refVal;$/;"	m	class:TsDesc
refVal	TsOutput.h	/^  RefVal *refVal;$/;"	m	class:TsOutput
refVal	TsRestart.h	/^  RefVal *refVal;$/;"	m	class:TsRestart
refVec	RefVector.h	/^  VecType& refVec;$/;"	m	class:RefVec
ref_length	MultiGridKernel.h	/^  double ref_length;$/;"	m	class:MultiGridKernel
ref_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef typename ADD_REFERENCE<T1>::TYPE ref_type;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_IMPL
refdensity	LocalRiemann.h	/^  double refdensity,refentropy,relaxFactorJwl;$/;"	m	class:LocalRiemannGfmpar
refentropy	LocalRiemann.h	/^  double refdensity,refentropy,relaxFactorJwl;$/;"	m	class:LocalRiemannGfmpar
referenceSolution	IoData.h	/^  const char *referenceSolution;$/;"	m	struct:InputData
referenceState	ImplicitEmbeddedRomTsDesc.h	/^    DistSVec<double, dim> referenceState;$/;"	m	class:ImplicitEmbeddedRomTsDesc
reference_to_physical_t3	Dunavant.C	/^void reference_to_physical_t3 ( double t[], int n, double ref[], double phy[] )$/;"	f
registerNodes	IntersectorFRG/IntersectorFRG.C	/^int ClosestTriangle::registerNodes(int ip1, int trId, int& repeated1, int& repeated2)$/;"	f	class:ClosestTriangle
reinitializeFluidIds	FluidSelector.C	/^void FluidSelector::reinitializeFluidIds(DistVec<int> &fsId, DistSVec<double,dim> &Phin)$/;"	f	class:FluidSelector
reinitializeFluidIdsWithCracking	FluidSelector.C	/^void FluidSelector::reinitializeFluidIdsWithCracking(DistVec<int> &fsId, DistSVec<double,dim> &Phin)$/;"	f	class:FluidSelector
reinitializeLevelSet	LevelSet.C	/^void LevelSet<dimLS>::reinitializeLevelSet(DistSVec<double,3> &X, DistSVec<double,dimLS> &Phi, bool copylv2,int lsdim)$/;"	f	class:LevelSet
reinitializeLevelSetFM	LevelSet.C	/^void LevelSet<dimLS>::reinitializeLevelSetFM(DistSVec<double,3> &X, DistSVec<double,dimLS> &Phi, bool copylv2,int lsdim)$/;"	f	class:LevelSet
reinitializeMapsForSampleNodes	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::reinitializeMapsForSampleNodes() {$/;"	f	class:GappyPreprocessing
relAccuracy	IoData.h	/^  double relAccuracy;$/;"	m	struct:SparseGridData
relAccuracy	SparseGrid.h	/^  double relAccuracy;     \/\/ required relative accuracy$/;"	m	class:SparseGrid
relProjError	IoData.h	/^  enum RelativeProjectionError {REL_PROJ_ERROR_OFF = 0, REL_PROJ_ERROR_STATE = 1, REL_PROJ_ERROR_RESIDUAL = 2, REL_PROJ_ERROR_JACACTION = 3} relProjError;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::RelativeProjectionError
relativeMinimumEnergy	AlternatingLeastSquare/als_io.h	/^    double relativeMinimumEnergy;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
relativeMinimumEnergy	EmbeddedAlternatingLeastSquare.h	/^    double relativeMinimumEnergy;$/;"	m	class:EmbeddedAlternatingLeastSquare
relativeMinimumEnergy	IoData.h	/^    double relativeMinimumEnergy;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
relativeProjectionError	AlternatingLeastSquare/als_lapack.cpp	/^void AlternatingLeastSquare::relativeProjectionError() {$/;"	f	class:AlternatingLeastSquare
relativeProjectionError	IoData.h	/^  RelativeProjectionErrorData relativeProjectionError;$/;"	m	struct:ROBConstructionData
relax	arpack++/include/arlspdef.h	/^    int relax;$/;"	m	struct:__anon39
relax	arpack++/include/arlspdef.h	/^    int relax;$/;"	m	struct:__anon40
relaxFactorJwl	LocalRiemann.h	/^  double refdensity,refentropy,relaxFactorJwl;$/;"	m	class:LocalRiemannGfmpar
relaxationFactor	MultiGridKernel.h	/^  double relaxationFactor;$/;"	m	class:MultiGridKernel
remoteSize	CommunicatorMPI.C	/^int Communicator::remoteSize()$/;"	f	class:Communicator
removeForceAndDispComm	Timer.C	/^double Timer::removeForceAndDispComm(double t0)$/;"	f	class:Timer
removeHydroStaticContribution	Extrapolation.C	/^void Extrapolation<dim>::removeHydroStaticContribution(int i, int n[3],SVec<double,dim> &Ufar, $/;"	f	class:Extrapolation
removeIntersAndPhaseChange	Timer.C	/^double Timer::removeIntersAndPhaseChange(double t0)  \/\/removed from "Fluid Solution"$/;"	f	class:Timer
removeTriangle	TriangulatedSurface.C	/^void TriangulatedSurface::removeTriangle(int j)$/;"	f	class:TriangulatedSurface
renum	Connectivity.h	/^  int *renum;  \/\/ renumbering -> renum[old] = new$/;"	m	struct:compStruct
renumByComponent	ConnectivityCore.C	/^Connectivity::renumByComponent(int renumAlg)$/;"	f	class:Connectivity
renumRCM	ConnectivityCore.C	/^Connectivity::renumRCM(int *mask, int &nextNum, int *renum)$/;"	f	class:Connectivity
renumSloan	ConnectivityCore.C	/^Connectivity::renumSloan(int *mask, int &nextNum, int *renum)$/;"	f	class:Connectivity
renumVector	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::renumVector(SVec<Scalar2, dim3> &x)  {$/;"	f	class:RectangularSparseMat
renumVector	SparseMatrix.C	/^void SparseMat<Scalar,dim>::renumVector(SVec<Scalar2, dim> &x)  {$/;"	f	class:SparseMat
renumberEdges	ElemCore.C	/^void Elem::renumberEdges(Vec<int> &newNum)$/;"	f	class:Elem
renumberNodes	Elem.h	/^  void renumberNodes(NodeMap &nodemap) {$/;"	f	class:Elem
renumberNodes	Face.C	/^void Face::renumberNodes(NodeMap &nodemap)$/;"	f	class:Face
renumberNodes	MatchNode.C	/^void MatchNodeSet::renumberNodes(NodeMap &nodemap)$/;"	f	class:MatchNodeSet
renumberTargets	Connectivity.C	/^void Connectivity::renumberTargets(Map &theMap)$/;"	f	class:Connectivity
renumbering	IoData.h	/^  enum Renumbering {NATURAL = 0, RCM = 1} renumbering;$/;"	m	struct:PcData	typeref:enum:PcData::Renumbering
reorder	FaceCore.C	/^void Face::reorder()$/;"	f	class:Face
reorder	MapFace.h	/^    void reorder() {$/;"	f	struct:MaxFace
reqStatus	Communicator.h	/^  ResizeArray<MPI_Status> reqStatus;$/;"	m	class:Communicator
request	MemoryPool.C	/^void *MemoryPool::request(int nbytes)$/;"	f	class:MemoryPool
requireSpecialBDF	LevelSetTsDesc.h	/^  bool requireSpecialBDF;$/;"	m	class:LevelSetTsDesc
requireSpecialBDF	MultiPhysicsTsDesc.h	/^  bool requireSpecialBDF;$/;"	m	class:MultiPhysicsTsDesc
res	MultiGridCoupledTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridCoupledTsDesc
res	MultiGridEmbeddedTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig;$/;"	m	class:MultiGridEmbeddedTsDesc
res	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
res0	ImplicitRomTsDesc.h	/^  double target, res0;	\/\/ for Newton convergence$/;"	m	class:ImplicitRomTsDesc
resMat	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* resMat;$/;"	m	class:NonlinearRom
resType	TsParameters.h	/^  int resType;$/;"	m	class:TsParameters
reset	DistGeoState.C	/^void DistGeoState::reset(DistSVec<double,3> &Xmod)$/;"	f	class:DistGeoState
reset	DistLeastSquareSolver.C	/^DistLeastSquareSolver::reset() {$/;"	f	class:DistLeastSquareSolver
reset	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::reset(int it)$/;"	f	class:ExactRiemannSolver
reset	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::reset(const bool retry)$/;"	f	class:IntersectorFRG
reset	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::reset(const bool findStatus,const bool retry)$/;"	f	class:IntersectorPhysBAM
resetConfigSA	DistGeoState.h	/^  void resetConfigSA() { data.configSA = 0; }$/;"	f	class:DistGeoState
resetDistanceComparisonQuantitiesApproxUpdates	NonlinearRom.C	/^void NonlinearRom<dim>::resetDistanceComparisonQuantitiesApproxUpdates() {$/;"	f	class:NonlinearRom
resetFirstLayerLevelSetFS	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::resetFirstLayerLevelSetFS(DistSVec<double,dimLS> &PhiV, DistLevelSetStructure *distLSS,$/;"	f	class:MultiPhaseSpaceOperator
resetFixesTag	ImplicitEmbeddedRomTsDesc.h	/^    void resetFixesTag() { super::resetFixesTag(); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
resetFixesTag	ImplicitEmbeddedTsDesc.C	/^void ImplicitEmbeddedTsDesc<dim>::resetFixesTag()$/;"	f	class:ImplicitEmbeddedTsDesc
resetFixesTag	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::resetFixesTag()$/;"	f	class:ImplicitLevelSetTsDesc
resetFixesTag	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::resetFixesTag()$/;"	f	class:ImplicitMultiPhysicsTsDesc
resetFixesTag	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::resetFixesTag()$/;"	f	class:ImplicitRomTsDesc
resetFixesTag	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::resetFixesTag()$/;"	f	class:ImplicitTsDesc
resetFixesTag	MeshMotionSolver.h	/^  void resetFixesTag() { return;}$/;"	f	class:TetMeshMotionSolver
resetInputValues	IoDataCore.C	/^void IoData::resetInputValues()$/;"	f	class:IoData
resetInterfacialW	ExactRiemannSolver.C	/^void ExactRiemannSolver<dim>::resetInterfacialW(int edgeNum)$/;"	f	class:ExactRiemannSolver
resetOutputToStructure	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::resetOutputToStructure(DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
resetOutputToStructure	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::resetOutputToStructure(DistSVec<double,dim> &U)$/;"	f	class:LevelSetTsDesc
resetOutputToStructure	MeshMotionHandler.C	/^void AeroMeshMotionHandler::resetOutputToStructure(PostOperator<dim>* postOp,$/;"	f	class:AeroMeshMotionHandler
resetOutputToStructure	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::resetOutputToStructure(DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
resetOutputToStructure	TsDesc.C	/^void TsDesc<dim>::resetOutputToStructure(DistSVec<double,dim> &U)$/;"	f	class:TsDesc
resetTag	DistEdgeGrad.h	/^  void resetTag()$/;"	f	class:DistEdgeGrad
resetTag	DistNodalGrad.C	/^void DistNodalGrad<dim, Scalar>::resetTag()$/;"	f	class:DistNodalGrad
resetTag	SpaceOperator.C	/^void SpaceOperator<dim>::resetTag()$/;"	f	class:SpaceOperator
reshistory	TsParameters.h	/^  double* reshistory;$/;"	m	class:TsParameters
resid	arpack++/include/arrseig.h	/^  ARTYPE  *resid;     \/\/ Initial residual vector.$/;"	m	class:ARrcStdEig
residual	GappyPreprocessing.h	/^	const int residual;	\/\/ refer to residual as 0$/;"	m	class:GappyPreprocessing
residual	IoData.h	/^  ResidualData residual;$/;"	m	struct:ROBConstructionData
residual	IoData.h	/^  double residual;$/;"	m	struct:RestartParametersData
residual	IoData.h	/^  int residual;$/;"	m	struct:TsData
residual	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
residual	TsParameters.h	/^  double residual;$/;"	m	class:TsParameters
residual	TsRestart.h	/^  double residual;$/;"	m	class:TsRestart
residualBasisName	IoData.h	/^  const char *residualBasisName;$/;"	m	struct:NonlinearRomFilesData
residualBasisName	NonlinearRom.h	/^  char* residualBasisName;$/;"	m	class:NonlinearRom
residualBasisPrefix	IoData.h	/^  const char *residualBasisPrefix;$/;"	m	struct:NonlinearRomFilesData
residualBasisPrefix	NonlinearRom.h	/^  char* residualBasisPrefix;$/;"	m	class:NonlinearRom
residualOutputFreqTime	IoData.h	/^  int residualOutputFreqTime;$/;"	m	struct:ROMOutputData
residualOutputFreqTime	TsOutput.h	/^  int residualOutputFreqTime;$/;"	m	class:TsOutput
residualOutputMaxNewton	IoData.h	/^  int residualOutputMaxNewton;$/;"	m	struct:ROMOutputData
residualOutputMaxNewton	TsOutput.h	/^  int residualOutputMaxNewton;$/;"	m	class:TsOutput
residualPrefix	IoData.h	/^  const char *residualPrefix;$/;"	m	struct:NonlinearRomFilesData
residualRef	ImplicitPGTsDesc.h	/^  RefVec<DistSVec<double, dim> >residualRef;$/;"	m	class:ImplicitPGTsDesc
residualScaling	IoData.h	/^  enum ResidualScaling {SCALING_OFF=0, SCALING_BALANCED=1, SCALING_ENERGY=2} residualScaling;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::ResidualScaling
residualSingValsName	IoData.h	/^  const char *residualSingValsName;$/;"	m	struct:NonlinearRomFilesData
residualSingValsName	NonlinearRom.h	/^  char* residualSingValsName;$/;"	m	class:NonlinearRom
residualSnapFile	IoData.h	/^  const char *residualSnapFile;$/;"	m	struct:InputData
residualSnapsName	IoData.h	/^  const char *residualSnapsName;$/;"	m	struct:NonlinearRomFilesData
residualSnapsName	NonlinearRom.h	/^  char* residualSnapsName;$/;"	m	class:NonlinearRom
residualVector	IoData.h	/^  const char *residualVector;$/;"	m	struct:ROMOutputData
residualVectors	TsOutput.h	/^  char *residualVectors;$/;"	m	class:TsOutput
residuals	IoData.h	/^  const char *residuals;$/;"	m	struct:TransientData
residuals	TsOutput.h	/^  char *residuals;$/;"	m	class:TsOutput
residualsForCoordRange	IoData.h	/^  const char *residualsForCoordRange;$/;"	m	struct:ROMOutputData
resize	GappyPreprocessing.h	/^	void resize (int *size) {a[0].resize(size[0]); a[1].resize(size[1]); };	\/\/ within constructor, specify maximum size$/;"	f	struct:VecSubDomainData
resize	GappyPreprocessing.h	/^	void resize (int size) {a[0].resize(size); a[1].resize(size); };	\/\/ within constructor, specify maximum size$/;"	f	struct:VecSubDomainData
resize	ResizeArray.h	/^ResizeArray<Type>::resize(int ns)$/;"	f	class:ResizeArray
resize	Vector.h	/^  void resize(int l) $/;"	f	class:SVec
resize	Vector.h	/^  void resize(int l) $/;"	f	class:Vec
resize	VectorSet.h	/^void VecSet<VecType>::resize(int n)$/;"	f	class:VecSet
resizeMultiIndex	SparseGridCore.C	/^void SparseGrid::resizeMultiIndex(){$/;"	f	class:SparseGrid
resizeSurplus	SparseGridCore.C	/^void SparseGrid::resizeSurplus(){$/;"	f	class:SparseGrid
resjacfrequency	IoData.h	/^  int resjacfrequency;$/;"	m	struct:ROMOutputData
resolution	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    double resolution;$/;"	m	class:PhysBAM::TIMER
resolve	MultiGridSolver.h	/^int MultiGridSolver<ProblemDescriptor>::resolve(typename ProblemDescriptor::SolVecType &U,$/;"	f	class:MultiGridSolver
resolve	TsSolver.h	/^int TsSolver<ProblemDescriptor>::resolve(typename ProblemDescriptor::SolVecType &U,$/;"	f	class:TsSolver
resolveErrors	TsParameters.C	/^void TsParameters::resolveErrors()$/;"	f	class:TsParameters
restart	IoData.h	/^  RestartData restart;$/;"	m	struct:OutputData
restart	IoData.h	/^  RestartParametersData restart;$/;"	m	class:IoData
restart	TsDesc.h	/^  TsRestart *restart;$/;"	m	class:TsDesc
restartOutput	OneDimensionalSolver.C	/^void OneDimensional::restartOutput(double time, int iteration){$/;"	f	class:OneDimensional
restart_file_package	IoData.h	/^  const char *restart_file_package;$/;"	m	struct:InputData
restartmeshFile	FSI/DynamicNodalTransfer.h	/^  char *restartmeshFile;$/;"	m	class:EmbeddedStructure
restrict	DistVector.h	/^DistSVec<Scalar,dim>::restrict()$/;"	f	class:DistSVec
restrictMapping	NonlinearRom.h	/^  RestrictionMapping<dim>* restrictMapping() { return restrictionMapping; } $/;"	f	class:NonlinearRom
restrictMethod	IoData.h	/^  enum RestrictMethod { VOLUME_WEIGHTED = 0, AVERAGE = 1 } restrictMethod;$/;"	m	struct:MultiGridData	typeref:enum:MultiGridData::RestrictMethod
restrict_relax_factor	IoData.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	struct:MultiGridData
restrict_relax_factor	MultiGridCoupledTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridCoupledTsDesc
restrict_relax_factor	MultiGridEmbeddedTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridEmbeddedTsDesc
restrict_relax_factor	MultiGridKernel.h	/^  double restrict_relax_factor;$/;"	m	class:MultiGridKernel
restrict_relax_factor	MultiGridSegTsDesc.h	/^  double prolong_relax_factor,restrict_relax_factor;$/;"	m	class:MultiGridSegTsDesc
restrictedDistInfo	RestrictionMapping.h	/^  const DistInfo & restrictedDistInfo() const { return restrictedDistInfo_; }$/;"	f	class:RestrictionMapping
restrictedDistInfo_	RestrictionMapping.h	/^  DistInfo restrictedDistInfo_;$/;"	m	class:RestrictionMapping
restrictedToOrigin_	RestrictionMapping.h	/^  std::vector<std::vector<int> > restrictedToOrigin_;	\/\/ local node number in original$/;"	m	class:RestrictionMapping
restriction	RestrictionMapping.C	/^RestrictionMapping<dim>::restriction(const DistSVec<double, dim> & in, DistSVec<double, dim> & out) const {$/;"	f	class:RestrictionMapping
restriction	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
restrictionMapping	NonlinearRom.h	/^  RestrictionMapping<dim>* restrictionMapping;$/;"	m	class:NonlinearRom
restrictionOnPhi	Domain.C	/^void Domain::restrictionOnPhi(DistSVec<double,dim> &initial, DistVec<int> &fluidId,$/;"	f	class:Domain
restrictionOnPhi	SubDomain.C	/^void SubDomain::restrictionOnPhi(SVec<double,dim> &initial, Vec<int> &fluidId,$/;"	f	class:SubDomain
result	ImplicitEmbeddedRomTsDesc.h	/^    double **result; \/\/<! scratchpad for scalapack to store result, fixed size from initialization$/;"	m	class:ImplicitEmbeddedRomTsDesc
resulterrbound	utils/Predicate.C	/^REAL resulterrbound;$/;"	v
results	TsOutput.h	/^    double* results;$/;"	m	struct:TsOutput::__anon29
resultsOutput	OneDimensionalSolver.C	/^void OneDimensional::resultsOutput(double time, int iteration){$/;"	f	class:OneDimensional
reverse	ConnectivityCore.C	/^Connectivity::reverse(float *w)$/;"	f	class:Connectivity
reverseChannel	Communicator.h	/^  int *reverseChannel; \/\/ corresponding reverse channel$/;"	m	class:CommPattern
reverseChannel	CommunicatorCore.C	/^SubDTopo::reverseChannel(int channel)$/;"	f	class:SubDTopo
reverse_mapping	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    ARRAY<int> reverse_mapping,forward_mapping;$/;"	m	class:IntersectorPhysBAM
reynolds	KEpsilonTerm.h	/^  double reynolds;$/;"	m	class:KEpsilonTerm
reynolds	WallFcn.h	/^  double reynolds;$/;"	m	class:WallFcn
reynolds0	EmbeddedFluidShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
reynolds0	FluidCollocationShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:FluidCollocationShapeOptimizationHandler
reynolds0	FluidGnatShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:FluidGnatShapeOptimizationHandler
reynolds0	FluidMetricShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:FluidMetricShapeOptimizationHandler
reynolds0	FluidRomShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:FluidRomShapeOptimizationHandler
reynolds0	FluidShapeOptimizationHandler.h	/^  double reynolds0;$/;"	m	class:FluidShapeOptimizationHandler
reynoldsNS	NavierStokesTerm.h	/^  double reynoldsNS;$/;"	m	class:NavierStokesTerm
reynolds_mu	IoData.h	/^  double reynolds_mu;$/;"	m	struct:ReferenceStateData
reynolds_muNS	NavierStokesTerm.h	/^  double reynolds_muNS;$/;"	m	class:NavierStokesTerm
rho	Extrapolation.h	/^  double rho;$/;"	m	class:Extrapolation
rho	ImplicitRomTsDesc.h	/^  double rho;$/;"	m	class:ImplicitRomTsDesc
rho	IoData.h	/^  double rho;$/;"	m	struct:LineSearchData
rhoc	RecFcnDesc.h	/^  double pc,rhoc,vc;$/;"	m	class:RecFcnExtendedVanAlbada
rhomin	IoData.h	/^  double rhomin;$/;"	m	struct:FluidModelData
rhomin	VarFcnBase.h	/^  double rhomin,pmin;$/;"	m	class:VarFcnBase
rhoref	IoData.h	/^  double A1,R1,rhoref,A2,R2;$/;"	m	struct:JWLModelData
rhoref	VarFcnJwl.h	/^  double A1, A2, R1, R2, rhoref;$/;"	m	class:VarFcnJwl
rhs	ImplicitCollocationTsDesc.h	/^  Vec<double> rhs;$/;"	m	class:ImplicitCollocationTsDesc
rhs	ImplicitMetricTsDesc.h	/^  Vec<double> rhs;$/;"	m	class:ImplicitMetricTsDesc
rhs	ImplicitPGTsDesc.h	/^  Vec<double> rhs;$/;"	m	class:ImplicitPGTsDesc
rhs	NewtonSolver.h	/^  typename ProblemDescriptor::SolVecType rhs; \/\/ right hand side$/;"	m	class:NewtonSolver
rhsBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsBuffer() const {$/;"	f	class:DistLeastSquareSolver
rhsBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsBuffer() {$/;"	f	class:DistLeastSquareSolver
rhsBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsBuffer(int rank) const {$/;"	f	class:DistLeastSquareSolver
rhsBuffer	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsBuffer(int rank) {$/;"	f	class:DistLeastSquareSolver
rhsBuffer_	DistLeastSquareSolver.h	/^  SimpleBuffer<Scalar> rhsBuffer_;$/;"	m	class:DistLeastSquareSolver
rhsColBlockSize	DistLeastSquareSolver.h	/^  int rhsColBlockSize()    const { return rhsColBlockSize_; }$/;"	f	class:DistLeastSquareSolver
rhsColBlockSize_	DistLeastSquareSolver.h	/^  int rhsRowBlockSize_, rhsColBlockSize_;$/;"	m	class:DistLeastSquareSolver
rhsCount	DistLeastSquareSolver.h	/^  int rhsCount()         const { return rhsCount_;         }$/;"	f	class:DistLeastSquareSolver
rhsCount_	DistLeastSquareSolver.h	/^  int largestDimension_, rhsCount_;$/;"	m	class:DistLeastSquareSolver
rhsDesc_	DistLeastSquareSolver.h	/^  ArrayDesc rhsDesc_;$/;"	m	class:DistLeastSquareSolver
rhsEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsEntry(int rank, int row) const {$/;"	f	class:DistLeastSquareSolver
rhsEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsEntry(int rank, int row) {$/;"	f	class:DistLeastSquareSolver
rhsEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsEntry(int row) const {$/;"	f	class:DistLeastSquareSolver
rhsEntry	DistLeastSquareSolver.h	/^DistLeastSquareSolver::rhsEntry(int row) {$/;"	f	class:DistLeastSquareSolver
rhsPhi	NewtonSolver.h	/^  typename ProblemDescriptor::PhiVecType rhsPhi; \/\/ $/;"	m	class:NewtonSolver
rhsRankHostCpu	DistLeastSquareSolver.C	/^DistLeastSquareSolver::rhsRankHostCpu(int globalRankIdx) const {$/;"	f	class:DistLeastSquareSolver
rhsRowBlockSize	DistLeastSquareSolver.h	/^  int rhsRowBlockSize()    const { return rhsRowBlockSize_; }$/;"	f	class:DistLeastSquareSolver
rhsRowBlockSize_	DistLeastSquareSolver.h	/^  int rhsRowBlockSize_, rhsColBlockSize_;$/;"	m	class:DistLeastSquareSolver
rhsRowHostCpu	DistLeastSquareSolver.C	/^DistLeastSquareSolver::rhsRowHostCpu(int globalRowIdx) const {$/;"	f	class:DistLeastSquareSolver
riemann	EmbeddedTsDesc.h	/^  DistExactRiemannSolver<dim> *riemann; \/\/Riemann solver -- used at both FF and FS interfaces$/;"	m	class:EmbeddedTsDesc
riemann	LevelSetTsDesc.h	/^  DistExactRiemannSolver<dim> *riemann;$/;"	m	class:LevelSetTsDesc
riemann	MatVecProd.h	/^    DistExactRiemannSolver<dim>* riemann;$/;"	m	struct:MatVecProd::_fsi
riemann	MatVecProd.h	/^    DistExactRiemannSolver<dim>* riemann;$/;"	m	struct:MatVecProdMultiPhase::_fsi
riemann	MatVecProd.h	/^  DistExactRiemannSolver<dim> *riemann;$/;"	m	class:MatVecProdMultiPhase
riemann	MultiPhysicsTsDesc.h	/^  DistExactRiemannSolver<dim> *riemann; \/\/Riemann solver -- used at both FF and FS interfaces$/;"	m	class:MultiPhysicsTsDesc
riemann	OneDimensionalSolver.h	/^  ExactRiemannSolver<5>* riemann;$/;"	m	class:OneDimensional
riemann1	TsDesc.h	/^  DistExactRiemannSolver<dim> *riemann1;$/;"	m	class:TsDesc
riemannComputation	IoData.h	/^  enum RiemannComputation {FE = 0, RK2 = 1, TABULATION2 = 2, TABULATION5 = 3} riemannComputation;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::RiemannComputation
riemannComputationType_	LocalRiemannDesc.h	/^  MultiFluidData::RiemannComputation riemannComputationType_;$/;"	m	class:LocalRiemannGfmparGasJWL
riemannComputationType_	LocalRiemannDesc.h	/^  MultiFluidData::RiemannComputation riemannComputationType_;$/;"	m	class:LocalRiemannGfmparTaitJWL
riemannEps	IoData.h	/^  double riemannEps;$/;"	m	struct:MultiFluidData
riemannInvariantGeneral1stOrder	LocalRiemann.h	/^void LocalRiemannGfmpar::riemannInvariantGeneral1stOrder(double *in, double *res,$/;"	f	class:LocalRiemannGfmpar
riemannInvariantGeneral1stOrder_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasJWL::riemannInvariantGeneral1stOrder_wrapper($/;"	f	class:LocalRiemannGfmparGasJWL
riemannInvariantGeneral1stOrder_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitJWL::riemannInvariantGeneral1stOrder_wrapper($/;"	f	class:LocalRiemannGfmparTaitJWL
riemannInvariantGeneral2ndOrder	LocalRiemann.h	/^void LocalRiemannGfmpar::riemannInvariantGeneral2ndOrder(double *in, double *res,$/;"	f	class:LocalRiemannGfmpar
riemannInvariantGeneral2ndOrder_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparGasJWL::riemannInvariantGeneral2ndOrder_wrapper($/;"	f	class:LocalRiemannGfmparGasJWL
riemannInvariantGeneral2ndOrder_wrapper	LocalRiemannDesc.h	/^void LocalRiemannGfmparTaitJWL::riemannInvariantGeneral2ndOrder_wrapper($/;"	f	class:LocalRiemannGfmparTaitJWL
riemannInvariantGeneralTabulation	LocalRiemann.h	/^int LocalRiemannGfmpar::riemannInvariantGeneralTabulation(double *in, double *res){$/;"	f	class:LocalRiemannGfmpar
riemannInvariantGeneralTabulation	LocalRiemannDesc.h	/^int LocalRiemannGfmparGasJWL::riemannInvariantGeneralTabulation(double *in, $/;"	f	class:LocalRiemannGfmparGasJWL
riemannInvariantGeneralTabulation	LocalRiemannDesc.h	/^int LocalRiemannGfmparTaitJWL::riemannInvariantGeneralTabulation(double *in, $/;"	f	class:LocalRiemannGfmparTaitJWL
riemannInvariantKernel1	LocalRiemann.h	/^double LocalRiemannGfmpar::riemannInvariantKernel1(double density, const RiemannInvParams& J) {$/;"	f	class:LocalRiemannGfmpar
riemannMaxIts	IoData.h	/^  int riemannMaxIts;$/;"	m	struct:MultiFluidData
riemannNormal	EmbeddedTsDesc.h	/^  int riemannNormal;  \/\/ 0: struct normal;  1: fluid normal (w.r.t. control volume face)$/;"	m	class:EmbeddedTsDesc
riemannNormal	IoData.h	/^  enum RiemannNormal {REAL = 0, MESH = 1, LEGACYMESH = 2 } riemannNormal;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::RiemannNormal
riemannNormal	IoData.h	/^  enum RiemannNormal {STRUCTURE = 0, FLUID = 1} riemannNormal;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::RiemannNormal
riemannNormal	MultiPhysicsTsDesc.h	/^  int riemannNormal;  \/\/ 0: struct normal;  1: fluid normal (w.r.t. control volume face)$/;"	m	class:MultiPhysicsTsDesc
riemannStatus	OneDimensionalSolver.h	/^  Vec<int> riemannStatus;$/;"	m	class:OneDimensional
riemannupdate	DistExactRiemannSolver.h	/^  DistSVec<double,dim> *riemannupdate; \/\/node based$/;"	m	class:DistExactRiemannSolver
right	KDTree.h	/^    KDTreeNode* left,*right;$/;"	m	struct:KDTree::KDTreeNode
right	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    KD_TREE_NODE<T>* right;$/;"	m	class:PhysBAM::KD_TREE_NODE
rightTree	IntersectorFRG/Geometry/KDTree.h	/^     KDTree<Obj, dim, CompType> *leftTree, *rightTree;$/;"	m	class:KDTree
rightmost_bit	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/integer_log.h	/^inline int rightmost_bit(unsigned int v)$/;"	f	namespace:PhysBAM
rinfo	arpack++/include/arunsmat.h	/^  ARTYPE  rinfo[20];$/;"	m	class:ARumNonSymMatrix
rinfo	arpack++/include/arusmat.h	/^  ARTYPE  rinfo[20];$/;"	m	class:ARumSymMatrix
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/rint.h	/^inline double rint(const double x){return floor(x+(x>0?.5:-.5));}$/;"	f	namespace:PhysBAM
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/rint.h	/^inline float rint(const float x){return floorf(x+(x>0?.5f:-.5f));}$/;"	f	namespace:PhysBAM
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^rint(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^rint(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^rint(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
rint	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^rint(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
rmaCom	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
rmesh	IoData.h	/^  RigidMeshMotionData rmesh;$/;"	m	class:IoData
rmmh	TsOutput.h	/^  RigidMeshMotionHandler *rmmh;$/;"	m	class:TsOutput
rob	IoData.h	/^  ROBConstructionData rob;$/;"	m	struct:NonlinearRomOfflineData
robConstruction	NonlinearRomDatabaseConstruction.h	/^  ROBConstructionData* robConstruction;$/;"	m	class:NonlinearRomDatabaseConstruction
robProductFile	IoData.h	/^  const char *robProductFile;$/;"	m	struct:TransientData
roejacappr3Dgas	FluxFcnDescSG.C	/^void roejacappr3Dgas(int type, double gamma, VarFcnBase *vf, double vfgam, double vfp, $/;"	f
roejacexact3D	FluxFcnDescSG.C	/^void roejacexact3D(int type, double gamma, VarFcnBase *vf, FluxFcnBase::Type localTypeJac, double* normal, $/;"	f
roejactait3D	FluxFcnDescTait.C	/^void roejactait3D(int type, double gamma, VarFcnBase *vf, FluxFcnBase::Type localTypeJac, double *normal,$/;"	f
roeturkeljac5	AutoDiff/roeturkeljac5.h	/^void roeturkeljac5(int type, double gamma, double gam, double pstiff, double enormal[3],$/;"	f
rom	ImplicitRomTsDesc.h	/^  NonlinearRom<dim>* rom;$/;"	m	class:ImplicitRomTsDesc
rom	IoData.h	/^  ROMOutputData rom;$/;"	m	struct:OutputData
romConstr	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
romDatabase	IoData.h	/^  NonlinearRomFileSystemData romDatabase;$/;"	m	class:IoData
romFile	IoData.h	/^  const char *romFile;$/;"	m	struct:LinearizedData
romFile	IoData.h	/^  const char *romFile;$/;"	m	struct:TransientData
romFiles	NonlinearRom.h	/^  NonlinearRomFilesData* romFiles;$/;"	m	class:NonlinearRom
romInitialConditionFile	IoData.h	/^  const char *romInitialConditionFile;$/;"	m	struct:TransientData
romOffline	IoData.h	/^  NonlinearRomOfflineData romOffline;$/;"	m	class:IoData
romOffline	Timer.h	/^                gappyOffline, romOffline, icInterp, NUMTIMINGS$/;"	e	enum:Timer::TimerIndex
romOnline	IoData.h	/^  NonlinearRomOnlineData romOnline;$/;"	m	class:IoData
romSol	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
romSpatialOnlyHomotomyStepExpGrowthRate	IoData.h	/^  double romSpatialOnlyHomotomyStepExpGrowthRate;$/;"	m	struct:NonlinearRomOnlineData
romSpatialOnlyInitialHomotomyStep	IoData.h	/^  double romSpatialOnlyInitialHomotomyStep;$/;"	m	struct:NonlinearRomOnlineData
romSpatialOnlyMaxHomotomyStep	IoData.h	/^  double romSpatialOnlyMaxHomotomyStep;$/;"	m	struct:NonlinearRomOnlineData
romTimeInteg	Timer.h	/^		romConstr, romTimeInteg, comm, localCom, globalCom, interCom, rmaCom, io,$/;"	e	enum:Timer::TimerIndex
rom_ksp	ImplicitEmbeddedRomTsDesc.h	/^    KspSolver<DistEmbeddedVec<double,dim>, MatVecProd<dim,dim>, KspPrec<dim>, Communicator> *rom_ksp;$/;"	m	class:ImplicitEmbeddedRomTsDesc
rom_pc	ImplicitEmbeddedRomTsDesc.h	/^    KspPrec<dim> *rom_pc;$/;"	m	class:ImplicitEmbeddedRomTsDesc
root	KDTree.h	/^  KDTreeNode* root;$/;"	m	class:KDTree
root	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    int leaves,root;$/;"	m	class:PhysBAM::BOX_HIERARCHY
root	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    LOG_ENTRY* root;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
root	RTree.h	/^  Node* root;$/;"	m	class:RTree
root1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T root1,root2,root3; \/\/ root1 < root2 < root3$/;"	m	class:PhysBAM::CUBIC
root1	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T root1,root2; \/\/ root1 < root2$/;"	m	class:PhysBAM::QUADRATIC
root2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T root1,root2,root3; \/\/ root1 < root2 < root3$/;"	m	class:PhysBAM::CUBIC
root2	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    T root1,root2; \/\/ root1 < root2$/;"	m	class:PhysBAM::QUADRATIC
root3	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    T root1,root2,root3; \/\/ root1 < root2 < root3$/;"	m	class:PhysBAM::CUBIC
rootLS	ConnectivityCore.C	/^Connectivity::rootLS(int root, int *xls, int *ls, int &w, int *mask)$/;"	f	class:Connectivity
root_node	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    KD_TREE_NODE<T>* root_node;$/;"	m	class:PhysBAM::KD_TREE
root_six	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double root_six=sqrt(6.);$/;"	m	namespace:PhysBAM
root_three	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double root_three=sqrt(3.);$/;"	m	namespace:PhysBAM
root_two	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double root_two=sqrt(2.);$/;"	m	namespace:PhysBAM
root_two_thirds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double root_two_thirds=sqrt(2.\/3);$/;"	m	namespace:PhysBAM
roots	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/CUBIC.h	/^    int roots; \/\/ number of roots, -1 indicates a=b=c=0 - always a root!$/;"	m	class:PhysBAM::CUBIC
roots	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Polynomials/QUADRATIC.h	/^    int roots; \/\/ number of roots, -1 indicates a=b=c=0 - always a root!$/;"	m	class:PhysBAM::QUADRATIC
rot	arpack++/include/blas1c.h	/^inline void rot(const ARint &n, double dx[], const ARint &incx, $/;"	f
rot	arpack++/include/blas1c.h	/^inline void rot(const ARint &n, float dx[], const ARint &incx, float dy[],$/;"	f
rotDir	MapFace.h	/^    int rotDir; $/;"	m	struct:MaxFace
rotInfo	DistBcData.h	/^  map<int, RotationData *> &rotInfo;$/;"	m	class:DistBcData
rotLocVec	CorotSolver.C	/^void CorotSolver::rotLocVec(double mat[3][3], double v[3]) $/;"	f	class:CorotSolver
rotLocVec	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::rotLocVec(double mat[3][3], double v[3]) $/;"	f	class:EmbeddedCorotSolver
rotOwn	FSI/DynamicNodalTransfer.h	/^  int *rotOwn;$/;"	m	class:EmbeddedStructure
rotOwn	IntersectorFRG/IntersectorFRG.h	/^    int *rotOwn;$/;"	m	class:DistIntersectorFRG
rotOwn	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int *rotOwn;$/;"	m	class:DistIntersectorPhysBAM
rotOwn	SubDomain.h	/^  int *rotOwn;$/;"	m	class:SubDomain
rotateNormal	BCApplier.h	/^  void rotateNormal(double dRot[3][3]) {$/;"	f	struct:ProjData
rotateProjNormal	BCApplierCore.C	/^BCApplier::rotateProjNormal(double dRot[3][3])$/;"	f	class:BCApplier
rotationID	IoData.h	/^  int rotationID;$/;"	m	struct:SurfaceData
rotationMap	FSI/DynamicNodalTransfer.h	/^  map<int,RotationData*> *rotationMap;$/;"	m	class:EmbeddedStructure
rotationMap	IoData.h	/^  ObjectMap<RotationData> rotationMap;$/;"	m	struct:Velocity
rotations	IoData.h	/^  Velocity rotations;$/;"	m	class:IoData
rotg	arpack++/include/blas1c.h	/^inline void rotg(double &da, double &db, double &c, double &s) {$/;"	f
rotg	arpack++/include/blas1c.h	/^inline void rotg(float &da, float &db, float &c, float &s) {$/;"	f
row	GenMatrix.h	/^    int row,col;$/;"	m	struct:GenMat::AuxilliaryIterator
rowBlockSize_	DistLeastSquareSolver.h	/^  int rowBlockSize_, colBlockSize_;$/;"	m	class:DistLeastSquareSolver
rowCpus	DistLeastSquareSolver.h	/^  int rowCpus() const { return rowCpus_; }$/;"	f	class:DistLeastSquareSolver
rowCpus_	DistLeastSquareSolver.h	/^  int rowCpus_, colCpus_;$/;"	m	class:DistLeastSquareSolver
rowHostCpu	DistLeastSquareSolver.C	/^DistLeastSquareSolver::rowHostCpu(int globalRowIdx) const {$/;"	f	class:DistLeastSquareSolver
rowind	arpack++/include/arlsupm.h	/^    int  *rowind; \/* pointer to array of row indices of the nonzeros *\/$/;"	m	struct:__anon46
rowind	arpack++/include/arlsupm.h	/^    int *rowind;  \/* pointer to array of row indices of the nonzeros *\/$/;"	m	struct:__anon49
rowind	arpack++/include/arlsupm.h	/^  int  *rowind;      \/* pointer to array of compressed row indices of $/;"	m	struct:__anon48
rowind_colptr	arpack++/include/arlsupm.h	/^  int *rowind_colptr;\/* pointer to array of beginning of columns in rowind[] *\/$/;"	m	struct:__anon48
roword	arpack++/include/ardfmat.h	/^  bool     roword;    \/\/ A variable that indicates if the data will be read$/;"	m	class:ARdfMatrix
rowptr	RectangularSparseMatrix.h	/^  int *rowptr() { return ia.v; }$/;"	f	class:RectangularSparseMat
rowptr	SparseMatrix.h	/^  int *rowptr() { return ia.v; }$/;"	f	class:SparseMat
rowptr	arpack++/include/arlsupm.h	/^    int  *rowptr; \/* pointer to array of beginning of rows in nzval[] $/;"	m	struct:__anon47
rowsPerBlock	ParallelRom.h	/^	int rowsPerBlock;$/;"	m	class:ParallelRom
rperm	RectangularSparseMatrix.C	/^void RectangularSparseMat<Scalar,dim,dim2>::rperm(int *perm)$/;"	f	class:RectangularSparseMat
rperm	SparseMatrix.C	/^void SparseMat<Scalar,dim>::rperm(int *perm)$/;"	f	class:SparseMat
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLCEuler3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLCKE3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLCSA3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLEEuler3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLEKE3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacHLLESA3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacRoeEuler3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacRoeKE3D
rshift	FluxFcnDesc.h	/^  int rshift;$/;"	m	class:FluxFcnApprJacRoeSA3D
rshift	SpaceOperator.h	/^  int rshift;$/;"	m	class:SpaceOperator
rstFluxFcn	SpaceOperator.C	/^void SpaceOperator<dim>::rstFluxFcn(IoData &ioData)$/;"	f	class:SpaceOperator
rstSpaceOp	MatVecProd.C	/^void MatVecProdFD<dim, neq>::rstSpaceOp(IoData & ioData, VarFcn *varFcn, SpaceOperator<dim> *spo, bool typeAlloc, SpaceOperator<dim> *spofd)$/;"	f	class:MatVecProdFD
rstSpaceOp	MatVecProd.C	/^void MatVecProdH1<dim,Scalar,neq>::rstSpaceOp(IoData & ioData, VarFcn *varFcn, SpaceOperator<dim> *spo, bool typeAlloc, SpaceOperator<dim> *spofd)$/;"	f	class:MatVecProdH1
rstSpaceOp	MatVecProd.C	/^void MatVecProdH2<dim,Scalar,neq>::rstSpaceOp$/;"	f	class:MatVecProdH2
rstSpaceOp	MatVecProd.h	/^  virtual void rstSpaceOp(IoData &, VarFcn *, SpaceOperator<dim> *, bool, SpaceOperator<dim> * = 0){$/;"	f	class:MatVecProd
rstSpaceOp	MatVecProd.h	/^  void rstSpaceOp(IoData &, VarFcn *, SpaceOperator<dim> *, bool, SpaceOperator<dim> * = 0)$/;"	f	class:MatVecProd_dRdX
rstVar	DistBcData.C	/^void DistBcData<dim>::rstVar(IoData &ioData)$/;"	f	class:DistBcData
rstVar	DistTimeState.C	/^void DistTimeState<dim>::rstVar(IoData & ioData) $/;"	f	class:DistTimeState
rstVar	FemEquationTermDesc.h	/^  void rstVar$/;"	f	class:FemEquationTermNS
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) $/;"	f	class:FemEquationTermKE
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) $/;"	f	class:FemEquationTermSA
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) $/;"	f	class:FemEquationTermSAmean
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) {$/;"	f	class:FemEquationTermDESmean
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) {$/;"	f	class:FemEquationTermDESturb
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) {$/;"	f	class:FemEquationTermKEmean
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) {$/;"	f	class:FemEquationTermKEturb
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com) {$/;"	f	class:FemEquationTermSAturb
rstVar	FemEquationTermDesc.h	/^  void rstVar(IoData &ioData, Communicator *com)$/;"	f	class:FemEquationTermDES
rstVar	NavierStokesTerm.h	/^void NavierStokesTerm::rstVar(IoData &iod, Communicator *com)$/;"	f	class:NavierStokesTerm
rstVar	PostFcn.C	/^void PostFcnDES::rstVar(IoData &iod, Communicator *com)$/;"	f	class:PostFcnDES
rstVar	PostFcn.C	/^void PostFcnEuler::rstVar(IoData &iod, Communicator *com)$/;"	f	class:PostFcnEuler
rstVar	PostFcn.C	/^void PostFcnKE::rstVar(IoData &iod, Communicator *com)$/;"	f	class:PostFcnKE
rstVar	PostFcn.C	/^void PostFcnNS::rstVar(IoData &iod, Communicator *com)$/;"	f	class:PostFcnNS
rstVar	PostFcn.C	/^void PostFcnSA::rstVar(IoData &iod, Communicator *com)$/;"	f	class:PostFcnSA
rstVar	PostOperator.h	/^  void rstVar(IoData &iod) {pressInfty = iod.aero.pressure;}								$/;"	f	class:PostOperator
rstVar	RefVal.C	/^void RefVal::rstVar(IoData &ioData)$/;"	f	class:RefVal
rstVar	ThermalCondFcn.h	/^  void rstVar(IoData &iod) { thermal_conductivity_coefficient = iod.eqs.thermalCondModel.conductivity; }$/;"	f	class:ConstantThermalCondFcn
rstVar	ThermalCondFcn.h	/^  void rstVar(IoData &iod)$/;"	f	class:ConstantPrandtlThermalCondFcn
rstVar	TimeData.C	/^void TimeData::rstVar(IoData &ioData)$/;"	f	class:TimeData
rstVar	TsOutput.C	/^void TsOutput<dim>::rstVar(IoData &iod) {$/;"	f	class:TsOutput
rstVar	TsParameters.C	/^void TsParameters::rstVar(IoData &ioData) {$/;"	f	class:TsParameters
rstVar	TsRestartCore.C	/^void TsRestart::rstVar(IoData &ioData) {$/;"	f	class:TsRestart
rstVar	VarFcn.h	/^  void rstVar(IoData &iod) { assert(numPhases==1); varFcn[0]->rstVar(iod); }$/;"	f	class:VarFcn
rstVar	VarFcnBase.h	/^  virtual void rstVar(IoData &iod) {}$/;"	f	class:VarFcnBase
rstVar	VarFcnSGEuler.h	/^  void rstVar(IoData &iod) {$/;"	f	class:VarFcnSGEuler
rstVar	VarFcnSGKE.h	/^  void rstVar(IoData &iod) {$/;"	f	class:VarFcnSGKE
rstVar	VarFcnSGSA.h	/^  void rstVar(IoData &iod) {$/;"	f	class:VarFcnSGSA
rstVar	ViscoFcn.h	/^  void rstVar(IoData &iod) {  $/;"	f	class:ConstantViscoFcn
rstVar	ViscoFcn.h	/^  void rstVar(IoData &iod)$/;"	f	class:PrandtlViscoFcn
rstVar	ViscoFcn.h	/^  void rstVar(IoData &iod)$/;"	f	class:SutherlandViscoFcn
rstVar	WallFcnCore.C	/^void WallFcn::rstVar(IoData &iod, Communicator *com)$/;"	f	class:WallFcn
rstVarDES	DESTerm.h	/^void DESTerm::rstVarDES(IoData &iod)$/;"	f	class:DESTerm
rstVarFet	SpaceOperator.h	/^  void rstVarFet(IoData &ioData) $/;"	f	class:SpaceOperator
rstVarImplicitCoupledTsDesc	ImplicitCoupledTsDesc.C	/^void ImplicitCoupledTsDesc<dim>::rstVarImplicitCoupledTsDesc(IoData &ioData)$/;"	f	class:ImplicitCoupledTsDesc
rstVarImplicitEmbeddedCoupledTsDesc	ImplicitEmbeddedCoupledTsDesc.C	/^void ImplicitEmbeddedCoupledTsDesc<dim>::rstVarImplicitEmbeddedCoupledTsDesc(IoData &ioData)$/;"	f	class:ImplicitEmbeddedCoupledTsDesc
rstVarImplicitRomTsDesc	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::rstVarImplicitRomTsDesc(IoData &ioData)$/;"	f	class:ImplicitRomTsDesc
rstVarKE	KEpsilonTerm.h	/^void KEpsilonTerm::rstVarKE(IoData &iod)$/;"	f	class:KEpsilonTerm
rstVarNS	NavierStokesTerm.h	/^void NavierStokesTerm::rstVarNS(IoData &iod, Communicator *com)$/;"	f	class:NavierStokesTerm
rstVarPostFcn	PostOperator.h	/^  void rstVarPostFcn(IoData &ioData) {postFcn->rstVar(ioData, com);}								$/;"	f	class:PostOperator
rstVarSA	SpalartAllmarasTerm.h	/^void SATerm::rstVarSA(IoData &iod)$/;"	f	class:SATerm
rstdata	IoData.h	/^  const char *rstdata;$/;"	m	struct:InputData
rstrt	StructExc.h	/^  int rstrt;$/;"	m	class:StructExc
run	AlternatingLeastSquare/als_lapack.cpp	/^void AlternatingLeastSquare::run(int maxIterations) {$/;"	f	class:AlternatingLeastSquare
run	AutoDiff/SpaceDerivatives.h	/^  static void run(const A& a, B& b) { b = Eigen::Map<B>(const_cast<Scalar*>(a.data())); }$/;"	f	struct:assign_coherent_impl
run	AutoDiff/SpaceDerivatives.h	/^  static void run(const A& a, B& b) { b = a; }$/;"	f	struct:assign_coherent_impl
run	AutoDiff/SpaceDerivatives.h	/^  static void run(const A& a, B& b) { b = a[0]; }$/;"	f	struct:assign_coherent_impl
run	AutoDiff/SpaceDerivatives.h	/^  static void run(const A& a, B& b) { b[0] = a; }$/;"	f	struct:assign_coherent_impl
run	AutoDiff/SpaceDerivatives.h	/^  static void run(const A& a, B& b) {$/;"	f	struct:assign_coherent_impl
run	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
rupdate	ExactRiemannSolver.h	/^  SVec<double,dim>  &rupdate;$/;"	m	class:ExactRiemannSolver
rupdate	OneDimensionalSolver.h	/^  SVec<double,dim> rupdate;$/;"	m	class:OneDimensional
rv	IoData.h	/^  RefVal rv;$/;"	m	struct:ReferenceStateData
rvec	arpack++/include/arrseig.h	/^  bool    rvec;       \/\/ Indicates if eigenvectors\/Schur vectors were$/;"	m	class:ARrcStdEig
rwork	arpack++/include/arrseig.h	/^  ARFLOAT *rwork;     \/\/ Original ARPACK internal vector.$/;"	m	class:ARrcStdEig
s	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    T s;$/;"	m	class:PhysBAM::QUATERNION
s0	Face.h	/^  double s0[3], s1[3];  \/\/each face is split into three facets. $/;"	m	struct:HHCoeffs
s1	Face.h	/^  double s0[3], s1[3];  \/\/each face is split into three facets. $/;"	m	struct:HHCoeffs
sBit	IoData.h	/^  int sBit;$/;"	m	struct:SurfaceData
sGlobalLU_t	arpack++/include/arlspdef.h	/^} sGlobalLU_t;$/;"	t	typeref:struct:__anon35
sRecInfo	Communicator.h	/^  SubRecInfo<T> *sRecInfo;$/;"	m	class:CommPattern
sTraceOn	arpack++/include/debug.h	/^inline void sTraceOn(const ARint digit, const ARint getv0, const ARint aupd, $/;"	f
sVals	NonlinearRom.h	/^  std::vector<double>* sVals;$/;"	m	class:NonlinearRom
s_len_trim	Dunavant.C	/^int s_len_trim ( char *s )$/;"	f
sa	IoData.h	/^  SAModelData sa;$/;"	m	struct:TurbulenceModelData
sa	IoData.h	/^  SensitivityAnalysis sa;$/;"	m	class:IoData
sampleMesh	Edge.h	/^  bool sampleMesh;$/;"	m	class:EdgeSet
sampleMesh	Elem.h	/^	bool sampleMesh;$/;"	m	class:ElemSet
sampleMesh	Face.h	/^	bool sampleMesh;$/;"	m	class:FaceSet
sampleMesh	SubDomain.h	/^  bool sampleMesh;$/;"	m	class:SubDomain
sampleNodes	NonlinearRom.h	/^  std::vector<int> sampleNodes;$/;"	m	class:NonlinearRom
sampleNodes_	RestrictionMapping.h	/^  std::set<int> sampleNodes_;$/;"	m	class:RestrictionMapping
sampledApproxMetricNonlinearSnapsName	IoData.h	/^  const char *sampledApproxMetricNonlinearSnapsName;$/;"	m	struct:NonlinearRomFilesData
sampledApproxMetricNonlinearSnapsName	NonlinearRom.h	/^  char* sampledApproxMetricNonlinearSnapsName;$/;"	m	class:NonlinearRom
sampledCentersName	IoData.h	/^  const char *sampledCentersName;$/;"	m	struct:NonlinearRomFilesData
sampledCentersName	NonlinearRom.h	/^  char* sampledCentersName;$/;"	m	class:NonlinearRom
sampledDisplacementName	IoData.h	/^  const char *sampledDisplacementName;  \/\/ sampled initial displacement vector$/;"	m	struct:NonlinearRomFilesData
sampledDisplacementName	NonlinearRom.h	/^  char* sampledDisplacementName;$/;"	m	class:NonlinearRom
sampledJacActionBasisName	IoData.h	/^  const char *sampledJacActionBasisName; \/\/podFileJacHat;$/;"	m	struct:NonlinearRomFilesData
sampledJacActionBasisName	NonlinearRom.h	/^  char* sampledJacActionBasisName;$/;"	m	class:NonlinearRom
sampledKrylovBasisName	IoData.h	/^  const char *sampledKrylovBasisName;$/;"	m	struct:NonlinearRomFilesData
sampledKrylovBasisName	NonlinearRom.h	/^  char* sampledKrylovBasisName;$/;"	m	class:NonlinearRom
sampledMatchStateName	IoData.h	/^  const char *sampledMatchStateName;      \/\/comparison state;$/;"	m	struct:NonlinearRomFilesData
sampledMatchStateName	NonlinearRom.h	/^  char* sampledMatchStateName;$/;"	m	class:NonlinearRom
sampledMeshConstruction	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
sampledMeshFraction	IoData.h	/^  double sampledMeshFraction;$/;"	m	struct:ApproximatedMetricData
sampledMeshName	IoData.h	/^  const char *sampledMeshName;          \/\/mesh;$/;"	m	struct:NonlinearRomFilesData
sampledMeshName	NonlinearRom.h	/^  char* sampledMeshName;$/;"	m	class:NonlinearRom
sampledMeshTargetRegion	IoData.h	/^  SchemeFixData sampledMeshTargetRegion;  \/\/ use fix regions to specify target areas for sampled mesh construction$/;"	m	struct:GappyConstructionData
sampledMeshUsed	IoData.h	/^  enum SampledMeshUsed {SAMPLED_MESH_NOT_USED = 0, SAMPLED_MESH_USED = 1} sampledMeshUsed;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::SampledMeshUsed
sampledMultiSolutionsName	IoData.h	/^  const char *sampledMultiSolutionsName; \/\/ multiple solutions. Can start from one, or an arbitrary linear combination.$/;"	m	struct:NonlinearRomFilesData
sampledMultiSolutionsName	NonlinearRom.h	/^  char* sampledMultiSolutionsName;$/;"	m	class:NonlinearRom
sampledNodeDistInfo	Domain.h	/^  DistInfo *sampledNodeDistInfo;$/;"	m	class:Domain
sampledNodesFactor	IoData.h	/^  double sampledNodesFactor;$/;"	m	struct:GappyConstructionData
sampledNodesFullCoordsName	IoData.h	/^  const char *sampledNodesFullCoordsName; \/\/ sampled nodes in full mesh coordinates$/;"	m	struct:NonlinearRomFilesData
sampledNodesFullCoordsName	NonlinearRom.h	/^  char* sampledNodesFullCoordsName;$/;"	m	class:NonlinearRom
sampledNodesName	IoData.h	/^  const char *sampledNodesName;         \/\/sampleNodes;$/;"	m	struct:NonlinearRomFilesData
sampledNodesName	NonlinearRom.h	/^  char* sampledNodesName;$/;"	m	class:NonlinearRom
sampledOutput	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
sampledRefStateName	IoData.h	/^  const char *sampledRefStateName;$/;"	m	struct:NonlinearRomFilesData
sampledRefStateName	NonlinearRom.h	/^  char* sampledRefStateName;$/;"	m	class:NonlinearRom
sampledResidualBasisName	IoData.h	/^  const char *sampledResidualBasisName; \/\/podFileResHat;$/;"	m	struct:NonlinearRomFilesData
sampledResidualBasisName	NonlinearRom.h	/^  char* sampledResidualBasisName;$/;"	m	class:NonlinearRom
sampledSensitivityBasisName	IoData.h	/^  const char *sampledSensitivityBasisName;$/;"	m	struct:NonlinearRomFilesData
sampledSensitivityBasisName	NonlinearRom.h	/^  char* sampledSensitivityBasisName;$/;"	m	class:NonlinearRom
sampledShapeDerivativeName	IoData.h	/^  const char *sampledShapeDerivativeName;      $/;"	m	struct:NonlinearRomFilesData
sampledShapeDerivativeName	NonlinearRom.h	/^  char* sampledShapeDerivativeName;$/;"	m	class:NonlinearRom
sampledSolutionName	IoData.h	/^  const char *sampledSolutionName;      \/\/solution;$/;"	m	struct:NonlinearRomFilesData
sampledSolutionName	NonlinearRom.h	/^  char* sampledSolutionName;$/;"	m	class:NonlinearRom
sampledStateBasisName	IoData.h	/^  const char *sampledStateBasisName;    \/\/podStateRed;$/;"	m	struct:NonlinearRomFilesData
sampledStateBasisName	NonlinearRom.h	/^  char* sampledStateBasisName;$/;"	m	class:NonlinearRom
sampledWallDistName	IoData.h	/^  const char *sampledWallDistName;      \/\/wallDistanceRed;$/;"	m	struct:NonlinearRomFilesData
sampledWallDistName	NonlinearRom.h	/^  char* sampledWallDistName;$/;"	m	class:NonlinearRom
sasum_	arpack++/include/arlnames.h	142;"	d
sasum_	arpack++/include/arlnames.h	71;"	d
saupp	arpack++/include/saupp.h	/^inline void saupp(ARint& ido, char bmat, ARint n, char* which, ARint nev,$/;"	f
saveNewtonSystemVectors	ImplicitPGTsDesc.h	/^  void saveNewtonSystemVectors(const int totalTimeSteps) {this->saveNewtonSystemVectorsAction(totalTimeSteps);}$/;"	f	class:ImplicitPGTsDesc
saveNewtonSystemVectors	ImplicitRomPostproTsDesc.h	/^  void saveNewtonSystemVectors(const int totalTimeSteps) {this->saveNewtonSystemVectorsAction(totalTimeSteps);}$/;"	f	class:ImplicitRomPostproTsDesc
saveNewtonSystemVectors	ImplicitRomTsDesc.h	/^  virtual void saveNewtonSystemVectors(const int _it) {};	\/\/ only implemented for PG\/Galerkin$/;"	f	class:ImplicitRomTsDesc
saveNewtonSystemVectorsAction	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::saveNewtonSystemVectorsAction(const int totalTimeSteps) {$/;"	f	class:ImplicitRomTsDesc
saved_state	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    PAIR<T,GEOMETRY_PARTICLES<TV>*> saved_state;$/;"	m	class:PhysBAM::PhysBAMInterface
saxpy_	arpack++/include/arlnames.h	150;"	d
saxpy_	arpack++/include/arlnames.h	79;"	d
sbmv	arpack++/include/blas1c.h	/^inline void sbmv(const char* uplo, const ARint &n, const ARint &k, $/;"	f
scFlag	IoData.h	/^  enum SensitivityComputation {ANALYTICAL = 0, SEMIANALYTICAL = 1,  FINITEDIFFERENCE = 2} scFlag;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityComputation
scal	arpack++/include/blas1c.h	/^inline void scal(const ARint &n, const arcomplex<double> &da,$/;"	f
scal	arpack++/include/blas1c.h	/^inline void scal(const ARint &n, const arcomplex<float> &da,$/;"	f
scal	arpack++/include/blas1c.h	/^inline void scal(const ARint &n, double &da, double dx[], const ARint &incx) {$/;"	f
scal	arpack++/include/blas1c.h	/^inline void scal(const ARint &n, float &da, float dx[], const ARint &incx) {$/;"	f
scalComp0	Vector.h	/^  static int scalComp0(const void* a, const void* b) {$/;"	f	class:SVec
scalComp0	Vector.h	/^  static int scalComp0(const void* a, const void* b) {$/;"	f	class:Vec
scalComp1	Vector.h	/^  static int scalComp1(const void* a, const void* b) {$/;"	f	class:SVec
scalComp1	Vector.h	/^  static int scalComp1(const void* a, const void* b) {$/;"	f	class:Vec
scalapackCpuDecomp	ParallelRom.C	/^void ParallelRom<dim>::scalapackCpuDecomp(const int nCol) {$/;"	f	class:ParallelRom
scalapackSVD	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::scalapackSVD(VecSet< DistSVec<double, dim> >*& snapshots, VecSet< DistSVec<double, dim> > &Utrue,$/;"	f	class:NonlinearRomDatabaseConstruction
scalar	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_EXPRESSION.h	/^    T1 scalar;$/;"	m	class:PhysBAM::VECTOR_SCALE
scalarEdgePat	Domain.h	/^  CommPattern<double> *scalarEdgePat;$/;"	m	class:Domain
scalarNormalExtrap	SubDomainCore.C	/^double SubDomain::scalarNormalExtrap(double* value, Vec3D target, Vec3D normal, int myTet, SVec<double,3> &X, bool check = 0)$/;"	f	class:SubDomain
scalar_zero	MultiGridOperator.h	/^  DistVec<Scalar>* scalar_zero;$/;"	m	class:MultiGridOperator
scalars	OneDimensionalSolver.h	/^  char *scalars[PostFcn::SSIZE];$/;"	m	class:OneDimensional
scalars	TsOutput.h	/^    char *scalars[PostFcn::SSIZE];$/;"	m	struct:TsOutput::line_output
scalars	TsOutput.h	/^  char *scalars[PostFcn::SSIZE];$/;"	m	class:TsOutput
scale	SparseGridCore.C	/^void SparseGrid::scale(const double *subGrid, double *scaledCoord, const int op) const{$/;"	f	class:SparseGrid
scaleGrid	SparseGridCore.C	/^void SparseGrid::scaleGrid(const double *refIn, const double *refOut, int outputRangeFlag){$/;"	f	class:SparseGrid
scaleSolution	Domain.C	/^void Domain::scaleSolution(DistSVec<Scalar,dim> &data, RefVal* refVal)  {$/;"	f	class:Domain
scale_expansion	utils/Predicate.C	/^int scale_expansion(int elen, REAL *e, REAL b, REAL *h)            $/;"	f
scale_expansion_zeroelim	utils/Predicate.C	/^int scale_expansion_zeroelim(int elen, REAL *e, REAL b, REAL *h)   $/;"	f
scasum_	arpack++/include/arlnames.h	103;"	d
scasum_	arpack++/include/arlnames.h	174;"	d
schemes	IoData.h	/^  SchemesData schemes;$/;"	m	class:IoData
scnrm2_	arpack++/include/arlnames.h	107;"	d
scnrm2_	arpack++/include/arlnames.h	178;"	d
sconst	AutoDiff/SpaceDerivatives.h	/^                       FunctionTemplate<Scalar>::NumberOfScalarConstants,1>& sconst;$/;"	m	class:FirstPartialSpaceDerivatives
sconst	AutoDiff/SpaceDerivatives.h	/^                       FunctionTemplate<Scalar>::NumberOfScalarConstants,1>& sconst;$/;"	m	class:SpatialView
sconst	AutoDiff/SpaceDerivatives.h	/^                       VectorValuedFunctionTemplate<Scalar>::NumberOfScalarConstants,1>& sconst;$/;"	m	class:Jacobian
sconst	AutoDiff/SpaceDerivatives.h	/^    Eigen::Array<typename Base::ScalarConstantType, FunctionTemplate<Scalar>::NumberOfScalarConstants, 1> sconst;$/;"	m	class:JacobianVectorProduct
sconst	AutoDiff/roeturkeljac5.h	/^    const Eigen::Array<double,18,1> &sconst;$/;"	m	class:RoeTurkelFlux5Function
scope	IntersectorFRG/IntersectorFRG.h	/^    set<int> scope;$/;"	m	class:IntersectorFRG
scope	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ARRAY<int> scope;$/;"	m	struct:PhysBAM::SubDInterface
scopeDepth	DistVMSLESTerm.h	/^  int scopeDepth;$/;"	m	class:DistVMSLESTerm
scopeDepth1	DistDynamicVMSTerm.h	/^  int          scopeWidth, scopeDepth1, scopeDepth2;$/;"	m	class:DistDynamicVMSTerm
scopeDepth2	DistDynamicVMSTerm.h	/^  int          scopeWidth, scopeDepth1, scopeDepth2;$/;"	m	class:DistDynamicVMSTerm
scopeWidth	DistDynamicVMSTerm.h	/^  int          scopeWidth, scopeDepth1, scopeDepth2;$/;"	m	class:DistDynamicVMSTerm
scopeWidth	DistVMSLESTerm.h	/^  int scopeWidth;$/;"	m	class:DistVMSLESTerm
scope_identifier	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    std::string scope_identifier;$/;"	m	class:PhysBAM::LOG_REAL::LOG_SCOPE
scoped_triangle_mesh	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    TRIANGLE_MESH* scoped_triangle_mesh;$/;"	m	struct:PhysBAM::SubDInterface
scopy_	arpack++/include/arlnames.h	144;"	d
scopy_	arpack++/include/arlnames.h	73;"	d
sdot_	arpack++/include/arlnames.h	149;"	d
sdot_	arpack++/include/arlnames.h	78;"	d
se_t	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef IS_ENUM_HELPER<selector> se_t;$/;"	t	struct:PhysBAM::IS_ENUM_IMPL
search	RTree.h	/^	  T* search(T2* obj, Node* n, SVec<double,3>& X, Vec3D& loc) $/;"	f	class:RTree
search	RTree.h	/^	  T* search(T2* obj, SVec<double,3>& X, Vec3D& loc) $/;"	f	class:RTree
searchPoint	SubDomainCore.C	/^Elem* SubDomain::searchPoint(Vec3D Xp, SVec<double,3>& X) {$/;"	f	class:SubDomain
second	arpack++/include/lapackc.h	/^inline void second(const float &t) {$/;"	f
seek	BinFileHandler.h	/^void BinFileHandler::seek(BinFileHandler::OffType size) $/;"	f	class:BinFileHandler
segfault_sigaction	Main.C	/^void segfault_sigaction(int signal, siginfo_t *si, void *arg)$/;"	f
segment_mesh	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    SEGMENT_MESH* segment_mesh; \/\/ segment mesh consisting of all the edges$/;"	m	class:PhysBAM::TRIANGLE_MESH
segments	tools/alloca.cougar.c	/^    long segments;		\/* Current number of stack segments.  *\/$/;"	m	struct:stk_stat	file:
selectSampledNodes	IoData.h	/^  enum SelectSampledNodes {SELECT_SAMPLED_NODES_FALSE = 0, SELECT_SAMPLED_NODES_TRUE = 1} selectSampledNodes;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::SelectSampledNodes
selector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool selector=OR<OR<IS_SCALAR<T>::value,IS_REFERENCE<T>::value,IS_FUNCTION<T>::value,IS_CLASS<T>::value>::value,IS_ARRAY<T>::value>::value;$/;"	m	struct:PhysBAM::IS_ENUM_IMPL
selector	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef IS_CONVERTIBLE_IMPL_SELECT<IS_SCALAR<T1>::value,IS_SCALAR<T2>::value> selector;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_DISPATCH_BASE
semi_infinite	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    bool semi_infinite; \/\/ indicates whether the ray is semi_infinite or should stop at t_max$/;"	m	class:PhysBAM::RAY
send	MatchNode.C	/^void MatchNodeSet::send(double scale, double (*f)[dim], double (*buffer)[dim])$/;"	f	class:MatchNodeSet
sendData	Communicator.C	/^CommPattern<T>::sendData(int channel, T *data)$/;"	f	class:CommPattern
sendDisplacement	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendDisplacement(Communication::Window<double> *window)$/;"	f	class:EmbeddedStructure
sendFluidSuggestedTimestep	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::sendFluidSuggestedTimestep(double dtf0)$/;"	f	class:DynamicNodalTransfer
sendFluidSuggestedTimestep	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendFluidSuggestedTimestep(double dtf0)$/;"	f	class:EmbeddedStructure
sendFluidSuggestedTimestep	StructExc.C	/^void StructExc::sendFluidSuggestedTimestep(double dtf0)$/;"	f	class:StructExc
sendForce	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::sendForce()$/;"	f	class:DynamicNodalTransfer
sendForce	StructExc.C	/^void StructExc::sendForce(DistSVec<double,3> &F, bool applyScale)$/;"	f	class:StructExc
sendForceSensitivity	MeshMotionHandler.h	/^  virtual void sendForceSensitivity(DistSVec<double,3> *, bool applyScale = true) {}$/;"	f	class:MeshMotionHandler
sendForceSensitivity	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::sendForceSensitivity(DistSVec<double,3> *dFdS, bool applyScale)$/;"	f	class:AeroMeshMotionHandler
sendForceSensitivity	TsDesc.C	/^void TsDesc<dim>::sendForceSensitivity(DistSVec<double,3> *dFdS, bool applyScale)$/;"	f	class:TsDesc
sendHeatPower	StructExc.C	/^void StructExc::sendHeatPower(DistVec<double>& P) $/;"	f	class:StructExc
sendInfo	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendInfo(Communication::Window<double> *window)$/;"	f	class:EmbeddedStructure
sendInitialPosition	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendInitialPosition(Communication::Window<double> *window)$/;"	f	class:EmbeddedStructure
sendLocalForce	SubDomainCore.C	/^void SubDomain::sendLocalForce(Vec3D flocal, LevelSetResult& lsRes, double(*Fs)[3])$/;"	f	class:SubDomain
sendMaxTime	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendMaxTime(Communication::Window<double> *window)$/;"	f	class:EmbeddedStructure
sendNumParam	MeshMotionHandler.h	/^  virtual void sendNumParam(int) {}$/;"	f	class:MeshMotionHandler
sendNumParam	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::sendNumParam(int numParam)$/;"	f	class:AeroMeshMotionHandler
sendNumParam	StructExc.C	/^void StructExc::sendNumParam(int numParam)$/;"	f	class:StructExc
sendNumParam	TsDesc.C	/^void TsDesc<dim>::sendNumParam(int numParam)$/;"	f	class:TsDesc
sendSubcyclingInfo	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendSubcyclingInfo(\/*Communication::Window<int> *window*\/)$/;"	f	class:EmbeddedStructure
sendTimeStep	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::sendTimeStep(Communication::Window<double> *window)$/;"	f	class:EmbeddedStructure
sendTo	Communicator.C	/^void Communicator::sendTo(int cpu, int tag, Scalar *buffer, int len)$/;"	f	class:Communicator
sendWithMasterFlag	MatchNode.C	/^void MatchNodeSet::sendWithMasterFlag(double scale, double (*f)[dim], double (*buffer)[dim], bool *masterFlag, int locOffset)$/;"	f	class:MatchNodeSet
sensAlpha	IoData.h	/^  enum SensitivityAOA {OFF_SENSITIVITYALPHA = 0, ON_SENSITIVITYALPHA = 1} sensAlpha;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityAOA
sensBeta	IoData.h	/^  enum SensitivityYAW {OFF_SENSITIVITYBETA = 0, ON_SENSITIVITYBETA = 1} sensBeta;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityYAW
sensFSI	IoData.h	/^  enum SensitivityFSI  {OFF_SENSITIVITYFSI  = 0, ON_SENSITIVITYFSI  = 1} sensFSI;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityFSI
sensLiftx	IoData.h	/^  enum SensitivityLiftx {OFF_SENSITIVITYLIFTX = 0, ON_SENSITIVITYLIFTX = 1} sensLiftx;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityLiftx
sensLifty	IoData.h	/^  enum SensitivityLifty {OFF_SENSITIVITYLIFTY = 0, ON_SENSITIVITYLIFTY = 1} sensLifty;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityLifty
sensLiftz	IoData.h	/^  enum SensitivityLiftz {OFF_SENSITIVITYLIFTZ = 0, ON_SENSITIVITYLIFTZ = 1} sensLiftz;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityLiftz
sensMach	IoData.h	/^  enum SensitivityMach {OFF_SENSITIVITYMACH = 0, ON_SENSITIVITYMACH = 1} sensMach;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityMach
sensMesh	IoData.h	/^  enum SensitivityMesh {OFF_SENSITIVITYMESH = 0, ON_SENSITIVITYMESH = 1} sensMesh;$/;"	m	struct:SensitivityAnalysis	typeref:enum:SensitivityAnalysis::SensitivityMesh
sensitivity	IoData.h	/^  NonlinearRomOnlineNonStateData sensitivity;$/;"	m	struct:NonlinearRomOnlineData
sensitivity	IoData.h	/^  NonlinearRomOnlineNonStateData sensitivity;$/;"	m	struct:RelativeProjectionErrorData
sensitivity	IoData.h	/^  SensitivityData sensitivity;$/;"	m	struct:ROBConstructionData
sensitivityBasis	NonlinearRom.h	/^  VecSet<DistSVec<double, dim> >* sensitivityBasis;$/;"	m	class:NonlinearRom
sensitivityBasisCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<std::vector<double> > > sensitivityBasisCentersDifProduct;          \/\/[mCenter][pCenter][:]$/;"	m	class:NonlinearRom
sensitivityBasisName	IoData.h	/^  const char *sensitivityBasisName;$/;"	m	struct:NonlinearRomFilesData
sensitivityBasisName	NonlinearRom.h	/^  char* sensitivityBasisName;$/;"	m	class:NonlinearRom
sensitivityBasisPrefix	IoData.h	/^  const char *sensitivityBasisPrefix;$/;"	m	struct:NonlinearRomFilesData
sensitivityBasisPrefix	NonlinearRom.h	/^  char* sensitivityBasisPrefix;$/;"	m	class:NonlinearRom
sensitivityClusterName	IoData.h	/^  const char *sensitivityClusterName;$/;"	m	struct:NonlinearRomDirectoriesData
sensitivityClusterName	NonlinearRom.h	/^  const char* sensitivityClusterName;$/;"	m	class:NonlinearRom
sensitivityDistanceComparisonInfoName	IoData.h	/^  const char *sensitivityDistanceComparisonInfoName;$/;"	m	struct:NonlinearRomFilesData
sensitivityDistanceComparisonInfoName	NonlinearRom.h	/^  char* sensitivityDistanceComparisonInfoName;$/;"	m	class:NonlinearRom
sensitivityFlag	MeshMotionSolver.h	/^  bool sensitivityFlag;$/;"	m	class:TetMeshMotionSolver
sensitivityPrefix	IoData.h	/^  const char *sensitivityPrefix;$/;"	m	struct:NonlinearRomFilesData
sensitivitySVals	NonlinearRom.h	/^  std::vector<double>* sensitivitySVals;$/;"	m	class:NonlinearRom
sensitivitySingValsName	IoData.h	/^  const char *sensitivitySingValsName;$/;"	m	struct:NonlinearRomFilesData
sensitivitySingValsName	NonlinearRom.h	/^  char* sensitivitySingValsName;$/;"	m	class:NonlinearRom
sensitivitySnapFile	IoData.h	/^  const char *sensitivitySnapFile;$/;"	m	struct:InputData
sensitivitySnapsName	IoData.h	/^  const char *sensitivitySnapsName;$/;"	m	struct:NonlinearRomFilesData
sensitivitySnapsName	NonlinearRom.h	/^  char* sensitivitySnapsName;$/;"	m	class:NonlinearRom
sensor	DistNodalGrad.h	/^  DistSVec<Scalar,3>* sensor;$/;"	m	class:DistNodalGrad
sensoutput	IoData.h	/^  const char* sensoutput;$/;"	m	struct:SensitivityAnalysis
ser	IoData.h	/^  double ser;$/;"	m	struct:CFLData
ser	IoData.h	/^  double ser;$/;"	m	struct:TsData
ser	TsParameters.h	/^  double ser;$/;"	m	class:TsParameters
serialLSMultiRHSGap	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::serialLSMultiRHSGap(int iPodBasis, double **lsCoeff) {$/;"	f	class:GappyPreprocessing
serialPseudoInverse	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::serialPseudoInverse(int iPodBasis) {$/;"	f	class:GappyPreprocessing
set	AlternatingLeastSquare/als_util.cpp	/^double& set(double *M, int m, int n, int r, int c) {$/;"	f
set	DistVector.h	/^DistSVec<Scalar,dim>::set(const Scalar *y)$/;"	f	class:DistSVec
set	GhostPoint.h	/^void set(double *Vf, int tag)$/;"	f	class:GhostPoint
set	MemoryPool.C	/^void MemoryPool::set(int nbytes, void *p)$/;"	f	class:MemoryPool
set	Vector.h	/^SVec<Scalar,dim>::set(const Scalar *y)$/;"	f	class:SVec
setA	MultiGridKspSolver.h	/^  void setA(DistMat<Scalar,neq>* A) { macroA = A; } $/;"	f	class:MultiGridMatVecProd
setAdjointFlagOn	MeshMotionSolver.h	/^  virtual void setAdjointFlagOn() {}$/;"	f	class:MeshMotionSolver
setAdjointFlagOn	MeshMotionSolver.h	/^  void setAdjointFlagOn() { adjointFlag = true; }$/;"	f	class:TetMeshMotionSolver
setBCond	SubDomain.h	/^  void setBCond(BCondSet *subBC) { mmsBCs = subBC; }$/;"	f	class:SubDomain
setBcFcn	SpaceOperator.C	/^void SpaceOperator<dim>::setBcFcn(BcFcn *bf)$/;"	f	class:SpaceOperator
setBit	IoData.h	/^  void setBit(int b) { sBit = b; }$/;"	f	struct:SurfaceData
setBoundaryConditionsGas	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsGas(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsGasGas	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsGasGas(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsGasLiquid	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsGasLiquid(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsJWL	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsJWL(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsJWLGas	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsJWLGas(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsJWLLiquid	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsJWLLiquid(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsLiquid	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsLiquid(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsLiquidGas	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsLiquidGas(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryConditionsLiquidLiquid	DistBcData.C	/^void DistBcDataEuler<dim>::setBoundaryConditionsLiquidLiquid(IoData &iod,$/;"	f	class:DistBcDataEuler
setBoundaryStateVectorHH	BcData.h	/^  void setBoundaryStateVectorHH(Vec<double>* hh) { boundaryStateHH = hh; }$/;"	f	class:BcData
setBufferPosition	MatchNodeCore.C	/^void MatchNodeSet::setBufferPosition(int i, int elempos, double pos[2], int (*stElem)[3], double (*xs)[3])$/;"	f	class:MatchNodeSet
setBufferPosition	MatchNodeCore.C	/^void MatchNodeSet::setBufferPosition(int i, int pos)$/;"	f	class:MatchNodeSet
setCJInitialState	ProgrammedBurn.C	/^void ProgrammedBurn::setCJInitialState(ProgrammedBurn::Burn& B,VarFcn* vf,DistSVec<double,dim>& U,DistVec<int>& fid,DistVec<int>& fidn) {$/;"	f	class:ProgrammedBurn
setCJInitialState	ProgrammedBurn.C	/^void ProgrammedBurn::setCJInitialState(ProgrammedBurn::Burn& B,VarFcn* vf,SVec<double,dim>& U,Vec<int>& fid,Vec<int>& fidn) {$/;"	f	class:ProgrammedBurn
setChannelNums	SubDomainCore.C	/^void SubDomain::setChannelNums(SubDTopo &subTopo)$/;"	f	class:SubDomain
setComLenEdges	SubDomain.C	/^void SubDomain::setComLenEdges(int dim, CommPattern<Scalar> &cp)$/;"	f	class:SubDomain
setComLenInletNodes	SubDomain.C	/^void SubDomain::setComLenInletNodes(int dim, CommPattern<Scalar> &cp)$/;"	f	class:SubDomain
setComLenNodes	SubDomain.C	/^void SubDomain::setComLenNodes(int dim, CommPattern<Scalar> &cp)$/;"	f	class:SubDomain
setCurrentState	KspBinaryOutput.C	/^void KspBinaryOutput<VecType>::setCurrentState(VecType &state) {$/;"	f	class:KspBinaryOutput
setCurrentStateForKspBinaryOutput	ImplicitEmbeddedRomTsDesc.h	/^    void setCurrentStateForKspBinaryOutput(DistSVec<double, dim> &Q) { super::setCurrentStateForKspBinaryOutput(Q); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
setCurrentStateForKspBinaryOutput	ImplicitEmbeddedTsDesc.h	/^  void setCurrentStateForKspBinaryOutput(DistSVec<double,dim> &Q) {}$/;"	f	class:ImplicitEmbeddedTsDesc
setCurrentStateForKspBinaryOutput	ImplicitLevelSetTsDesc.h	/^  void setCurrentStateForKspBinaryOutput(DistSVec<double,dim> &Q) {}$/;"	f	class:ImplicitLevelSetTsDesc
setCurrentStateForKspBinaryOutput	ImplicitMultiPhysicsTsDesc.h	/^  void setCurrentStateForKspBinaryOutput(DistSVec<double,dim> &Q) {}$/;"	f	class:ImplicitMultiPhysicsTsDesc
setCurrentStateForKspBinaryOutput	ImplicitTsDesc.h	/^  void setCurrentStateForKspBinaryOutput(DistSVec<double,dim> &Q) {if (kspBinaryOutput) kspBinaryOutput->setCurrentState(Q);}$/;"	f	class:ImplicitTsDesc
setCurrentStateForKspBinaryOutput	MeshMotionSolver.h	/^  void setCurrentStateForKspBinaryOutput(DistSVec<double,3>&) {}$/;"	f	class:TetMeshMotionSolver
setCurrentTime	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::setCurrentTime(double t,DistSVec<double,dim>& U) { $/;"	f	class:EmbeddedTsDesc
setCurrentTime	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::setCurrentTime(double t,DistSVec<double,dim>& U) { $/;"	f	class:LevelSetTsDesc
setCurrentTime	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::setCurrentTime(double t,DistSVec<double,dim>& U) { $/;"	f	class:MultiPhysicsTsDesc
setCurrentTime	ProgrammedBurn.C	/^void ProgrammedBurn::setCurrentTime(double t,VarFcn* vf,DistSVec<double,dim>& U,DistVec<int>& fid,DistVec<int>& fidn) {$/;"	f	class:ProgrammedBurn
setCurrentTime	ProgrammedBurn.C	/^void ProgrammedBurn::setCurrentTime(double t,VarFcn* vf,SVec<double,dim>& U,Vec<int>& fid,Vec<int>& fidn) {$/;"	f	class:ProgrammedBurn
setCurrentTime	TsDesc.h	/^  virtual void setCurrentTime(double t,DistSVec<double,dim>& U) { }$/;"	f	class:TsDesc
setCurrentTimeStep	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::setCurrentTimeStep(double dt) { $/;"	f	class:EmbeddedTsDesc
setCurrentTimeStep	TsDesc.h	/^  virtual void setCurrentTimeStep(double dt) { }$/;"	f	class:TsDesc
setDFSPAR	FluidShapeOptimizationHandler.C	/^void FluidShapeOptimizationHandler<dim>::setDFSPAR(IoData &ioData)$/;"	f	class:FluidShapeOptimizationHandler
setDensity	VarFcn.h	/^  void setDensity(const double density, double *V, int tag=0) { check(tag); return varFcn[tag]->setDensity(density,V); }$/;"	f	class:VarFcn
setDensity	VarFcn.h	/^  void setDensity(double *V, double *Vorig, int tag=0) { check(tag); return varFcn[tag]->setDensity(V,Vorig); }$/;"	f	class:VarFcn
setDensity	VarFcnBase.h	/^  virtual void setDensity(const double density, double *V) { V[0] = density; }$/;"	f	class:VarFcnBase
setDensity	VarFcnBase.h	/^  virtual void setDensity(double *V, double *Vorig) { V[0] = Vorig[0]; }$/;"	f	class:VarFcnBase
setDerivativeOfBoundaryConditionsGas	DistBcData.C	/^void DistBcDataEuler<dim>::setDerivativeOfBoundaryConditionsGas(IoData &iod,$/;"	f	class:DistBcDataEuler
setDofType	BCApplierCore.C	/^BCApplier::setDofType(MatchNodeSet** matchNodes)$/;"	f	class:BCApplier
setDt	DistTimeState.h	/^    void setDt(double dt){ *(this->dt) = dt; }$/;"	f	class:DistTimeState
setDtMin	DistTimeState.h	/^  void setDtMin(double dt){dtMin = dt;}$/;"	f	class:DistTimeState
setDtNm1	DistTimeState.C	/^void DistTimeState<dim>::setDtNm1(double dt) {$/;"	f	class:DistTimeState
setEdgeNum	FaceTria.h	/^  void setEdgeNum(int edge_id, int l) { edgeNumT[edge_id] = l; }$/;"	f	class:FaceTria
setElementNumber	FaceCore.C	/^void Face::setElementNumber(int num, int rotDir)$/;"	f	class:Face
setEmbeddedALEDofType	BCApplierCore.C	/^BCApplier::setEmbeddedALEDofType(MatchNodeSet** matchNodes)$/;"	f	class:BCApplier
setEps	KspSolver.h	/^  void setEps(double e) { eps = e; }$/;"	f	class:KspSolver
setExactBoundaryJacobian	Domain.C	/^void Domain::setExactBoundaryJacobian(DistSVec<double,dim>& U, DistSVec<double,3>& X,$/;"	f	class:Domain
setExactBoundaryResidual	Domain.C	/^void Domain::setExactBoundaryResidual(DistSVec<double,dim>& U, DistSVec<double,3>& X,$/;"	f	class:Domain
setExactBoundaryValues	Domain.C	/^void Domain::setExactBoundaryValues(DistSVec<double,dim>& U, DistSVec<double,3>& X,$/;"	f	class:Domain
setExactSquare	TriangulatedInterface.C	/^void TriangulatedInterface::setExactSquare(double loc, double vel) {$/;"	f	class:TriangulatedInterface
setExistsNm1	DistTimeState.C	/^void DistTimeState<dim>::setExistsNm1() {$/;"	f	class:DistTimeState
setFEGhostPoint	HigherOrderFSI.C	/^bool HigherOrderFSI::setFEGhostPoint(int dir, int i, VarFcn *varFun, SVec<double,dim>& U, $/;"	f	class:HigherOrderFSI
setFEMstencil	Domain.C	/^void Domain::setFEMstencil(DistSVec<double,3> &X, DistLevelSetStructure *distLSS, DistVec<int> &fluidId, DistSVec<double,dim> &U)$/;"	f	class:Domain
setFEMstencil	HigherOrderFSI.C	/^void HigherOrderFSI::setFEMstencil(V6NodeData *FEMstencilData_p,$/;"	f	class:HigherOrderFSI
setFEMstencil	SpaceOperator.C	/^void SpaceOperator<dim>::setFEMstencil(DistSVec<double,3> &X, DistLevelSetStructure *distLSS, DistVec<int> &fluidId, DistSVec<double,dim> &U)$/;"	f	class:SpaceOperator
setFEMstencil	SubDomain.C	/^void SubDomain::setFEMstencil(SVec<double,3> &X, LevelSetStructure &LSS, $/;"	f	class:SubDomain
setFaceToElementConnectivity	DomainCore.C	/^void Domain::setFaceToElementConnectivity()$/;"	f	class:Domain
setFaceToElementConnectivity	ElemCore.C	/^int Elem::setFaceToElementConnectivity(int i, Vec<bool> &tagNodes, $/;"	f	class:Elem
setFaceToElementConnectivity	SubDomainCore.C	/^int SubDomain::setFaceToElementConnectivity()$/;"	f	class:SubDomain
setFaceType	SubDomainCore.C	/^void SubDomain::setFaceType(int *facemap)$/;"	f	class:SubDomain
setFailSafe	TsDesc.h	/^  void setFailSafe(bool flag){ failSafeFlag = flag; }$/;"	f	class:TsDesc
setFarFieldMask	DomainCore.C	/^void Domain::setFarFieldMask(DistVec<double>& ffMask, DistVec<double>& neighborMask) {$/;"	f	class:Domain
setFarFieldMask	SubDomainCore.C	/^void SubDomain::setFarFieldMask(Vec<double>& ffMask, Vec<double>& neighborMask){$/;"	f	class:SubDomain
setFarFieldNodes	SubDomainCore.C	/^void SubDomain::setFarFieldNodes()$/;"	f	class:SubDomain
setFemEquationTerm	SpaceOperator.C	/^void SpaceOperator<dim>::setFemEquationTerm(FemEquationTerm *fem)$/;"	f	class:SpaceOperator
setFluidIds	ProgrammedBurnCore.C	/^void ProgrammedBurn::setFluidIds(double t, DistVec<int>& fluidIds,DistSVec<double,5>& U) {$/;"	f	class:ProgrammedBurn
setFluidIds	ProgrammedBurnCore.C	/^void ProgrammedBurn::setFluidIds(double t, Vec<int>& fluidIds,SVec<double,5>& U) {$/;"	f	class:ProgrammedBurn
setFluidSubcycling	EmbeddedTsDesc.h	/^  virtual void setFluidSubcycling(bool inSub) {inSubCycling = inSub;}$/;"	f	class:EmbeddedTsDesc
setFluidSubcycling	MultiPhysicsTsDesc.h	/^  virtual void setFluidSubcycling(bool inSub) {inSubCycling = inSub;}$/;"	f	class:MultiPhysicsTsDesc
setFluidSubcycling	TsDesc.h	/^  virtual void setFluidSubcycling(bool inSub) { }$/;"	f	class:TsDesc
setFluxFcn	SpaceOperator.C	/^void SpaceOperator<dim>::setFluxFcn(FluxFcn **ff)$/;"	f	class:SpaceOperator
setForceGenerator	PostOperator.h	/^  void setForceGenerator(ForceGenerator<dim> *fg) { forceGen = fg; }$/;"	f	class:PostOperator
setGhost	DistEmbeddedVector.h	/^void DistEmbeddedVec<Scalar,dim>::setGhost(DistVec<GhostPoint<dim>*>& gp,VarFcn* vf) {$/;"	f	class:DistEmbeddedVec
setGhostOccludedValue	ElemTet.C	/^double* ElemTet::setGhostOccludedValue(int i, SVec<double,3> &X, $/;"	f	class:ElemTet
setGhostStencil	DistEmbeddedVector.h	/^void DistEmbeddedVec<Scalar,dim>::setGhostStencil(DistVec<GhostPoint<dim>*>& gp) {$/;"	f	class:DistEmbeddedVec
setGlobalTimeStep	DistTimeState.h	/^  void setGlobalTimeStep (double t) { *dt = t; }$/;"	f	class:DistTimeState
setHH	DistEmbeddedVector.h	/^void DistEmbeddedVec<Scalar,dim>::setHH(DistVec<Scalar>& hh) {$/;"	f	class:DistEmbeddedVec
setHHCoeffPointer	FluxFcn.h	/^  void setHHCoeffPointer(double* hh) { $/;"	f	class:FluxFcn
setHHCoeffPointer	FluxFcnBase.h	/^  void setHHCoeffPointer(double* hh) { hhcoeffptr = hh; }$/;"	f	class:FluxFcnBase
setInletNode	InletNodeCore.C	/^void InletNode::setInletNode(int i, int fnum, int tnum, int* flist, int* tlist)$/;"	f	class:InletNode
setInletNodes	DomainCore.C	/^void Domain::setInletNodes(IoData &ioData)$/;"	f	class:Domain
setInletNodes	SubDomainCore.C	/^void SubDomain::setInletNodes(IoData& ioData)$/;"	f	class:SubDomain
setInletNodes2	SubDomainCore.C	/^void SubDomain::setInletNodes2(IoData& ioData)$/;"	f	class:SubDomain
setInterpWeightsForMultiIC	TsDesc.h	/^  virtual void setInterpWeightsForMultiIC(std::vector<double> ) {}$/;"	f	class:TsDesc
setIoData	Timer.C	/^void Timer::setIoData(IoData &_ioData)$/;"	f	class:Timer
setKspBinaryOutput	KspSolver.C	/^KspSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::setKspBinaryOutput(KspBinaryOutput<VecType>* kspBinOut)$/;"	f	class:KspSolver
setLastPhaseChangeValue	HigherOrderFSI.C	/^void HigherOrderFSI::setLastPhaseChangeValue(int nodeId, const double* v) $/;"	f	class:HigherOrderFSI
setLastPhaseChangeValue	HigherOrderMultiFluid.C	/^setLastPhaseChangeValue(int nodeId,const double* v) {$/;"	f	class:HigherOrderMultiFluid
setLastPhaseChangeValues	HigherOrderFSI.C	/^void HigherOrderFSI::setLastPhaseChangeValues(SVec<double,dim>& update,Vec<double>& weight) $/;"	f	class:HigherOrderFSI
setLastPhaseChangeValues	HigherOrderMultiFluid.C	/^setLastPhaseChangeValues(SVec<double,dim>& update,Vec<double>& weight) {$/;"	f	class:HigherOrderMultiFluid
setLastPhaseChangeValues	SpaceOperator.C	/^setLastPhaseChangeValues(DistExactRiemannSolver<dim>* riemann) {$/;"	f	class:MultiPhaseSpaceOperator
setLen	Communicator.C	/^CommPattern<T>::setLen(int channel, int len, int ldim, int nvec)$/;"	f	class:CommPattern
setLen	DistInfo.h	/^  void setLen(int sub, int len) { subLen[sub] = len; }$/;"	f	struct:DistInfo
setLimitedExtrapolation	HigherOrderFSI.C	/^void HigherOrderFSI::setLimitedExtrapolation() $/;"	f	class:HigherOrderFSI
setLimitedExtrapolation	HigherOrderMultiFluid.C	/^void HigherOrderMultiFluid::setLimitedExtrapolation() {$/;"	f	class:HigherOrderMultiFluid
setMasterFlag	Edge.h	/^  void setMasterFlag(bool *flag) { masterFlag = flag; }$/;"	f	class:EdgeSet
setMaxIts	KspSolver.h	/^  void setMaxIts(int i) { maxits = i; }$/;"	f	class:KspSolver
setMaxVerbose	Communicator.h	/^  void setMaxVerbose(int v) { maxverbose = v; }$/;"	f	class:Communicator
setMeshMotionHandler	TsOutput.C	/^void TsOutput<dim>::setMeshMotionHandler(IoData &ioData, MeshMotionHandler *mmh)$/;"	f	class:TsOutput
setMeshSensitivitySolverPositionVector	TsDesc.C	/^void TsDesc<dim>::setMeshSensitivitySolverPositionVector()$/;"	f	class:TsDesc
setMeshVel	VarFcn.h	/^  void setMeshVel(Vec3D &v)  { meshVel = v; }$/;"	f	class:VarFcn
setMultiFluidRiemannNormal	EdgeCore.C	/^void EdgeSet::setMultiFluidRiemannNormal(MultifluidRiemannNormal m) {$/;"	f	class:EdgeSet
setNewCrackingFlag	FSI/CrackingSurface.h	/^  void setNewCrackingFlag(bool flag) {gotNewCracking = flag;}$/;"	f	class:CrackingSurface
setNewSize	DenseMatrix.C	/^GenFullM<Scalar>::setNewSize(int nr, double initVal)$/;"	f	class:GenFullM
setNewSize	DenseMatrix.C	/^GenFullM<Scalar>::setNewSize(int nr, int nc, double initVal)$/;"	f	class:GenFullM
setNewSize	DenseMatrix.C	/^void SymFullM<Scalar>::setNewSize(int nr, double initVal)$/;"	f	class:SymFullM
setNodeBcValue	SubDomain.C	/^void SubDomain::setNodeBcValue(double* Vin, SVec<double,dim>& Unode)$/;"	f	class:SubDomain
setNodeBcValue2	SubDomain.C	/^void SubDomain::setNodeBcValue2(double* Uin, SVec<double,dim>& Unode)$/;"	f	class:SubDomain
setNodeFaceType	FaceCore.C	/^void Face::setNodeFaceType(int* nodeFaceType)$/;"	f	class:Face
setNodeFaceType	SubDomainCore.C	/^void SubDomain::setNodeFaceType(CommPattern<int> &ntP)$/;"	f	class:SubDomain
setNodeType	AgglomeratedFace.C	/^void AgglomeratedFace::setNodeType(int* priority, int* nodeType) {$/;"	f	class:AgglomeratedFace
setNodeType	DomainCore.C	/^void Domain::setNodeType(IoData &ioData)$/;"	f	class:Domain
setNodeType	FaceCore.C	/^void Face::setNodeType(int* priority, int* nodeType)$/;"	f	class:Face
setNodeType	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::setNodeType() {$/;"	f	class:MultiGridLevel
setNodeType	SubDomainCore.C	/^void SubDomain::setNodeType(int* priority, CommPattern<int> &ntP)$/;"	f	class:SubDomain
setNumArenas	Malloc.C	/^void setNumArenas(int na)$/;"	f
setNumLocSub	MatVecProd.h	/^  void setNumLocSub(int nLocSub) { numLocSub = nLocSub; }$/;"	f	struct:dRdXoperators
setNumOfFluids	LevelSet/LevelSetStructure.h	/^    void setNumOfFluids(int nf) {numFluid = nf;}$/;"	f	class:DistLevelSetStructure
setOperator	ImplicitEmbeddedSegTsDesc.C	/^void ImplicitEmbeddedSegTsDesc<dim,neq1,neq2>::setOperator(MatVecProd<dim,neq> *mvp, KspPrec<neq> *pc, $/;"	f	class:ImplicitEmbeddedSegTsDesc
setOperator	ImplicitSegTsDesc.C	/^void ImplicitSegTsDesc<dim,neq1,neq2>::setOperator(MatVecProd<dim,neq> *mvp, KspPrec<neq> *pc, $/;"	f	class:ImplicitSegTsDesc
setOperators	ImplicitCoupledTsDesc.C	/^void ImplicitCoupledTsDesc<dim>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitCoupledTsDesc
setOperators	ImplicitEmbeddedCoupledTsDesc.C	/^void ImplicitEmbeddedCoupledTsDesc<dim>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitEmbeddedCoupledTsDesc
setOperators	ImplicitEmbeddedRomTsDesc.h	/^    void setOperators(DistSVec<double, dim> &) {};$/;"	f	class:ImplicitEmbeddedRomTsDesc
setOperators	ImplicitEmbeddedSegTsDesc.C	/^void ImplicitEmbeddedSegTsDesc<dim,neq1,neq2>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitEmbeddedSegTsDesc
setOperators	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitLevelSetTsDesc
setOperators	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitMultiPhysicsTsDesc
setOperators	ImplicitSegTsDesc.C	/^void ImplicitSegTsDesc<dim,neq1,neq2>::setOperators(DistSVec<double,dim> &Q)$/;"	f	class:ImplicitSegTsDesc
setOperators	MeshMotionSolver.C	/^void TetMeshMotionSolver::setOperators(DistSVec<double,3> &X)$/;"	f	class:TetMeshMotionSolver
setOperators	MeshMotionSolver.h	/^  virtual void setOperators(DistSVec<double,3> &) {}$/;"	f	class:MeshMotionSolver
setOperatorsLS	ImplicitLevelSetTsDesc.C	/^void ImplicitLevelSetTsDesc<dim,dimLS>::setOperatorsLS(DistSVec<double,dimLS> &Q)$/;"	f	class:ImplicitLevelSetTsDesc
setOperatorsLS	ImplicitMultiPhysicsTsDesc.C	/^void ImplicitMultiPhysicsTsDesc<dim,dimLS>::setOperatorsLS(DistSVec<double,dimLS> &Q)$/;"	f	class:ImplicitMultiPhysicsTsDesc
setParameters	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::setParameters(int v1, int v2, int$/;"	f	class:MultiGridKernel
setPhiExact	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::setPhiExact() {$/;"	f	class:LevelSetTsDesc
setPorosity	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::setPorosity() {$/;"	f	class:DistIntersectorFRG
setPorosity	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::setPorosity() {$/;"	f	class:DistIntersectorPhysBAM
setPositionVector	MeshMotionHandler.h	/^  virtual void setPositionVector(DistSVec<double,3> &) {}$/;"	f	class:MeshMotionHandler
setPositionVector	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::setPositionVector(DistSVec<double,3> &X)$/;"	f	class:AeroMeshMotionHandler
setPreconditioner	LocalRiemannDesc.h	/^  void setPreconditioner(double beta) { prec = true; mach = beta; }$/;"	f	class:LocalRiemannFluidStructure
setPressure	VarFcn.h	/^  void setPressure(const double p, double *V, int tag=0)  { check(tag); return varFcn[tag]->setPressure(p,V); }$/;"	f	class:VarFcn
setPressure	VarFcn.h	/^  void setPressure(double *V, double *Vorig, int tag=0){ check(tag); return varFcn[tag]->setPressure(V,Vorig); }$/;"	f	class:VarFcn
setPressure	VarFcnBase.h	/^  virtual void setPressure(const double p, double *V)  { V[4] = p;   }$/;"	f	class:VarFcnBase
setPressure	VarFcnBase.h	/^  virtual void setPressure(double *V, double *Vorig){ V[4] = Vorig[4]; }$/;"	f	class:VarFcnBase
setPressure	VarFcnTait.h	/^  void setPressure(const double p, double *V){V[0] = pow( (p-p_)\/a_ , 1.0\/b_); }$/;"	f	class:VarFcnTait
setPressure	VarFcnTait.h	/^  void setPressure(double *V, double *Vorig) {V[0] = Vorig[0];}$/;"	f	class:VarFcnTait
setProblemSize	ImplicitCollocationTsDesc.C	/^void ImplicitCollocationTsDesc<dim>::setProblemSize(DistSVec<double, dim> &U) {$/;"	f	class:ImplicitCollocationTsDesc
setProblemSize	ImplicitGnatTsDesc.C	/^void ImplicitGnatTsDesc<dim>::setProblemSize(DistSVec<double, dim> &U) {$/;"	f	class:ImplicitGnatTsDesc
setProblemSize	ImplicitMetricTsDesc.C	/^void ImplicitMetricTsDesc<dim>::setProblemSize(DistSVec<double, dim> &U) {$/;"	f	class:ImplicitMetricTsDesc
setProblemSize	ImplicitPGTsDesc.C	/^void ImplicitPGTsDesc<dim>::setProblemSize(DistSVec<double, dim> &U) {$/;"	f	class:ImplicitPGTsDesc
setProblemSize	ImplicitRomTsDesc.h	/^  virtual void setProblemSize(DistSVec<double, dim> &) {};$/;"	f	class:ImplicitRomTsDesc
setRecFcn	SpaceOperator.C	/^void SpaceOperator<dim>::setRecFcn(RecFcn *rf)$/;"	f	class:SpaceOperator
setReferenceResidual	ImplicitGappyTsDesc.C	/^void ImplicitGappyTsDesc<dim>::setReferenceResidual()$/;"	f	class:ImplicitGappyTsDesc
setReferenceResidual	ImplicitPGTsDesc.C	/^void ImplicitPGTsDesc<dim>::setReferenceResidual()$/;"	f	class:ImplicitPGTsDesc
setReferenceResidual	ImplicitRomTsDesc.h	/^  virtual void setReferenceResidual() {};$/;"	f	class:ImplicitRomTsDesc
setResidual	DistTimeState.h	/^  void setResidual(DistSVec<double,dim> *rn) { if (Rn != 0) delete Rn; Rn = rn; }$/;"	f	class:DistTimeState
setRestartIterationAndTime	TsDesc.h	/^  void setRestartIterationAndTime(int it, double t) { restart->etime = t; restart->iteration = it;}$/;"	f	class:TsDesc
setRunTime	Timer.C	/^void Timer::setRunTime() $/;"	f	class:Timer
setSIstencil	Domain.C	/^void Domain::setSIstencil(DistSVec<double,3> &X, DistLevelSetStructure *distLSS, DistVec<int> &fluidId, DistSVec<double,dim> &U)$/;"	f	class:Domain
setSIstencil	HigherOrderFSI.C	/^void HigherOrderFSI::setSIstencil(V6NodeData *SIstencilData, SVec<double,dim> &U)$/;"	f	class:HigherOrderFSI
setSIstencil	SpaceOperator.C	/^void SpaceOperator<dim>::setSIstencil(DistSVec<double,3> &X, DistLevelSetStructure *distLSS, DistVec<int> &fluidId, DistSVec<double,dim> &U)$/;"	f	class:SpaceOperator
setSIstencil	SubDomain.C	/^void SubDomain::setSIstencil(SVec<double,3> &X, LevelSetStructure &LSS, $/;"	f	class:SubDomain
setSampleNodes	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::setSampleNodes(int iCluster) {$/;"	f	class:GappyPreprocessing
setSetupTime	Timer.C	/^void Timer::setSetupTime() $/;"	f	class:Timer
setStabilAlpha	LocalRiemannDesc.h	/^  void setStabilAlpha(double a) { stabil_alpha = a; }$/;"	f	class:LocalRiemannFluidStructure
setStatus	IntersectorFRG/IntersectorFRG.h	/^    void setStatus(DistVec<int> nodeTag) { *status = nodeTag; } \/\/for reset after failSafe$/;"	f	class:DistIntersectorFRG
setStatus	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    void setStatus(DistVec<int> nodeTag) { *status = nodeTag; }$/;"	f	class:DistIntersectorPhysBAM
setStatus	LevelSet/MultiGridLevelSetStructure.h	/^    void setStatus(DistVec<int> nodeTag) { }$/;"	f	class:DistMultiGridLevelSetStructure
setTemperatureG	HigherOrderFSI.C	/^void HigherOrderFSI::setTemperatureG(double *Vf, double** dVf,$/;"	f	class:HigherOrderFSI
setTimer	Communicator.h	/^  void setTimer(Timer *t) { timer = t; }$/;"	f	class:Communicator
setTransfer	ParallelRom.C	/^void ParallelRom<dim>::setTransfer() {$/;"	f	class:ParallelRom
setTsOutput	MatVecProd.h	/^  virtual void setTsOutput(TsOutput<dim>* outputPointer) {} $/;"	f	class:MatVecProd
setTsOutput	MatVecProd.h	/^  void setTsOutput(TsOutput<dim>* outputPointer) {output = outputPointer;}$/;"	f	class:MatVecProdFD
setTurbRelaxCutoff	MultiGridLevel.h	/^    void setTurbRelaxCutoff(double t) { turbRelaxCutoff = t; }$/;"	f	class:MultiGridLevel
setTurboG	HigherOrderFSI.C	/^void HigherOrderFSI::setTurboG(double* Vf, double** dVf,$/;"	f	class:HigherOrderFSI
setType	Face.h	/^  void setType(int t) { code = t; }$/;"	f	class:Face
setType	FaceCore.C	/^void Face::setType(int *facemap)$/;"	f	class:Face
setTypePrec	KspSolver.h	/^  void setTypePrec(int tp) { typePrec = tp; }$/;"	f	class:KspSolver
setUpBasisBasisProducts	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::setUpBasisBasisProducts() {$/;"	f	class:GappyPreprocessing
setUpGreedy	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::setUpGreedy(int iCluster) {$/;"	f	class:GappyPreprocessing
setUpGreedy	SurfMeshGen.h	/^	void setUpGreedy() { ;}$/;"	f	class:SurfMeshGen
setUpPodResJac	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::setUpPodResJac(int iCluster) {$/;"	f	class:GappyPreprocessing
setUpSampledNodeTargetRegionMask	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::setUpSampledNodeTargetRegionMask() {$/;"	f	class:GappyPreprocessing
setUseVolumeWeightedAverage	MultiGridKernel.C	/^void MultiGridKernel<Scalar>::setUseVolumeWeightedAverage(bool b) {$/;"	f	class:MultiGridKernel
setUseVolumeWeightedAverage	MultiGridLevel.h	/^    void setUseVolumeWeightedAverage(bool b) { useVolumeWeightedAverage = b; }$/;"	f	class:MultiGridLevel
setVelocityG	HigherOrderFSI.C	/^void HigherOrderFSI::setVelocityG(double* Vf, double** dVf,$/;"	f	class:HigherOrderFSI
setVelocityWfG	HigherOrderFSI.C	/^void HigherOrderFSI::setVelocityWfG(double* Vf, double** dVf, VarFcn *vf,$/;"	f	class:HigherOrderFSI
setViscousSwitch	LocalRiemannDesc.h	/^  void setViscousSwitch(double v) { viscous_switch = v; }$/;"	f	class:LocalRiemannFluidStructure
setVolumeID	Elem.h	/^  void setVolumeID(int i) {volume_id = i;}$/;"	f	class:Elem
setWallMask	DomainCore.C	/^void Domain::setWallMask(DistVec<double>& wallMask, DistVec<double>& neighborMask) {$/;"	f	class:Domain
setWallMask	SubDomainCore.C	/^void SubDomain::setWallMask(Vec<double>& wallMask, Vec<double>& neighborMask){$/;"	f	class:SubDomain
setWallNodes	SubDomainCore.C	/^void SubDomain::setWallNodes()$/;"	f	class:SubDomain
set_dX0	MeshMotionSolver.C	/^void TetMeshMotionSolver::set_dX0(DistSVec<double,3> &dX)$/;"	f	class:TetMeshMotionSolver
set_dX0	MeshMotionSolver.h	/^  virtual void set_dX0(DistSVec<double,3> &dX) {}$/;"	f	class:MeshMotionSolver
setdXdSb	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::setdXdSb(int N, double* dxdS, double* dydS, double* dzdS){$/;"	f	class:DistIntersectorFRG
setdXdSb	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::setdXdSb(int N, double* dxdS, double* dydS, double* dzdS){$/;"	f	class:DistIntersectorPhysBAM
setdXdSb	LevelSet/MultiGridLevelSetStructure.h	/^    void setdXdSb(int, double*, double*, double*) {}$/;"	f	class:MultiGridLevelSetStructure
setdXdSb	LevelSet/MultiGridLevelSetStructure.h	/^    void setdXdSb(int, double*, double*, double*){}$/;"	f	class:DistMultiGridLevelSetStructure
settag	EdgeGrad.h	/^  void settag(bool *ftag) { tag = ftag; }$/;"	f	class:EdgeGrad
setup	AlternatingLeastSquare/als_io.cpp	/^EmbeddedAlternatingLeastSquareData::setup(const char *name, ClassAssigner *father){$/;"	f	class:EmbeddedAlternatingLeastSquareData
setup	CorotSolver.C	/^CorotSolver::setup(DistSVec<double,3> &X)$/;"	f	class:CorotSolver
setup	DistGeoState.C	/^void DistGeoState::setup(const char *name, TimeData &timeData,$/;"	f	class:DistGeoState
setup	DistTimeState.C	/^void DistTimeState<dim>::setup(const char *name, DistSVec<double,3> &X,$/;"	f	class:DistTimeState
setup	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::setup(double *Xtilde, int nNodes)$/;"	f	class:EmbeddedCorotSolver
setup	FaceCore.C	/^void Face::setup(int fc, int *nn, int nnum, int sid)$/;"	f	class:Face
setup	HeatTransferHandlerCore.C	/^void HeatTransferHandler::setup(int* rstrt, double* maxTime)$/;"	f	class:HeatTransferHandler
setup	InletNodeCore.C	/^void InletNodeSet::setup(int loc, int num, IoData& ioData)$/;"	f	class:InletNodeSet
setup	IoData.C	/^void NewtonData<GenericKrylov>::setup(const char *name, ClassAssigner *father)$/;"	f	class:NewtonData
setup	IoData.C	/^void ObjectMap<DataType>::setup(const char *name, ClassAssigner *p)  {$/;"	f	class:ObjectMap
setup	IoDataCore.C	/^void AeroelasticData::setup(const char *name, ClassAssigner *father)$/;"	f	class:AeroelasticData
setup	IoDataCore.C	/^void ApproximatedMetricData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:ApproximatedMetricData
setup	IoDataCore.C	/^void BFixData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BFixData
setup	IoDataCore.C	/^void BLMeshMotionData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BLMeshMotionData
setup	IoDataCore.C	/^void BasisUpdatesData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:BasisUpdatesData
setup	IoDataCore.C	/^void BcsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BcsData
setup	IoDataCore.C	/^void BcsFreeStreamData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BcsFreeStreamData
setup	IoDataCore.C	/^void BcsHydroData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BcsHydroData
setup	IoDataCore.C	/^void BcsWallData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BcsWallData
setup	IoDataCore.C	/^void BoundarySchemeData::setup(const char *name, ClassAssigner *father)$/;"	f	class:BoundarySchemeData
setup	IoDataCore.C	/^void CFLData::setup(const char *name, ClassAssigner *father)$/;"	f	class:CFLData
setup	IoDataCore.C	/^void CFixData::setup(const char *name, ClassAssigner *father)$/;"	f	class:CFixData
setup	IoDataCore.C	/^void ClippingData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ClippingData
setup	IoDataCore.C	/^void ClusteringData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:ClusteringData
setup	IoDataCore.C	/^void DESModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DESModelData
setup	IoDataCore.C	/^void DGCLData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DGCLData
setup	IoDataCore.C	/^void DataCompressionData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:DataCompressionData
setup	IoDataCore.C	/^void DefoMeshMotionData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DefoMeshMotionData
setup	IoDataCore.C	/^void DeformingData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DeformingData
setup	IoDataCore.C	/^void DynamicLESData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DynamicLESData
setup	IoDataCore.C	/^void DynamicVMSData::setup(const char *name, ClassAssigner *father)$/;"	f	class:DynamicVMSData
setup	IoDataCore.C	/^void EmbeddedAlternatingLeastSquareData::setup(const char *name, ClassAssigner *father){$/;"	f	class:EmbeddedAlternatingLeastSquareData
setup	IoDataCore.C	/^void EmbeddedFramework::setup(const char *name) {$/;"	f	class:EmbeddedFramework
setup	IoDataCore.C	/^void EquationsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:EquationsData
setup	IoDataCore.C	/^void ExplicitData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ExplicitData
setup	IoDataCore.C	/^void FluidModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:FluidModelData
setup	IoDataCore.C	/^void FluidRemapData::setup(const char * name, ClassAssigner * father) {$/;"	f	class:FluidRemapData
setup	IoDataCore.C	/^void ForcePoints::setup(const char *name, ClassAssigner *father)$/;"	f	class:ForcePoints
setup	IoDataCore.C	/^void ForcedData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ForcedData
setup	IoDataCore.C	/^void GappyConstructionData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:GappyConstructionData
setup	IoDataCore.C	/^void GasModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:GasModelData
setup	IoDataCore.C	/^void HeavingData::setup(const char *name, ClassAssigner *father)$/;"	f	class:HeavingData
setup	IoDataCore.C	/^void ImplicitData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ImplicitData
setup	IoDataCore.C	/^void ImplosionSetup::setup(const char *name) {$/;"	f	class:ImplosionSetup
setup	IoDataCore.C	/^void InitialConditions::setup(const char *name, ClassAssigner *father) {$/;"	f	class:InitialConditions
setup	IoDataCore.C	/^void InputData::setup(const char *name, ClassAssigner *father)$/;"	f	class:InputData
setup	IoDataCore.C	/^void JWLModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:JWLModelData
setup	IoDataCore.C	/^void JacobianActionData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:JacobianActionData
setup	IoDataCore.C	/^void KEModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:KEModelData
setup	IoDataCore.C	/^void KirchhoffData::setup$/;"	f	class:KirchhoffData
setup	IoDataCore.C	/^void KrylovData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:KrylovData
setup	IoDataCore.C	/^void KspData::setup(const char *name, ClassAssigner *father)$/;"	f	class:KspData
setup	IoDataCore.C	/^void KspFluidData::setup(const char *name, ClassAssigner *father)$/;"	f	class:KspFluidData
setup	IoDataCore.C	/^void LESModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:LESModelData
setup	IoDataCore.C	/^void LineSearchData::setup(const char *name, ClassAssigner *father)$/;"	f	class:LineSearchData
setup	IoDataCore.C	/^void LinearizedData::setup(const char *name, ClassAssigner *father)$/;"	f	class:LinearizedData
setup	IoDataCore.C	/^void LiquidModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:LiquidModelData
setup	IoDataCore.C	/^void MultiFluidData::setup(const char *name, ClassAssigner *father)$/;"	f	class:MultiFluidData
setup	IoDataCore.C	/^void MultiGridData::setup(const char *name, ClassAssigner *father)$/;"	f	class:MultiGridData
setup	IoDataCore.C	/^void MultiInitialConditionsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:MultiInitialConditionsData
setup	IoDataCore.C	/^void NonlinearRomDirectoriesData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomDirectoriesData
setup	IoDataCore.C	/^void NonlinearRomFileSystemData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomFileSystemData
setup	IoDataCore.C	/^void NonlinearRomFilesData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomFilesData
setup	IoDataCore.C	/^void NonlinearRomOfflineData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomOfflineData
setup	IoDataCore.C	/^void NonlinearRomOnlineData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomOnlineData
setup	IoDataCore.C	/^void NonlinearRomOnlineNonStateData::setup(const char *name, ClassAssigner *father)$/;"	f	class:NonlinearRomOnlineNonStateData
setup	IoDataCore.C	/^void OneDimensionalInfo::setup(const char *name){$/;"	f	class:OneDimensionalInfo
setup	IoDataCore.C	/^void OneDimensionalInputData::setup(const char * name, ClassAssigner * father) {$/;"	f	class:OneDimensionalInputData
setup	IoDataCore.C	/^void OutputData::setup(const char *name, ClassAssigner *father)$/;"	f	class:OutputData
setup	IoDataCore.C	/^void PadeData::setup(const char *name, ClassAssigner *father)$/;"	f	class:PadeData
setup	IoDataCore.C	/^void PcData::setup(const char *name, ClassAssigner *father)$/;"	f	class:PcData
setup	IoDataCore.C	/^void PitchingData::setup(const char *name, ClassAssigner *father)$/;"	f	class:PitchingData
setup	IoDataCore.C	/^void PorousMedia::setup(const char *name, ClassAssigner *father)  {$/;"	f	class:PorousMedia
setup	IoDataCore.C	/^void PreconditionData::setup(const char *name, ClassAssigner *father)$/;"	f	class:PreconditionData
setup	IoDataCore.C	/^void Probes::Node::setup(const char *name, ClassAssigner *father) {$/;"	f	class:Probes::Node
setup	IoDataCore.C	/^void Probes::setup(const char *name, ClassAssigner *father)$/;"	f	class:Probes
setup	IoDataCore.C	/^void ProblemData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ProblemData
setup	IoDataCore.C	/^void ProgrammedBurnData::setup(const char* name, ClassAssigner* father) {$/;"	f	class:ProgrammedBurnData
setup	IoDataCore.C	/^void ROBConstructionData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ROBConstructionData
setup	IoDataCore.C	/^void ROMOutputData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:ROMOutputData
setup	IoDataCore.C	/^void ReferenceStateData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ReferenceStateData
setup	IoDataCore.C	/^void RelativeProjectionErrorData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:RelativeProjectionErrorData
setup	IoDataCore.C	/^void ResidualData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:ResidualData
setup	IoDataCore.C	/^void RestartData::setup(const char *name, ClassAssigner *father)$/;"	f	class:RestartData
setup	IoDataCore.C	/^void RestartParametersData::setup(const char *name, ClassAssigner *father)$/;"	f	class:RestartParametersData
setup	IoDataCore.C	/^void RigidMeshMotionData::setup(const char *name, ClassAssigner *father)$/;"	f	class:RigidMeshMotionData
setup	IoDataCore.C	/^void RotationData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:RotationData
setup	IoDataCore.C	/^void SAModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SAModelData
setup	IoDataCore.C	/^void SFixData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SFixData
setup	IoDataCore.C	/^void SchemeData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SchemeData
setup	IoDataCore.C	/^void SchemeFixData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SchemeFixData
setup	IoDataCore.C	/^void SchemesData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SchemesData
setup	IoDataCore.C	/^void SensitivityAnalysis::setup(const char *name, ClassAssigner *father)$/;"	f	class:SensitivityAnalysis
setup	IoDataCore.C	/^void SensitivityData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:SensitivityData
setup	IoDataCore.C	/^void SmagorinskyLESData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SmagorinskyLESData
setup	IoDataCore.C	/^void SnapshotsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SnapshotsData
setup	IoDataCore.C	/^void SparseGridData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SparseGridData
setup	IoDataCore.C	/^void SpiralingData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SpiralingData
setup	IoDataCore.C	/^void StateData::setup(const char *name, ClassAssigner *father) {$/;"	f	class:StateData
setup	IoDataCore.C	/^void StateSnapshotsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:StateSnapshotsData
setup	IoDataCore.C	/^void Surfaces::setup(const char *name)  {$/;"	f	class:Surfaces
setup	IoDataCore.C	/^void SymmetryData::setup(const char *name, ClassAssigner *father)$/;"	f	class:SymmetryData
setup	IoDataCore.C	/^void TBFixData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TBFixData
setup	IoDataCore.C	/^void ThermalCondModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ThermalCondModelData
setup	IoDataCore.C	/^void TransientData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TransientData
setup	IoDataCore.C	/^void TripDomainData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TripDomainData
setup	IoDataCore.C	/^void TsData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TsData
setup	IoDataCore.C	/^void TurbulenceClosureData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TurbulenceClosureData
setup	IoDataCore.C	/^void TurbulenceModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:TurbulenceModelData
setup	IoDataCore.C	/^void VMSLESData::setup(const char *name, ClassAssigner *father)$/;"	f	class:VMSLESData
setup	IoDataCore.C	/^void Velocity::setup(const char *name, ClassAssigner *father)  {$/;"	f	class:Velocity
setup	IoDataCore.C	/^void VelocityPoints::setup(const char *name, ClassAssigner *father)$/;"	f	class:VelocityPoints
setup	IoDataCore.C	/^void ViscosityModelData::setup(const char *name, ClassAssigner *father)$/;"	f	class:ViscosityModelData
setup	IoDataCore.C	/^void Volumes::setup(const char *name, ClassAssigner *father)  {$/;"	f	class:Volumes
setup	IoDataCore.C	/^void WaleLESData::setup(const char *name, ClassAssigner *father)$/;"	f	class:WaleLESData
setup	IoDataCore.C	/^void WallDistanceMethodData::setup(const char *name, ClassAssigner *father)$/;"	f	class:WallDistanceMethodData
setup	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::setup()  {$/;"	f	class:IluPrec
setup	KspPrec.C	/^void JacobiPrec<Scalar,dim, Scalar2>::setup()$/;"	f	class:JacobiPrec
setup	KspPrec.h	/^  void setup() {}$/;"	f	class:IdentityPrec
setup	KspSolver.C	/^KspSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::setup(int nlit, int nlmaxits, VecType &b)$/;"	f	class:KspSolver
setup	LevelSet.C	/^void LevelSet<dimLS>::setup(const char *name, DistSVec<double,3> &X, DistSVec<double,dim> &U,$/;"	f	class:LevelSet
setup	LowMachPrec.h	/^  virtual void setup(IoData &iod) {$/;"	f	class:LowMachPrec
setup	LowMachPrec.h	/^  void setup(IoData &iod) {$/;"	f	class:SpatialLowMachPrec
setup	LowMachPrec.h	/^  void setup(IoData &iod) {$/;"	f	class:TimeLowMachPrec
setup	MeshMotionHandler.C	/^void AeroMeshMotionHandler::setup(int *rstrt, double *maxTime, PostOperator<dim>* postOp,$/;"	f	class:AeroMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void DeformingMeshMotionHandler::setup(DistSVec<double,3> &X)$/;"	f	class:DeformingMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void EmbeddedALEMeshMotionHandler::setup(DistSVec<double,3> &X, DistSVec<double,3> &Xdot)$/;"	f	class:EmbeddedALEMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::setup(double *maxTime)$/;"	f	class:EmbeddedMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void HeavingMeshMotionHandler::setup(DistSVec<double,3> &X)$/;"	f	class:HeavingMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void PitchingMeshMotionHandler::setup(DistSVec<double,3> &X)$/;"	f	class:PitchingMeshMotionHandler
setup	MeshMotionHandlerCore.C	/^void SpiralingMeshMotionHandler::setup(DistSVec<double,3> &X)$/;"	f	class:SpiralingMeshMotionHandler
setup	MeshMotionSolver.C	/^void TetMeshMotionSolver::setup(DistSVec<double,3> &X)$/;"	f	class:TetMeshMotionSolver
setup	MultiGridPrec.C	/^void MultiGridPrec<Scalar,dim,Scalar2>::setup(DistSVec<Scalar2,dim>& U)$/;"	f	class:MultiGridPrec
setup	MultiGridPrec.h	/^  void setup() { } $/;"	f	class:MultiGridPrec
setup	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
setup1	DistGeoState.C	/^void DistGeoState::setup1(const char *name, DistSVec<double,3> *X, DistVec<double> *ctrlVol)$/;"	f	class:DistGeoState
setup2	DistGeoState.C	/^void DistGeoState::setup2(TimeData &timeData)$/;"	f	class:DistGeoState
setup3	DistGeoState.C	/^void DistGeoState::setup3(const char *name, DistSVec<double,3> *X, DistVec<double> *ctrlVol)$/;"	f	class:DistGeoState
setupBcs	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::setupBcs(DistBcData<dim>& fineBcData, DistBcData<dim>& coarseBcData,$/;"	f	class:MultiGridLevel
setupBcs	MultiGridSpaceOperator.C	/^void MultiGridSpaceOperator<Scalar,dim>::setupBcs(DistBcData<dim>* bcd) {$/;"	f	class:MultiGridSpaceOperator
setupCmdFileVariables	IoDataCore.C	/^void IoData::setupCmdFileVariables()$/;"	f	class:IoData
setupDefaultConstants	LowMachPrec.h	/^  virtual void setupDefaultConstants(){$/;"	f	class:LowMachPrec
setupEmbeddedFSISolver	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::setupEmbeddedFSISolver(IoData &ioData)$/;"	f	class:MultiPhysicsTsDesc
setupFixes	MultiGridKernel.C	/^setupFixes(IoData& ioData,int lvl,DistSVec<Scalar,3>& X0) {$/;"	f	class:MultiGridKernel
setupFixes	OneDimensionalSolver.C	/^void OneDimensional::setupFixes(IoData& ioData) {$/;"	f	class:OneDimensional
setupFluidIdVolumesInitialConditions	DomainCore.C	/^void Domain::setupFluidIdVolumesInitialConditions(const int volid, const int myId, DistVec<int> &fluidId)$/;"	f	class:Domain
setupFluidIdVolumesInitialConditions	SubDomainCore.C	/^void SubDomain::setupFluidIdVolumesInitialConditions(const int volid, const int myId, Vec<int> &fluidId)$/;"	f	class:SubDomain
setupInitialDisplacement	DistGeoState.C	/^void DistGeoState::setupInitialDisplacement(const char *name, DistSVec<double,3> *X, DistVec<double> *ctrlVol)$/;"	f	class:DistGeoState
setupIodConstants	LowMachPrec.h	/^  virtual void setupIodConstants(IoData &iod){$/;"	f	class:LowMachPrec
setupMultiPhaseFlowSolver	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::setupMultiPhaseFlowSolver(IoData &ioData)$/;"	f	class:MultiPhysicsTsDesc
setupOneDimensional	IoDataCore.C	/^void IoData::setupOneDimensional() {$/;"	f	class:IoData
setupOutputFiles	OneDimensionalSolver.C	/^void OneDimensional::setupOutputFiles(IoData& iod) {$/;"	f	class:OneDimensional
setupOutputToDisk	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::setupOutputToDisk(IoData &ioData, bool *lastIt, int it, double t,$/;"	f	class:EmbeddedTsDesc
setupOutputToDisk	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::setupOutputToDisk(IoData &ioData, bool *lastIt,$/;"	f	class:LevelSetTsDesc
setupOutputToDisk	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::setupOutputToDisk(IoData &ioData, bool *lastIt,$/;"	f	class:MultiPhysicsTsDesc
setupOutputToDisk	TsDesc.C	/^void TsDesc<dim>::setupOutputToDisk(IoData &ioData, bool *lastIt, int it, double t, $/;"	f	class:TsDesc
setupPhiFluidStructureInitialConditions	LevelSet.C	/^void LevelSet<dimLS>::setupPhiFluidStructureInitialConditions(IoData &iod, DistSVec<double,3> &X, $/;"	f	class:LevelSet
setupPhiMultiFluidInitialConditions	LevelSet.C	/^void LevelSet<dimLS>::setupPhiMultiFluidInitialConditions(IoData &iod, DistSVec<double,3> &X, DistSVec<double,dimLS> &Phi){$/;"	f	class:LevelSet
setupPhiOneDimensionalSolution	LevelSet.C	/^void LevelSet<dimLS>::setupPhiOneDimensionalSolution(IoData &iod, DistSVec<double,3> &X, DistSVec<double,dim> &U, DistSVec<double,dimLS> &Phi, FluidSelector* fs, VarFcn* vf){$/;"	f	class:LevelSet
setupPhiVolumesInitialConditions	Domain.C	/^void Domain::setupPhiVolumesInitialConditions(const int volid, const int fluidId, DistSVec<double,dimLS> &Phi){$/;"	f	class:Domain
setupPhiVolumesInitialConditions	LevelSet.C	/^void LevelSet<dimLS>::setupPhiVolumesInitialConditions(IoData &iod, DistSVec<double,dimLS> &Phi){$/;"	f	class:LevelSet
setupPhiVolumesInitialConditions	SubDomain.C	/^void SubDomain::setupPhiVolumesInitialConditions(const int volid, $/;"	f	class:SubDomain
setupProbes	OneDimensionalSolver.C	/^void OneDimensional::setupProbes(IoData& iod) {$/;"	f	class:OneDimensional
setupTR	KspPrec.C	/^void IluPrec<Scalar,dim, Scalar2>::setupTR()  {$/;"	f	class:IluPrec
setupTR	KspPrec.h	/^  virtual void setupTR() { std::cout << "setupTR not implemented for this Preconditioner" << endl; }$/;"	f	class:KspPrec
setupTR	KspPrec.h	/^  void setupTR() {}$/;"	f	class:IdentityPrec
setupTimeStepping	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::setupTimeStepping(DistSVec<double,dim> *U, IoData &ioData)$/;"	f	class:EmbeddedTsDesc
setupTimeStepping	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::setupTimeStepping(DistSVec<double,dim> *U, IoData &ioData)$/;"	f	class:LevelSetTsDesc
setupTimeStepping	MultiGridCoupledTsDesc.C	/^setupTimeStepping(DistSVec<double,dim> *U0, IoData &iod) {$/;"	f	class:MultiGridCoupledTsDesc
setupTimeStepping	MultiGridEmbeddedTsDesc.C	/^setupTimeStepping(DistSVec<double,dim> *U0, IoData &iod) {$/;"	f	class:MultiGridEmbeddedTsDesc
setupTimeStepping	MultiGridSegTsDesc.C	/^setupTimeStepping(DistSVec<double,dim> *U0, IoData &iod) {$/;"	f	class:MultiGridSegTsDesc
setupTimeStepping	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::setupTimeStepping(DistSVec<double,dim> *U, IoData &ioData)$/;"	f	class:MultiPhysicsTsDesc
setupTimeStepping	TsDesc.C	/^void TsDesc<dim>::setupTimeStepping(DistSVec<double,dim> *U, IoData &iod)$/;"	f	class:TsDesc
setupUExactSolutionInitialConditions	DistTimeState.C	/^void DistTimeState<dim>::setupUExactSolutionInitialConditions(IoData &iod, DistSVec<double,3> &X)$/;"	f	class:DistTimeState
setupUFluidIdInitialConditions	DistTimeState.C	/^void DistTimeState<dim>::setupUFluidIdInitialConditions(IoData &iod, DistVec<int> &pointId)$/;"	f	class:DistTimeState
setupUMultiFluidInitialConditions	DistTimeState.C	/^void DistTimeState<dim>::setupUMultiFluidInitialConditions(IoData &iod, DistSVec<double,3> &X)$/;"	f	class:DistTimeState
setupUOneDimensionalSolution	DistTimeState.C	/^void DistTimeState<dim>::setupUOneDimensionalSolution(IoData &iod, DistSVec<double,3> &X)$/;"	f	class:DistTimeState
setupUVolumesInitialConditions	DistTimeState.C	/^void DistTimeState<dim>::setupUVolumesInitialConditions(IoData &iod)$/;"	f	class:DistTimeState
setupUVolumesInitialConditions	Domain.C	/^void Domain::setupUVolumesInitialConditions(const int volid, double UU[dim],$/;"	f	class:Domain
setupUVolumesInitialConditions	SubDomain.C	/^void SubDomain::setupUVolumesInitialConditions(const int volid, double UU[dim],$/;"	f	class:SubDomain
setupVelocityPoints	MeshMotionHandlerCore.C	/^void RigidMeshMotionHandler::setupVelocityPoints(IoData &ioData)$/;"	f	class:RigidMeshMotionHandler
seupp	arpack++/include/seupp.h	/^inline void seupp(bool rvec, char HowMny, double d[], double Z[],$/;"	f
seupp	arpack++/include/seupp.h	/^inline void seupp(bool rvec, char HowMny, float d[], float Z[],$/;"	f
sfactor_param_t	arpack++/include/arlspdef.h	/^} sfactor_param_t;$/;"	t	typeref:struct:__anon39
sfix1	IoData.h	/^  SFixData sfix1;$/;"	m	struct:SchemeFixData
sfix10	IoData.h	/^  SFixData sfix10;$/;"	m	struct:SchemeFixData
sfix2	IoData.h	/^  SFixData sfix2;$/;"	m	struct:SchemeFixData
sfix3	IoData.h	/^  SFixData sfix3;$/;"	m	struct:SchemeFixData
sfix4	IoData.h	/^  SFixData sfix4;$/;"	m	struct:SchemeFixData
sfix5	IoData.h	/^  SFixData sfix5;$/;"	m	struct:SchemeFixData
sfix6	IoData.h	/^  SFixData sfix6;$/;"	m	struct:SchemeFixData
sfix7	IoData.h	/^  SFixData sfix7;$/;"	m	struct:SchemeFixData
sfix8	IoData.h	/^  SFixData sfix8;$/;"	m	struct:SchemeFixData
sfix9	IoData.h	/^  SFixData sfix9;$/;"	m	struct:SchemeFixData
sfric	IoData.h	/^  const char *sfric;$/;"	m	struct:TransientData
sgCluster_	LocalRiemannDesc.h	/^  SparseGridCluster *sgCluster_;$/;"	m	class:LocalRiemannGfmparGasJWL
sgCluster_	LocalRiemannDesc.h	/^  SparseGridCluster *sgCluster_;$/;"	m	class:LocalRiemannGfmparTaitJWL
sgZeroDensityPJwlDensity	LocalRiemannDesc.h	/^double LocalRiemannGfmparGasJWL::sgZeroDensityPJwlDensity(const double density, const double pressure,$/;"	f	class:LocalRiemannGfmparGasJWL
sgemm_	arpack++/include/arlnames.h	155;"	d
sgemm_	arpack++/include/arlnames.h	84;"	d
sgemv_	arpack++/include/arlnames.h	153;"	d
sgemv_	arpack++/include/arlnames.h	82;"	d
sger_	arpack++/include/arlnames.h	146;"	d
sger_	arpack++/include/arlnames.h	75;"	d
shapederivatives	IoData.h	/^  const char *shapederivatives;$/;"	m	struct:InputData
shapederivatives	TsInput.h	/^  char *shapederivatives;$/;"	m	struct:TsInput
shapederivativesType	IoData.h	/^  enum ShapeDerivativeType {WALL=0, VOLUME=1} shapederivativesType;$/;"	m	struct:InputData	typeref:enum:InputData::ShapeDerivativeType
shapederivativestype	IoData.h	/^  const char *shapederivativestype;$/;"	m	struct:InputData
sharedEdges	MultiGridLevel.h	/^    EdgeDef*** sharedEdges;$/;"	m	class:MultiGridLevel
sharedEdges	SubDomain.h	/^  EdgeDef **sharedEdges;$/;"	m	class:SubDomain
sharedInletNodes	SubDomain.h	/^  Connectivity *sharedInletNodes;$/;"	m	class:SubDomain
sharedNodes	MultiGridLevel.h	/^    Connectivity ** sharedNodes;$/;"	m	class:MultiGridLevel
sharedNodes	MultiGridLevel.h	/^  std::vector<int> sharedNodes;$/;"	m	struct:MultigridSubdomain
sharedNodes	MultiGridLevel.h	/^  std::vector<std::pair<int,int> > sharedNodes;$/;"	m	struct:NeighborDomain
sharedNodes	SubDomain.h	/^  Connectivity *sharedNodes;$/;"	m	class:SubDomain
shaseg	tools/alloca.cougar.c	/^    long shaseg:32;		\/* Size of increments to stack.  *\/$/;"	m	struct:stack_control_header	file:
shgrow	tools/alloca.cougar.c	/^    long shgrow:32;		\/* Number of times stack has grown.  *\/$/;"	m	struct:stack_control_header	file:
shhwm	tools/alloca.cougar.c	/^    long shhwm:32;		\/* High water mark of stack.  *\/$/;"	m	struct:stack_control_header	file:
shockGAS	LocalRiemann.h	/^void LocalRiemannGfmpar::shockGAS(double phi, double gamogam1,$/;"	f	class:LocalRiemannGfmpar
shockJWL	LocalRiemann.h	/^void LocalRiemannGfmpar::shockJWL(double phi, double omega,$/;"	f	class:LocalRiemannGfmpar
shockTAIT	LocalRiemann.h	/^void LocalRiemannGfmpar::shockTAIT(double phi,$/;"	f	class:LocalRiemannGfmpar
shockreducer	IoData.h	/^  double shockreducer;$/;"	m	struct:PreconditionData
shockreducer	LowMachPrec.h	/^  double shockreducer;  $/;"	m	class:LowMachPrec
shsize	tools/alloca.cougar.c	/^    long shsize:32;		\/* Current size of stack (all segments).  *\/$/;"	m	struct:stack_control_header	file:
sigma	DistNodalGrad.h	/^  DistVec<Scalar>* sigma;$/;"	m	class:DistNodalGrad
sigma	IoData.h	/^  double sigma;$/;"	m	struct:DESModelData
sigma	IoData.h	/^  double sigma;$/;"	m	struct:SAModelData
sigmaI	arpack++/include/arrseig.h	/^  ARFLOAT sigmaI;     \/\/ Imaginary part of shift (for nonsymmetric problems).$/;"	m	class:ARrcStdEig
sigmaR	arpack++/include/arrseig.h	/^  ARTYPE  sigmaR;     \/\/ Shift (real part only if problem is nonsymmetric).$/;"	m	class:ARrcStdEig
sigma_eps	IoData.h	/^  double sigma_eps;$/;"	m	struct:KEModelData
sigma_eps	KEpsilonTerm.h	/^  double sigma_eps;$/;"	m	class:KEpsilonTerm
sigma_eps1	IoData.h	/^  double sigma_eps1;$/;"	m	struct:KEModelData
sigma_eps1	KEpsilonTerm.h	/^  double sigma_eps1;$/;"	m	class:KEpsilonTerm
sigma_eps2	IoData.h	/^  double sigma_eps2;$/;"	m	struct:KEModelData
sigma_eps2	KEpsilonTerm.h	/^  double sigma_eps2;$/;"	m	class:KEpsilonTerm
sigma_k	IoData.h	/^  double sigma_k;$/;"	m	struct:KEModelData
sigma_k	KEpsilonTerm.h	/^  double sigma_k;$/;"	m	class:KEpsilonTerm
sign	LocalRiemannDesc.h	/^  double sign;$/;"	m	class:LocalRiemannGfmparTaitJWL
sign	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sign.h	/^inline T sign(const T a)$/;"	f	namespace:PhysBAM
sign	SubDomain.h	/^  int glLeft, glRight, edgeNum, sign;$/;"	m	struct:EdgeDef
sign_nonzero	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sign.h	/^inline T sign_nonzero(const T a)$/;"	f	namespace:PhysBAM
signedDistance	IntersectorFRG/IntersectorFRG.C	/^  double signedDistance() {$/;"	f	class:ClosestTriangle
simType	EmbeddedTsDesc.h	/^  int simType;        \/\/ 0: steady-state    1: unsteady$/;"	m	class:EmbeddedTsDesc
simType	MultiPhysicsTsDesc.h	/^  int simType;        \/\/ 0: steady-state    1: unsteady$/;"	m	class:MultiPhysicsTsDesc
simpleUpdateInfoName	IoData.h	/^  const char *simpleUpdateInfoName;$/;"	m	struct:NonlinearRomFilesData
simpleUpdateInfoName	NonlinearRom.h	/^  char* simpleUpdateInfoName;$/;"	m	class:NonlinearRom
sin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^sin(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
sin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^sin(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
sin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^sin(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
sin	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^sin(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
sinc	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Robust_Functions.h	/^inline T sinc(const T x) \/\/ sin(x)\/x$/;"	f	namespace:PhysBAM
singValTolerance	IoData.h	/^  double singValTolerance;$/;"	m	struct:DataCompressionData
singleInterpolation	SparseGridCore.C	/^void SparseGrid::singleInterpolation(const double *coord, double *output) const{$/;"	f	class:SparseGrid
singleInterpolationGradient	SparseGridCore.C	/^void SparseGrid::singleInterpolationGradient(const double *coord, double *output) const{$/;"	f	class:SparseGrid
singleTimeIntegration	OneDimensionalSolver.C	/^void OneDimensional::singleTimeIntegration(double dt){$/;"	f	class:OneDimensional
singleton_instance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^TIMER* TIMER::singleton_instance;$/;"	m	class:PhysBAM::TIMER	file:
singleton_instance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    static TIMER* singleton_instance;$/;"	m	class:PhysBAM::TIMER
sixth	ElemTet.h	/^  static const double sixth;$/;"	m	class:ElemTet
sixth	ElemTetCore.C	/^const double ElemTet::sixth = 1.0\/6.0;$/;"	m	class:ElemTet	file:
size	AgglomeratedFace.h	/^  int size() const { return numFaces; }$/;"	f	class:AgglomeratedFaceSet
size	BCond.h	/^  int size() const { return numBC; }$/;"	f	class:BCondSet
size	Communicator.h	/^    int size() {return length;}$/;"	f	class:Communication::Window
size	Communicator.h	/^  int size() const { return numCPU; }$/;"	f	class:Communicator
size	Connectivity.h	/^  int size;           \/\/ size of pointer$/;"	m	class:Connectivity
size	Edge.h	/^  int size() const { return numEdges; }$/;"	f	class:EdgeSet
size	Elem.h	/^  int size() const { return numElems; }$/;"	f	class:ElemSet
size	Face.h	/^  int size() const { return numFaces; }$/;"	f	class:FaceSet
size	InletNode.h	/^  	int size() const { return numInletNodes; }$/;"	f	class:InletNodeSet
size	MacroCell.h	/^  int size() const { return numMacroCells; }$/;"	f	class:MacroCellSet
size	MacroCell.h	/^  int size() { return numSubCells; }$/;"	f	class:MacroCell
size	MatchNode.h	/^  int size() const { return numNodes; }$/;"	f	class:MatchNodeSet
size	MemoryPool.h	/^  ResizeArray<int> size;$/;"	m	class:MemoryPool
size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX.h	/^    enum WORKAROUND1 {m=m_input,n=n_input,size=n_input*m_input};$/;"	e	enum:PhysBAM::MATRIX::WORKAROUND1
size	SimpleBuffer.h	/^  size_t size() const { return numValues_; }$/;"	f	class:SimpleBuffer
size	SparseGrid.h	/^    int size() const{ return numElem_; }$/;"	f	class:SparseGrid::Heap
size	VarFcn.h	/^  int size()                {return numPhases;}$/;"	f	class:VarFcn
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:Diff
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:Div
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:Expr
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:InnerProd
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:OuterProd
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:SVec
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:Sum
size	Vector.h	/^  int size() const { return len; }$/;"	f	class:Vec
size	VectorSet.h	/^  const typename VecType::InfoType &size() const { return len; }$/;"	f	class:VecSet
sizeIs	SimpleBuffer.h	/^void SimpleBuffer<Scalar>::sizeIs(size_t numValues) {$/;"	f	class:SimpleBuffer
sizeMB	DistEmbeddedVector.h	/^  double sizeMB() { return realVec.sizeMB()*2; }$/;"	f	class:DistEmbeddedVec
sizeMB	Vector.h	/^  double sizeMB() const { return static_cast<double>(len * sizeof(Scalar)) \/ (1024.0*1024.0); }$/;"	f	class:Vec
sizeMB	Vector.h	/^  double sizeMB() const { return static_cast<double>(len*dim * sizeof(Scalar)) \/ (1024.0*1024.0); }$/;"	f	class:SVec
sizeMultiIndex	SparseGrid.h	/^  int sizeMultiIndex;$/;"	m	class:SparseGrid
sizeNorms	Face.h	/^  int sizeNorms() const { return numFaceNorms; }$/;"	f	class:FaceSet
sizeSurplus	SparseGrid.h	/^  int sizeSurplus;$/;"	m	class:SparseGrid
size_	SparseGrid.h	/^    int size_;$/;"	m	class:SparseGrid::Heap
slidingSurfaceTreatment	BCApplier.h	/^    const DefoMeshMotionData::SlidingSurfaceTreatment &slidingSurfaceTreatment;$/;"	m	class:BCApplier
slidingSurfaceTreatment	IoData.h	/^  enum SlidingSurfaceTreatment {Default = 0, PrescribedAverage = 1} slidingSurfaceTreatment;$/;"	m	struct:DefoMeshMotionData	typeref:enum:DefoMeshMotionData::SlidingSurfaceTreatment
slope	LowMachPrec.h	/^  double slope;$/;"	m	class:LowMachPrec
sma	IoData.h	/^  SmagorinskyLESData sma;$/;"	m	struct:LESModelData
smag	PostOperator.h	/^  SmagorinskyLESTerm *smag;$/;"	m	class:PostOperator
smag	SpaceOperator.h	/^  SmagorinskyLESTerm *smag;$/;"	m	class:SpaceOperator
smmh	TsOutput.h	/^  SpiralingMeshMotionHandler *smmh;$/;"	m	class:TsOutput
smode	StructExc.h	/^  int smode;$/;"	m	class:StructExc
smooth	MultiGridCoupledTsDesc.C	/^smooth(int lvl, MultiGridDistSVec<double,dim>& x,$/;"	f	class:MultiGridCoupledTsDesc
smooth	MultiGridEmbeddedTsDesc.C	/^smooth(int lvl, MultiGridDistSVec<double,dim>& x,$/;"	f	class:MultiGridEmbeddedTsDesc
smooth	MultiGridSegTsDesc.C	/^smooth(int lvl, MultiGridDistSVec<double,dim>& x,$/;"	f	class:MultiGridSegTsDesc
smooth	MultiGridSmoothingMatrix.C	/^smooth(SVec<Scalar,dim>& r, SVec<Scalar,dim>& du) {$/;"	f	class:MultiGridSmoothingMatrix
smooth0	MultiGridCoupledTsDesc.C	/^smooth0(DistSVec<double,dim>& x,int steps) {$/;"	f	class:MultiGridCoupledTsDesc
smooth0	MultiGridEmbeddedTsDesc.C	/^smooth0(DistSVec<double,dim>& x,int steps) {$/;"	f	class:MultiGridEmbeddedTsDesc
smooth0	MultiGridSegTsDesc.C	/^smooth0(DistSVec<double,dim>& x,int steps) {$/;"	f	class:MultiGridSegTsDesc
smoothBlockJacobi	MultiGridSmoothingMatrix.C	/^smoothBlockJacobi(SVec<Scalar,dim>& r, SVec<Scalar,dim>& du) {$/;"	f	class:MultiGridSmoothingMatrix
smoothLineJacobi	MultiGridSmoothingMatrix.C	/^smoothLineJacobi(SVec<Scalar,dim>& r, SVec<Scalar,dim>& du) {$/;"	f	class:MultiGridSmoothingMatrix
smoothRAS	MultiGridSmoothingMatrix.C	/^smoothRAS(SVec<Scalar,dim>& r, SVec<Scalar,dim>& du) {$/;"	f	class:MultiGridSmoothingMatrix
smoothWithGMRES	MultiGridCoupledTsDesc.h	/^  bool smoothWithGMRES;$/;"	m	class:MultiGridCoupledTsDesc
smoothWithGMRES	MultiGridEmbeddedTsDesc.h	/^  bool smoothWithGMRES;$/;"	m	class:MultiGridEmbeddedTsDesc
smoothWithGMRES	MultiGridKernel.h	/^  bool smoothWithGMRES;$/;"	m	class:MultiGridKernel
smoothWithGMRES	MultiGridSegTsDesc.h	/^  bool smoothWithGMRES;$/;"	m	class:MultiGridSegTsDesc
smoothingMatrices	MultiGridCoupledTsDesc.h	/^  MultiGridSmoothingMatrices<double,dim>* smoothingMatrices;$/;"	m	class:MultiGridCoupledTsDesc
smoothingMatrices	MultiGridEmbeddedTsDesc.h	/^  MultiGridSmoothingMatrices<double,dim>* smoothingMatrices;$/;"	m	class:MultiGridEmbeddedTsDesc
smoothingMatrices	MultiGridKspSolver.h	/^  MultiGridSmoothingMatrix<Scalar,neq>** smoothingMatrices;                                           $/;"	m	class:MultiGridJacobiPrec
smoothingMatrices	MultiGridKspSolver.h	/^  MultiGridSmoothingMatrix<Scalar,neq>** smoothingMatrices;$/;"	m	class:MultiGridRASPrec
smoothingMatrices	MultiGridKspSolver.h	/^  MultiGridSmoothingMatrix<Scalar,neq>*** smoothingMatrices;$/;"	m	class:MultiGridKspSolver
smoothingMatrices	MultiGridPrec.h	/^  MultiGridSmoothingMatrices<Scalar2, dim>* smoothingMatrices;$/;"	m	class:MultiGridPrec
smoothingMatrices1	MultiGridSegTsDesc.h	/^  MultiGridSmoothingMatrices<double,neq1>* smoothingMatrices1;$/;"	m	class:MultiGridSegTsDesc
smoothingMatrices2	MultiGridSegTsDesc.h	/^  MultiGridSmoothingMatrices<double,neq2>* smoothingMatrices2;$/;"	m	class:MultiGridSegTsDesc
snap	NonlinearRom.h	/^  VecSet< DistSVec<double, dim> >* snap; \/\/ snap(nTotSnaps, domain.getNodeDistInfo())$/;"	m	class:NonlinearRom
snapHatApproxMetric	GappyPreprocessing.h	/^  SetOfVec snapHatApproxMetric;$/;"	m	class:GappyPreprocessing
snapID	NonlinearRom.h	/^  typedef pair<std::string, int> snapID;$/;"	t	class:NonlinearRom
snapIndex	NonlinearRomDatabaseConstruction.C	/^  int snapIndex; \/\/ snapshot #$/;"	m	struct:sortStruct	file:
snapRefState	NonlinearRom.h	/^  DistSVec<double, dim>* snapRefState; $/;"	m	class:NonlinearRom
snapsInCluster	NonlinearRom.h	/^  int* snapsInCluster; \/\/ number of snaps in each cluster$/;"	m	class:NonlinearRom
snapsLinSolv	Timer.h	/^		snapsLinSolv, padeReconstr, correlMatrix, eigSolv, aj, jacEvaluate, jacApply, residual, restriction,$/;"	e	enum:Timer::TimerIndex
snapshotNormTolerance	IoData.h	/^  double snapshotNormTolerance;$/;"	m	struct:ClusteringData
snapshots	IoData.h	/^  SnapshotsData snapshots;$/;"	m	struct:JacobianActionData
snapshots	IoData.h	/^  SnapshotsData snapshots;$/;"	m	struct:KrylovData
snapshots	IoData.h	/^  SnapshotsData snapshots;$/;"	m	struct:ResidualData
snapshots	IoData.h	/^  SnapshotsData snapshots;$/;"	m	struct:SensitivityData
snapshots	IoData.h	/^  StateSnapshotsData snapshots;$/;"	m	struct:StateData
snapshotsConstruction	SubDomain.C	/^void SubDomain::snapshotsConstruction(SVec<double, dim> **data, bcomp* snaps, int nSteps, int iDim, int iStrMode, int iNode, int nStrMode, double freq1)$/;"	f	class:SubDomain
sndChannel	MultiGridLevel.h	/^    inline int sndChannel(int glSub,int neighb) const {$/;"	f	class:MultiGridLevel
sndChannel	SubDomain.h	/^  int *sndChannel;$/;"	m	class:SubDomain
sndConnect	Communicator.h	/^  Connectivity *sndConnect;$/;"	m	class:CommPattern
sndData	SubDomain.C	/^void SubDomain::sndData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
sndDiagBlocks	SubDomain.C	/^void SubDomain::sndDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
sndDiagInletBlocks	SubDomain.C	/^void SubDomain::sndDiagInletBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
sndEdgeData	SubDomain.C	/^void SubDomain::sndEdgeData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
sndEdgeData	SubDomainCore.C	/^void SubDomain::sndEdgeData(CommPattern<double> &edgePat, double *edgeData)$/;"	f	class:SubDomain
sndEdgeInfo	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::sndEdgeInfo(CommPattern<int> &edgeNumPat,int mySub)$/;"	f	class:MultiGridLevel
sndEdgeInfo	SubDomainCore.C	/^void SubDomain::sndEdgeInfo(CommPattern<int> &edgeNumPat)$/;"	f	class:SubDomain
sndGhostOffDiagBlocks	SubDomain.C	/^void SubDomain::sndGhostOffDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
sndGhostStates	SubDomain.C	/^void SubDomain::sndGhostStates(CommPattern<double> &sp, Vec<GhostPoint<dim>*> &ghostPoints, int shift)$/;"	f	class:SubDomain
sndGhostTags	SubDomain.C	/^void SubDomain::sndGhostTags(CommPattern<int> &sp, Vec<GhostPoint<dim>*> &ghostPoints)$/;"	f	class:SubDomain
sndGhostWeights	SubDomain.C	/^void SubDomain::sndGhostWeights(CommPattern<double> &sp, Vec<GhostPoint<dim>*> &ghostPoints, int shift)$/;"	f	class:SubDomain
sndInletData	SubDomain.C	/^void SubDomain::sndInletData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
sndInletRhsData	SubDomain.C	/^void SubDomain::sndInletRhsData(CommPattern<Scalar> &sp, Scalar (*w)[dim])$/;"	f	class:SubDomain
sndNormals	SubDomainCore.C	/^void SubDomain::sndNormals(CommPattern<double> &edgePat, Vec3D *edgeNorm,$/;"	f	class:SubDomain
sndNumGhostStates	SubDomain.C	/^void SubDomain::sndNumGhostStates(CommPattern<int> &sp, Vec<GhostPoint<dim>*> &ghostPoints)$/;"	f	class:SubDomain
sndOffDiagBlocks	SubDomain.C	/^void SubDomain::sndOffDiagBlocks(CommPattern<Scalar> &sp, GenMat<Scalar,dim> &A)$/;"	f	class:SubDomain
sndParity	StructExc.h	/^  int sndParity;$/;"	m	class:StructExc
snrm2_	arpack++/include/arlnames.h	147;"	d
snrm2_	arpack++/include/arlnames.h	76;"	d
solicitFluidIdFS	SubDomainCore.C	/^void SubDomain::solicitFluidIdFS(LevelSetStructure &LSS, Vec<int> &fluidId, SVec<bool,4> &poll)$/;"	f	class:SubDomain
solidX	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> *solidX;   \/\/pointer to Xs$/;"	m	class:DistIntersectorFRG
solidX	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> *solidX;   \/\/pointer to Xs$/;"	m	class:DistIntersectorPhysBAM
solidX0	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> *solidX0;  \/\/pointer to Xs0$/;"	m	class:DistIntersectorFRG
solidX0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> *solidX0;  \/\/pointer to Xs0$/;"	m	class:DistIntersectorPhysBAM
solidXdS	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> *solidXdS; \/\/pointer to dXdSb$/;"	m	class:DistIntersectorFRG
solidXdS	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> *solidXdS; \/\/pointer to dXdSb$/;"	m	class:DistIntersectorPhysBAM
solidXn	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> *solidXn;  \/\/pointer to Xs_n$/;"	m	class:DistIntersectorFRG
solidXn	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> *solidXn;  \/\/pointer to Xs_n$/;"	m	class:DistIntersectorPhysBAM
solidXnp1	IntersectorFRG/IntersectorFRG.h	/^    Vec<Vec3D> *solidXnp1;\/\/pointer to Xs_np1$/;"	m	class:DistIntersectorFRG
solidXnp1	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<Vec3D> *solidXnp1;\/\/pointer to Xs_np1$/;"	m	class:DistIntersectorPhysBAM
solutionIncrement	Timer.h	/^		solutionIncrement, linearSystemForm, linearSystemSolve, checkConvergence, gramSchmidt, romSol,$/;"	e	enum:Timer::TimerIndex
solutionMethod	IoData.h	/^  enum SolutionMethod { TIMESTEPPING = 0, MULTIGRID = 1} solutionMethod;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::SolutionMethod
solutions	IoData.h	/^  const char *solutions;$/;"	m	struct:InputData
solutions	IoData.h	/^  const char *solutions;$/;"	m	struct:RestartData
solutions	OneDimensionalSolver.h	/^  char *solutions;$/;"	m	class:OneDimensional
solutions	TsInput.h	/^  char *solutions;$/;"	m	struct:TsInput
solutions	TsRestart.h	/^  char *solutions[3];$/;"	m	class:TsRestart
solve	CorotSolver.C	/^void CorotSolver::solve(DistSVec<double,3> &dX, DistSVec<double,3> &X, BCApplier* meshMotionBCs)$/;"	f	class:CorotSolver
solve	DistLeastSquareSolver.C	/^DistLeastSquareSolver::solve() {$/;"	f	class:DistLeastSquareSolver
solve	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::solve(double *Xtilde, int nNodes, DistSVec<double,3> &X, DistSVec<double,3> &dX)$/;"	f	class:EmbeddedCorotSolver
solve	KspSolver.C	/^CgSolver<VecType,MatVecProdOp,PrecOp,IoOp>::solve(VecType &f, VecType &x)$/;"	f	class:CgSolver
solve	KspSolver.C	/^GcrSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::solve(VecType &b, VecType &x)$/;"	f	class:GcrSolver
solve	KspSolver.C	/^GmresSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::solve(VecSet<VecType> &b, $/;"	f	class:GmresSolver
solve	KspSolver.C	/^GmresSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::solve(VecType &b, VecType &x)$/;"	f	class:GmresSolver
solve	KspSolver.C	/^RichardsonSolver<VecType,MatVecProdOp,PrecOp,IoOp>::solve(VecType &b, VecType &x)$/;"	f	class:RichardsonSolver
solve	MeshMotionSolver.C	/^int EmbeddedALETetMeshMotionSolver::solve(DistSVec<double,3> &dX, DistSVec<double,3> &X)  {$/;"	f	class:EmbeddedALETetMeshMotionSolver
solve	MeshMotionSolver.C	/^int TetMeshMotionSolver::solve(DistSVec<double,3> &dX, DistSVec<double,3> &X)  {$/;"	f	class:TetMeshMotionSolver
solve	Modal.C	/^void ModalSolver<dim>::solve()  {$/;"	f	class:ModalSolver
solve	MultiGridKspSolver.C	/^solve(int lvl, MultiGridMvpMatrix<Scalar,neq>& M,$/;"	f	class:MultiGridKspSolver
solve	MultiGridSolver.h	/^int MultiGridSolver<ProblemDescriptor>::solve(IoData &ioData)$/;"	f	class:MultiGridSolver
solve	NewtonSolver.h	/^NewtonSolver<ProblemDescriptor>::solve(typename ProblemDescriptor::SolVecType &Q , const int timeStep, const double t)$/;"	f	class:NewtonSolver
solve	NonlinearRomOffline.C	/^void NonlinearRomOfflineSolver<dim>::solve()  {$/;"	f	class:NonlinearRomOfflineSolver
solve	Solvers/LevelSetSolver5.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:LevelSetSolver
solve	Solvers/NavierStokesCoupledSolver5.C	/^  ::solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesCoupledSolver
solve	Solvers/NavierStokesCoupledSolver6.C	/^  ::solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesCoupledSolver
solve	Solvers/NavierStokesCoupledSolver7.C	/^  ::solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesCoupledSolver
solve	Solvers/NavierStokesEmbeddedCoupledSolver5.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesEmbeddedCoupledSolver
solve	Solvers/NavierStokesEmbeddedCoupledSolver6.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesEmbeddedCoupledSolver
solve	Solvers/NavierStokesEmbeddedCoupledSolver7.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesEmbeddedCoupledSolver
solve	Solvers/NavierStokesEmbeddedSegSolver651.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesEmbeddedSegSolver
solve	Solvers/NavierStokesEmbeddedSegSolver752.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesEmbeddedSegSolver
solve	Solvers/NavierStokesMultiPhysicsEmbedded5.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesMultiPhysicsEmbedded
solve	Solvers/NavierStokesSegSolver651.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesSegSolver
solve	Solvers/NavierStokesSegSolver752.C	/^  solve(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f	class:NavierStokesSegSolver
solve	TsSolver.h	/^int TsSolver<ProblemDescriptor>::solve(IoData &ioData)$/;"	f	class:TsSolver
solve2x2System	LocalRiemann.h	/^bool LocalRiemannGfmpar::solve2x2System(double *mat, double *rhs, double *res)$/;"	f	class:LocalRiemannGfmpar
solveAdjoint	MeshMotionSolver.C	/^int TetMeshMotionSolver::solveAdjoint(DistSVec<double,3> &rhs, DistSVec<double,3> &lambdaX)  {$/;"	f	class:TetMeshMotionSolver
solveDeltaRot	CorotSolver.C	/^void CorotSolver::solveDeltaRot(DistSVec<double,3> &X, double deltaRot[3][3], double cg1[3])$/;"	f	class:CorotSolver
solveDeltaRot	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::solveDeltaRot(double *Xs, double deltaRot[3][3], double cg1[3])$/;"	f	class:EmbeddedCorotSolver
solveInTimeDomain	Modal.C	/^void ModalSolver<dim>::solveInTimeDomain()  {$/;"	f	class:ModalSolver
solveLS	KspSolver.C	/^CgSolver<VecType,MatVecProdOp,PrecOp,IoOp>::solveLS(VecType &f, VecType &x)$/;"	f	class:CgSolver
solveLS	KspSolver.C	/^GmresSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::solveLS(VecType &b, VecType &x)$/;"	f	class:GmresSolver
solveLS	KspSolver.C	/^RichardsonSolver<VecType,MatVecProdOp,PrecOp,IoOp>::solveLS(VecType &b, VecType &x)$/;"	f	class:RichardsonSolver
solveLS	KspSolver.h	/^  virtual int solveLS(VecType &, VecType &) { return 0; };$/;"	f	class:KspSolver
solveLS	NewtonSolver.h	/^NewtonSolver<ProblemDescriptor>::solveLS(typename ProblemDescriptor::PhiVecType &Phi,$/;"	f	class:NewtonSolver
solveLU	BlockTridiagonalMatrix.C	/^void BlockTridiagonalMatrix<Scalar,dim>::solveLU(Scalar (*b)[dim],Scalar (*x)[dim]) {$/;"	f	class:BlockTridiagonalMatrix
solveLinearSystem	ImplicitCoupledTsDesc.C	/^int ImplicitCoupledTsDesc<dim>::solveLinearSystem(int it, DistSVec<double,dim> &b, $/;"	f	class:ImplicitCoupledTsDesc
solveLinearSystem	ImplicitEmbeddedCoupledTsDesc.C	/^int ImplicitEmbeddedCoupledTsDesc<dim>::solveLinearSystem(int it, $/;"	f	class:ImplicitEmbeddedCoupledTsDesc
solveLinearSystem	ImplicitEmbeddedRomTsDesc.cpp	/^int ImplicitEmbeddedRomTsDesc<dim>::solveLinearSystem(int it, DistSVec<double, dim> &rhs,$/;"	f	class:ImplicitEmbeddedRomTsDesc
solveLinearSystem	ImplicitEmbeddedSegTsDesc.C	/^int ImplicitEmbeddedSegTsDesc<dim,neq1,neq2>::solveLinearSystem(int it, DistSVec<double,dim> &b,$/;"	f	class:ImplicitEmbeddedSegTsDesc
solveLinearSystem	ImplicitLevelSetTsDesc.C	/^int ImplicitLevelSetTsDesc<dim,dimLS>::solveLinearSystem(int it, DistSVec<double,dim> &b,$/;"	f	class:ImplicitLevelSetTsDesc
solveLinearSystem	ImplicitMultiPhysicsTsDesc.C	/^int ImplicitMultiPhysicsTsDesc<dim,dimLS>::solveLinearSystem(int it, DistSVec<double,dim> &b,$/;"	f	class:ImplicitMultiPhysicsTsDesc
solveLinearSystem	ImplicitRomTsDesc.C	/^int ImplicitRomTsDesc<dim>::solveLinearSystem(int it , Vec<double> &rhs, Vec<double> &sol)$/;"	f	class:ImplicitRomTsDesc
solveLinearSystem	ImplicitSegTsDesc.C	/^int ImplicitSegTsDesc<dim,neq1,neq2>::solveLinearSystem(int it, DistSVec<double,dim> &b, $/;"	f	class:ImplicitSegTsDesc
solveLinearSystem	MeshMotionSolver.C	/^int TetMeshMotionSolver::solveLinearSystem(int it, DistSVec<double,3> &rhs, $/;"	f	class:TetMeshMotionSolver
solveLinearSystem	MeshMotionSolver.h	/^  virtual int solveLinearSystem(int, DistSVec<double,3> &, DistSVec<double,3> &) { return 0; }$/;"	f	class:MeshMotionSolver
solveLinearSystem	SubDomainCore.C	/^void SubDomain::solveLinearSystem(bcomp *a, bcomp *b, int n) {$/;"	f	class:SubDomain
solveLinearSystemLS	ImplicitLevelSetTsDesc.C	/^int ImplicitLevelSetTsDesc<dim,dimLS>::solveLinearSystemLS(int it, DistSVec<double,dimLS> &b,$/;"	f	class:ImplicitLevelSetTsDesc
solveLinearSystemLS	ImplicitMultiPhysicsTsDesc.C	/^int ImplicitMultiPhysicsTsDesc<dim,dimLS>::solveLinearSystemLS(int it, DistSVec<double,dimLS> &b,$/;"	f	class:ImplicitMultiPhysicsTsDesc
solveMRhs	KspSolver.C	/^GcrSolver<VecType,MatVecProdOp,PrecOp,IoOp, ScalarT>::solveMRhs(VecType &b, VecType &x)$/;"	f	class:GcrSolver
solveNLAllFE	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::solveNLAllFE(DistSVec<double,dim> &U, double t0, DistSVec<double,dim> &Ubc)$/;"	f	class:ExplicitEmbeddedTsDesc
solveNLAllFE	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLAllFE(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLAllRK2	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::solveNLAllRK2(DistSVec<double,dim> &U, double t0, DistSVec<double,dim> &Ubc)$/;"	f	class:ExplicitEmbeddedTsDesc
solveNLAllRK2	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLAllRK2(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLAllRK2bis	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLAllRK2bis(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLAllRK4	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::solveNLAllRK4(DistSVec<double,dim> &U, double t0, DistSVec<double,dim> &Ubc)$/;"	f	class:ExplicitEmbeddedTsDesc
solveNLEuler	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLEuler(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLEulerRK2	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLEulerRK2(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLEulerRK4	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLEulerRK4(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLLevelSet	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLLevelSet(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLLevelSet	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLLevelSet(DistSVec<double,dim>& U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLLevelSetFE	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLLevelSetFE(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLLevelSetRK2	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLLevelSetRK2(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLLevelSetRK2	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLLevelSetRK2(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLLevelSetRK4	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLLevelSetRK4(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLLevelSetRK4	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLLevelSetRK4(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLNavierStokes	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLNavierStokes(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLNavierStokesFE	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLNavierStokesFE(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLNavierStokesRK2	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLNavierStokesRK2(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLNavierStokesRK4	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLNavierStokesRK4(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNLSystemOneBlock	ExplicitEmbeddedTsDesc.C	/^void ExplicitEmbeddedTsDesc<dim>::solveNLSystemOneBlock(DistSVec<double,dim> &U)$/;"	f	class:ExplicitEmbeddedTsDesc
solveNLSystemOneBlock	ExplicitLevelSetTsDesc.C	/^void ExplicitLevelSetTsDesc<dim,dimLS>::solveNLSystemOneBlock(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLSystemTwoBlocks	ExplicitLevelSetTsDesc.C	/^int ExplicitLevelSetTsDesc<dim,dimLS>::solveNLSystemTwoBlocks(DistSVec<double,dim> &U)$/;"	f	class:ExplicitLevelSetTsDesc
solveNLSystemTwoBlocks	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNLSystemTwoBlocks(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNewtonSystem	ImplicitCollocationTsDesc.C	/^void ImplicitCollocationTsDesc<dim>::solveNewtonSystem(const int &it, double &res, bool &breakloop, DistSVec<double, dim> &U, const int& totalTimeSteps)  {$/;"	f	class:ImplicitCollocationTsDesc
solveNewtonSystem	ImplicitGnatTsDesc.C	/^void ImplicitGnatTsDesc<dim>::solveNewtonSystem(const int &it, double &res, bool &breakloop, DistSVec<double, dim> &U, const int& totalTimeSteps)  {$/;"	f	class:ImplicitGnatTsDesc
solveNewtonSystem	ImplicitMetricTsDesc.C	/^void ImplicitMetricTsDesc<dim>::solveNewtonSystem(const int &it, double &res, bool &breakloop, DistSVec<double, dim> &U, const int& totalTimeSteps)  {$/;"	f	class:ImplicitMetricTsDesc
solveNewtonSystem	ImplicitPGTsDesc.C	/^void ImplicitPGTsDesc<dim>::solveNewtonSystem(const int &it, double &res, bool &breakloop, DistSVec<double, dim> &U, const int& totalTimeSteps)  {$/;"	f	class:ImplicitPGTsDesc
solveNewtonSystem	ImplicitRomPostproTsDesc.C	/^void ImplicitRomPostproTsDesc<dim>::solveNewtonSystem(const int &it, double &res, bool &breakloop, DistSVec<double, dim> &U, const int& totalTimeSteps)  {$/;"	f	class:ImplicitRomPostproTsDesc
solveNonLinearSystem	ExplicitEmbeddedTsDesc.C	/^int ExplicitEmbeddedTsDesc<dim>::solveNonLinearSystem(DistSVec<double,dim>& U,int)$/;"	f	class:ExplicitEmbeddedTsDesc
solveNonLinearSystem	ExplicitLevelSetTsDesc.C	/^int ExplicitLevelSetTsDesc<dim,dimLS>::solveNonLinearSystem(DistSVec<double,dim> &U, int)$/;"	f	class:ExplicitLevelSetTsDesc
solveNonLinearSystem	ExplicitMultiPhysicsTsDesc.C	/^int ExplicitMultiPhysicsTsDesc<dim,dimLS>::solveNonLinearSystem(DistSVec<double,dim> &U, int)$/;"	f	class:ExplicitMultiPhysicsTsDesc
solveNonLinearSystem	ExplicitTsDesc.C	/^int ExplicitTsDesc<dim>::solveNonLinearSystem(DistSVec<double,dim>& U, int)$/;"	f	class:ExplicitTsDesc
solveNonLinearSystem	ImplicitEmbeddedTsDesc.C	/^int ImplicitEmbeddedTsDesc<dim>::solveNonLinearSystem(DistSVec<double,dim> &U, int)$/;"	f	class:ImplicitEmbeddedTsDesc
solveNonLinearSystem	ImplicitLevelSetTsDesc.C	/^int ImplicitLevelSetTsDesc<dim,dimLS>::solveNonLinearSystem(DistSVec<double,dim> &U, int)$/;"	f	class:ImplicitLevelSetTsDesc
solveNonLinearSystem	ImplicitMultiPhysicsTsDesc.C	/^int ImplicitMultiPhysicsTsDesc<dim,dimLS>::solveNonLinearSystem(DistSVec<double,dim> &U, int)$/;"	f	class:ImplicitMultiPhysicsTsDesc
solveNonLinearSystem	ImplicitRomTsDesc.C	/^int ImplicitRomTsDesc<dim>::solveNonLinearSystem(DistSVec<double, dim> &U, const int totalTimeSteps)  {$/;"	f	class:ImplicitRomTsDesc
solveNonLinearSystem	ImplicitTsDesc.C	/^int ImplicitTsDesc<dim>::solveNonLinearSystem(DistSVec<double,dim> &U, const int timeStep)$/;"	f	class:ImplicitTsDesc
solveNonLinearSystem	TsDesc.h	/^  virtual int solveNonLinearSystem(DistSVec<double,dim> &U, int) { return 0; }$/;"	f	class:TsDesc
solveNonlinearSystem	ImplicitEmbeddedRomTsDesc.h	/^    int solveNonlinearSystem(DistSVec<double, dim> &Q, const int totalTimeSteps) { return super::solveNonLinearSystem(Q, totalTimeSteps); };$/;"	f	class:ImplicitEmbeddedRomTsDesc
solveRotMat	CorotSolver.C	/^void CorotSolver::solveRotMat(double m[3][3], double v[3])  $/;"	f	class:CorotSolver
solveRotMat	EmbeddedCorotSolver.C	/^void EmbeddedCorotSolver::solveRotMat(double m[3][3], double v[3])  $/;"	f	class:EmbeddedCorotSolver
solveSGTait	LocalRiemannDesc.h	/^inline void solveSGTait(double Rg,double Ug,double Pg, $/;"	f
solveSensitivity	MeshMotionSolver.h	/^  int solveSensitivity(DistSVec<double,3> &, DistSVec<double,3> &) { return 0; };$/;"	f	class:TetMeshMotionSolver
solveT	KspSolver.C	/^GmresSolver<VecType,MatVecProdOp,PrecOp,IoOp,ScalarT>::solveT(VecType &b,$/;"	f	class:GmresSolver
solveT	KspSolver.h	/^  int solveT(VecType &, VecType &) { return 0; }$/;"	f	class:GcrSolver
solveT	KspSolver.h	/^  int solveT(VecType &, VecType &) { return 0; }$/;"	f	class:RichardsonSolver
solveT	KspSolver.h	/^  int solveT(VecType &, VecType &) { return 0;}$/;"	f	class:CgSolver
solveWithMultipleICs	IoData.h	/^  enum SolveWithMultipleICs {_MULTIPLE_ICS_FALSE_ = 0, _MULTIPLE_ICS_TRUE_ = 1} solveWithMultipleICs;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::SolveWithMultipleICs
solveWithMultipleICs	TsSolver.h	/^int TsSolver<ProblemDescriptor>::solveWithMultipleICs(typename ProblemDescriptor::SolVecType &U, IoData &iod)$/;"	f	class:TsSolver
solvefluid	IoData.h	/^  enum SolveFluid {OFF = 0, ON = 1} solvefluid;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::SolveFluid
solverErrors	ErrorHandler.h	/^  std::vector<int> *solverErrors;$/;"	m	struct:ErrorHandler
sort	SparseGridCore.C	/^void SparseGrid::Heap::sort(int index, const double *value){$/;"	f	class:SparseGrid::Heap
sort	Vector.h	/^  void sort(int (*comp)(const void*, const void*),int imin=0,int imax=0) {$/;"	f	class:Vec
sort	Vector.h	/^  void sort(int mode = 0) {$/;"	f	class:SVec
sort	Vector.h	/^  void sort(int mode = 0) {$/;"	f	class:Vec
sortStruct	NonlinearRomDatabaseConstruction.C	/^struct sortStruct {$/;"	s	file:
sortedNodes	ReinitializeDistanceToWall.h	/^  DistVec<int> sortedNodes;$/;"	m	class:ReinitializeDistanceToWall
source	OneDimensionalSolver.h	/^  OneDimensionalSourceTerm *source; $/;"	m	class:OneDimensional
sourceIsLocal	Communicator.h	/^  int sourceIsLocal(int channel) { return glSubToCPU[allPairs[channel].from] == cpuNum; }$/;"	f	class:SubDTopo
sourceTermOrder	IoData.h	/^  int sourceTermOrder;$/;"	m	struct:OneDimensionalInfo
sower	IoData.h	/^  const char *sower;$/;"	m	struct:InputData
sowerInputs	IoData.h	/^  enum SowerInputs {SOWER_INPUTS_FALSE = 0, SOWER_INPUTS_TRUE = 1} sowerInputs;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::SowerInputs
sp	IoData.h	/^  SpiralingData sp;$/;"	m	struct:ForcedData
sp	parser/Assigner.h	/^    double T::*sp;$/;"	m	class:ClassDouble::T
sp	parser/Assigner.h	/^    int T::*sp;$/;"	m	class:ClassInt::T
spaceOp	MatVecProd.h	/^  MultiPhaseSpaceOperator<dim,dimLS> *spaceOp;$/;"	m	class:MatVecProdLS
spaceOp	MatVecProd.h	/^  MultiPhaseSpaceOperator<dim,dimLS> *spaceOp;$/;"	m	class:MatVecProdMultiPhase
spaceOp	MatVecProd.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:MatVecProdFD
spaceOp	MatVecProd.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:MatVecProdH1
spaceOp	MatVecProd.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:MatVecProdH2
spaceOp	MatVecProd.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:MatVecProd_dRdX
spaceOp	Modal.h	/^    SpaceOperator<dim> *spaceOp;$/;"	m	class:ModalSolver
spaceOp	PostOperator.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:PostOperator
spaceOp	TsDesc.h	/^  SpaceOperator<dim> *spaceOp;$/;"	m	class:TsDesc
spaceOp1	ImplicitEmbeddedSegTsDesc.h	/^  SpaceOperator<dim> *spaceOp1;$/;"	m	class:ImplicitEmbeddedSegTsDesc
spaceOp1	ImplicitSegTsDesc.h	/^  SpaceOperator<dim> *spaceOp1;$/;"	m	class:ImplicitSegTsDesc
spaceOp2	ImplicitEmbeddedSegTsDesc.h	/^  SpaceOperator<dim> *spaceOp2;$/;"	m	class:ImplicitEmbeddedSegTsDesc
spaceOp2	ImplicitSegTsDesc.h	/^  SpaceOperator<dim> *spaceOp2;$/;"	m	class:ImplicitSegTsDesc
sparseFlag	IoData.h	/^  int sparseFlag;$/;"	m	struct:SensitivityAnalysis
sparseGrid	IoData.h	/^  SparseGridData sparseGrid;$/;"	m	struct:MultiFluidData
sparseGrid	IoData.h	/^  const char *sparseGrid;$/;"	m	struct:TransientData
sparseGrids_	SparseGridCluster.h	/^  SparseGrid *sparseGrids_;$/;"	m	class:SparseGridCluster
spatialOnlyWithHomotopy	ImplicitRomTsDesc.h	/^  bool spatialOnlyWithHomotopy;$/;"	m	class:ImplicitRomTsDesc
spatialSetup	OneDimensionalSolver.C	/^void OneDimensional::spatialSetup(){$/;"	f	class:OneDimensional
specificHeat	IoData.h	/^  double specificHeat;$/;"	m	struct:LiquidModelData
specificHeatCstPressure	VarFcn.h	/^  double specificHeatCstPressure(int tag=0) const{ check(tag); return varFcn[tag]->specificHeatCstPressure(); }$/;"	f	class:VarFcn
specificHeatCstPressure	VarFcnBase.h	/^  virtual double specificHeatCstPressure() const{ $/;"	f	class:VarFcnBase
specificHeatCstPressure	VarFcnSGEuler.h	/^  double specificHeatCstPressure() const { return gam; }$/;"	f	class:VarFcnSGEuler
specificHeatCstPressure	VarFcnSGKE.h	/^  double specificHeatCstPressure() const { return gam; }$/;"	f	class:VarFcnSGKE
specificHeatCstPressure	VarFcnSGSA.h	/^  double specificHeatCstPressure() const { return gam; }$/;"	f	class:VarFcnSGSA
specificHeatCstPressure	VarFcnTait.h	/^  double specificHeatCstPressure() const{ return C_; }$/;"	f	class:VarFcnTait
specificHeatPressure	IoData.h	/^  double specificHeatPressure;$/;"	m	struct:GasModelData
specificHeatRatio	IoData.h	/^  double specificHeatRatio;$/;"	m	struct:GasModelData
specifiedIC	NonlinearRom.h	/^  bool specifiedIC;$/;"	m	class:NonlinearRom
speed	IoData.h	/^  const char *speed;$/;"	m	struct:TransientData
speed_of_light	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double speed_of_light=2.99792458e8; \/\/ m\/s$/;"	m	namespace:PhysBAM
sphereMap	IoData.h	/^  ObjectMap<SphereData> sphereMap;$/;"	m	struct:MultiInitialConditionsData
spheres	DistNodalGrad.h	/^  double spheres[SchemeFixData::num * 2][4];$/;"	m	class:DistNodalGrad
spheres	IoData.h	/^  SFixData* spheres[num];$/;"	m	struct:SchemeFixData
spherical	OneDimensionalSolver.h	/^    bool spherical;$/;"	m	class:OneDimensional::Veval
sphericalHarmonic	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::sphericalHarmonic$/;"	f	class:KirchhoffIntegrator
split	CommunicatorMPI.C	/^void Communicator::split(int color, int maxcolor, Communicator** c)$/;"	f	class:Communicator
split	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::split(DistEmbeddedVec<Scalar,dim1> &y, DistEmbeddedVec<Scalar,dim2> &z)$/;"	f	class:DistEmbeddedVec
split	DistVector.h	/^DistSVec<Scalar,dim>::split(DistSVec<Scalar,dim1> &y, DistSVec<Scalar,dim2> &z)$/;"	f	class:DistSVec
splitQuads	FSI/CrackingSurface.cpp	/^int CrackingSurface::splitQuads(int* quadTopo, int nQuads, int(*triaTopo)[3])$/;"	f	class:CrackingSurface
splitQuads	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::splitQuads(int* quads, int nStElems)$/;"	f	class:EmbeddedStructure
splitVal	IntersectorFRG/Geometry/KDTree.h	/^     double splitVal; \/\/ Value detemining which branch to take$/;"	m	class:KDTree
split_axis	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    int split_axis; \/\/ 0 means leaf$/;"	m	class:PhysBAM::KD_TREE_NODE
split_value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less
split_value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^        ARRAY_VIEW<const TV>* points;int axis;T split_value;$/;"	m	class:PhysBAM::KD_TREE::Partition_Helper_Less_Equal
split_value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    T split_value;$/;"	m	class:PhysBAM::KD_TREE_NODE
splitter	utils/Predicate.C	/^REAL splitter;     \/* = 2^ceiling(p \/ 2) + 1.  Used to split floats in half. *\/$/;"	v
sprec	DistTimeState.h	/^  SpatialLowMachPrec sprec; \/\/only for computation of irey$/;"	m	class:DistTimeState
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLCEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLCKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLCSA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLEEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLEKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacHLLESA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacRoeEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacRoeKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnApprJacRoeSA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnExactJacRoeEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnExactJacRoeKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnExactJacRoeSA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLCEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLCKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLCSA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLEEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLEKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacHLLESA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacRoeEuler3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacRoeKE3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnFDJacRoeSA3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnRoeKEturb3D
sprec	FluxFcnDesc.h	/^  SpatialLowMachPrec sprec;$/;"	m	class:FluxFcnRoeSAturb3D
sptrf	arpack++/include/lapackc.h	/^inline void sptrf(const char* trans, const ARint &n, double ap[], $/;"	f
sptrf	arpack++/include/lapackc.h	/^inline void sptrf(const char* trans, const ARint &n, float ap[], $/;"	f
sptrs	arpack++/include/lapackc.h	/^inline void sptrs(const char* trans, const ARint &n, const ARint &nrhs,$/;"	f
sqNorm	Vector.h	/^double sqNorm(Vec3D x) { return x.v[0]*x.v[0] + x.v[1]*x.v[1] + x.v[2]*x.v[2]; }$/;"	f
sqNorm	Vector.h	/^double sqNorm(complex<Scalar> x) { return (x*conj(x)).real(); }$/;"	f
sqNorm	Vector.h	/^double sqNorm(double x) { return x*x;}$/;"	f
sqr	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/sqr.h	/^inline T sqr(const T a)$/;"	f	namespace:PhysBAM
sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.cpp	/^sqrt(const VECTOR<T,d>& v)$/;"	f	class:PhysBAM
sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^sqrt(const VECTOR<T,1>& v)$/;"	f	namespace:PhysBAM
sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^sqrt(const VECTOR<T,2>& v)$/;"	f	namespace:PhysBAM
sqrt	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^sqrt(const VECTOR<T,3>& v)$/;"	f	namespace:PhysBAM
srot_	arpack++/include/arlnames.h	152;"	d
srot_	arpack++/include/arlnames.h	81;"	d
ss	tools/alloca.cougar.c	/^    long ss[0200];		\/* 0200 overflow words.  *\/$/;"	m	struct:stack_segment_linkage	file:
ssa0	tools/alloca.cougar.c	/^    long ssa0;$/;"	m	struct:stack_segment_linkage	file:
ssa1	tools/alloca.cougar.c	/^    long ssa1;$/;"	m	struct:stack_segment_linkage	file:
ssa2	tools/alloca.cougar.c	/^    long ssa2;$/;"	m	struct:stack_segment_linkage	file:
ssa3	tools/alloca.cougar.c	/^    long ssa3;$/;"	m	struct:stack_segment_linkage	file:
ssa4	tools/alloca.cougar.c	/^    long ssa4;$/;"	m	struct:stack_segment_linkage	file:
ssa5	tools/alloca.cougar.c	/^    long ssa5;$/;"	m	struct:stack_segment_linkage	file:
ssa6	tools/alloca.cougar.c	/^    long ssa6;$/;"	m	struct:stack_segment_linkage	file:
ssa7	tools/alloca.cougar.c	/^    long ssa7;$/;"	m	struct:stack_segment_linkage	file:
ssbase	tools/alloca.cougar.c	/^    long ssbase:32;		\/* Offset to stack base.  *\/$/;"	m	struct:stack_segment_linkage	file:
sscal	arpack++/include/blas1c.h	/^inline void sscal(const ARint &n, const double &da, arcomplex<double> dx[],$/;"	f
sscal	arpack++/include/blas1c.h	/^inline void sscal(const ARint &n, const float &da, arcomplex<float> dx[],$/;"	f
sscal_	arpack++/include/arlnames.h	145;"	d
sscal_	arpack++/include/arlnames.h	74;"	d
sscale	OneDimensionalSolver.h	/^  double sscale[PostFcn::SSIZE];$/;"	m	class:OneDimensional
sscale	TsOutput.h	/^  double sscale[PostFcn::SSIZE];$/;"	m	class:TsOutput
sscray	tools/alloca.cougar.c	/^    long sscray[7];		\/* Reserved for Cray Research.  *\/$/;"	m	struct:stack_segment_linkage	file:
sscsnm	tools/alloca.cougar.c	/^    long sscsnm;		\/* Private control structure number for$/;"	m	struct:stack_segment_linkage	file:
ssgvup	tools/alloca.cougar.c	/^    long ssgvup;		\/* Pointer to multitasking thread giveup.  *\/$/;"	m	struct:stack_segment_linkage	file:
sspseg	tools/alloca.cougar.c	/^    long sspseg:32;		\/* Offset to linkage control of previous$/;"	m	struct:stack_segment_linkage	file:
sss0	tools/alloca.cougar.c	/^    long sss0;$/;"	m	struct:stack_segment_linkage	file:
sss1	tools/alloca.cougar.c	/^    long sss1;$/;"	m	struct:stack_segment_linkage	file:
sss2	tools/alloca.cougar.c	/^    long sss2;$/;"	m	struct:stack_segment_linkage	file:
sss3	tools/alloca.cougar.c	/^    long sss3;$/;"	m	struct:stack_segment_linkage	file:
sss4	tools/alloca.cougar.c	/^    long sss4;$/;"	m	struct:stack_segment_linkage	file:
sss5	tools/alloca.cougar.c	/^    long sss5;$/;"	m	struct:stack_segment_linkage	file:
sss6	tools/alloca.cougar.c	/^    long sss6;$/;"	m	struct:stack_segment_linkage	file:
sss7	tools/alloca.cougar.c	/^    long sss7;$/;"	m	struct:stack_segment_linkage	file:
sssize	tools/alloca.cougar.c	/^    long sssize:32;		\/* Number of words in this segment.  *\/$/;"	m	struct:stack_segment_linkage	file:
sstcpt	tools/alloca.cougar.c	/^    long sstcpt:32;		\/* Pointer to task common address block.  *\/$/;"	m	struct:stack_segment_linkage	file:
sstpid	tools/alloca.cougar.c	/^    long sstpid;		\/* Process ID for pid based multi-tasking.  *\/$/;"	m	struct:stack_segment_linkage	file:
ssusr1	tools/alloca.cougar.c	/^    long ssusr1;		\/* Reserved for user.  *\/$/;"	m	struct:stack_segment_linkage	file:
ssusr2	tools/alloca.cougar.c	/^    long ssusr2;		\/* Reserved for user.  *\/$/;"	m	struct:stack_segment_linkage	file:
ssymv_	arpack++/include/arlnames.h	148;"	d
ssymv_	arpack++/include/arlnames.h	77;"	d
ssyr2_	arpack++/include/arlnames.h	151;"	d
ssyr2_	arpack++/include/arlnames.h	80;"	d
stElem	EmbeddedCorotSolver.h	/^  int (*stElem)[3];$/;"	m	class:EmbeddedCorotSolver
stElem	IntersectorFRG/IntersectorFRG.h	/^    int (*stElem)[3];     \/\/structural elements (element to node connectivity)$/;"	m	class:DistIntersectorFRG
stElem	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int (*stElem)[3]; \/\/structure elements (topology)$/;"	m	class:DistIntersectorPhysBAM
stabil_alpha	IoData.h	/^  double stabil_alpha;$/;"	m	struct:EmbeddedFramework
stabil_alpha	LocalRiemannDesc.h	/^  double stabil_alpha;$/;"	m	class:LocalRiemannFluidStructure
stack_control_header	tools/alloca.cougar.c	/^struct stack_control_header$/;"	s	file:
stack_dir	tools/alloca.cougar.c	/^static int stack_dir;		\/* 1 or -1 once known.  *\/$/;"	v	file:
stack_end_t	arpack++/include/arlspdef.h	/^typedef enum {HEAD, TAIL}              stack_end_t;$/;"	t	typeref:enum:__anon33
stack_segment_linkage	tools/alloca.cougar.c	/^struct stack_segment_linkage$/;"	s	file:
start	IntersectorFRG/IntersectorFRG.C	/^ClosestTriangle::start(Vec3D xp) {$/;"	f	class:ClosestTriangle
start	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^        double start,elapsed,accumulator;$/;"	m	struct:PhysBAM::TIMER::DATA
startCode	tools/loader.C	/^int startCode(int argc, char **argv, const char *routine)$/;"	f
startLevelSetSolver	Solvers/LevelSetSolver.h	/^void startLevelSetSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startModalSolver	ModalSolver.C	/^void startModalSolver(Communicator *com, IoData &ioData, Domain &domain)$/;"	f
startNavierStokesCoupledSolver	Solvers/NavierStokesCoupledSolver.h	/^void startNavierStokesCoupledSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesEmbedded	Solvers/NavierStokesEmbedded.h	/^void startNavierStokesEmbedded(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesEmbeddedCoupledSolver	Solvers/NavierStokesEmbeddedCoupledSolver.h	/^void startNavierStokesEmbeddedCoupledSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesEmbeddedSegSolver	Solvers/NavierStokesEmbeddedSegSolver.h	/^void startNavierStokesEmbeddedSegSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesMultiPhysicsEmbedded	Solvers/NavierStokesMultiPhysicsEmbedded.h	/^void startNavierStokesMultiPhysicsEmbedded(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesSegSolver	Solvers/NavierStokesSegSolver.h	/^void startNavierStokesSegSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNavierStokesSolver	NavierStokesSolver.C	/^void startNavierStokesSolver(IoData &ioData, GeoSource &geoSource, Domain &domain)$/;"	f
startNonlinearRomOfflineSolver	NonlinearRomOfflineSolver.C	/^void startNonlinearRomOfflineSolver(Communicator *com, IoData &ioData, Domain &domain, GeoSource &geoSource)$/;"	f
startSparseGridGeneration	NavierStokesSolver.C	/^void startSparseGridGeneration(IoData &ioData, Domain &domain)$/;"	f
start_on_separate_line	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    static bool start_on_separate_line,log_file_start_on_separate_line;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
startup	IoData.h	/^  enum Startup {REGULAR = 0, MODIFIED = 1} startup;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::Startup
state	IoData.h	/^  StateData state;$/;"	m	struct:ROBConstructionData
state	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK,class T> struct HASHTABLE_ENTRY_TEMPLATE{HASHTABLE_ENTRY_STATE state;TK key;T data;};$/;"	m	struct:PhysBAM::HASHTABLE_ENTRY_TEMPLATE
state	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^template<class TK> struct HASHTABLE_ENTRY_TEMPLATE<TK,void>{HASHTABLE_ENTRY_STATE state;TK key;};$/;"	m	struct:PhysBAM::HASHTABLE_ENTRY_TEMPLATE
stateBasisCentersDifProduct	NonlinearRom.h	/^  std::vector<std::vector<std::vector<std::vector<double> > > > stateBasisCentersDifProduct;  \/\/[iCluster][mCenter][pCenter][:]$/;"	m	class:NonlinearRom
stateBasisName	IoData.h	/^  const char *stateBasisName;$/;"	m	struct:NonlinearRomFilesData
stateBasisName	NonlinearRom.h	/^  char* stateBasisName;$/;"	m	class:NonlinearRom
stateBasisPrefix	IoData.h	/^  const char *stateBasisPrefix;$/;"	m	struct:NonlinearRomFilesData
stateBasisPrefix	NonlinearRom.h	/^  char* stateBasisPrefix;$/;"	m	class:NonlinearRom
stateDistanceComparisonInfoExactUpdatesMultiICName	IoData.h	/^  const char *stateDistanceComparisonInfoExactUpdatesMultiICName;$/;"	m	struct:NonlinearRomFilesData
stateDistanceComparisonInfoExactUpdatesMultiICName	NonlinearRom.h	/^  char* stateDistanceComparisonInfoExactUpdatesMultiICName;$/;"	m	class:NonlinearRom
stateDistanceComparisonInfoExactUpdatesName	IoData.h	/^  const char *stateDistanceComparisonInfoExactUpdatesName;$/;"	m	struct:NonlinearRomFilesData
stateDistanceComparisonInfoExactUpdatesName	NonlinearRom.h	/^  char* stateDistanceComparisonInfoExactUpdatesName;$/;"	m	class:NonlinearRom
stateDistanceComparisonInfoName	IoData.h	/^  const char *stateDistanceComparisonInfoName;$/;"	m	struct:NonlinearRomFilesData
stateDistanceComparisonInfoName	NonlinearRom.h	/^  char* stateDistanceComparisonInfoName;$/;"	m	class:NonlinearRom
stateIncrement	ImplicitTsDesc.h	/^  DistSVec<double,dim> *stateIncrement;$/;"	m	class:ImplicitTsDesc
stateInitialization	OneDimensionalSolver.C	/^void OneDimensional::stateInitialization(OneDimensionalInfo &data){$/;"	f	class:OneDimensional
stateMaskSnapFile	IoData.h	/^    const char *stateMaskSnapFile; \/\/<! for snapshot with embedded methods, Lei Lei, 02\/03\/2016$/;"	m	struct:InputData
stateMaskVector	IoData.h	/^    const char *stateMaskVector;$/;"	m	struct:ROMOutputData
stateMaskVectors	TsOutput.h	/^    char *stateMaskVectors; \/\/<! for embdded ROM, Lei lei, 02\/01\/2016$/;"	m	class:TsOutput
stateOutputFreqNewton	IoData.h	/^  int stateOutputFreqNewton;$/;"	m	struct:ROMOutputData
stateOutputFreqNewton	TsOutput.h	/^  int stateOutputFreqNewton;$/;"	m	class:TsOutput
stateOutputFreqTime	IoData.h	/^  int stateOutputFreqTime;$/;"	m	struct:ROMOutputData
stateOutputFreqTime	TsOutput.h	/^  int stateOutputFreqTime;$/;"	m	class:TsOutput
statePrefix	IoData.h	/^  const char *statePrefix;$/;"	m	struct:NonlinearRomFilesData
stateSingValsName	IoData.h	/^  const char *stateSingValsName;$/;"	m	struct:NonlinearRomFilesData
stateSingValsName	NonlinearRom.h	/^  char* stateSingValsName;$/;"	m	class:NonlinearRom
stateSnapFile	IoData.h	/^  const char *stateSnapFile;$/;"	m	struct:InputData
stateSnapRefSolution	IoData.h	/^  const char *stateSnapRefSolution;$/;"	m	struct:InputData
stateSnapsFromFile	NonlinearRom.h	/^  std::vector<int> stateSnapsFromFile;   \/\/ stateSnapsFromFile[iFile] = number of snapshots taken from file iFile$/;"	m	class:NonlinearRom
stateSnapsName	IoData.h	/^  const char *stateSnapsName;$/;"	m	struct:NonlinearRomFilesData
stateSnapsName	NonlinearRom.h	/^  char* stateSnapsName;$/;"	m	class:NonlinearRom
stateSnapshotClustersAfterOverlap	NonlinearRomDatabaseConstruction.h	/^  std::vector<std::vector<std::vector<bool> > > stateSnapshotClustersAfterOverlap;  \/\/ [iFile][iSnap][iCluster] = true or false$/;"	m	class:NonlinearRomDatabaseConstruction
stateSnapshotTags	NonlinearRom.h	/^  std::vector<std::vector<double> > stateSnapshotTags; \/\/ stateSnapshotInfo[iFile][iSnap] = tag associated with snapshot$/;"	m	class:NonlinearRom
stateSnapshotsData	IoData.h	/^    StateSnapshotsData stateSnapshotsData;$/;"	m	struct:EmbeddedAlternatingLeastSquareData
stateVector	IoData.h	/^  const char *stateVector;$/;"	m	struct:ROMOutputData
stateVectors	TsOutput.h	/^  char *stateVectors;$/;"	m	class:TsOutput
static_assert_test	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<int x> struct static_assert_test{};$/;"	s	namespace:PhysBAM
status	LevelSet/LevelSetStructure.h	/^    DistVec<int> *status;$/;"	m	class:DistLevelSetStructure
status	LevelSet/LevelSetStructure.h	/^    Vec<int> &status;$/;"	m	class:LevelSetStructure
status	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<int> &status;$/;"	m	class:MultiGridLevelSetStructure
status	MemoryPool.h	/^  ResizeArray<bool> status;$/;"	m	class:MemoryPool
status0	IntersectorFRG/IntersectorFRG.h	/^    DistVec<int> *status0;  \/\/previous node status$/;"	m	class:DistIntersectorFRG
status0	IntersectorFRG/IntersectorFRG.h	/^    Vec<int> &status0; \/\/<! status at the previous time-step.$/;"	m	class:IntersectorFRG
status0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    DistVec<int> *status0;  \/\/previous node status$/;"	m	class:DistIntersectorPhysBAM
status0	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec<int> &status0; \/\/<! status at the previous time-step.$/;"	m	class:IntersectorPhysBAM
stcols	arpack++/include/ardfmat.h	/^  int      stcols;    \/\/ Number of columns actually stored in val.$/;"	m	class:ARdfMatrix
steady	HeatTransferHandler.h	/^  bool steady;$/;"	m	class:HeatTransferHandler
steady	MeshMotionHandler.h	/^  bool steady;$/;"	m	class:AeroMeshMotionHandler
steady	MeshMotionHandler.h	/^  bool steady;$/;"	m	class:EmbeddedMeshMotionHandler
steady	TsOutput.h	/^  bool steady;$/;"	m	class:TsOutput
steadyTol	EmbeddedFluidShapeOptimizationHandler.h	/^  double steadyTol;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
steadyTol	FluidShapeOptimizationHandler.h	/^  double steadyTol;$/;"	m	class:FluidShapeOptimizationHandler
stencil	DistEmbeddedVector.h	/^    const std::set<int>& stencil(int iSub) const { return x.stencil(iSub); }$/;"	f	class:EmbeddedDiffExpr
stencil	DistEmbeddedVector.h	/^    const std::set<int>& stencil(int iSub) const { return x.stencil(iSub); }$/;"	f	class:EmbeddedExpr
stencil	DistEmbeddedVector.h	/^    const std::set<int>& stencil(int iSub) const { return x.stencil(iSub); }$/;"	f	class:EmbeddedSumExpr
stencil	DistEmbeddedVector.h	/^  const std::set<int>& stencil(int iSub) const { return ghostNodes[iSub]; }$/;"	f	class:DistEmbeddedVec
stencil	DistEmbeddedVector.h	/^  const std::set<int>& stencil(int iSub) const { return x.stencil(iSub); }$/;"	f	class:EmbeddedScaleExpr
step	EmbeddedFluidShapeOptimizationHandler.h	/^  int step;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
step	FluidCollocationShapeOptimizationHandler.h	/^  int step;$/;"	m	class:FluidCollocationShapeOptimizationHandler
step	FluidGnatShapeOptimizationHandler.h	/^  int step;$/;"	m	class:FluidGnatShapeOptimizationHandler
step	FluidMetricShapeOptimizationHandler.h	/^  int step;$/;"	m	class:FluidMetricShapeOptimizationHandler
step	FluidRomShapeOptimizationHandler.h	/^  int step;$/;"	m	class:FluidRomShapeOptimizationHandler
step	FluidShapeOptimizationHandler.h	/^  int step;$/;"	m	class:FluidShapeOptimizationHandler
step	OneDimensionalSolver.h	/^    int step;$/;"	m	struct:OneDimensional::__anon12
step	TriangulatedInterface.h	/^  void step(Domain* domain, DistSVec<double,3>& X,$/;"	f	class:TriangulatedInterface
step	TsOutput.h	/^    int step;$/;"	m	struct:TsOutput::__anon29
step1ForA6	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step1ForA6(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step1ForC0FEM	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step1ForC0FEM(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step1ForC0XFEM	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step1ForC0XFEM(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step1ForC0XFEM3D	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step1ForC0XFEM3D(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step2ForA6	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step2ForA6(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step2ForC0	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step2ForC0(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step2ForC0XFEM3D	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step2ForC0XFEM3D(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
step2ForPP	MeshMotionHandlerCore.C	/^void EmbeddedMeshMotionHandler::step2ForPP(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
stepsize	IoData.h	/^  double stepsize;$/;"	m	struct:LinearizedData
stepsizeinitial	IoData.h	/^  double stepsizeinitial;$/;"	m	struct:LinearizedData
stiffFlag	MeshMotionSolver.h	/^  bool stiffFlag;$/;"	m	class:TetMeshMotionSolver
stiffenedGas_rarefaction	ImplicitRiemann.C	/^void stiffenedGas_rarefaction(double Pstar, double gamma, double Pck, double Pk,double rhok, double out[])$/;"	f
stiffenedGas_shock	ImplicitRiemann.C	/^void stiffenedGas_shock(double Pstar, double gamma, double Pck, double Pk,double rhok, double out[])$/;"	f
stk_stat	tools/alloca.cougar.c	/^struct stk_stat$/;"	s	file:
stk_trailer	tools/alloca.cougar.c	/^struct stk_trailer$/;"	s	file:
stkm_free	tools/alloca.cougar.c	/^    long stkm_free;		\/* Number of deallocations by $STKMRET.  *\/$/;"	m	struct:stk_stat	file:
stko_free	tools/alloca.cougar.c	/^    long stko_free;		\/* Number of deallocations by $STKRETN.  *\/$/;"	m	struct:stk_stat	file:
stko_mallocs	tools/alloca.cougar.c	/^    long stko_mallocs;		\/* Block allocations by $STKOFEN.  *\/$/;"	m	struct:stk_stat	file:
storeAllClusters	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::StoreAllClusters
storeAllClusters	IoData.h	/^  enum StoreAllClusters {STORE_ALL_CLUSTERS_FALSE = 0, STORE_ALL_CLUSTERS_TRUE = 1} storeAllClusters;$/;"	m	struct:ROBConstructionData	typeref:enum:ROBConstructionData::StoreAllClusters
storeFluidSuggestedTimestep	MeshMotionHandler.h	/^  virtual void storeFluidSuggestedTimestep(double dtf) {dtf0 = dtf;}$/;"	f	class:MeshMotionHandler
storeOldV	DistExactRiemannSolver.C	/^void DistExactRiemannSolver<dim>::storeOldV(DistSVec<double,dim> &V) {$/;"	f	class:DistExactRiemannSolver
storePreviousPrimitive	DistExactRiemannSolver.C	/^void DistExactRiemannSolver<dim>::storePreviousPrimitive(DistSVec<double,dim> &V,$/;"	f	class:DistExactRiemannSolver
storePreviousPrimitive	Domain.C	/^void Domain::storePreviousPrimitive(DistSVec<double,dim> &V, DistVec<int> &fluidId, $/;"	f	class:Domain
storePreviousPrimitive	SubDomain.C	/^void SubDomain::storePreviousPrimitive(SVec<double,dim> &V, Vec<int> &fluidId, $/;"	f	class:SubDomain
store_id	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    bool store_id;$/;"	m	class:PhysBAM::POINT_CLOUD
store_values_on_internal_nodes	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    bool store_values_on_internal_nodes;$/;"	m	class:PhysBAM::KD_TREE
store_velocity	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.h	/^    bool store_velocity;$/;"	m	class:PhysBAM::GEOMETRY_PARTICLES
storedAllOfflineQuantities	NonlinearRom.h	/^  bool storedAllOfflineQuantities;$/;"	m	class:NonlinearRom
storedAllOnlineQuantities	NonlinearRom.h	/^  bool storedAllOnlineQuantities;$/;"	m	class:NonlinearRom
str	parser/Assigner.h	/^  const char *T::*str;$/;"	m	class:ClassStr::T
strCom	Domain.h	/^  Communicator *strCom;$/;"	m	class:Domain
strCom	StructExc.h	/^  Communicator *strCom;$/;"	m	class:StructExc
strExc	HeatTransferHandler.h	/^  StructExc* strExc;$/;"	m	class:HeatTransferHandler
strExc	MeshMotionHandler.h	/^  StructExc *strExc;$/;"	m	class:AeroMeshMotionHandler
strKPtraces	IoData.h	/^  const char *strKPtraces;$/;"	m	struct:RestartData
strKPtraces	IoData.h	/^  const char* strKPtraces;$/;"	m	struct:InputData
strModesFile	IoData.h	/^  const char *strModesFile;$/;"	m	struct:InputData
strModesFile	IoData.h	/^  const char *strModesFile;$/;"	m	struct:LinearizedData
strTimer	Domain.h	/^  Timer *strTimer;$/;"	m	class:Domain
strategy	IoData.h	/^  enum Strategy {DEFAULT = -1, RESIDUAL = 0, DIRECTION = 1, DFT = 2, HYBRID = 3, FIXEDUNSTEADY = 4, OLD = 5} strategy;$/;"	m	struct:CFLData	typeref:enum:CFLData::Strategy
stream	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    std::istream& stream;$/;"	m	class:PhysBAM::TYPED_ISTREAM
stream	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    std::ostream& stream;$/;"	m	class:PhysBAM::TYPED_OSTREAM
stringMap	parser/ParseTree.h	/^    std::map<Token,const char *> stringMap;$/;"	m	class:ParseTree
stringNew	parser/StringManager.C	/^char * StringManager::stringNew(int bufferLength)$/;"	f	class:StringManager
string_sprintf	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.h	/^inline std::string string_sprintf(const char *format_string,...) \/\/ Assumes a max string length of 2048, since Windows doesn't support safety$/;"	f	namespace:PhysBAM::STRING_UTILITIES
strings	parser/StringManager.h	/^  std::list<char*> strings;$/;"	m	class:StringManager
strip	DistVector.h	/^DistSVec<Scalar,dim>::strip(DistSVec<Scalar,dim1> &y)$/;"	f	class:DistSVec
strows	arpack++/include/ardfmat.h	/^  int      strows;    \/\/ Number of rows actually stored in val.$/;"	m	class:ARdfMatrix
strsm_	arpack++/include/arlnames.h	156;"	d
strsm_	arpack++/include/arlnames.h	85;"	d
strsv_	arpack++/include/arlnames.h	154;"	d
strsv_	arpack++/include/arlnames.h	83;"	d
structExc	FSI/DynamicNodalTransfer.h	/^  StructExc* structExc;$/;"	m	class:EmbeddedStructure
structId	VarFcn.h	/^  int structId()             {return ghostId;}$/;"	f	class:VarFcn
structNorm	IntersectorFRG/IntersectorFRG.C	/^  Vec3D *structNorm;$/;"	m	class:ClosestTriangle	file:
structNormal	IoData.h	/^  enum StructureNormal {ELEMENT_BASED = 0, NODE_BASED = 1} structNormal;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::StructureNormal
structPhase	VarFcn.h	/^  int structPhase()          {return ghostPhase;}$/;"	f	class:VarFcn
structPos	TsRestart.h	/^  char *structPos;$/;"	m	class:TsRestart
structSubcycling	FSI/DynamicNodalTransfer.h	/^        int  structSubcycling() {return structureSubcycling;}$/;"	f	class:DynamicNodalTransfer
structUpd	Timer.h	/^		structUpd, mesh, meshAssembly, meshPrecSetup, meshKsp, podConstr,$/;"	e	enum:Timer::TimerIndex
structX	IntersectorFRG/IntersectorFRG.C	/^  Vec3D *structX;$/;"	m	class:ClosestTriangle	file:
structure	FSI/DynamicNodalTransfer.h	/^        EmbeddedStructure structure;$/;"	m	class:DynamicNodalTransfer
structureSubcycling	FSI/DynamicNodalTransfer.h	/^        int structureSubcycling;$/;"	m	class:DynamicNodalTransfer
structureSubcycling	MeshMotionHandler.h	/^  int structureSubcycling() {return dynNodalTransfer->structSubcycling();}$/;"	f	class:EmbeddedMeshMotionHandler
structureSubcycling	MeshMotionHandler.h	/^  virtual int    structureSubcycling() {return 0;}$/;"	f	class:MeshMotionHandler
structureSubcycling	TsDesc.h	/^  int structureSubcycling() {return (mmh ? mmh->structureSubcycling() : 0);}$/;"	f	class:TsDesc
sub	BlockTridiagonalMatrix.h	/^  Scalar (*sub)[dim*dim];$/;"	m	class:BlockTridiagonalMatrix
sub	DenseMatrixOps.h	/^  static void sub(Scalar (*b)[5], int i, Scalar (*c)[5], int j) {$/;"	f	class:VectorOp
sub	DenseMatrixOps.h	/^  static void sub(Scalar (*b)[dim], int i, Scalar (*c)[dim], int j) {$/;"	f	class:VectorOp
sub2pack	IntersectorFRG/IntersectorFRG.h	/^    map<int,int> sub2pack;$/;"	m	class:IntersectorFRG
sub2pack	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    map<int,int> sub2pack;$/;"	m	class:IntersectorPhysBAM
subAssigner	parser/Assigner.h	/^    map<int, Assigner *>subAssigner;$/;"	m	class:ClassAssigner
subBcData	DistBcData.h	/^  BcData<dim> **subBcData;$/;"	m	class:DistBcData
subCells	MacroCell.h	/^  int* subCells;$/;"	m	class:MacroCell
subD	GappyPreprocessing.h	/^	SubDomain** subD; $/;"	m	class:GappyPreprocessing
subD	IntersectorFRG/IntersectorFRG.h	/^    SubDomain *subD;$/;"	m	class:IntersectorFRG
subD	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    SubDomain &subD;$/;"	m	class:IntersectorPhysBAM
subD	LevelSet/MultiGridLevelSetStructure.h	/^    SubDomain &subD;$/;"	m	class:MultiGridLevelSetStructure
subDFindMaxError	GappyPreprocessing.C	/^template<int dim> void GappyPreprocessing<dim>::subDFindMaxError(int iSub, bool$/;"	f	class:GappyPreprocessing
subData	DistVector.h	/^  Scalar (*subData(int i) const)[dim] { return this->v+distInfo.subOffset[i]; }$/;"	f	class:DistSVec
subData	DistVector.h	/^  Scalar *subData(int isub) const { return this->v+distInfo.subOffset[isub]; }$/;"	f	class:DistVec
subDomain	CurvatureDetection.h	/^  SubDomain** subDomain;$/;"	m	class:CurvatureDetection
subDomain	DistBcData.h	/^  SubDomain **subDomain;$/;"	m	class:DistBcData
subDomain	DistEdgeGrad.h	/^  SubDomain** subDomain;$/;"	m	class:DistEdgeGrad
subDomain	DistExtrapolation.h	/^  SubDomain** subDomain;$/;"	m	class:DistExtrapolation
subDomain	DistMacroCell.h	/^  SubDomain** subDomain;$/;"	m	class:DistMacroCellSet
subDomain	DistMatrix.h	/^  SubDomain **subDomain;$/;"	m	class:DistMat
subDomain	Domain.h	/^  SubDomain **subDomain;$/;"	m	class:Domain
subDomain	EdgeGalerkin.h	/^  SubDomain **subDomain;$/;"	m	class:EdgeGalerkin
subDomain	MatVecProd.h	/^  SubDomain **subDomain;$/;"	m	class:MatVecProd_dRdX
subDomain	ParallelRom.h	/^	SubDomain **subDomain;$/;"	m	class:ParallelRom
subDomain	PostOperator.h	/^  SubDomain **subDomain;$/;"	m	class:PostOperator
subDomainToProcessorMap	IntersectorPhysBAM/FloodFill.h	/^int* subDomainToProcessorMap;$/;"	m	class:FloodFill
subEdgeGrad	DistEdgeGrad.h	/^  EdgeGrad<dim>** subEdgeGrad;$/;"	m	class:DistEdgeGrad
subExactRiemannSolver	DistExactRiemannSolver.h	/^  ExactRiemannSolver<dim> **subExactRiemannSolver;$/;"	m	class:DistExactRiemannSolver
subExtrapolation	DistExtrapolation.h	/^  Extrapolation<dim>** subExtrapolation;$/;"	m	class:DistExtrapolation
subGeoState	DistGeoState.h	/^  GeoState **subGeoState;$/;"	m	class:DistGeoState
subId	IoData.h	/^    int subId;$/;"	m	struct:Probes::Node
subId	TsOutput.h	/^    int* subId;$/;"	m	struct:TsOutput::__anon29
subIdx	VectorSet.h	/^   int subIdx;$/;"	m	class:SubVecSet
subIndexedMap	parser/ParseTree.h	/^    std::map<int,ParseTree *> subIndexedMap;$/;"	m	class:ParseTree
subLSS	LevelSet/MultiGridLevelSetStructure.h	/^  MultiGridLevelSetStructure** subLSS;$/;"	m	class:DistMultiGridLevelSetStructure
subLen	DistInfo.h	/^  int *subLen;$/;"	m	struct:DistInfo
subLenReg	DistInfo.h	/^  int *subLenReg;$/;"	m	struct:DistInfo
subMatchNode	MatchNode.h	/^  int subMatchNode(int i) { return(index[i][0]); } \/\/HB: returns the subdomain node of the ith matched node 	$/;"	f	class:MatchNodeSet
subNodalGrad	DistNodalGrad.h	/^  NodalGrad<dim, Scalar> **subNodalGrad;$/;"	m	class:DistNodalGrad
subNumNeighb	Communicator.h	/^  int *subNumNeighb;$/;"	m	class:SubDTopo
subOffset	DistInfo.h	/^  int *subOffset;$/;"	m	struct:DistInfo
subOffsetReg	DistInfo.h	/^  int *subOffsetReg;$/;"	m	struct:DistInfo
subSize	DistInfo.h	/^  int subSize(int sub) const { return (subLen) ? subLen[sub] : 0; } \/\/HB$/;"	f	struct:DistInfo
subSize	DistVector.h	/^  int subSize(int i) const { return distInfo.subLen[i]; }$/;"	f	class:DistSVec
subSize	DistVector.h	/^  int subSize(int isub) const { return distInfo.subLen[isub]; }$/;"	f	class:DistVec
subTimeState	DistTimeState.h	/^  TimeState<dim> **subTimeState;$/;"	m	class:DistTimeState
subToCluster	GeoSource.h	/^  int (*subToCluster)[2];$/;"	m	class:GeoSource
subToSub	GeoSource.h	/^  Connectivity *subToSub;$/;"	m	class:GeoSource
subToSub	MultiGridLevel.h	/^    Connectivity * subToSub;$/;"	m	class:MultiGridLevel
subTokenMap	parser/ParseTree.h	/^    std::map<Token,ParseTree *> subTokenMap;$/;"	m	class:ParseTree
subTopo	Domain.h	/^  SubDTopo *subTopo;$/;"	m	class:Domain
subVec	DistVector.h	/^  SVec<Scalar,dim> **subVec;$/;"	m	class:DistSVec
subVec	DistVector.h	/^  Vec<Scalar> **subVec;$/;"	m	class:DistVec
subtractCenters	IoData.h	/^  enum SubtractClusterCenters {SUBTRACT_CENTERS_FALSE = 0, SUBTRACT_CENTERS_TRUE = 1} subtractCenters;$/;"	m	struct:StateSnapshotsData	typeref:enum:StateSnapshotsData::SubtractClusterCenters
subtractNearestSnapsToCenters	IoData.h	/^  enum SubtractNearestSnapshotToCenter {SUBTRACT_NEAREST_FALSE = 0, SUBTRACT_NEAREST_TRUE = 1} subtractNearestSnapsToCenters;$/;"	m	struct:StateSnapshotsData	typeref:enum:StateSnapshotsData::SubtractNearestSnapshotToCenter
subtractRefSol	IoData.h	/^  enum ProjectSnapshotsMinusRefSol {PROJECT_SNAPS_MINUS_REF_SOL_FALSE = 0, PROJECT_SNAPS_MINUS_REF_SOL_TRUE = 1} subtractRefSol;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::ProjectSnapshotsMinusRefSol
subtractRefState	IoData.h	/^  enum SubtractRefState {SUBTRACT_REF_STATE_FALSE = 0, SUBTRACT_REF_STATE_TRUE = 1} subtractRefState;$/;"	m	struct:StateSnapshotsData	typeref:enum:StateSnapshotsData::SubtractRefState
sufficDecreaseLS	ImplicitEmbeddedTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitEmbeddedTsDesc
sufficDecreaseLS	ImplicitLevelSetTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitLevelSetTsDesc
sufficDecreaseLS	ImplicitMultiPhysicsTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitMultiPhysicsTsDesc
sufficDecreaseLS	ImplicitTsDesc.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:ImplicitTsDesc
sufficDecreaseLS	MeshMotionSolver.h	/^  double contractionLS, sufficDecreaseLS;$/;"	m	class:TetMeshMotionSolver
suffix	SubDomain.h	/^  char suffix[100];$/;"	m	class:SubDomain
sum	DenseMatrixOps.h	/^  static void sum(Scalar (*a)[5], int k, Scalar (*b)[5], int i, Scalar (*c)[5], int j) {$/;"	f	class:VectorOp
sum	DenseMatrixOps.h	/^  static void sum(Scalar (*a)[dim], int k, Scalar (*b)[dim], int i, $/;"	f	class:VectorOp
sum	DistVector.h	/^DistVec<Scalar>::sum() const$/;"	f	class:DistVec
sum	DistVector.h	/^void DistSVec<Scalar,dim>::sum(Scalar sumres[dim]) const$/;"	f	class:DistSVec
sum	Vector.h	/^  Scalar sum() const { $/;"	f	class:Vec
sum	Vector.h	/^  double* sum()  {$/;"	f	class:SVec
sumInletNormals	SubDomainCore.C	/^void SubDomain::sumInletNormals(Vec<Vec3D>& inletNodeNorm, Vec<Vec3D>& faceNorm, Vec<int>& numFaceNeighb)$/;"	f	class:SubDomain
summonSlaves	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::summonSlaves(double *&mem, VecSet<DistSVec<double, dim> > &X, const int M,$/;"	f	class:EmbeddedAlternatingLeastSquare
summonSlaves	ParallelRomExtension.cpp	/^void ParallelRomExtension<dim>::summonSlaves(double *&mem, Mat &X, const int M,$/;"	f	class:ParallelRomExtension
summonZombies	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::summonZombies(double *&mem, VecSet<DistSVec<double, dim> > &X, const int M,$/;"	f	class:EmbeddedAlternatingLeastSquare
summonZombies	ParallelRomExtension.cpp	/^void ParallelRomExtension<dim>::summonZombies(double *&mem, Mat &X, const int M,$/;"	f	class:ParallelRomExtension
sup_to_col	arpack++/include/arlsupm.h	/^  int *sup_to_col;   \/* sup_to_col[s] points to the start of the s-th $/;"	m	struct:__anon48
super	BlockTridiagonalMatrix.h	/^  Scalar (*super)[dim*dim];$/;"	m	class:BlockTridiagonalMatrix
super	ImplicitEmbeddedRomTsDesc.h	/^    typedef ImplicitEmbeddedCoupledTsDesc<dim> super;$/;"	t	class:ImplicitEmbeddedRomTsDesc
supno	arpack++/include/arlspdef.h	/^    int     *supno;   $/;"	m	struct:__anon35
supno	arpack++/include/arlspdef.h	/^    int     *supno;   $/;"	m	struct:__anon36
supno	arpack++/include/arlspdef.h	/^    int     *supno;   $/;"	m	struct:__anon37
supno	arpack++/include/arlspdef.h	/^    int     *supno;   $/;"	m	struct:__anon38
suppress_cerr	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool suppress_cerr;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
suppress_cout	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool suppress_cout;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
suppress_timing	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool suppress_timing;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
surfComputeMap	PostOperator.h	/^  map<int,int> surfComputeMap; \/\/AS far as I can figure out this map is never used$/;"	m	class:PostOperator
surfKI	IoData.h	/^  KirchhoffData surfKI;$/;"	m	class:IoData
surfOutMap	PostOperator.h	/^  map<int,int> surfOutMap;$/;"	m	class:PostOperator
surfOutMapHF	PostOperator.h	/^  map<int,int> surfOutMapHF;$/;"	m	class:PostOperator
surface	EmbeddedFluidShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
surface	FluidCollocationShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:FluidCollocationShapeOptimizationHandler
surface	FluidGnatShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:FluidGnatShapeOptimizationHandler
surface	FluidMetricShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:FluidMetricShapeOptimizationHandler
surface	FluidRomShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:FluidRomShapeOptimizationHandler
surface	FluidShapeOptimizationHandler.h	/^  double surface;$/;"	m	class:FluidShapeOptimizationHandler
surface	IoData.h	/^  double surface;$/;"	m	struct:TransientData
surface	TsOutput.h	/^  double surface;$/;"	m	class:TsOutput
surfaceCentersName	IoData.h	/^  const char *surfaceCentersName;$/;"	m	struct:NonlinearRomFilesData
surfaceCentersName	NonlinearRom.h	/^  char* surfaceCentersName;$/;"	m	class:NonlinearRom
surfaceDisplacementName	IoData.h	/^  const char *surfaceDisplacementName;$/;"	m	struct:NonlinearRomFilesData
surfaceDisplacementName	NonlinearRom.h	/^  char* surfaceDisplacementName;$/;"	m	class:NonlinearRom
surfaceID	FSI/DynamicNodalTransfer.h	/^  int *surfaceID;$/;"	m	class:EmbeddedStructure
surfaceID	IntersectorFRG/IntersectorFRG.h	/^    int *surfaceID;$/;"	m	class:DistIntersectorFRG
surfaceID	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int *surfaceID;$/;"	m	class:DistIntersectorPhysBAM
surfaceInitialDisplacementName	IoData.h	/^  const char *surfaceInitialDisplacementName;$/;"	m	struct:NonlinearRomFilesData
surfaceMap	BCApplier.h	/^    map<int,SurfaceData*>& surfaceMap;$/;"	m	class:BCApplier
surfaceMap	IoData.h	/^  ObjectMap<SurfaceData> surfaceMap;$/;"	m	struct:Surfaces
surfaceMatchStateName	IoData.h	/^  const char *surfaceMatchStateName;$/;"	m	struct:NonlinearRomFilesData
surfaceMatchStateName	NonlinearRom.h	/^  char* surfaceMatchStateName;$/;"	m	class:NonlinearRom
surfaceMeshConstruction	GappyPreprocessing.h	/^  bool surfaceMeshConstruction;$/;"	m	class:GappyPreprocessing
surfaceMeshConstruction	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
surfaceMeshName	IoData.h	/^  const char *surfaceMeshName;$/;"	m	struct:NonlinearRomFilesData
surfaceMeshName	NonlinearRom.h	/^  char* surfaceMeshName;$/;"	m	class:NonlinearRom
surfaceMultiSolutionsName	IoData.h	/^  const char *surfaceMultiSolutionsName;$/;"	m	struct:NonlinearRomFilesData
surfaceMultiSolutionsName	NonlinearRom.h	/^  char* surfaceMultiSolutionsName;$/;"	m	class:NonlinearRom
surfaceNormals	LevelSet/MultiGridLevelSetStructure.h	/^    Vec<Vec3D> &surfaceNormals;$/;"	m	class:MultiGridLevelSetStructure
surfaceNormals	LevelSet/MultiGridLevelSetStructure.h	/^  DistVec<Vec3D>* surfaceNormals;$/;"	m	class:DistMultiGridLevelSetStructure
surfaceOutput	Timer.h	/^		approxMetricPrepro, surfaceMeshConstruction, surfaceOutput, sampledMeshConstruction, sampledOutput, pseudoInv,$/;"	e	enum:Timer::TimerIndex
surfacePrefix	IoData.h	/^  const char *surfacePrefix;$/;"	m	struct:NonlinearRomFilesData
surfaceRefStateName	IoData.h	/^  const char *surfaceRefStateName;$/;"	m	struct:NonlinearRomFilesData
surfaceRefStateName	NonlinearRom.h	/^  char* surfaceRefStateName;$/;"	m	class:NonlinearRom
surfaceShapeDerivativeName	IoData.h	/^  const char *surfaceShapeDerivativeName;$/;"	m	struct:NonlinearRomFilesData
surfaceShapeDerivativeName	NonlinearRom.h	/^  char* surfaceShapeDerivativeName;$/;"	m	class:NonlinearRom
surfaceSolutionName	IoData.h	/^  const char *surfaceSolutionName;$/;"	m	struct:NonlinearRomFilesData
surfaceSolutionName	NonlinearRom.h	/^  char* surfaceSolutionName;$/;"	m	class:NonlinearRom
surfaceStateBasisName	IoData.h	/^  const char *surfaceStateBasisName;$/;"	m	struct:NonlinearRomFilesData
surfaceStateBasisName	NonlinearRom.h	/^  char* surfaceStateBasisName;$/;"	m	class:NonlinearRom
surfaceWallDistName	IoData.h	/^  const char *surfaceWallDistName;$/;"	m	struct:NonlinearRomFilesData
surfaceWallDistName	NonlinearRom.h	/^  char* surfaceWallDistName;$/;"	m	class:NonlinearRom
surface_id	Face.h	/^  int surface_id;$/;"	m	class:Face
surface_levelset	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    LocalLevelSet *surface_levelset;$/;"	m	class:PhysBAM::PhysBAMInterface
surfaceheatflux	IoData.h	/^  const char *surfaceheatflux;$/;"	m	struct:TransientData
surfaces	IoData.h	/^  Surfaces surfaces;$/;"	m	class:IoData
surplus	SparseGrid.h	/^  double **surplus;       \/\/ hierarchical surplus for each point for each output$/;"	m	class:SparseGrid
surrogateinterface	IoData.h	/^  enum SurrogateInterface{HYBRID = 0, EXTERNAL = 1} surrogateinterface;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::SurrogateInterface
sutherlandConstant	IoData.h	/^  double sutherlandConstant;$/;"	m	struct:ViscosityModelData
sutherlandReferenceTemperature	IoData.h	/^  double sutherlandReferenceTemperature;$/;"	m	struct:ViscosityModelData
swap	arpack++/include/blas1c.h	/^inline void swap(const ARint &n, arcomplex<double> dx[], const ARint &incx,$/;"	f
swap	arpack++/include/blas1c.h	/^inline void swap(const ARint &n, arcomplex<float> dx[], const ARint &incx,$/;"	f
swap	arpack++/include/blas1c.h	/^inline void swap(const ARint &n, double dx[], const ARint &incx,$/;"	f
swap	arpack++/include/blas1c.h	/^inline void swap(const ARint &n, float dx[], const ARint &incx,$/;"	f
swapBytes	BinFileHandler.h	/^  bool swapBytes;$/;"	m	class:BinFileHandler
swapVector	BinFileHandler.h	/^void BinFileHandler::swapVector(Scalar *p, int nobjs)$/;"	f	class:BinFileHandler
sweepFreq	IoData.h	/^  int sweepFreq;$/;"	m	struct:RelativeProjectionErrorData
switchOpt	TsOutput.h	/^  bool switchOpt;$/;"	m	class:TsOutput
sym	Communicator.h	/^  Symmetry sym;$/;"	m	class:CommPattern
symbolicILU	SparseMatrix.C	/^void SparseMat<Scalar,dim>::symbolicILU(const int levfill)$/;"	f	class:SparseMat
symmetry	IoData.h	/^  SymmetryData symmetry;$/;"	m	struct:DefoMeshMotionData
symmetry	IoData.h	/^  enum Symmetry {NONE = 0, X = 1, Y = 2, Z = 3} symmetry;$/;"	m	struct:SchemeFixData	typeref:enum:SchemeFixData::Symmetry
sync	Communicator.h	/^  int sync() { return(barrier()); } ;$/;"	f	class:Communicator
sync	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    int sync()$/;"	f	class:PhysBAM::LOG_REAL::LOG_CERR_BUFFER	file:
sync	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    int sync()$/;"	f	class:PhysBAM::LOG_REAL::LOG_COUT_BUFFER	file:
syncMap	IntersectorPhysBAM/Mpi_Utilities.C	/^void syncMap(Domain& domain, Communicator& com,map<int,int>& localMap){$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
syncNodeColors	IntersectorPhysBAM/Mpi_Utilities.C	/^void syncNodeColors(Domain& domain, Communicator& com,const DistVec<int>& nodeColors_input,set<pair<pair<GLOBAL_SUBD_ID,int>,pair<GLOBAL_SUBD_ID,int> > >& connections){$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
synchronizeMaxNumber	IntersectorPhysBAM/Mpi_Utilities.h	/^void synchronizeMaxNumber(Communicator& com, T& numberToMax)$/;"	f	namespace:PHYSBAM_MPI_UTILITIES
sysSmb	parser/Dictionary.C	/^SysSmbMap *sysSmb = 0;$/;"	v
systemApprox	ImplicitRomTsDesc.h	/^  bool systemApprox;$/;"	m	class:ImplicitRomTsDesc
systemApproximation	IoData.h	/^  enum SystemApproximation {SYSTEM_APPROXIMATION_NONE = 0, GNAT = 1, COLLOCATION = 2, APPROX_METRIC_NL = 3} systemApproximation;$/;"	m	struct:NonlinearRomOnlineData	typeref:enum:NonlinearRomOnlineData::SystemApproximation
t	AutoDiff/SpaceDerivatives.h	/^    Scalar t;$/;"	m	class:SpatialView
t	Elem.h	/^  Target *t;$/;"	m	class:ElemWrapper_Scalar_dim_neq
t	Elem.h	/^  Target *t;$/;"	m	class:ElemWrapper_dim
t	Elem.h	/^  Target *t;$/;"	m	class:ElemWrapper_dim_obj
t	Extrapolation.h	/^  double t;$/;"	m	struct:ExtrapolationNodeData
t	Face.h	/^  Target *t;$/;"	m	class:FaceWrapper_Scalar_dim_neq
t	Face.h	/^  Target *t;$/;"	m	class:FaceWrapper_dim
t	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^    TV t; \/\/ defaults to 0$/;"	m	class:PhysBAM::FRAME
t	V6NodeData.h	/^  double t;$/;"	m	struct:V6NodeData
t0	FSI/DynamicNodalTransfer.h	/^  double t0; \/\/ starting time.$/;"	m	class:EmbeddedStructure
t0	ODEIntegrator.h	/^  double t0,tfinal;$/;"	m	class:ODEIntegrator
tId	IntersectorFRG/IntersectorFRG.h	/^    DistVec<int> *tId;$/;"	m	class:DistIntersectorFRG
tInput	Modal.h	/^    TsInput *tInput;$/;"	m	class:ModalSolver
tInput	NonlinearRomOffline.h	/^    TsInput *tInput;$/;"	m	class:NonlinearRomOfflineSolver
tMax	FSI/DynamicNodalTransfer.h	/^        double tMax;$/;"	m	class:DynamicNodalTransfer
tMax	FSI/DynamicNodalTransfer.h	/^  double dt, tMax;$/;"	m	class:EmbeddedStructure
tOutput	Modal.h	/^    TsOutput<dim> *tOutput;$/;"	m	class:ModalSolver
tRestart	Modal.h	/^    TsRestart *tRestart;$/;"	m	class:ModalSolver
tScale	FSI/DynamicNodalTransfer.h	/^        const double tScale; \/\/scaling factor for time$/;"	m	class:DynamicNodalTransfer
tScale	FSI/DynamicNodalTransfer.h	/^  double tScale;$/;"	m	class:EmbeddedStructure
tState	Modal.h	/^    DistTimeState<dim> *tState;$/;"	m	class:ModalSolver
t_max	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/RAY.h	/^    T t_max; \/\/ maximum value of t allowed for the ray$/;"	m	class:PhysBAM::RAY
table	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    ARRAY<ENTRY> table;$/;"	m	class:PhysBAM::HASHTABLE
tabulate	SparseGrid.C	/^void SparseGrid::tabulate(FnType fn, bool restart){$/;"	f	class:SparseGrid
tabulate	SparseGrid.C	/^void SparseGrid::tabulate(void (T::*fn)(double *, double *, double *), $/;"	f	class:SparseGrid
tabulate	SparseGridGeneratorDesc.h	/^  void tabulate(IoData & ioData){$/;"	f	class:SparseGridGeneratorDesc
tabulationC	DistExactRiemannSolver.h	/^  SparseGridCluster *tabulationC;$/;"	m	class:DistExactRiemannSolver
tabulationC	OneDimensionalSolver.h	/^  SparseGridCluster* tabulationC;$/;"	m	class:OneDimensional
tabulationFileName	IoData.h	/^  const char *tabulationFileName;$/;"	m	struct:SparseGridData
tag	CurvatureDetection.h	/^  DistVec<double>* tag;$/;"	m	class:CurvatureDetection
tag	DistEdgeGrad.h	/^  DistVec<bool> *tag;$/;"	m	class:DistEdgeGrad
tag	DistNodalGrad.h	/^  DistVec<bool> *tag;$/;"	m	class:DistNodalGrad
tag	Domain.h	/^  DistSVec<int,2> *tag;$/;"	m	class:Domain
tag	EdgeGrad.h	/^  bool *tag;$/;"	m	class:EdgeGrad
tag	ImplicitEmbeddedTsDesc.h	/^  DistSVec<bool,2> *tag;$/;"	m	class:ImplicitEmbeddedTsDesc
tag	ImplicitLevelSetTsDesc.h	/^  DistSVec<bool,2> *tag;$/;"	m	class:ImplicitLevelSetTsDesc
tag	ImplicitMultiPhysicsTsDesc.h	/^  DistSVec<bool,2> *tag;$/;"	m	class:ImplicitMultiPhysicsTsDesc
tag	ImplicitRomTsDesc.h	/^  DistSVec<bool,2> *tag;$/;"	m	class:ImplicitRomTsDesc
tag	ImplicitTsDesc.h	/^  DistSVec<bool,2> *tag;$/;"	m	class:ImplicitTsDesc
tag	IoData.h	/^  enum Tag {MACH = 0, TIME = 1, VELOCITY = 2} tag;$/;"	m	struct:RigidMeshMotionData	typeref:enum:RigidMeshMotionData::Tag
tag	ReinitializeDistanceToWall.h	/^  DistVec<int> tag;$/;"	m	class:ReinitializeDistanceToWall
tagBar	Domain.h	/^  DistSVec<int,2> *tagBar;$/;"	m	class:Domain
tagEdgesOnBoundaries	FaceCore.C	/^void Face::tagEdgesOnBoundaries(Vec<bool> &tagEdges)$/;"	f	class:Face
tagNodesOnBoundaries	FaceCore.C	/^void Face::tagNodesOnBoundaries(Vec<bool> &tagNodes)$/;"	f	class:Face
tait_rarefaction	ImplicitRiemann.C	/^void tait_rarefaction(double rhostar, double Pinf,double a, double alpha,$/;"	f
tait_shock	ImplicitRiemann.C	/^void tait_shock(double rhostar, double Pinf,double a, double alpha,$/;"	f
target	Connectivity.h	/^  int *target;        \/\/ value of the connectivity$/;"	m	class:Connectivity
target	ImplicitRomTsDesc.h	/^  double target, res0;	\/\/ for Newton convergence$/;"	m	class:ImplicitRomTsDesc
targetRegionMask	GappyPreprocessing.h	/^  DistVec<double>* targetRegionMask;$/;"	m	class:GappyPreprocessing
tau_n	TimeData.h	/^  double tau_n;$/;"	m	class:TimeData
tau_nm1	TimeData.h	/^  double tau_nm1;$/;"	m	class:TimeData
tavcsdles	IoData.h	/^  const char *tavcsdles;$/;"	m	struct:TransientData
tavcsdvms	IoData.h	/^  const char *tavcsdvms;$/;"	m	struct:TransientData
tavdensity	IoData.h	/^  const char *tavdensity;$/;"	m	struct:TransientData
tavdisplacement	IoData.h	/^  const char *tavdisplacement;$/;"	m	struct:TransientData
tavforces	IoData.h	/^  const char *tavforces;$/;"	m	struct:TransientData
tavforces	TsOutput.h	/^  char *tavforces;$/;"	m	class:TsOutput
tavlift	IoData.h	/^  const char *tavlift;$/;"	m	struct:TransientData
tavlift	TsOutput.h	/^  char *tavlift;$/;"	m	class:TsOutput
tavmach	IoData.h	/^  const char *tavmach;$/;"	m	struct:TransientData
tavpressure	IoData.h	/^  const char *tavpressure;$/;"	m	struct:TransientData
tavsfric	IoData.h	/^  const char *tavsfric;$/;"	m	struct:TransientData
tavtemperature	IoData.h	/^  const char *tavtemperature;$/;"	m	struct:TransientData
tavtotalpressure	IoData.h	/^  const char *tavtotalpressure;$/;"	m	struct:TransientData
tavvelocity	IoData.h	/^  const char *tavvelocity;$/;"	m	struct:TransientData
tavvorticity	IoData.h	/^  const char *tavvorticity;$/;"	m	struct:TransientData
tc	IoData.h	/^  TurbulenceClosureData tc;$/;"	m	struct:EquationsData
tell	BinFileHandler.h	/^BinFileHandler::OffType BinFileHandler::tell() $/;"	f	class:BinFileHandler
temp	IoData.h	/^  double temp;$/;"	m	struct:SurfaceData
temp	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
temperature	IoData.h	/^  const char *temperature;$/;"	m	struct:LinePlot
temperature	IoData.h	/^  const char *temperature;$/;"	m	struct:Probes
temperature	IoData.h	/^  const char *temperature;$/;"	m	struct:TransientData
temperature	IoData.h	/^  double temperature;$/;"	m	struct:BcsFreeStreamData
temperature	IoData.h	/^  double temperature;$/;"	m	struct:BcsWallData
temperature	IoData.h	/^  double temperature;$/;"	m	struct:BoundaryData
temperature	IoData.h	/^  double temperature;$/;"	m	struct:InitialConditions
temperature	IoData.h	/^  double temperature;$/;"	m	struct:ReferenceStateData
temperature	RefVal.h	/^  double temperature;$/;"	m	class:RefVal
temperature1	IoData.h	/^  double density1, velocity1, pressure1,temperature1;$/;"	m	struct:OneDimensionalInfo
temperature2	IoData.h	/^  double density2, velocity2, pressure2,temperature2;$/;"	m	struct:OneDimensionalInfo
template_applyToDerivativeOfResidualTerm	BcFcnCore.C	/^void BcFcnNS::template_applyToDerivativeOfResidualTerm(int type, double *Vwall, double *dVwall, double *U, double *dU, double *dF)$/;"	f	class:BcFcnNS
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnKE::template_applyToDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnKE
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnKEturb::template_applyToDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnKEturb
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnNS::template_applyToDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnNS
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnSA::template_applyToDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnSA
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnSA::template_applyToDiagonalTerm(int type, double *Vwall, double *dVwall, double *U, Scalar *A)$/;"	f	class:BcFcnSA
template_applyToDiagonalTerm	BcFcn.C	/^void BcFcnSAturb::template_applyToDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnSAturb
template_applyToOffDiagonalTerm	BcFcn.C	/^void BcFcnKE::template_applyToOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnKE
template_applyToOffDiagonalTerm	BcFcn.C	/^void BcFcnKEturb::template_applyToOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnKEturb
template_applyToOffDiagonalTerm	BcFcn.C	/^void BcFcnNS::template_applyToOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnNS
template_applyToOffDiagonalTerm	BcFcn.C	/^void BcFcnSA::template_applyToOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnSA
template_applyToOffDiagonalTerm	BcFcn.C	/^void BcFcnSAturb::template_applyToOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnSAturb
template_applyToResidualTerm	BcFcnCore.C	/^void BcFcnNS::template_applyToResidualTerm(int type, double *Vwall, double *U, double *F)$/;"	f	class:BcFcnNS
template_applyToSolutionVectorTerm	BcFcnCore.C	/^void BcFcnNS::template_applyToSolutionVectorTerm(int type, double *Vwall, double *U)$/;"	f	class:BcFcnNS
template_applyToTurbDiagonalTerm	BcFcn.C	/^void BcFcnKE::template_applyToTurbDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnKE
template_applyToTurbDiagonalTerm	BcFcn.C	/^void BcFcnKEturb::template_applyToTurbDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnKEturb
template_applyToTurbDiagonalTerm	BcFcn.C	/^void BcFcnSA::template_applyToTurbDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnSA
template_applyToTurbDiagonalTerm	BcFcn.C	/^void BcFcnSAturb::template_applyToTurbDiagonalTerm(int type, double *Vwall, double *U, Scalar *A)$/;"	f	class:BcFcnSAturb
template_applyToTurbOffDiagonalTerm	BcFcn.C	/^void BcFcnKE::template_applyToTurbOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnKE
template_applyToTurbOffDiagonalTerm	BcFcn.C	/^void BcFcnKEturb::template_applyToTurbOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnKEturb
template_applyToTurbOffDiagonalTerm	BcFcn.C	/^void BcFcnSA::template_applyToTurbOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnSA
template_applyToTurbOffDiagonalTerm	BcFcn.C	/^void BcFcnSAturb::template_applyToTurbOffDiagonalTerm(int type, Scalar *A)$/;"	f	class:BcFcnSAturb
template_zeroDiagonalTerm	BcFcn.C	/^void BcFcnNS::template_zeroDiagonalTerm(int type, Scalar *A)  {$/;"	f	class:BcFcnNS
tempnormalderivative	IoData.h	/^  const char *tempnormalderivative;$/;"	m	struct:TransientData
temporalSetup	OneDimensionalSolver.C	/^void OneDimensional::temporalSetup(){$/;"	f	class:OneDimensional
tener	TsOutput.h	/^  double tener,tenerold;$/;"	m	class:TsOutput
tenerold	TsOutput.h	/^  double tener,tenerold;$/;"	m	class:TsOutput
tensorize	SparseGridCore.C	/^void SparseGrid::tensorize(double **res, double ** coordDim,$/;"	f	class:SparseGrid
test	ImplicitEmbeddedRomTsDesc.cpp	/^void ImplicitEmbeddedRomTsDesc<dim>::test(){$/;"	f	class:ImplicitEmbeddedRomTsDesc
test	IoData.h	/^  enum Test {REGULAR = 0} test;$/;"	m	struct:ProblemData	typeref:enum:ProblemData::Test
test	SparseGrid.C	/^void SparseGrid::test(FnType fn, int type, int *number, double *param){$/;"	f	class:SparseGrid
test	SparseGrid.C	/^void SparseGrid::test(void (T::*fn)(double *, double *, double *), T &object,$/;"	f	class:SparseGrid
test	TsDesc.h	/^    virtual void test() {} \/\/ a placeholder for derived class to run tests\/diagnostics$/;"	f	class:TsDesc
testAlpha	IntersectorPhysBAM/IntersectorPhysBAM.C	/^IntersectorPhysBAM::testAlpha(Vec3D Xi, Vec3D Xj, Vec3D X0, Vec3D X1, Vec3D X2){$/;"	f	class:IntersectorPhysBAM
testAlpha	LevelSet/MultiGridLevelSetStructure.h	/^    void testAlpha(Vec3D, Vec3D, int, int, int, double*, double){}$/;"	f	class:DistMultiGridLevelSetStructure
testApproxMetric	IoData.h	/^  enum TestApproxMetric {TEST_APPROX_METRIC_FALSE = 0, TEST_APPROX_METRIC_TRUE = 1} testApproxMetric;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::TestApproxMetric
testCase	IoData.h	/^  int testCase; $/;"	m	struct:EmbeddedFramework
testCase	IoData.h	/^  int testCase;$/;"	m	struct:MultiFluidData
testEdge	SubDomain.h	/^  int testEdge;$/;"	m	class:SubDomain
testInnerProduct	GappyPreprocessing.C	/^void GappyPreprocessing<dim>::testInnerProduct(const char *snapshotType) {$/;"	f	class:GappyPreprocessing
testIsActive	IntersectorFRG/IntersectorFRG.h	/^    bool testIsActive(double t, int n) const                         {return (status[n]>=0 && status[n]!=OUTSIDECOLOR);}$/;"	f	class:IntersectorFRG
testIsActive	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    bool testIsActive(double t, int n) const {return (status[n] >= 0 && status[n]!=OUTSIDECOLOR);}$/;"	f	class:IntersectorPhysBAM
testNormals	DomainCore.C	/^void Domain::testNormals(DistVec<Vec3D> &edgeNorm, DistVec<double> &edgeNormVel,$/;"	f	class:Domain
testNormals	SubDomainCore.C	/^void SubDomain::testNormals(Vec<Vec3D> &edgeNorm, Vec<double> &edgeNormVel,$/;"	f	class:SubDomain
testProbabilisticSVD	IoData.h	/^  enum TestProbabilisticSVD {TEST_PROBABILISTIC_SVD_FALSE = 0, TEST_PROBABILISTIC_SVD_TRUE = 1} testProbabilisticSVD;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::TestProbabilisticSVD
testProbabilisticSVD	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::testProbabilisticSVD(VecSet< DistSVec<double, dim> >*& snapshots, VecSet< DistSVec<double, dim> > &Utrue, std::vector<double>& singularValues, FullM &Vtrue, int podMethod, int randMatDimension, int nPowerIts, bool computeV)  {$/;"	f	class:NonlinearRomDatabaseConstruction
testingALS	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::testingALS(){$/;"	f	class:EmbeddedAlternatingLeastSquare
testingInitialization	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::testingInitialization() {$/;"	f	class:EmbeddedAlternatingLeastSquare
testingSnapshotIO	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::testingSnapshotIO() {$/;"	f	class:EmbeddedAlternatingLeastSquare
tet	Extrapolation.h	/^  int tet;$/;"	m	struct:ExtrapolationNodeData
tet	V6NodeData.h	/^  int tet;$/;"	m	struct:V6NodeData
teta	EmbeddedFluidShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
teta	FluidCollocationShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:FluidCollocationShapeOptimizationHandler
teta	FluidGnatShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:FluidGnatShapeOptimizationHandler
teta	FluidMetricShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:FluidMetricShapeOptimizationHandler
teta	FluidRomShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:FluidRomShapeOptimizationHandler
teta	FluidShapeOptimizationHandler.h	/^  double teta;$/;"	m	class:FluidShapeOptimizationHandler
tets	InletNode.h	/^	int *tets;				\/\/list of the tets connected to the node$/;"	m	class:InletNode
tets2	InletNode.h	/^        int *tets2;				\/\/list of the secondary tetrahedra used for extrapolation$/;"	m	class:InletNode
tfinal	ODEIntegrator.h	/^  double t0,tfinal;$/;"	m	class:ODEIntegrator
tforce	RefVal.h	/^  double tforce;$/;"	m	class:RefVal
theStringManager	parser/StringManager.C	/^StringManager theStringManager;$/;"	v
thermalCondFcn	NavierStokesTerm.h	/^  ThermalCondFcn *thermalCondFcn;$/;"	m	class:NavierStokesTerm
thermalCondModel	IoData.h	/^  ThermalCondModelData thermalCondModel;$/;"	m	struct:EquationsData
thermal_conductivity_coefficient	ThermalCondFcn.h	/^  double thermal_conductivity_coefficient;$/;"	m	class:ConstantThermalCondFcn
thickness_over_two	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    T thickness_parameter,thickness_over_two;$/;"	m	class:PhysBAM::PhysBAMInterface
thickness_parameter	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    T thickness_parameter,thickness_over_two;$/;"	m	class:PhysBAM::PhysBAMInterface
thinsvd	f77src/thinsvd.f	/^      subroutine thinsvd(/;"	s
third	ElemTet.h	/^  static const double third;$/;"	m	class:ElemTet
third	ElemTetCore.C	/^const double ElemTet::third = 1.0\/3.0;$/;"	m	class:ElemTet	file:
third	FaceTria.h	/^  static const double third;$/;"	m	class:FaceTria
third	FaceTriaCore.C	/^const double FaceTria::third = 1.0\/3.0;$/;"	m	class:FaceTria	file:
third	FemEquationTermDesc.C	/^const double NavierStokesTerm::third = 1.0\/3.0;$/;"	m	class:NavierStokesTerm	file:
third	NavierStokesTerm.h	/^  static const double third;$/;"	m	class:NavierStokesTerm
third	PostFcn.C	/^const double PostFcnEuler::third = 1.0\/3.0;$/;"	m	class:PostFcnEuler	file:
third	PostFcn.h	/^  static const double third;$/;"	m	class:PostFcnEuler
third	WallFcn.h	/^  const static double third;$/;"	m	class:WallFcn
third	WallFcnCore.C	/^const double WallFcn::third = 1.0 \/ 3.0;$/;"	m	class:WallFcn	file:
thirteen_over_twelve	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double thirteen_over_twelve=13.\/12;$/;"	m	namespace:PhysBAM
thisCPU	Communicator.h	/^  int thisCPU;$/;"	m	class:Communicator
thisCPU	GappyPreprocessing.h	/^	int numLocSub, nTotCpus, thisCPU; $/;"	m	class:GappyPreprocessing
thisCPU	ParallelRom.h	/^	int thisCPU;$/;"	m	class:ParallelRom
this_address	tools/alloca.cougar.c	/^    long this_address;		\/* Address of this block.  *\/$/;"	m	struct:stk_trailer	file:
this_size	tools/alloca.cougar.c	/^    long this_size;		\/* Size of this block (does not include$/;"	m	struct:stk_trailer	file:
threshold	DistTimeState.C	/^  double threshold;$/;"	m	struct:SetFirstOrderNodes	file:
threshold	PostOperator.h	/^  double threshold;$/;"	m	class:PostOperator
threshold	RecFcnDesc.h	/^  double threshold;$/;"	m	class:RecFcnLtdSensor
threshold	arpack++/include/arlnsmat.h	/^  double      threshold;$/;"	m	class:ARluNonSymMatrix
threshold	arpack++/include/arlsmat.h	/^  double      threshold;$/;"	m	class:ARluSymMatrix
threshold	arpack++/include/arunsmat.h	/^  double  threshold;$/;"	m	class:ARumNonSymMatrix
threshold	arpack++/include/arusmat.h	/^  double  threshold;$/;"	m	class:ARumSymMatrix
time	IoData.h	/^  double time;$/;"	m	struct:ForcePoints
time	IoData.h	/^  double time;$/;"	m	struct:VelocityPoints
time	LevelSetTsDesc.h	/^    double time,loc;$/;"	m	struct:LevelSetTsDesc::exactInterfacePoint
time	OneDimensionalSolver.h	/^  double time;$/;"	m	class:OneDimensional
time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    double time;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
time	RefVal.h	/^  double time;$/;"	m	class:RefVal
timeFreq	IoData.h	/^  int timeFreq;$/;"	m	struct:NonlinearRomOnlineNonStateData
timeIntegrate	Modal.C	/^void ModalSolver<dim>::timeIntegrate(VecSet<DistSVec<double, dim> > &snaps, $/;"	f	class:ModalSolver
timeIntegrateROM	Modal.C	/^ModalSolver<dim>::timeIntegrateROM(double *romOp, VecSet<Vec<double> > &romOp0, double *romOp1, double *romOp2, VecSet<Vec<double> > &ecMat, VecSet<Vec<double> > &gMat, VecSet<DistSVec<double, dim> > &podVecs, int nSteps, int nPodVecs, double *delU, double *delY, double sdt)  {$/;"	f	class:ModalSolver
timeIntegrator	MeshMotionHandler.h	/^  enum TimeIntegrator {IMPLICIT_FIRST_ORDER, IMPLICIT_SECOND_ORDER} timeIntegrator;$/;"	m	class:AeroMeshMotionHandler	typeref:enum:AeroMeshMotionHandler::TimeIntegrator
timeIt	KspBinaryOutput.h	/^  int* timeIt;$/;"	m	class:KspBinaryOutput
timePreconditioner	LowMachPrec.h	/^  bool timePreconditioner() const { return prec==2; }$/;"	f	class:TimeLowMachPrec
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProdFD
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProdH1
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProdH2
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProdLS
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProdMultiPhase
timeState	MatVecProd.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:MatVecProd_dRdX
timeState	MultiGridOperator.h	/^  DistTimeState<dim>* timeState;$/;"	m	class:MultiGridOperator
timeState	TsDesc.h	/^  DistTimeState<dim> *timeState;$/;"	m	class:TsDesc
timeStep	EmbeddedTsDesc.h	/^  double timeStep;$/;"	m	class:EmbeddedTsDesc
timeStep	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
timeStepCalculation	IoData.h	/^  enum TimeStepCalculation {CFL = 0, ERRORESTIMATION = 1} timeStepCalculation;$/;"	m	struct:TsData	typeref:enum:TsData::TimeStepCalculation
timeStepCalculation	TsDesc.h	/^  TsData::TimeStepCalculation timeStepCalculation;$/;"	m	class:TsDesc
timeStepOffset	FSI/DynamicNodalTransfer.h	/^  double timeStepOffset;$/;"	m	class:EmbeddedStructure
timeType	ExplicitEmbeddedTsDesc.h	/^  ExplicitData::Type timeType;$/;"	m	class:ExplicitEmbeddedTsDesc
timeType	ExplicitLevelSetTsDesc.h	/^  ExplicitData::Type timeType;$/;"	m	class:ExplicitLevelSetTsDesc
timeType	ExplicitMultiPhysicsTsDesc.h	/^  ExplicitData::Type timeType;$/;"	m	class:ExplicitMultiPhysicsTsDesc
timeVpts	MeshMotionHandler.h	/^  double *timeVpts;$/;"	m	class:RigidMeshMotionHandler
timeac	LowMachPrec.h	/^  bool timeac;$/;"	m	class:LowMachPrec
timer	Communicator.h	/^  Timer *timer;$/;"	m	class:Communicator
timer	Domain.h	/^  Timer *timer;$/;"	m	class:Domain
timer	EdgeGalerkin.h	/^  Timer *timer;$/;"	m	class:EdgeGalerkin
timer	FSI/DynamicNodalTransfer.h	/^        Timer *timer;$/;"	m	class:DynamicNodalTransfer
timer	FSI/DynamicNodalTransfer.h	/^  Timer *timer;$/;"	m	class:EmbeddedStructure
timer	MeshMotionSolver.h	/^  Timer *timer;$/;"	m	class:TetMeshMotionSolver
timer	NonlinearRom.h	/^  Timer *timer;$/;"	m	class:NonlinearRom
timer	SpaceOperator.h	/^  Timer *timer;$/;"	m	class:SpaceOperator
timer	TsDesc.h	/^  Timer *timer;$/;"	m	class:TsDesc
timer_id	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    int timer_id;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
timer_id	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    int timer_id;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
timer_singleton	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    TIMER* timer_singleton;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
timer_start_time	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    double timer_start_time;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
timers	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.h	/^    ARRAY<DATA> timers;$/;"	m	class:PhysBAM::TIMER
timestamp	Dunavant.C	/^void timestamp ( )$/;"	f
timestep	IoData.h	/^  double timestep;$/;"	m	struct:ForcedData
timestep	IoData.h	/^  double timestep;$/;"	m	struct:RigidMeshMotionData
timestep	IoData.h	/^  double timestep;$/;"	m	struct:TsData
timestepinitial	IoData.h	/^  double timestepinitial;$/;"	m	struct:TsData
timestring	Dunavant.C	/^char *timestring ( )$/;"	f
tinit	TsOutput.h	/^  double tprevf, tprevl, tinit;$/;"	m	class:TsOutput
title	arpack++/include/arhbmat.h	/^  char    title[73];       \/\/ Title.$/;"	m	class:ARhbMatrix
tk	parser/Assigner.h	/^    vector<int> tk;$/;"	m	class:ClassToken
tk	parser/Assigner.h	/^   vector<int> tk;$/;"	m	class:SysTokenObj
tk	parser/Assigner.h	/^  vector<int> tk;$/;"	m	class:ClassArray
tkm	parser/Dictionary.h	/^   TokenMap tkm;$/;"	m	class:Dictionary
tlength	RefVal.h	/^  double tlength;$/;"	m	class:RefVal
tm	IoData.h	/^  KspData tm;$/;"	m	struct:KspFluidData
tm	IoData.h	/^  SchemeData tm;$/;"	m	struct:SchemesData
tm	IoData.h	/^  TurbulenceModelData tm;$/;"	m	struct:TurbulenceClosureData
tmax	EmbeddedTsDesc.h	/^  double tmax;$/;"	m	class:EmbeddedTsDesc
tmax	IoData.h	/^  double Prate, Pinit, tmax;$/;"	m	struct:ImplosionSetup
tmax	LevelSetTsDesc.h	/^  double tmax;$/;"	m	class:LevelSetTsDesc
tmax	MultiPhysicsTsDesc.h	/^  double tmax;$/;"	m	class:MultiPhysicsTsDesc
tmax	StructExc.h	/^  double tmax;$/;"	m	class:StructExc
tmcoupling	IoData.h	/^  enum TurbulenceModelCoupling {WEAK = 0, STRONG = 1} tmcoupling;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::TurbulenceModelCoupling
tmp	DistBcData.h	/^  DistSVec<double,2> *tmp;$/;"	m	class:DistBcDataSA
tmp	DistBcData.h	/^  DistSVec<double,3> *tmp;$/;"	m	class:DistBcDataKE
tmp2	PostOperator.h	/^  DistSVec<double,2>* tmp2;$/;"	m	class:PostOperator
to	Communicator.h	/^    int from, to, cpuID;$/;"	m	struct:SubDTopo::CPair
toTransfer	MultiGridLevel.h	/^    std::map<int,std::set<int> >* toTransfer;$/;"	m	class:MultiGridLevel
toWrite	TsOutput.C	/^bool TsOutput<dim>::toWrite(int it, bool lastIt, double t)$/;"	f	class:TsOutput
toWrite	TsRestartCore.C	/^bool TsRestart::toWrite(int it, bool lastIt, double t)$/;"	f	class:TsRestart
to_bool	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/ELEMENT_ID.h	/^enum {none=0,equality=1,compare=2,increment=4,add_T=8,to_bool=16,negate=32,for_loop=compare|increment,logical=equality|to_bool};$/;"	e	enum:PhysBAM::ELEMENT_ID_HELPER::__anon17
toc_DESMESH	Manual/Aerof3d.html	/^<\/li><li><a name="toc_DESMESH" href="#DESMESH">Appendix C DETACHED EDDY SIMULATIONS (DES): MESH REQUIREMENTS<\/a>$/;"	a
toc_Examples	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Examples" href="#Examples">5 EXAMPLES<\/a>$/;"	a
toc_Hints_005fand_005ftips	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Hints_005fand_005ftips" href="#Hints_005fand_005ftips">Appendix A HINTS AND TIPS<\/a>$/;"	a
toc_Installation	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Installation" href="#Installation">2 INSTALLATION<\/a>$/;"	a
toc_Introduction	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Introduction" href="#Introduction">1 INTRODUCTION<\/a>$/;"	a
toc_Objects	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Objects" href="#Objects">4 OBJECTS<\/a>$/;"	a
toc_Overview	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Overview" href="#Overview">3 OVERVIEW<\/a>$/;"	a
toc_ROM	Manual/Aerof3d.html	/^<\/li><li><a name="toc_ROM" href="#ROM">Appendix B ROM OUTPUT FORMAT<\/a>$/;"	a
toc_Restarting-AERO_002dF	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Restarting-AERO_002dF" href="#Restarting-AERO_002dF">8 RESTARTING AEROF<\/a>$/;"	a
toc_Restarting-Aero_002dFL	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Restarting-Aero_002dFL" href="#Restarting-Aero_002dFL">9 RESTARTING AEROFL<\/a>$/;"	a
toc_Running-AERO_002dFL	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Running-AERO_002dFL" href="#Running-AERO_002dFL">7 RUNNING AEROFL<\/a>$/;"	a
toc_Running-Aero_002dF	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Running-Aero_002dF" href="#Running-Aero_002dF">6 RUNNING AEROF<\/a>$/;"	a
toc_Sensitivities	Manual/Aerof3d.html	/^<\/li><li><a name="toc_Sensitivities" href="#Sensitivities">Appendix E COMPUTATION OF SENSITIVITIES<\/a>$/;"	a
toc_TAB	Manual/Aerof3d.html	/^<\/li><li><a name="toc_TAB" href="#TAB">Appendix D SPARSE GRID TABULATION OF RIEMANN INVARIANTS AND SOLUTIONS<\/a>$/;"	a
toc_Top	Manual/Aerof3d.html	/^<li><a name="toc_Top" href="#Top">AERO-F<\/a>$/;"	a
token	parser/Assigner.h	/^    int T::*token;$/;"	m	class:ClassToken::T
token	parser/Dictionary.h	/^   int token(const char *text) { $/;"	f	class:Dictionary
token	parser/ParseTree.h	/^    int token;$/;"	m	class:ParseNode
tokenInt	parser/Assigner.h	/^    int T::*tokenInt;$/;"	m	class:ClassToken::T
tokenMap	parser/ParseTree.h	/^    std::map<Token,Token> tokenMap;$/;"	m	class:ParseTree
tol	arpack++/include/arrseig.h	/^  ARFLOAT tol;        \/\/ Stopping criterion (relative accuracy of Ritz values).$/;"	m	class:ARrcStdEig
tolerance	IoData.h	/^  double tolerance;$/;"	m	struct:ApproximatedMetricData
tolerance	IoData.h	/^  double tolerance;$/;"	m	struct:DataCompressionData
tolerance	IoData.h	/^  double tolerance;$/;"	m	struct:LinearizedData
tolerance	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/ITERATIVE_SOLVER.h	/^    T tolerance;$/;"	m	class:PhysBAM::ITERATIVE_SOLVER
tolpre_	LocalRiemannDesc.h	/^  double tolpre_;$/;"	m	class:LocalRiemannGfmparGasGas
tolpre_	LocalRiemannDesc.h	/^  double tolpre_;$/;"	m	class:LocalRiemannGfmparTaitTait
topologically_sorted_incident_elements	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.h	/^    ARRAY<ARRAY<int> >* topologically_sorted_incident_elements; \/\/ sorted version of incident_elements for manifold meshes$/;"	m	class:PhysBAM::TRIANGLE_MESH
topologyNormal	MultiGridLevel.h	/^    DistVec<Vec3D>* topologyNormal;$/;"	m	class:MultiGridLevel
totLen	DistInfo.h	/^  int totLen;$/;"	m	struct:DistInfo
totNodes	FSI/CrackingSurface.h	/^  int totNodes()  const {return nTotalNodes;}$/;"	f	class:CrackingSurface
totSize	MatchNode.h	/^  int totSize() const { return totalSize; }$/;"	f	class:MatchNodeSet
totStElems	FSI/DynamicNodalTransfer.h	/^        int  totStElems() {return structure.totalElems;}$/;"	f	class:DynamicNodalTransfer
totStElems	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int totStNodes, totStElems;$/;"	m	class:DistIntersectorPhysBAM
totStNodes	FSI/DynamicNodalTransfer.h	/^        int  totStNodes() {return structure.totalNodes;}$/;"	f	class:DynamicNodalTransfer
totStNodes	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    int totStNodes, totStElems;$/;"	m	class:DistIntersectorPhysBAM
totStructNodes	EmbeddedTsDesc.h	/^  int totStructNodes;$/;"	m	class:EmbeddedTsDesc
totStructNodes	MultiPhysicsTsDesc.h	/^  int totStructNodes;$/;"	m	class:MultiPhysicsTsDesc
totTrias	FSI/CrackingSurface.h	/^  int totTrias()  const {return nTotalTrias;}$/;"	f	class:CrackingSurface
total	Timer.h	/^		setup, run, total, fluid, nodalWeights, nodalGrad, fvTerm, feTerm, fvJac,$/;"	e	enum:Timer::TimerIndex
totalEleCommunicated	GappyPreprocessing.h	/^  int *totalEleCommunicated;$/;"	m	class:GappyPreprocessing
totalElems	FSI/DynamicNodalTransfer.h	/^  int nElems, totalElems;$/;"	m	class:EmbeddedStructure
totalEnergy	Modal.h	/^    double totalEnergy;$/;"	m	class:ModalSolver
totalNeiData	SubDomain.h	/^  int **totalNeiData;$/;"	m	class:SubDomain
totalNodes	FSI/DynamicNodalTransfer.h	/^  int nNodes, totalNodes;$/;"	m	class:EmbeddedStructure
totalNodesCommunicated	GappyPreprocessing.h	/^  int *totalNodesCommunicated;$/;"	m	class:GappyPreprocessing
totalPressure	IoData.h	/^  double totalPressure;$/;"	m	struct:BoundaryData
totalSize	MatchNode.h	/^  int numNodes, totalSize;$/;"	m	class:MatchNodeSet
totalTemperature	IoData.h	/^  double totalTemperature;$/;"	m	struct:BoundaryData
totalTimeIntegration	OneDimensionalSolver.C	/^void OneDimensional::totalTimeIntegration(){$/;"	f	class:OneDimensional
total_mesh_volume	MultiGridLevel.h	/^    double total_mesh_volume;$/;"	m	class:MultiGridLevel
total_needed	arpack++/include/arlspdef.h	/^    float total_needed;$/;"	m	struct:__anon41
total_time	IntersectorPhysBAM/FloodFill.C	/^static double total_time=0;$/;"	v	file:
totalpressure	IoData.h	/^  const char *totalpressure;$/;"	m	struct:TransientData
toupper	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Parsing/STRING_UTILITIES.cpp	/^std::string toupper(const std::string& str)$/;"	f	namespace:PhysBAM::STRING_UTILITIES
tpower	RefVal.h	/^  double tpower;$/;"	m	class:RefVal
tprec	DistTimeState.h	/^  TimeLowMachPrec    tprec;$/;"	m	class:DistTimeState
tprevf	TsOutput.h	/^  double tprevf, tprevl, tinit;$/;"	m	class:TsOutput
tprevl	TsOutput.h	/^  double tprevf, tprevl, tinit;$/;"	m	class:TsOutput
tr	IoData.h	/^  TripDomainData tr;$/;"	m	struct:TurbulenceClosureData
trId	IntersectorFRG/IntersectorFRG.C	/^  int trId() const { return id; }$/;"	f	class:MyTriangle
trNodes	LevelSet/LevelSetStructure.h	/^  int trNodes[3];$/;"	m	struct:LevelSetResult
tracker	LevelSet/LevelSetStructure.h	/^  int tracker[2]; \/\/ for mode=0: tracker[0] = tria Id; for mode=1: the two vertices; for mode=2: the vertex$/;"	m	struct:ClosestPoint
transMatMatProd	VecSetOp.h	/^void transMatMatProd (const VecSet< DistSVec<double, dim> > &matrix1, $/;"	f
transMatMatProdRestrict	VecSetOp.h	/^void transMatMatProdRestrict(const VecSet< DistSVec<double, dim> > &matrix1,$/;"	f
transMatMatSymProd	VecSetOp.h	/^void transMatMatSymProd (const VecSet< DistSVec<double, dim> > &matrix, double *targetBuffer){$/;"	f
transMatVecProd	VecSetOp.h	/^void transMatVecProd (const VecSet< DistSVec<double, dim> > &matrix, const$/;"	f
transMatVecProdRestrict	VecSetOp.h	/^void transMatVecProdRestrict(const VecSet< DistSVec<double, dim> > &matrix, const$/;"	f
transcon	ConnectivityCore.C	/^Connectivity::transcon( Connectivity* tc)$/;"	f	class:Connectivity
transconOne	ConnectivityCore.C	/^Connectivity::transconOne( Connectivity* tc)$/;"	f	class:Connectivity
transferData	ParallelRom.C	/^void ParallelRom<dim>::transferData(VecContainer &snaps, double* subMat, int nSnaps) {$/;"	f	class:ParallelRom
transferDataBack	ParallelRom.C	/^void ParallelRom<dim>::transferDataBack(double *U, VecContainer &Utrue , int nSnaps) {$/;"	f	class:ParallelRom
transferDataBackLS	ParallelRom.C	/^void ParallelRom<dim>::transferDataBackLS (double *subMatB, int n, double$/;"	f	class:ParallelRom
transient	IoData.h	/^  TransientData transient;$/;"	m	struct:OutputData
transpose	AlternatingLeastSquare/als_util.cpp	/^double *transpose(double *A, int M, int N){$/;"	f
transpose	DenseMatrixOps.h	/^  static void transpose(Scalar *a, Scalar *b) {$/;"	f	class:DenseMatrixOp
transpose	EmbeddedAlternatingLeastSquare.C	/^void EmbeddedAlternatingLeastSquare<dim>::transpose(double* &buff1, double* &buff2, int nrow, int ncol){$/;"	f	class:EmbeddedAlternatingLeastSquare
transpose	ParallelRomExtension.cpp	/^void ParallelRomExtension<dim>::transpose(double* &buff1, double* &buff2, int nrow, int ncol){$/;"	f	class:ParallelRomExtension
transpose	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/TRANSPOSE_MATRIX.h	/^    T_MATRIX transpose;$/;"	m	class:PhysBAM::TRANSPOSE_MATRIX
transpose_multiply	AlternatingLeastSquare/als_util.cpp	/^int transpose_multiply(double *A, int nrow, int ncol, double *C) {$/;"	f
traversal_stack	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.h	/^    mutable STACK<int> traversal_stack;$/;"	m	class:PhysBAM::BOX_HIERARCHY
tree	parser/ParseTree.h	/^    ParseTree &tree;$/;"	m	class:ParseNode
tree	parser/ParseTree.h	/^  ParseTree T::*tree;$/;"	m	class:ClassParseTree::T
tref	DistBcData.h	/^  double tref;$/;"	m	class:DistBcData
triNodes	IntersectorFRG/IntersectorFRG.C	/^  int (*triNodes)[3];$/;"	m	class:ClosestTriangle	file:
triNorms	IntersectorFRG/IntersectorFRG.h	/^    Vec3D *triNorms;$/;"	m	class:DistIntersectorFRG
triNorms	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    Vec3D *triNorms;$/;"	m	class:DistIntersectorPhysBAM
triSize	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double *triSize;$/;"	m	class:DistIntersectorPhysBAM
tria2quad	FSI/CrackingSurface.h	/^  int (*tria2quad)[2]; \/\/size: nTotalTrias$/;"	m	class:CrackingSurface
triangleID	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^  int triangleID; \/\/ -> -1 if no intersection$/;"	m	struct:PhysBAM::IntersectionResult
triangleList	TriangulatedSurface.h	/^  Vec3D (*triangleList)[3];$/;"	m	class:TriangulatedSurface
triangleNodeNum	TriangulatedSurface.h	/^  int (*triangleNodeNum)[3];$/;"	m	class:TriangulatedSurface
triangle_area	Dunavant.C	/^double triangle_area ( double t[2*3] )$/;"	f
triangle_hierarchy	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    TRIANGLE_HIERARCHY<T>* triangle_hierarchy;$/;"	m	class:PhysBAM::PhysBAMInterface
triangle_hierarchy	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    TRIANGLE_HIERARCHY<T>* triangle_hierarchy;$/;"	m	struct:PhysBAM::SubDInterface
triangle_id_map	FSI/CrackingSurface.h	/^  int* triangle_id_map;$/;"	m	class:CrackingSurface
triangle_list	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ARRAY<TRIANGLE_3D<T> > triangle_list;$/;"	m	class:PhysBAM::PhysBAMInterface
triangle_list	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ARRAY<TRIANGLE_3D<T> > triangle_list;$/;"	m	struct:PhysBAM::SubDInterface
triangle_list	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    ARRAY<TRIANGLE_3D<T> >* triangle_list;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
triangle_mesh	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    TRIANGLE_MESH& triangle_mesh;$/;"	m	class:PhysBAM::PhysBAMInterface
triangle_points_plot	Dunavant.C	/^void triangle_points_plot ( char *file_name, double node_xy[], int node_show,$/;"	f
triangles_in_group	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    ARRAY<ARRAY<int> > triangles_in_group;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
triangles_per_group	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.h	/^    int triangles_per_group;$/;"	m	class:PhysBAM::TRIANGLE_HIERARCHY
triangulatedInterfaceLSS	SubDomain.h	/^  LevelSetStructure* triangulatedInterfaceLSS;$/;"	m	class:SubDomain
triangulatedLSS	Edge.h	/^  LevelSetStructure* triangulatedLSS;$/;"	m	class:EdgeSet
trip	DynamicLESTerm.h	/^  bool trip;$/;"	m	class:DynamicLESTerm
trip	DynamicVMSTerm.h	/^  bool trip;$/;"	m	class:DynamicVMSTerm
trip	FemEquationTermDesc.h	/^  bool trip, usefv3;$/;"	m	class:FemEquationTermDES
trip	FemEquationTermDesc.h	/^  bool trip, usefv3;$/;"	m	class:FemEquationTermSA
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermDESmean
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermDESturb
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermKE
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermKEmean
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermKEturb
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermSAmean
trip	FemEquationTermDesc.h	/^  bool trip;$/;"	m	class:FemEquationTermSAturb
trip	SmagorinskyLESTerm.h	/^  bool trip;$/;"	m	class:SmagorinskyLESTerm
trip	VMSLESTerm.h	/^  bool trip;$/;"	m	class:VMSLESTerm
trip	WaleLESTerm.h	/^  bool trip;$/;"	m	class:WaleLESTerm
triple_int_hash	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    unsigned int triple_int_hash(unsigned int a,unsigned int b,unsigned int c)$/;"	f	class:PhysBAM::HASH
true	arpack++/include/arch.h	/^  int true  = 1;$/;"	v
trueLevelSet	LevelSet.h	/^  bool trueLevelSet[dimLS]; \/\/ some level-sets take only values -1 and +1 (volumeID initialization)$/;"	m	class:LevelSet
truncateBufferedBasis	NonlinearRom.C	/^void NonlinearRom<dim>::truncateBufferedBasis() {$/;"	f	class:NonlinearRom
tryAllClusters	ImplicitRomTsDesc.C	/^void ImplicitRomTsDesc<dim>::tryAllClusters(DistSVec<double, dim> &U, const int totalTimeSteps, int* bestCluster) {$/;"	f	class:ImplicitRomTsDesc
tryAllFreq	ImplicitRomTsDesc.h	/^  int tryAllFreq;$/;"	m	class:ImplicitRomTsDesc
tryAllFreq	IoData.h	/^  int tryAllFreq;$/;"	m	struct:NonlinearRomOnlineData
tryingAllClusters	ImplicitRomTsDesc.h	/^  bool tryingAllClusters;$/;"	m	class:ImplicitRomTsDesc
ts	IoData.h	/^  TsData ts;$/;"	m	class:IoData
tsDescTmp	GappyPreprocessing.h	/^	TsDesc<dim> *tsDescTmp;$/;"	m	class:GappyPreprocessing
tscale	MeshMotionHandler.h	/^  double tscale;$/;"	m	class:MeshMotionHandler
tscale	MeshMotionHandler.h	/^  double tscale;$/;"	m	class:RigidMeshMotionHandler
tscale	TsOutput.h	/^  double tscale;$/;"	m	class:TsOutput
tsoffset	IoData.h	/^  double tsoffset;$/;"	m	struct:ForcedData
turbRelaxCutoff	IoData.h	/^  double turbRelaxCutoff;$/;"	m	struct:MultiGridData
turbRelaxCutoff	MultiGridKernel.h	/^  double turbRelaxCutoff;$/;"	m	class:MultiGridKernel
turbRelaxCutoff	MultiGridLevel.h	/^    double turbRelaxCutoff;$/;"	m	class:MultiGridLevel
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermDES
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermDESmean
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermKE
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermKEmean
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermSA
turbThermalCondFcn	FemEquationTermDesc.h	/^  ConstantPrandtlThermalCondFcn turbThermalCondFcn;$/;"	m	class:FemEquationTermSAmean
turbulenceWeight	IoData.h	/^  double turbulenceWeight;$/;"	m	struct:NonlinearRomOnlineData
turbulentConductivity	ThermalCondFcn.h	/^  double turbulentConductivity(double mut)$/;"	f	class:ConstantPrandtlThermalCondFcn
turbulentConductivityDerivative	ThermalCondFcn.h	/^  double turbulentConductivityDerivative(double dmut)$/;"	f	class:ConstantPrandtlThermalCondFcn
tvelocity	RefVal.h	/^  double tvelocity;$/;"	m	class:RefVal
twoLayers	GappyPreprocessing.h	/^	bool twoLayers; 	\/\/ debugging flag$/;"	m	class:GappyPreprocessing
twoPhase	IntersectorFRG/IntersectorFRG.h	/^    bool twoPhase; \/\/including fluid-shell-fluid and fluid-solid$/;"	m	class:DistIntersectorFRG
two_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double two_pi=2*pi;$/;"	m	namespace:PhysBAM
two_thirds	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double two_thirds=2.\/3;$/;"	m	namespace:PhysBAM
two_thirds_pi	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^const double two_thirds_pi=2.\/3*pi;$/;"	m	namespace:PhysBAM
twothird	FemEquationTermDesc.C	/^const double NavierStokesTerm::twothird = 2.0\/3.0;$/;"	m	class:NavierStokesTerm	file:
twothird	NavierStokesTerm.h	/^  static const double twothird;$/;"	m	class:NavierStokesTerm
twothird	ViscoFcn.h	/^const double twothird = 2.0\/3.0;$/;"	v
twothirds	DynamicLESTerm.h	/^  double twothirds;$/;"	m	class:DynamicLESTerm
twothirds	DynamicVMSTerm.h	/^  double twothirds;$/;"	m	class:DynamicVMSTerm
twothirds	SmagorinskyLESTerm.h	/^  double twothirds;$/;"	m	class:SmagorinskyLESTerm
twothirds	VMSLESTerm.h	/^  double twothirds;$/;"	m	class:VMSLESTerm
twothirds	WaleLESTerm.h	/^  double twothirds;$/;"	m	class:WaleLESTerm
type	Aerof_unordered_set.h	/^  type;$/;"	t	struct:Aerof_unordered_set
type	DiagMatrix.h	/^  enum Type {DENSE = 0, DIAGONAL = 1} type;$/;"	m	class:DiagMat	typeref:enum:DiagMat::Type
type	ElemTet.h	/^  Type type() { return Elem::TET; }$/;"	f	class:ElemTet
type	EmbeddedCorotSolver.h	/^  enum Type {BASIC, COROTATIONAL} type;$/;"	m	class:EmbeddedCorotSolver	typeref:enum:EmbeddedCorotSolver::Type
type	Extrapolation.h	/^  int type;$/;"	m	class:Extrapolation
type	FaceTria.h	/^  Type type() { return Face::TRIA; }$/;"	f	class:FaceTria
type	IoData.h	/^              GHIDAGLIA = 3, MODIFIED_GHIDAGLIA = 4} type;$/;"	m	struct:BoundarySchemeData	typeref:enum:BoundarySchemeData::Type
type	IoData.h	/^             ACOUSTICBEAM=5, SPIRALING = 6, ACOUSTICVISCOUSBEAM=7} type;$/;"	m	struct:ForcedData	typeref:enum:ForcedData::Type
type	IoData.h	/^   enum Type {PSEUDOSTRUCTURAL = 0, ALGEBRAIC = 1 } type;$/;"	m	struct:BLMeshMotionData	typeref:enum:BLMeshMotionData::Type
type	IoData.h	/^  bool type[SIZE];$/;"	m	struct:ProblemData
type	IoData.h	/^  enum Type { ADIABATIC = 1, ISOTHERMAL = 2 } type;$/;"	m	struct:SurfaceData	typeref:enum:SurfaceData::Type
type	IoData.h	/^  enum Type { COMPRESSIBLE = 0 } type;$/;"	m	struct:LiquidModelData	typeref:enum:LiquidModelData::Type
type	IoData.h	/^  enum Type {BACKWARD_EULER = 0, CRANK_NICOLSON = 1, THREE_POINT_BDF = 2, FOUR_POINT_BDF = 3, SPATIAL_ONLY = 4} type;$/;"	m	struct:ImplicitData	typeref:enum:ImplicitData::Type
type	IoData.h	/^  enum Type {BASIC = 0, COROTATIONAL = 1} type;$/;"	m	struct:DefoMeshMotionData	typeref:enum:DefoMeshMotionData::Type
type	IoData.h	/^  enum Type {CONSTANT = 0, SUTHERLAND = 1, PRANDTL = 2} type;$/;"	m	struct:ViscosityModelData	typeref:enum:ViscosityModelData::Type
type	IoData.h	/^  enum Type {CONSTANT_PRANDTL = 0, CONSTANT = 1} type;$/;"	m	struct:ThermalCondModelData	typeref:enum:ThermalCondModelData::Type
type	IoData.h	/^  enum Type {D1VMSLES = 0, D2VMSLES = 1, D3VMSLES = 2} type;$/;"	m	struct:DynamicVMSData	typeref:enum:DynamicVMSData::Type
type	IoData.h	/^  enum Type {DEFAULT = 0, ROM = 1, FORCED = 2} type;$/;"	m	struct:LinearizedData	typeref:enum:LinearizedData::Type
type	IoData.h	/^  enum Type {DIRECTSTATE = 1, MASSFLOW = 2, POROUSWALL = 3} type;$/;"	m	struct:BoundaryData	typeref:enum:BoundaryData::Type
type	IoData.h	/^  enum Type {EULER = 0, NAVIER_STOKES = 1} type;$/;"	m	struct:EquationsData	typeref:enum:EquationsData::Type
type	IoData.h	/^  enum Type {EXPLICIT = 0, IMPLICIT = 1} type;$/;"	m	struct:TsData	typeref:enum:TsData::Type
type	IoData.h	/^  enum Type {EXTERNAL = 0, INTERNAL = 1} type;$/;"	m	struct:BcsFreeStreamData	typeref:enum:BcsFreeStreamData::Type
type	IoData.h	/^  enum Type {FLUID = 0, POROUS = 1} type;$/;"	m	struct:VolumeData	typeref:enum:VolumeData::Type
type	IoData.h	/^  enum Type {IDEAL = 0, JWL = 1} type;$/;"	m	struct:JWLModelData	typeref:enum:JWLModelData::Type
type	IoData.h	/^  enum Type {IDEAL = 0, STIFFENED = 1} type;$/;"	m	struct:GasModelData	typeref:enum:GasModelData::Type
type	IoData.h	/^  enum Type {IDENTITY = 0, JACOBI = 1, AS = 2, RAS = 3, ASH = 4, AAS = 5, MG = 6} type;$/;"	m	struct:PcData	typeref:enum:PcData::Type
type	IoData.h	/^  enum Type {ISOTHERMAL = 0, ADIABATIC = 1} type;$/;"	m	struct:BcsWallData	typeref:enum:BcsWallData::Type
type	IoData.h	/^  enum Type {ITERATIVE = 0, NONITERATIVE = 1, HYBRID = 2} type;$/;"	m	struct:WallDistanceMethodData	typeref:enum:WallDistanceMethodData::Type
type	IoData.h	/^  enum Type {NONE = 0, BACKTRACKING = 1} type;$/;"	m	struct:LineSearchData	typeref:enum:LineSearchData::Type
type	IoData.h	/^  enum Type {NONE = 0, EDDY_VISCOSITY = 1, LES = 2} type;$/;"	m	struct:TurbulenceClosureData	typeref:enum:TurbulenceClosureData::Type
type	IoData.h	/^  enum Type {ONE_EQUATION_SPALART_ALLMARAS = 0, ONE_EQUATION_DES = 1, TWO_EQUATION_KE = 2} type;$/;"	m	struct:TurbulenceModelData	typeref:enum:TurbulenceModelData::Type
type	IoData.h	/^  enum Type {POD = 0, BALANCED_POD = 1} type;$/;"	m	struct:DataCompressionData	typeref:enum:DataCompressionData::Type
type	IoData.h	/^  enum Type {RICHARDSON = 0, CG = 1, GMRES = 2, GCR = 3} type;$/;"	m	struct:KspData	typeref:enum:KspData::Type
type	IoData.h	/^  enum Type {RUNGE_KUTTA_4 = 0, RUNGE_KUTTA_2 = 1, FORWARD_EULER = 2, ONE_BLOCK_RK2 = 3, ONE_BLOCK_RK2bis = 4} type;$/;"	m	struct:ExplicitData	typeref:enum:ExplicitData::Type
type	IoData.h	/^  enum Type {SINGLE = 0, DOUBLE = 1} type;$/;"	m	struct:RestartData	typeref:enum:RestartData::Type
type	IoData.h	/^  enum Type {SMAGORINSKY = 0, DYNAMIC = 1, VMS = 2, DYNAMICVMS = 3, WALE = 4} type;$/;"	m	struct:LESModelData	typeref:enum:LESModelData::Type
type	IoData.h	/^  enum Type{LINEAR=0, SMOOTHSTEP=1} type;$/;"	m	struct:ImplosionSetup	typeref:enum:ImplosionSetup::Type
type	KspPrec.h	/^  PcData::Type type;$/;"	m	class:IluPrec
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    const STREAM_TYPE type;$/;"	m	class:PhysBAM::TYPED_ISTREAM
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    const STREAM_TYPE type;$/;"	m	class:PhysBAM::TYPED_OSTREAM
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^      typedef IS_CONVERTIBLE_IMPL<T1,T2> type;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_IMPL_SELECT::rebind
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^      typedef TRUE_TYPE type;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_IMPL_SELECT::rebind
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    typedef typename isc_binder::type type;$/;"	t	struct:PhysBAM::IS_CONVERTIBLE_DISPATCH_BASE
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <> struct IS_ENUM_HELPER<false> {template <class T> struct type {static const bool value=IS_CONVERTIBLE<typename ADD_REFERENCE<T>::TYPE,INT_CONVERTIBLE>::value;};};$/;"	s	struct:PhysBAM::IS_ENUM_HELPER
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <bool is_typename_arithmetic_or_reference = true> struct IS_ENUM_HELPER {template <class T> struct type {static const bool value=false;};};$/;"	s	struct:PhysBAM::IS_ENUM_HELPER
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,int size> struct REMOVE_ALL_EXTENTS<T[size]> {typedef typename REMOVE_ALL_EXTENTS<T>::type type;};$/;"	t	struct:PhysBAM::REMOVE_ALL_EXTENTS
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_ALL_EXTENTS {typedef T type;};$/;"	t	struct:PhysBAM::REMOVE_ALL_EXTENTS
type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct REMOVE_ALL_EXTENTS<T[]> {typedef typename REMOVE_ALL_EXTENTS<T>::type type;};$/;"	t	struct:PhysBAM::REMOVE_ALL_EXTENTS
type	VarFcnBase.h	/^  enum Type{ PERFECTGAS = 0, STIFFENEDGAS = 1, TAIT = 2, JWL = 3} type;$/;"	m	class:VarFcnBase	typeref:enum:VarFcnBase::Type
type	arpack++/include/arhbmat.h	/^  char    type[4];         \/\/ Matrix type.$/;"	m	class:ARhbMatrix
typeClipping	IoData.h	/^  enum Clipping {NONE = 0, ABS_VALUE = 1, FREESTREAM = 2, CUTOFF = 3} typeClipping;$/;"	m	struct:TsData	typeref:enum:TsData::Clipping
typeElement	MeshMotionSolver.h	/^  DefoMeshMotionData::Element typeElement;$/;"	m	class:TetMeshMotionSolver
typeEpsFormula	KspConvCriterion.h	/^  KspData::EpsFormula typeEpsFormula;$/;"	m	class:KspConvCriterion
typeGradient	DistNodalGrad.h	/^  SchemeData::Gradient typeGradient;$/;"	m	class:DistNodalGrad
typeIntegrator	TimeData.h	/^  ImplicitData::Type typeIntegrator;$/;"	m	class:TimeData
typeJac	FluxFcnBase.h	/^  enum Type {CONSERVATIVE = 0, PRIMITIVE = 1} typeJac;$/;"	m	class:FluxFcnBase	typeref:enum:FluxFcnBase::Type
typeLaw	MeshMotionHandler.h	/^  RigidMeshMotionData::LawType typeLaw;$/;"	m	class:RigidMeshMotionHandler
typeNormals	GeoData.h	/^  DGCLData::Normals typeNormals;$/;"	m	class:GeoData
typePhaseChange	IoData.h	/^  enum TypePhaseChange {ASIS = 0, RIEMANN_SOLUTION = 1, EXTRAPOLATION = 2} typePhaseChange;$/;"	m	struct:MultiFluidData	typeref:enum:MultiFluidData::TypePhaseChange
typePhaseChange	OneDimensionalSolver.h	/^  int typePhaseChange;$/;"	m	class:OneDimensional
typePrec	KspSolver.h	/^  int typePrec;$/;"	m	class:KspSolver
typeStartup	TimeData.h	/^  ImplicitData::Startup typeStartup;$/;"	m	class:TimeData
typeTag	MeshMotionHandler.h	/^  RigidMeshMotionData::Tag typeTag;$/;"	m	class:RigidMeshMotionHandler
typeTimeStep	IoData.h	/^  enum TypeTimeStep {AUTO = 0, LOCAL = 1, GLOBAL = 2} typeTimeStep;$/;"	m	struct:TsData	typeref:enum:TsData::TypeTimeStep
typeTimeStep	TimeData.h	/^  TsData::TypeTimeStep typeTimeStep;$/;"	m	class:TimeData
typeVelocities	GeoData.h	/^  DGCLData::Velocities typeVelocities;$/;"	m	class:GeoData
u	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
u	MeshMotionHandler.h	/^  Vec3D u;$/;"	m	class:RigidRollMeshMotionHandler
u	MeshMotionHandler.h	/^  double u, v, w;$/;"	m	class:PitchingMeshMotionHandler
ucol	arpack++/include/arlspdef.h	/^    double  *ucol;    \/* U columns *\/$/;"	m	struct:__anon36
ucol	arpack++/include/arlspdef.h	/^    float  *ucol;    \/* U columns *\/$/;"	m	struct:__anon35
ucol	arpack++/include/arlspdef.h	/^    ldcomplex  *ucol;    \/* U columns *\/$/;"	m	struct:__anon38
ucol	arpack++/include/arlspdef.h	/^    lscomplex  *ucol;    \/* U columns *\/$/;"	m	struct:__anon37
uh	MvpMatrix.h	/^  SVec<Scalar, dim*3>* uh, *hu;$/;"	m	class:MvpMat
uicNorm	NonlinearRom.h	/^  double uicNorm;$/;"	m	class:NonlinearRom
um21i	arpack++/include/umfpackc.h	/^inline void um21i(ARint keep[], arcomplex<double> cntl[], ARint icntl[],$/;"	f
um21i	arpack++/include/umfpackc.h	/^inline void um21i(ARint keep[], arcomplex<float> cntl[], ARint icntl[],$/;"	f
um21i	arpack++/include/umfpackc.h	/^inline void um21i(ARint keep[], double cntl[], ARint icntl[],$/;"	f
um21i	arpack++/include/umfpackc.h	/^inline void um21i(ARint keep[], float cntl[], ARint icntl[],$/;"	f
um2fa	arpack++/include/umfpackc.h	/^inline void um2fa(const ARint &n, const ARint &ne, const ARint &job,$/;"	f
um2so	arpack++/include/umfpackc.h	/^inline void um2so(const ARint &n, const ARint &job, $/;"	f
umax	LevelSetTsDesc.h	/^  DistVec<double> umax;$/;"	m	class:LevelSetTsDesc
umax	MultiPhysicsTsDesc.h	/^  DistVec<double> umax;$/;"	m	class:MultiPhysicsTsDesc
unburnedEOS	IoData.h	/^  int unburnedEOS,burnedEOS;$/;"	m	struct:ProgrammedBurnData
underflows	tools/alloca.cougar.c	/^    long underflows;		\/* Number of stack underflow calls ($STKRETN).  *\/$/;"	m	struct:stk_stat	file:
unifPressure	EmbeddedTsDesc.h	/^  double unifPressure[2];$/;"	m	class:EmbeddedTsDesc
uniformIC	NonlinearRom.h	/^  SVec<double, dim>* uniformIC;  \/\/ value of uniform initial condition at node 0 (should be representative)$/;"	m	class:NonlinearRom
uniformdoublerand	utils/Predicate.C	/^double uniformdoublerand()$/;"	f
uniformfloatrand	utils/Predicate.C	/^float uniformfloatrand()$/;"	f
unionColors	IntersectorPhysBAM/FloodFill.C	/^void FloodFill::unionColors(Domain& domain, Communicator& com,$/;"	f	class:FloodFill
unionOfSampleNodes	GappyPreprocessing.h	/^  int unionOfSampleNodes; \/\/ = -1 (makes the code a bit easier to read)$/;"	m	class:GappyPreprocessing
union_value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool union_value=false; \/\/ TODO: use __is_union(T) for gcc 4.3+$/;"	m	struct:PhysBAM::IS_CLASS
unionize	IntersectorPhysBAM/FloodFill.C	/^void unionize(const set<pair<pair<GLOBAL_SUBD_ID,int>,pair<GLOBAL_SUBD_ID,int> > >& connections, map<pair<GLOBAL_SUBD_ID,int>,int>& localToGlobalColorMap)$/;"	f	namespace:__anon7
unit_sphere_size	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/constants.h	/^template<int d> struct unit_sphere_size{STATIC_ASSERT(d<4);static const double value;};$/;"	s	namespace:PhysBAM
unknown10	tools/alloca.cougar.c	/^    long unknown10;$/;"	m	struct:stk_trailer	file:
unknown11	tools/alloca.cougar.c	/^    long unknown11;$/;"	m	struct:stk_trailer	file:
unknown12	tools/alloca.cougar.c	/^    long unknown12;$/;"	m	struct:stk_trailer	file:
unknown13	tools/alloca.cougar.c	/^    long unknown13;$/;"	m	struct:stk_trailer	file:
unknown14	tools/alloca.cougar.c	/^    long unknown14;$/;"	m	struct:stk_trailer	file:
unknown2	tools/alloca.cougar.c	/^    long unknown2;$/;"	m	struct:stk_trailer	file:
unknown3	tools/alloca.cougar.c	/^    long unknown3;$/;"	m	struct:stk_trailer	file:
unknown5	tools/alloca.cougar.c	/^    long unknown5;$/;"	m	struct:stk_trailer	file:
unknown6	tools/alloca.cougar.c	/^    long unknown6;$/;"	m	struct:stk_trailer	file:
unknown7	tools/alloca.cougar.c	/^    long unknown7;$/;"	m	struct:stk_trailer	file:
unknown8	tools/alloca.cougar.c	/^    long unknown8;$/;"	m	struct:stk_trailer	file:
unknown9	tools/alloca.cougar.c	/^    long unknown9;$/;"	m	struct:stk_trailer	file:
unknownCount	DistLeastSquareSolver.h	/^  int unknownCount()     const { return unknownCount_;     }$/;"	f	class:DistLeastSquareSolver
unknownCount_	DistLeastSquareSolver.h	/^  int equationCount_, unknownCount_;$/;"	m	class:DistLeastSquareSolver
unsteady	ImplicitRomTsDesc.h	/^  bool unsteady;$/;"	m	class:ImplicitRomTsDesc
update	DistBcData.C	/^void DistBcData<dim>::update(DistSVec<double,3> &X)  {$/;"	f	class:DistBcData
update	DistGeoState.C	/^void DistGeoState::update(DistSVec<double,3> &X, DistVec<double> &ctrlVol)$/;"	f	class:DistGeoState
update	DistTimeState.C	/^void DistTimeState<dim>::update(DistSVec<double,dim> &Q, DistSVec<double,dim> &Qtilde,$/;"	f	class:DistTimeState
update	DistTimeState.C	/^void DistTimeState<dim>::update(DistSVec<double,dim> &Q,bool increasingPressure)$/;"	f	class:DistTimeState
update	FSI/CrackingSurface.cpp	/^void PhantomElement::update(int* nod, double* ph) {$/;"	f	class:PhantomElement
update	FluidSelector.h	/^  void update(){$/;"	f	class:FluidSelector
update	HeatTransferHandlerCore.C	/^double HeatTransferHandler::update(bool* lastIt, int it, DistVec<double>& T)$/;"	f	class:HeatTransferHandler
update	LevelSet.C	/^void LevelSet<dimLS>::update(DistSVec<double,dimLS> &Phi)$/;"	f	class:LevelSet
update	MeshMotionHandler.h	/^  double update(bool *lastIt, int it, double t, DistSVec<double,3> &Xdot, DistSVec<double,3> &X) {return dts;}$/;"	f	class:EmbeddedMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AccAeroMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AccAeroMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AccDeformingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AccDeformingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AccHeavingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AccHeavingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AccMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AccMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AccPitchingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AccPitchingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double AeroMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:AeroMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double DeformingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:DeformingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double EmbeddedALEMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedALEMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double HeavingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:HeavingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double PitchingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:PitchingMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double RbmExtractor::update(bool *lastIt, int it,double t,$/;"	f	class:RbmExtractor
update	MeshMotionHandlerCore.C	/^double RigidRollMeshMotionHandler::update(bool *lastIt, int it, double t, $/;"	f	class:RigidRollMeshMotionHandler
update	MeshMotionHandlerCore.C	/^double SpiralingMeshMotionHandler::update(bool *lastIt, int it, double t,$/;"	f	class:SpiralingMeshMotionHandler
update	TimeData.C	/^void TimeData::update()$/;"	f	class:TimeData
update	TriangulatedInterface.C	/^void TriangulatedInterface::update(double dt) {$/;"	f	class:TriangulatedInterface
updateBasis	NonlinearRom.h	/^  virtual bool updateBasis(int, DistSVec<double, dim> &, Vec<double>* coords = NULL) {return false;};$/;"	f	class:NonlinearRom
updateBasis	NonlinearRomOnlineII.C	/^bool NonlinearRomOnlineII<dim>::updateBasis(int iCluster, DistSVec<double, dim> &U, Vec<double>* coords) {$/;"	f	class:NonlinearRomOnlineII
updateBasis	NonlinearRomOnlineIII.C	/^bool NonlinearRomOnlineIII<dim>::updateBasis(int iCluster, DistSVec<double, dim> &U, Vec<double>* coords) {$/;"	f	class:NonlinearRomOnlineIII
updateBasisFastApprox	NonlinearRomOnlineII.C	/^bool NonlinearRomOnlineII<dim>::updateBasisFastApprox(int iCluster, DistSVec<double, dim> &U) {$/;"	f	class:NonlinearRomOnlineII
updateBasisFastApprox	NonlinearRomOnlineIII.C	/^bool NonlinearRomOnlineIII<dim>::updateBasisFastApprox(int iCluster, DistSVec<double, dim> &U) {$/;"	f	class:NonlinearRomOnlineIII
updateBasisFastExact	NonlinearRomOnlineII.C	/^bool NonlinearRomOnlineII<dim>::updateBasisFastExact(int currentCluster, DistSVec<double, dim> &U, Vec<double>* coords) {$/;"	f	class:NonlinearRomOnlineII
updateBasisFastExact	NonlinearRomOnlineIII.C	/^bool NonlinearRomOnlineIII<dim>::updateBasisFastExact(int currentCluster, DistSVec<double, dim> &U, Vec<double>* coords) {$/;"	f	class:NonlinearRomOnlineIII
updateBasisSimple	NonlinearRomOnlineII.C	/^bool NonlinearRomOnlineII<dim>::updateBasisSimple(int iCluster, DistSVec<double, dim> &U) {$/;"	f	class:NonlinearRomOnlineII
updateBoundaryExternalState	TsDesc.C	/^void TsDesc<dim>::updateBoundaryExternalState()$/;"	f	class:TsDesc
updateColOfV	AlternatingLeastSquare/als_lapack.cpp	/^void AlternatingLeastSquare::updateColOfV(double *X, unsigned char *M, double *UT, double *V, const int j){$/;"	f	class:AlternatingLeastSquare
updateConfigSA	DistGeoState.h	/^  void updateConfigSA() { data.configSA += 1; }$/;"	f	class:DistGeoState
updateCost	SparseGridCore.C	/^void SparseGrid::updateCost(){$/;"	f	class:SparseGrid
updateCracking	FSI/CrackingSurface.cpp	/^int CrackingSurface::updateCracking(int numConnUpdate, int numLSUpdate, int* connUpdate, double* phi, $/;"	f	class:CrackingSurface
updateCracking	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::updateCracking(int (*abc)[3])$/;"	f	class:DistIntersectorPhysBAM
updateDStep2	MeshMotionHandler.h	/^  virtual void updateDStep2(DistSVec<double,3> &, DistSVec<double,3> &, bool applyScale = false) {}$/;"	f	class:MeshMotionHandler
updateDStep2	MeshMotionHandlerCore.C	/^void AeroMeshMotionHandler::updateDStep2(DistSVec<double,3> &X, DistSVec<double,3> &dXdSb, bool applyScale)$/;"	f	class:AeroMeshMotionHandler
updateDtCoeff	DistTimeState.C	/^void DistTimeState<dim>::updateDtCoeff()$/;"	f	class:DistTimeState
updateError	SparseGridCore.C	/^void SparseGrid::updateError(const int nPointsSubGrid){$/;"	f	class:SparseGrid
updateFarField	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarField(DistSVec<double,3> &X)$/;"	f	class:DistBcDataEuler
updateFarField	DistBcData.h	/^  virtual void updateFarField(DistSVec<double,3> &) {}$/;"	f	class:DistBcData
updateFarFieldGas	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarFieldGas(DistSVec<double,3> &X)$/;"	f	class:DistBcDataEuler
updateFarFieldGasSA	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarFieldGasSA(DistSVec<double,3> &X, DistSVec<double,3> &dX, double &dMach)$/;"	f	class:DistBcDataEuler
updateFarFieldJWL	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarFieldJWL(DistSVec<double,3> &X)$/;"	f	class:DistBcDataEuler
updateFarFieldLiquid	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarFieldLiquid(DistSVec<double,3> &X)$/;"	f	class:DistBcDataEuler
updateFarFieldSA	DistBcData.C	/^void DistBcDataEuler<dim>::updateFarFieldSA(DistSVec<double,3> &X, DistSVec<double,3> &dX, double &dMach)$/;"	f	class:DistBcDataEuler
updateFarFieldSA	DistBcData.h	/^  virtual void updateFarFieldSA(DistSVec<double,3> &, DistSVec<double,3> &, double &) {}$/;"	f	class:DistBcData
updateFarfieldCoeffs	TsDesc.C	/^void TsDesc<dim>::updateFarfieldCoeffs(double dt)$/;"	f	class:TsDesc
updateFixes	DistNodalGrad.C	/^void DistNodalGrad<dim,Scalar>::updateFixes() {$/;"	f	class:DistNodalGrad
updateFixes	SpaceOperator.h	/^  void updateFixes() { ngrad->updateFixes(); }$/;"	f	class:SpaceOperator
updateFluidIdFF	FluidSelector.C	/^void FluidSelector::updateFluidIdFF(DistLevelSetStructure *distLSS, DistSVec<double,dim> &Phi)$/;"	f	class:FluidSelector
updateFluidIdFF2	FluidSelector.C	/^void FluidSelector::updateFluidIdFF2(DistLevelSetStructure *distLSS, DistSVec<double,dim> &Phi)$/;"	f	class:FluidSelector
updateFluidIdFS	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::updateFluidIdFS(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
updateFluidIdFS	FluidSelector.C	/^void FluidSelector::updateFluidIdFS(DistLevelSetStructure *distLSS, DistSVec<double,dim> &PhiV)$/;"	f	class:FluidSelector
updateFluidIdFS2	FluidSelector.C	/^void FluidSelector::updateFluidIdFS2(DistLevelSetStructure *distLSS, DistSVec<double,dim> &PhiV, DistSVec<bool,4> &pollp)$/;"	f	class:FluidSelector
updateFluidIdFS2	SubDomain.C	/^void SubDomain::updateFluidIdFS2(LevelSetStructure &LSS, SVec<double,dimLS> &PhiV, SVec<bool,3> &poll, $/;"	f	class:SubDomain
updateFluidIdFS2Prep	Domain.C	/^void Domain::updateFluidIdFS2Prep(DistLevelSetStructure &distLSS, DistSVec<double,dimLS> &PhiV, DistVec<int> &fluidId, DistSVec<bool,4> &poll)$/;"	f	class:Domain
updateFreq	ImplicitRomTsDesc.h	/^  bool updateFreq;$/;"	m	class:ImplicitRomTsDesc
updateGhostFluid	TsDesc.C	/^void TsDesc<dim>::updateGhostFluid(DistSVec<double,dim> &U, Vec3D& totalForce, double dt)$/;"	f	class:TsDesc
updateHH	DistTimeState.C	/^void DistTimeState<dim>::updateHH(DistVec<double> & hh) {$/;"	f	class:DistTimeState
updateHHState	Face.h	/^  void updateHHState(SVec<double,dim>& V, VarFcn* vf, double dt) {$/;"	f	class:FaceSet
updateInfo	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::updateInfo() {$/;"	f	class:DynamicNodalTransfer
updateIterator	MvpMatrix.h	/^  void updateIterator(MvpAuxilliaryIterator* mvpItr) {$/;"	f	class:MvpMat
updateLength	EdgeCore.C	/^void EdgeSet::updateLength(SVec<double,3>& X)$/;"	f	class:EdgeSet
updateMNS	StructExc.h	/^  void updateMNS(MatchNodeSet **mns) {matchNodes = mns;}$/;"	f	class:StructExc
updateModalValues	Modal.C	/^void ModalSolver<dim>::updateModalValues(double sdt, double *delU, double *delY, Vec<double> &modalF, int timeIt){$/;"	f	class:ModalSolver
updateMomentArm	MeshMotionHandlerCore.C	/^void RigidMeshMotionHandler::updateMomentArm(Vec3D &x0)  {$/;"	f	class:RigidMeshMotionHandler
updateNodeTag	DomainCore.C	/^void Domain::updateNodeTag(DistSVec<double,3> &X, DistLevelSetStructure *LSS, DistVec<int> &nodeTag0, DistVec<int> &nodeTag)$/;"	f	class:Domain
updateNodeTag	SubDomainCore.C	/^void SubDomain::updateNodeTag(SVec<double,3> &X, LevelSetStructure &LSS, Vec<int> &nodeTag0, Vec<int> &nodeTag)$/;"	f	class:SubDomain
updateNumStNodes	MatchNode.h	/^  void updateNumStNodes(int nn) {numNodes = nn;}$/;"	f	class:MatchNodeSet
updateNumStrNodes	StructExc.C	/^void StructExc::updateNumStrNodes(int nn) $/;"	f	class:StructExc
updateOutputToStructure	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::updateOutputToStructure(double dt, double dtLeft, DistSVec<double,dim> &U)$/;"	f	class:EmbeddedTsDesc
updateOutputToStructure	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::updateOutputToStructure(double dt, double dtLeft, SVec<double,3> &fs)$/;"	f	class:DynamicNodalTransfer
updateOutputToStructure	HeatTransferHandler.C	/^void HeatTransferHandler::updateOutputToStructure(double dt, double dtLeft,$/;"	f	class:HeatTransferHandler
updateOutputToStructure	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::updateOutputToStructure(double dt, double dtLeft,$/;"	f	class:LevelSetTsDesc
updateOutputToStructure	MeshMotionHandler.C	/^void AeroMeshMotionHandler::updateOutputToStructure(double dt, double dtLeft,$/;"	f	class:AeroMeshMotionHandler
updateOutputToStructure	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::updateOutputToStructure(double dt, double dtLeft, DistSVec<double,dim> &U)$/;"	f	class:MultiPhysicsTsDesc
updateOutputToStructure	TsDesc.C	/^void TsDesc<dim>::updateOutputToStructure(double dt, double dtLeft,$/;"	f	class:TsDesc
updatePerformed	ImplicitRomTsDesc.h	/^  bool updatePerformed;$/;"	m	class:ImplicitRomTsDesc
updatePhaseChange	DistExactRiemannSolver.C	/^void DistExactRiemannSolver<dim>::updatePhaseChange(DistSVec<double,dim> &V,$/;"	f	class:DistExactRiemannSolver
updatePhaseChange	ExactRiemannSolver.C	/^int ExactRiemannSolver<dim>::updatePhaseChange(SVec<double,dim> &V, Vec<int> &fluidId,$/;"	f	class:ExactRiemannSolver
updatePhaseChange	LocalRiemann.h	/^  int updatePhaseChange(double *V, int ID, int IDn, double *newV, double weight,bool isCellCut){$/;"	f	class:LocalRiemannGfmpar
updatePhaseChange	LocalRiemann.h	/^  int updatePhaseChange(double *V, int ID, int IDn, double *newV, double weight,bool isCellCut){$/;"	f	class:LocalRiemannLowMach
updatePhaseChange	LocalRiemann.h	/^  int updatePhaseChange(double *V, int ID, int IDn, double *newV, double weight,bool isCellCut){\/\/\/*nothing to do for GFMP*\/}$/;"	f	class:LocalRiemannGfmp
updatePhaseChange	LocalRiemann.h	/^  virtual int updatePhaseChange(double *V, int ID, int IDn, double *newV, double weight,bool isCellCut)$/;"	f	class:LocalRiemann
updatePhaseChangeFF	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::updatePhaseChangeFF(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
updatePhaseChangeFS	ExplicitMultiPhysicsTsDesc.C	/^void ExplicitMultiPhysicsTsDesc<dim,dimLS>::updatePhaseChangeFS(DistSVec<double,dim> &U)$/;"	f	class:ExplicitMultiPhysicsTsDesc
updatePhaseChangingNodeValues	LocalRiemann.h	/^  void updatePhaseChangingNodeValues( double * const dx, $/;"	f	class:LocalRiemannLowMach
updatePhaseChangingNodeValues	LocalRiemann.h	/^void LocalRiemannGfmpar::updatePhaseChangingNodeValues( double * const dx, $/;"	f	class:LocalRiemannGfmpar
updatePhysBAMInterface	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::updatePhysBAMInterface() $/;"	f	class:DistIntersectorFRG
updatePhysBAMInterface	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::updatePhysBAMInterface(Vec3D *particles, int size, $/;"	f	class:DistIntersectorPhysBAM
updatePrtout	TsOutput.C	/^void TsOutput<dim>::updatePrtout(double t)$/;"	f	class:TsOutput
updatePrtout	TsRestartCore.C	/^void TsRestart::updatePrtout(double t)$/;"	f	class:TsRestart
updateRowOfU	AlternatingLeastSquare/als_lapack.cpp	/^void AlternatingLeastSquare::updateRowOfU(double *X, unsigned char *M, double *UT, double *V, const int i) {$/;"	f	class:AlternatingLeastSquare
updateSA	DistBcData.C	/^void DistBcData<dim>::updateSA(DistSVec<double,3> &X, DistSVec<double,3> &dX, double &dMach)$/;"	f	class:DistBcData
updateStateVectors	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::updateStateVectors(DistSVec<double,dim> &U, int it)$/;"	f	class:EmbeddedTsDesc
updateStateVectors	LevelSetTsDesc.C	/^void LevelSetTsDesc<dim,dimLS>::updateStateVectors(DistSVec<double,dim> &U, int it)$/;"	f	class:LevelSetTsDesc
updateStateVectors	MultiGridOperator.C	/^void MultiGridOperator<Scalar,dim>::updateStateVectors(DistSVec<Scalar,dim>& U) {$/;"	f	class:MultiGridOperator
updateStateVectors	MultiGridSpaceOperator.C	/^updateStateVectors(int level, MultiGridDistSVec<Scalar,dim>& U) {$/;"	f	class:MultiGridSpaceOperator
updateStateVectors	MultiPhysicsTsDesc.C	/^void MultiPhysicsTsDesc<dim,dimLS>::updateStateVectors(DistSVec<double,dim> &U, int it)$/;"	f	class:MultiPhysicsTsDesc
updateStateVectors	TsDesc.C	/^void TsDesc<dim>::updateStateVectors(DistSVec<double,dim> &U, int it)$/;"	f	class:TsDesc
updateStep1	HeatTransferHandlerCore.C	/^double HeatTransferHandler::updateStep1(bool* lastIt, int it, DistVec<double>& T)$/;"	f	class:HeatTransferHandler
updateStep1	MeshMotionHandler.h	/^  virtual double updateStep1(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &, double * =0) {return 0.0;} $/;"	f	class:MeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AccAeroMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AccAeroMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AccDeformingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AccDeformingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AccHeavingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AccHeavingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AccMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AccMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AccPitchingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AccPitchingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double AeroMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:AeroMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double DeformingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:DeformingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double EmbeddedALEMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedALEMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double EmbeddedMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double HeavingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:HeavingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double PitchingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:PitchingMeshMotionHandler
updateStep1	MeshMotionHandlerCore.C	/^double SpiralingMeshMotionHandler::updateStep1(bool *lastIt, int it, double t,$/;"	f	class:SpiralingMeshMotionHandler
updateStep2	HeatTransferHandlerCore.C	/^double HeatTransferHandler::updateStep2(bool* lastIt, int it, DistVec<double>& T)$/;"	f	class:HeatTransferHandler
updateStep2	MeshMotionHandler.h	/^  virtual double updateStep2(bool *, int, double, DistSVec<double,3> &, DistSVec<double,3> &) {return 0.0;}$/;"	f	class:MeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AccAeroMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AccAeroMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AccDeformingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AccDeformingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AccHeavingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AccHeavingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AccMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AccMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AccPitchingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AccPitchingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double AeroMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:AeroMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double DeformingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:DeformingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double EmbeddedALEMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedALEMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double EmbeddedMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:EmbeddedMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double HeavingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:HeavingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double PitchingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:PitchingMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double RbmExtractor::updateStep2(bool *lastIt, int it,double t,$/;"	f	class:RbmExtractor
updateStep2	MeshMotionHandlerCore.C	/^double RigidRollMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:RigidRollMeshMotionHandler
updateStep2	MeshMotionHandlerCore.C	/^double SpiralingMeshMotionHandler::updateStep2(bool *lastIt, int it, double t,$/;"	f	class:SpiralingMeshMotionHandler
updateStructCoords	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::updateStructCoords(double c_n, double c_np1)$/;"	f	class:DistIntersectorFRG
updateStructure	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::updateStructure(double *xs, double *Vs, int nNodes, int (*abc)[3]) $/;"	f	class:DistIntersectorFRG
updateStructure	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::updateStructure(double *xs, double *Vs, int nNodes, int (*abc)[3])$/;"	f	class:DistIntersectorPhysBAM
updateStructure	LevelSet/MultiGridLevelSetStructure.h	/^    void updateStructure(double *Xs, double *Vs, int nNodes, int(*abc)[3]=0) {$/;"	f	class:DistMultiGridLevelSetStructure
updateSweptNodes	SpaceOperator.C	/^void MultiPhaseSpaceOperator<dim,dimLS>::updateSweptNodes(DistSVec<double,3> &X, int &phaseChangeChoice,$/;"	f	class:MultiPhaseSpaceOperator
updateSweptNodes	SpaceOperator.C	/^void SpaceOperator<dim>::updateSweptNodes(DistSVec<double,3> &X,DistVec<double> &ctrlVol,$/;"	f	class:SpaceOperator
updateU	AlternatingLeastSquare/als_lapack.h	/^    void updateU(const int i) { updateRowOfU(X, M, UT, V, i); }$/;"	f	class:AlternatingLeastSquare
updateV	AlternatingLeastSquare/als_lapack.h	/^    void updateV(const int j) { updateColOfV(X, M, UT, V, j); }$/;"	f	class:AlternatingLeastSquare
updateXb	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::updateXb(double epsilon){$/;"	f	class:DistIntersectorFRG
updateXb	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::updateXb(double epsilon){$/;"	f	class:DistIntersectorPhysBAM
updateXb	LevelSet/MultiGridLevelSetStructure.h	/^    void updateXb(double) {} \/\/  $/;"	f	class:DistMultiGridLevelSetStructure
update_tmp	MultiGridSegTsDesc.h	/^  MultiGridDistSVec<double,dim> V, res, R, F, U,Uold,dx,Forig,update_tmp;$/;"	m	class:MultiGridSegTsDesc
updatebc	IntersectorFRG/IntersectorFRG.C	/^void DistIntersectorFRG::updatebc() {$/;"	f	class:DistIntersectorFRG
updatebc	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void DistIntersectorPhysBAM::updatebc() {$/;"	f	class:DistIntersectorPhysBAM
updaterotation	FSI/DynamicNodalTransfer.cpp	/^void EmbeddedStructure::updaterotation(double time) {$/;"	f	class:EmbeddedStructure
uplo	arpack++/include/arbsmat.h	/^  char     uplo;$/;"	m	class:ARbdSymMatrix
uplo	arpack++/include/ardsmat.h	/^  char     uplo;$/;"	m	class:ARdsSymMatrix
uplo	arpack++/include/arlsmat.h	/^  char        uplo;$/;"	m	class:ARluSymMatrix
uplo	arpack++/include/arlspen.h	/^  char                   uplo;$/;"	m	class:ARluSymPencil
uplo	arpack++/include/arusmat.h	/^  char    uplo;$/;"	m	class:ARumSymMatrix
urefComponentwiseSums	NonlinearRom.h	/^  std::vector<std::vector<double> > urefComponentwiseSums; \/\/[iCluster][1:dim]$/;"	m	class:NonlinearRom
urefComponentwiseSumsName	NonlinearRom.h	/^  char* urefComponentwiseSumsName;  \/\/ for exact updates with uniform IC (exactUpdateInfoPrefix.exactUpdates_UrefComponentwiseSums)$/;"	m	class:NonlinearRom
urefMultiUicProducts	NonlinearRom.h	/^  std::vector<std::vector<double> > urefMultiUicProducts; \/\/ [iCluster][Uj]$/;"	m	class:NonlinearRom
urefMultiUicProductsName	NonlinearRom.h	/^  char* urefMultiUicProductsName;$/;"	m	class:NonlinearRom
urefUicProducts	NonlinearRom.h	/^  std::vector<double> urefUicProducts; \/\/ [iCluster] only precomputed if Uic specified$/;"	m	class:NonlinearRom
urefUicProductsName	NonlinearRom.h	/^  char* urefUicProductsName;        \/\/ for exact updates (exactUpdateInfoPrefix.exactUpdates_c)$/;"	m	class:NonlinearRom
urefUrefProducts	NonlinearRom.h	/^  std::vector<std::vector<double> > urefUrefProducts; \/\/[iCluster][jCluster] symmetric (lower triangular)$/;"	m	class:NonlinearRom
urefUrefProductsName	NonlinearRom.h	/^  char* urefUrefProductsName;       \/\/ for exact updates (exactUpdateInfoPrefix.exactUpdates_g)   $/;"	m	class:NonlinearRom
usPtr	Malloc.C	/^usptr_t *usPtr;$/;"	v
useExistingClusters	IoData.h	/^  enum UseExistingClusters {USE_EXISTING_CLUSTERS_FALSE = 0, USE_EXISTING_CLUSTERS_TRUE = 1} useExistingClusters;$/;"	m	struct:ClusteringData	typeref:enum:ClusteringData::UseExistingClusters
useFirstStateAsRefStateForIncrBasis	IoData.h	/^  enum UseFirstStateAsRefStateForIncrBasis {ASSUME_INCR_REFSTATE_FALSE = 0, ASSUME_INCR_REFSTATE_TRUE = 1} useFirstStateAsRefStateForIncrBasis;$/;"	m	struct:RelativeProjectionErrorData	typeref:enum:RelativeProjectionErrorData::UseFirstStateAsRefStateForIncrBasis
useGMRESAcceleration	IoData.h	/^  int useGMRESAcceleration;$/;"	m	struct:MultiGridData
useIncrements	ImplicitRomTsDesc.h	/^  bool useIncrements;$/;"	m	class:ImplicitRomTsDesc
useModal	SpaceOperator.h	/^  bool useModal() $/;"	f	class:SpaceOperator
useMultiSolutionsGappy	IoData.h	/^  enum UseMultiSolutionsGappy {MULTI_SOLUTIONS_GAPPY_FALSE=0, MULTI_SOLUTIONS_GAPPY_TRUE=1} useMultiSolutionsGappy;$/;"	m	struct:InputData	typeref:enum:InputData::UseMultiSolutionsGappy
useNm1	DistTimeState.h	/^  inline bool useNm1() const { return data->use_nm1; }$/;"	f	class:DistTimeState
useOldReducedSVecFunction	IoData.h	/^  enum UseOldReducedSVecFunction {USE_OLD_FALSE = 0, USE_OLD_TRUE = 1} useOldReducedSVecFunction;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::UseOldReducedSVecFunction
useUnionOfSampledNodes	IoData.h	/^  enum UseUnionOfSampledNodes {UNION_FALSE = 0, UNION_TRUE = 1} useUnionOfSampledNodes;$/;"	m	struct:GappyConstructionData	typeref:enum:GappyConstructionData::UseUnionOfSampledNodes
useVolumeWeightedAverage	MultiGridLevel.h	/^    bool useVolumeWeightedAverage;$/;"	m	class:MultiGridLevel
use_complex	SpaceOperator.h	/^  bool use_complex;$/;"	m	class:SpaceOperator
use_doubles	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^    const bool use_doubles; \/\/ otherwise use floats$/;"	m	class:PhysBAM::STREAM_TYPE
use_freq	TimeData.h	/^  bool use_freq;$/;"	m	class:TimeData
use_modal	SpaceOperator.h	/^  bool use_modal;$/;"	m	class:SpaceOperator
use_modal	TimeData.h	/^  bool use_modal;$/;"	m	class:TimeData
use_n	GeoData.h	/^  bool use_n;$/;"	m	class:GeoData
use_nm1	GeoData.h	/^  bool use_nm1;$/;"	m	class:GeoData
use_nm1	TimeData.h	/^  bool use_nm1;$/;"	m	class:TimeData
use_nm2	GeoData.h	/^  bool use_nm2;$/;"	m	class:GeoData
use_nm2	TimeData.h	/^  bool use_nm2;$/;"	m	class:TimeData
use_save	GeoData.h	/^  bool use_save;$/;"	m	class:GeoData
use_secondary_interpolation	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.h	/^    bool use_secondary_interpolation;$/;"	m	class:PhysBAM::IMPLICIT_OBJECT
usedNodes	FSI/CrackingSurface.h	/^  int usedNodes() const {return nUsedNodes;}$/;"	f	class:CrackingSurface
usedTrias	FSI/CrackingSurface.h	/^  int usedTrias() const {return nUsedTrias;}$/;"	f	class:CrackingSurface
usefv3	DESTerm.h	/^  bool usefv3;$/;"	m	class:DESTerm
usefv3	FemEquationTermDesc.h	/^  bool trip, usefv3;$/;"	m	class:FemEquationTermDES
usefv3	FemEquationTermDesc.h	/^  bool trip, usefv3;$/;"	m	class:FemEquationTermSA
usefv3	SpalartAllmarasTerm.h	/^  bool usefv3;$/;"	m	class:SATerm
using_externally_allocated_pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    bool using_externally_allocated_pointer;$/;"	m	class:PhysBAM::ARRAY
using_externally_allocated_pointer	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^    bool using_externally_allocated_pointer;$/;"	m	class:PhysBAM::ARRAY_VIEW
usub	arpack++/include/arlspdef.h	/^    int     *usub;$/;"	m	struct:__anon35
usub	arpack++/include/arlspdef.h	/^    int     *usub;$/;"	m	struct:__anon36
usub	arpack++/include/arlspdef.h	/^    int     *usub;$/;"	m	struct:__anon37
usub	arpack++/include/arlspdef.h	/^    int     *usub;$/;"	m	struct:__anon38
utime	arpack++/include/arlutil.h	/^    double  *utime;       \/* running time at various phases *\/$/;"	m	struct:__anon52
v	DenseMatrix.h	/^   Scalar *v;   \/\/ pointer to matrix data$/;"	m	class:GenFullM
v	DenseMatrix.h	/^  Scalar *v;$/;"	m	class:SymFullM
v	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
v	MeshMotionHandler.h	/^  Vec3D v;$/;"	m	class:RigidMeshMotionHandler
v	MeshMotionHandler.h	/^  double u, v, w;$/;"	m	class:PitchingMeshMotionHandler
v	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/QUATERNION.h	/^    TV v;$/;"	m	class:PhysBAM::QUATERNION
v	Vector.h	/^  Scalar (*v)[dim];$/;"	m	class:SVec
v	Vector.h	/^  Scalar *v;$/;"	m	class:Vec
v	Vector3D.h	/^  double v[3];$/;"	m	struct:Vec3D
v6data	EdgeGrad.h	/^  V6NodeDataOf2 v6data;$/;"	m	class:EdgeGrad
v6data	HigherOrderFSI.h	/^   V6NodeData (*v6data)[2];$/;"	m	class:HigherOrderFSI
v6data	HigherOrderMultiFluid.h	/^   V6NodeData (*v6data)[2];$/;"	m	class:HigherOrderMultiFluid
vProd	MatVecProd.h	/^  DistSVec<double, neq> *vProd;$/;"	m	class:MatVecProdH2
vWallNode	IntersectorFRG/IntersectorFRG.C	/^bool IntersectorFRG::vWallNode(int i, Vec3D &vWall)$/;"	f	class:IntersectorFRG
vWallNode	IntersectorPhysBAM/IntersectorPhysBAM.C	/^bool IntersectorPhysBAM::vWallNode(int i, Vec3D &vWall)$/;"	f	class:IntersectorPhysBAM
vWallNode	LevelSet/MultiGridLevelSetStructure.h	/^	 bool vWallNode(int i, Vec3D &vWall) {exit(-1);}$/;"	f	class:MultiGridLevelSetStructure
vWallWithSI	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::vWallWithSI(int n, Vec3D &vWall)$/;"	f	class:IntersectorFRG
vWallWithSI	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::vWallWithSI(int n, Vec3D &vWall)$/;"	f	class:IntersectorPhysBAM
vWallWithSI	LevelSet/MultiGridLevelSetStructure.h	/^	 void vWallWithSI(int n, Vec3D &vWall) {exit(-1);}$/;"	f	class:MultiGridLevelSetStructure
v_1D	OneDimensionalSolver.h	/^    double* x_1D,*v_1D;$/;"	m	class:OneDimensional::Veval
vacuum	LocalRiemannDesc.h	/^bool LocalRiemannGfmparGasJWL::vacuum(const double rhol, const double ul, const double pl,$/;"	f	class:LocalRiemannGfmparGasJWL
vacuum	LocalRiemannDesc.h	/^bool LocalRiemannGfmparTaitJWL::vacuum(const double rhol, const double ul, const double pl,$/;"	f	class:LocalRiemannGfmparTaitJWL
val	AutoDiff/Taylor.h	/^    Scalar &val() { return f0; }$/;"	f	class:Taylor2
val	AutoDiff/Taylor.h	/^    Scalar val() const { return f0; }$/;"	f	class:Taylor2
val	BCond.h	/^  double val;$/;"	m	struct:BCond
val	IntersectorFRG/IntersectorFRG.C	/^  double val(int i) const { return x[i]; }$/;"	f	class:MyTriangle
val	arpack++/include/ardfmat.h	/^  ARTYPE*  val;       \/\/ Numerical values of matrix entries.$/;"	m	class:ARdfMatrix
val	arpack++/include/arhbmat.h	/^  ARTYPE* val;             \/\/ Numerical values of matrix entries.$/;"	m	class:ARhbMatrix
val	parser/Assigner.h	/^    vector<int> val;$/;"	m	class:ClassToken
val	parser/Assigner.h	/^   double *val;$/;"	m	class:SysDoubleObj
val	parser/Assigner.h	/^   int *val;$/;"	m	class:SysIntObj
val	parser/Assigner.h	/^   vector<int> val;$/;"	m	class:SysTokenObj
val	parser/Assigner.h	/^  std::string val;$/;"	m	class:SysStrObj
val	parser/Assigner.h	/^  vector<int> val;$/;"	m	class:ClassArray
vals	SpaceOperator.h	/^    DistSVec<double,dim>* vals[2];$/;"	m	struct:MultiPhaseSpaceOperator::__anon28
value	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/BOX.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<BOX<TV>,RW> {static const bool value=false;}; \/\/ required since memory format differs from disk format$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^template<class T,class ID> struct IS_ARRAY<ARRAY<T,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<ARRAY<T,ID> > {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T2,class T_ARRAY2> struct IS_ARRAY_BASE<ARRAY_BASE<T2,T_ARRAY2,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::ARRAY_BASE::IS_ARRAY_BASE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    template<class T_ARRAY2> struct IS_ARRAY_BASE {static const bool value=false;};$/;"	m	struct:PhysBAM::ARRAY_BASE::IS_ARRAY_BASE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^{static const bool value=true;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_DIFFERENCE.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_DIFFERENCE<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY<ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_LEFT_MULTIPLE.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_LEFT_MULTIPLE<T1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^template<class T_ARRAY> struct IS_ARRAY<ARRAY_NEGATION<T_ARRAY> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_NEGATION.h	/^template<class T_ARRAY> struct IS_ARRAY_VIEW<ARRAY_NEGATION<T_ARRAY> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T2,class ENABLE=void> struct ARRAY_PLUS_SCALAR_VALID {static const bool value=false;};$/;"	m	struct:PhysBAM::ARRAY_PLUS_SCALAR_VALID
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY<ARRAY_PLUS_SCALAR<T1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^template<class T1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_PLUS_SCALAR<T1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PLUS_SCALAR.h	/^{static const bool value=IS_SAME<T1,T2>::value || IS_SCALAR<T1>::value;};$/;"	m	struct:PhysBAM::ARRAY_PLUS_SCALAR_VALID
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_PRODUCT.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_PRODUCT<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY<ARRAY_SUM<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_SUM.h	/^template<class T_ARRAY1,class T_ARRAY2> struct IS_ARRAY_VIEW<ARRAY_SUM<T_ARRAY1,T_ARRAY2> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_ARRAY<ARRAY_VIEW<T,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<ARRAY_VIEW<T,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_VIEW.h	/^template<class T,class ID> struct IS_CONST<ARRAY_VIEW<const T,ID> > {static const bool value=true;}; \/\/ ARRAY_VIEW<const T,ID> is equivalent to const ARRAY_VIEW<const T,ID>$/;"	m	struct:PhysBAM::IS_CONST
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^template<class T,class ID> struct IS_ARRAY<CONSTANT_ARRAY<T,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/CONSTANT_ARRAY.h	/^template<class T,class ID> struct IS_ARRAY_VIEW<CONSTANT_ARRAY<T,ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^template<class ID> struct IS_ARRAY<IDENTITY_ARRAY<ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/IDENTITY_ARRAY.h	/^template<class ID> struct IS_ARRAY_VIEW<IDENTITY_ARRAY<ID> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_ARRAY,class T_INDICES> struct IS_ARRAY<INDIRECT_ARRAY<T_ARRAY,T_INDICES> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/INDIRECT_ARRAY.h	/^template<class T_ARRAY,class T_INDICES> struct IS_ARRAY_VIEW<INDIRECT_ARRAY<T_ARRAY,T_INDICES> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct IS_ARRAY<PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/PROJECTED_ARRAY.h	/^template<class T_ARRAY,class T_PROJECTOR> struct IS_ARRAY_VIEW<PROJECTED_ARRAY<T_ARRAY,T_PROJECTOR> > {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/Hash.h	/^    int value;$/;"	m	class:PhysBAM::HASH
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/INTERVAL.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<INTERVAL<TV>,RW> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/RANGE.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<RANGE<TV>,RW> {static const bool value=false;}; \/\/ required since memory format differs from disk format$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/FRAME.h	/^template<class TV> struct HAS_CHEAP_COPY<FRAME<TV> > {static const bool value=true;};$/;"	m	struct:PhysBAM::HAS_CHEAP_COPY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<DIAGONAL_MATRIX<T,d> > {static const bool value=(d==2 || d==3);};$/;"	m	struct:PhysBAM::EFFICIENT_MATRIX
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<SYMMETRIC_MATRIX<T,d> > {static const bool value=(d==2 || d==3);};$/;"	m	struct:PhysBAM::EFFICIENT_MATRIX
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int d> struct EFFICIENT_MATRIX<VECTOR<T,d> > {static const bool value=(d<=3);};$/;"	m	struct:PhysBAM::EFFICIENT_MATRIX
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T,int m,int n> struct EFFICIENT_MATRIX<MATRIX<T,m,n> > {static const bool value=((m>=2 && m<=3 && n>=2 && n<=3) || (m==4 && n==4) || (m==0 && n==0));};$/;"	m	struct:PhysBAM::EFFICIENT_MATRIX
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^template<class T_MATRIX> struct EFFICIENT_MATRIX {static const bool value=false;};$/;"	m	struct:PhysBAM::EFFICIENT_MATRIX
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n,class RW> struct IS_BINARY_IO_SAFE<MATRIX<T,m,n>,RW> {static const bool value=AND<(m>0),(n>0),IS_BINARY_IO_SAFE<T,RW>::value>::value;};$/;"	m	class:PhysBAM::IS_BINARY_IO_SAFE::IS_BINARY_IO_SAFE::value
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n,class RW> struct IS_BINARY_IO_SAFE<MATRIX<T,m,n>,RW> {static const bool value=AND<(m>0),(n>0),IS_BINARY_IO_SAFE<T,RW>::value>::value;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n> struct IS_SCALAR_BLOCK<MATRIX<T,m,n> > {static const bool value=IS_SCALAR_BLOCK<T>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_BLOCK
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_FORWARD.h	/^template<class T,int m,int n> struct IS_SCALAR_VECTOR_SPACE<MATRIX<T,m,n> > {static const bool value=IS_SCALAR_VECTOR_SPACE<T>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_VECTOR_SPACE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV,class RW> struct IS_BINARY_IO_SAFE<ROTATION<TV>,RW> {static const bool value=(TV::m>1) && IS_BINARY_IO_SAFE<TV,RW>::value;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV> struct HAS_CHEAP_COPY<ROTATION<TV> > {static const bool value=true;};$/;"	m	struct:PhysBAM::HAS_CHEAP_COPY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/ROTATION.h	/^template<class TV> struct IS_SCALAR_BLOCK<ROTATION<TV> > {static const bool value=(TV::m>1) && IS_SCALAR_BLOCK<TV>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_BLOCK
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^template<class T> struct HAS_CHEAP_COPY<SYMMETRIC_MATRIX<T,3> > {static const bool value=true;};$/;"	m	struct:PhysBAM::HAS_CHEAP_COPY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<bool>{static const int value=1;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<char>{static const int value=1;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<double>{static const int value=8;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<float>{static const int value=4;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<int>{static const int value=4;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<short>{static const int value=2;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned char>{static const int value=1;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned int>{static const int value=4;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<> struct PLATFORM_INDEPENDENT_SIZE<unsigned short>{static const int value=2;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class RW> struct IS_BINARY_IO_SAFE<bool,RW> {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T,class RW,class ENABLER> struct IS_BINARY_IO_SAFE {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T> struct IS_PRIMITIVE_BINARY_IO_SAFE {static const bool value=!big_endian && (sizeof(T)==PLATFORM_INDEPENDENT_SIZE<T>::value);};$/;"	m	struct:PhysBAM::IS_PRIMITIVE_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/READ_WRITE.h	/^template<class T> struct PLATFORM_INDEPENDENT_SIZE<T,typename ENABLE_IF<IS_ENUM<T>::value>::TYPE>{static const int value=4;};$/;"	m	struct:PhysBAM::PLATFORM_INDEPENDENT_SIZE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T,class HAS> struct HAS_TYPED_READ{enum {value=false};};$/;"	e	enum:PhysBAM::HAS_TYPED_READ::__anon24
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T,class HAS> struct HAS_TYPED_WRITE{enum {value=false};};$/;"	e	enum:PhysBAM::HAS_TYPED_WRITE::__anon26
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T> struct HAS_TYPED_READ<T,typename FIRST<void,typename T::HAS_TYPED_READ_WRITE>::TYPE>{enum {value=true};};$/;"	e	enum:PhysBAM::HAS_TYPED_READ::__anon25
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Read_Write/Utilities/TYPED_STREAM.h	/^template<class T> struct HAS_TYPED_WRITE<T,typename FIRST<void,typename T::HAS_TYPED_READ_WRITE>::TYPE>{enum {value=true};};$/;"	e	enum:PhysBAM::HAS_TYPED_WRITE::__anon27
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value = helper::value;$/;"	m	struct:PhysBAM::IS_ENUM_IMPL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value = sizeof(_m_check(_m_from))==sizeof(YES_TYPE);$/;"	m	struct:PhysBAM::IS_CONVERTIBLE_BASIC_IMPL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value=AND<IS_CONVERTIBLE_BASIC_IMPL<ref_type,T2>::value,NOT<IS_ARRAY<T2>::value>::value>::value;$/;"	m	struct:PhysBAM::IS_CONVERTIBLE_IMPL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value=AND<sizeof(Is_Class_Tester<T>(0)) == sizeof(YES_TYPE),NOT<union_value>::value>::value;$/;"	m	struct:PhysBAM::IS_CLASS
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value=EMPTY_HELPER<CV_TYPE,IS_CLASS<CV_TYPE>::value>::value;$/;"	m	struct:PhysBAM::IS_EMPTY_VALUE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^    static const bool value=sizeof(check(Get_C(),0))==sizeof(YES_TYPE);$/;"	m	struct:PhysBAM::IS_BASE_OF_VALUE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct FALSE_TYPE {static const bool value=false;};$/;"	m	struct:PhysBAM::FALSE_TYPE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct IS_BASE_OF_VALUE<B,B> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_BASE_OF_VALUE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^struct TRUE_TYPE {static const bool value=true;};$/;"	m	struct:PhysBAM::TRUE_TYPE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <> struct IS_ENUM_HELPER<false> {template <class T> struct type {static const bool value=IS_CONVERTIBLE<typename ADD_REFERENCE<T>::TYPE,INT_CONVERTIBLE>::value;};};$/;"	m	struct:PhysBAM::IS_ENUM_HELPER::type
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <bool is_typename_arithmetic_or_reference = true> struct IS_ENUM_HELPER {template <class T> struct type {static const bool value=false;};};$/;"	m	struct:PhysBAM::IS_ENUM_HELPER::type
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class B,class D> struct IS_BASE_OF {static const bool value=IS_BASE_OF_VALUE<B,D>::value;};$/;"	m	struct:PhysBAM::IS_BASE_OF
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T,bool is_class=false> struct EMPTY_HELPER{static const bool value=false;};$/;"	m	struct:PhysBAM::EMPTY_HELPER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct EMPTY_HELPER<T,true>{static const bool value=sizeof(EMPTY_HELPER_BASE_T<T>)==sizeof(EMPTY_HELPER_NOBASE);};$/;"	m	struct:PhysBAM::EMPTY_HELPER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template <class T> struct IS_EMPTY {static const bool value=IS_EMPTY_VALUE<T>::value;};$/;"	m	struct:PhysBAM::IS_EMPTY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<> struct NOT<false> {static const bool value=true;};$/;"	m	struct:PhysBAM::NOT
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b1,bool b2,bool b3=false,bool b4=false> struct OR {static const bool value=b1 || b2 || b3 || b4;};$/;"	m	struct:PhysBAM::OR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b1,bool b2,bool b3=true,bool b4=true> struct AND {static const bool value=b1 && b2 && b3 && b4;};$/;"	m	struct:PhysBAM::AND
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<bool b> struct NOT {static const bool value=false;};$/;"	m	struct:PhysBAM::NOT
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,T v> struct STATIC_CONST {static const T value=v;};$/;"	m	struct:PhysBAM::STATIC_CONST
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T,class TF> struct IS_MEMBER_POINTER<TF T::*> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_MEMBER_POINTER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_CONVERTIBLE {static const bool value=IS_CONVERTIBLE_DISPATCH<T1,T2>::value;};$/;"	m	struct:PhysBAM::IS_CONVERTIBLE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T1,class T2> struct IS_SAME {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_SAME
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct HAS_TRIVIAL_DESTRUCTOR {static const bool value=IS_POD<T>::value;};$/;"	m	struct:PhysBAM::HAS_TRIVIAL_DESTRUCTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_CONST {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_CONST
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_CONST<const T> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_CONST
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_ENUM {static const bool value=IS_ENUM_IMPL<T>::value;};$/;"	m	struct:PhysBAM::IS_ENUM
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FLOATING_POINT {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_FLOATING_POINT
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FUNCTION {static const bool value=NOT<IS_CONVERTIBLE<T*, const volatile void*>::value>::value;};$/;"	m	struct:PhysBAM::IS_FUNCTION
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_FUNDAMENTAL {static const bool value=OR<IS_SCALAR<T>::value,IS_VOID<T>::value>::value;};$/;"	m	struct:PhysBAM::IS_FUNDAMENTAL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_INTEGRAL {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_INTEGRAL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_MEMBER_POINTER {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_MEMBER_POINTER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POD {static const bool value=IS_VOID<T>::value||IS_SCALAR_TYPE<typename REMOVE_ALL_EXTENTS<T>::type>::value;};$/;"	m	struct:PhysBAM::IS_POD
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POINTER {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_POINTER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_POINTER<T*> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_POINTER
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_REFERENCE {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_REFERENCE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_REFERENCE<T&> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_REFERENCE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SAME<T,T> {static const bool value=true;};$/;"	m	struct:PhysBAM::IS_SAME
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SCALAR {static const bool value=OR<IS_INTEGRAL<T>::value,IS_FLOATING_POINT<T>::value>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_SCALAR_TYPE {static const bool value=IS_SCALAR<T>::value||IS_ENUM<T>::value||IS_POINTER<T>::value||IS_MEMBER_POINTER<T>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_TYPE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T> struct IS_VOID {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_VOID
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY,class ENABLER=void> struct IS_ARRAY {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_ARRAY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<class T_ARRAY,class ENABLER=void> struct IS_ARRAY_VIEW {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<int i,int j> struct INTS_EQUAL {static const bool value=false;};$/;"	m	struct:PhysBAM::INTS_EQUAL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TYPE_UTILITIES.h	/^template<int i> struct INTS_EQUAL<i,i> {static const bool value=true;};$/;"	m	struct:PhysBAM::INTS_EQUAL
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<double,float>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<double,int>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<float,double>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<float,int>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<int,double>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<> struct CAN_ASSIGN<int,float>{static const bool value=false;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/ARITHMETIC_POLICY.h	/^template<class T> struct CAN_ASSIGN<T,T>{static const bool value=true;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct IS_SCALAR_BLOCK {static const bool value=IS_SCALAR<T>::value;}; \/\/ true if memory layout is contiguous array of scalars$/;"	m	struct:PhysBAM::IS_SCALAR_BLOCK
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/SCALAR_POLICY.h	/^template<class T> struct IS_SCALAR_VECTOR_SPACE {static const bool value=IS_SCALAR<T>::value;}; \/\/ true if we can compute vector space operations on the underlying array of scalars$/;"	m	struct:PhysBAM::IS_SCALAR_VECTOR_SPACE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/TWIST.h	/^template<class TV> struct CAN_ASSIGN<TWIST<TV>,TWIST<TV> > {static const bool value=true;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,0> >{static const bool value=true;};$/;"	m	struct:PhysBAM::EFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,1> >{static const bool value=true;};$/;"	m	struct:PhysBAM::EFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,2> >{static const bool value=true;};$/;"	m	struct:PhysBAM::EFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class T> struct EFFICIENT_VECTOR<VECTOR<T,3> >{static const bool value=true;};$/;"	m	struct:PhysBAM::EFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class TV> struct EFFICIENT_VECTOR{static const bool value=false;};$/;"	m	struct:PhysBAM::EFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^template<class TV> struct INEFFICIENT_VECTOR{static const bool value=IS_VECTOR<TV>::value && !EFFICIENT_VECTOR<TV>::value;};$/;"	m	struct:PhysBAM::INEFFICIENT_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^{static const bool value=true;};$/;"	m	struct:PhysBAM::CAN_ASSIGN
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d,class RW> struct IS_BINARY_IO_SAFE<VECTOR<T,d>,RW> {static const bool value=(d>0) && IS_BINARY_IO_SAFE<T,RW>::value;};$/;"	m	struct:PhysBAM::IS_BINARY_IO_SAFE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct HAS_CHEAP_COPY<VECTOR<T,d> > {static const bool value=true;};$/;"	m	struct:PhysBAM::HAS_CHEAP_COPY
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct IS_SCALAR_BLOCK<VECTOR<T,d> > {static const bool value=(d>0) && IS_SCALAR_BLOCK<T>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_BLOCK
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class T,int d> struct IS_SCALAR_VECTOR_SPACE<VECTOR<T,d> > {static const bool value=(d>0) && IS_SCALAR_VECTOR_SPACE<T>::value;};$/;"	m	struct:PhysBAM::IS_SCALAR_VECTOR_SPACE
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^template<class TV,class ENABLER=void> struct IS_VECTOR{static const bool value=false;};$/;"	m	struct:PhysBAM::IS_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_FORWARD.h	/^{static const bool value=IS_BASE_OF<VECTOR_BASE<typename TV::ELEMENT,TV>,TV>::value;};$/;"	m	struct:PhysBAM::IS_VECTOR
value	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^template<class T> struct IS_ARRAY_VIEW<VECTOR_ND<T> > {static const bool value=false;};$/;"	m	struct:PhysBAM::IS_ARRAY_VIEW
value	arpack++/include/arunsmat.h	/^  ARTYPE* value;$/;"	m	class:ARumNonSymMatrix
value	arpack++/include/arusmat.h	/^  ARTYPE* value;$/;"	m	class:ARumSymMatrix
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    typedef T value_type; \/\/ for stl$/;"	t	class:PhysBAM::ARRAY_BASE
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    typedef ENTRY value_type; \/\/ for stl$/;"	t	class:PhysBAM::HASHTABLE
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR.h	/^    typedef T value_type; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    typedef T value_type; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    typedef T value_type; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
value_type	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    typedef T value_type; \/\/ for stl$/;"	t	class:PhysBAM::VECTOR
values	AutoDiff/SpaceDerivatives.h	/^    int values() const { return ValuesAtCompileTime; }$/;"	f	class:SpatialView
values_	SimpleBuffer.h	/^  Scalar * values_;$/;"	m	class:SimpleBuffer
vanalbada	RecFcn.h	/^void RecFcn::vanalbada(double Vi, double ddVij, double Vj, double ddVji,$/;"	f	class:RecFcn
vanalbadaDerivative	RecFcn.h	/^void RecFcn::vanalbadaDerivative(double Vi, double dVi, double ddVij, double dddVij, double Vj, double dVj, double ddVji, double dddVji,$/;"	f	class:RecFcn
vanalbadaDerivativeOperators	RecFcn.h	/^void RecFcn::vanalbadaDerivativeOperators(double Vi, double ddVij, double Vj, double ddVji, $/;"	f	class:RecFcn
varFcn	DistDynamicLESTerm.h	/^  VarFcn *varFcn;$/;"	m	class:DistDynamicLESTerm
varFcn	DistDynamicVMSTerm.h	/^  VarFcn *varFcn;$/;"	m	class:DistDynamicVMSTerm
varFcn	DistTimeState.C	/^  VarFcn* varFcn;$/;"	m	struct:SetFirstOrderNodes	file:
varFcn	DistTimeState.h	/^  VarFcn *varFcn;$/;"	m	class:DistTimeState
varFcn	DistVMSLESTerm.h	/^  VarFcn *varFcn;$/;"	m	class:DistVMSLESTerm
varFcn	GhostPoint.h	/^  VarFcn *varFcn;$/;"	m	class:GhostPoint
varFcn	MultiGridSpaceOperator.h	/^  VarFcn* varFcn;$/;"	m	class:MultiGridSpaceOperator
varFcn	NavierStokesTerm.h	/^  VarFcn *varFcn;$/;"	m	class:NavierStokesTerm
varFcn	OneDimensionalSolver.h	/^    VarFcn* varFcn;$/;"	m	class:OneDimensional::Veval
varFcn	OneDimensionalSolver.h	/^  VarFcn *varFcn;$/;"	m	class:OneDimensional
varFcn	PostFcn.h	/^  VarFcn *varFcn;$/;"	m	class:PostFcn
varFcn	PostOperator.h	/^  VarFcn *varFcn;$/;"	m	class:PostOperator
varFcn	SpaceOperator.h	/^  VarFcn *varFcn;$/;"	m	class:SpaceOperator
varFcn	SparseGridGeneratorDesc.h	/^  VarFcn *varFcn;$/;"	m	class:SparseGridGeneratorDesc
varFcn	ThermalCondFcn.h	/^  VarFcn *varFcn;$/;"	m	class:ConstantPrandtlThermalCondFcn
varFcn	TsDesc.h	/^  VarFcn *varFcn;$/;"	m	class:TsDesc
varFcn	VarFcn.h	/^  VarFcnBase **varFcn;$/;"	m	class:VarFcn
varFcn	WallFcn.h	/^  VarFcn *varFcn;$/;"	m	class:WallFcn
varFcnTmp	GappyPreprocessing.h	/^  VarFcn *varFcnTmp;$/;"	m	class:GappyPreprocessing
vars	IoData.h	/^   enum vars {DENSITY = 0, VX = 1, VY = 2, VZ = 3, PRESSURE = 4, TEMPERATURE = 5, TOTALPRESSURE = 6, TOTALTEMPERATURE = 7, MDOT = 8, NUTILDE = 9, KENERGY = 10, EPSILON = 11, SIZE = 12};$/;"	g	struct:BoundaryData
vc	RecFcnDesc.h	/^  double pc,rhoc,vc;$/;"	m	class:RecFcnExtendedVanAlbada
vec1	CurvatureDetection.h	/^  CommPattern<double>* vec1;$/;"	m	class:CurvatureDetection
vec1PatSA	DistBcData.h	/^  CommPattern<double> *vec1PatSA;$/;"	m	class:DistBcDataSA
vec2Pat	DistBcData.h	/^  CommPattern<double> *vec2Pat;$/;"	m	class:DistBcDataSA
vec2Pat	PostOperator.h	/^  CommPattern<double>* vec2Pat;$/;"	m	class:PostOperator
vec2PatSA	DistBcData.h	/^  CommPattern<double> *vec2PatSA;$/;"	m	class:DistBcDataSA
vec3DPat	Domain.h	/^  CommPattern<double> *vec3DPat;$/;"	m	class:Domain
vec3Pat	DistBcData.h	/^  CommPattern<double> *vec3Pat;$/;"	m	class:DistBcDataKE
vec6	CurvatureDetection.h	/^  CommPattern<double>* vec6;$/;"	m	class:CurvatureDetection
vecPat	DistMatrix.h	/^  CommPattern<double> *vecPat;$/;"	m	class:DistMat
vecPat	Domain.h	/^  CommPattern<double> *vecPat;$/;"	m	class:Domain
vecSet	VectorSet.h	/^  VecType *vecSet;$/;"	m	class:VecSet
vectors	OneDimensionalSolver.h	/^  char *vectors[PostFcn::VSIZE];$/;"	m	class:OneDimensional
vectors	TsOutput.h	/^    char *vectors[PostFcn::VSIZE];$/;"	m	struct:TsOutput::line_output
vectors	TsOutput.h	/^  char *vectors[PostFcn::VSIZE];$/;"	m	class:TsOutput
vel	IoData.h	/^  Velocity vel;$/;"	m	struct:ForcedData
velVpts	MeshMotionHandler.h	/^  Vec3D *velVpts;$/;"	m	class:RigidMeshMotionHandler
vel_fac	IoData.h	/^  double vel_fac;$/;"	m	struct:SchemeData
velocities	IoData.h	/^                   IMPLICIT_IMPOSED_THREE_POINT_BDF_VEL = 5, IMPLICIT_ZERO = 6, EXPLICIT_RK2_VEL = 7} velocities;$/;"	m	struct:DGCLData	typeref:enum:DGCLData::Velocities
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDES
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermDESmean
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKE
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermKEmean
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermNS
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSA
velocity	FemEquationTermDesc.h	/^  double velocity, density, length;$/;"	m	class:FemEquationTermSAmean
velocity	IoData.h	/^  const char *velocity;$/;"	m	struct:LinePlot
velocity	IoData.h	/^  const char *velocity;$/;"	m	struct:Probes
velocity	IoData.h	/^  const char *velocity;$/;"	m	struct:TransientData
velocity	IoData.h	/^  double velocity;$/;"	m	struct:BcsFreeStreamData
velocity	IoData.h	/^  double velocity;$/;"	m	struct:InitialConditions
velocity	IoData.h	/^  double velocity;$/;"	m	struct:ReferenceStateData
velocity	IoData.h	/^  double velocity;$/;"	m	struct:SurfaceData
velocity	RefVal.h	/^  double velocity;$/;"	m	class:RefVal
velocity1	IoData.h	/^  double density1, velocity1, pressure1,temperature1;$/;"	m	struct:OneDimensionalInfo
velocity2	IoData.h	/^  double density2, velocity2, pressure2,temperature2;$/;"	m	struct:OneDimensionalInfo
velocityX	IoData.h	/^  double velocityX, velocityY, velocityZ;$/;"	m	struct:BoundaryData
velocityX	IoData.h	/^  double velocityX;$/;"	m	struct:VelocityPoints
velocityY	IoData.h	/^  double velocityX, velocityY, velocityZ;$/;"	m	struct:BoundaryData
velocityY	IoData.h	/^  double velocityY;$/;"	m	struct:VelocityPoints
velocityZ	IoData.h	/^  double velocityX, velocityY, velocityZ;$/;"	m	struct:BoundaryData
velocityZ	IoData.h	/^  double velocityZ;$/;"	m	struct:VelocityPoints
velocitynorm	IoData.h	/^  const char *velocitynorm;$/;"	m	struct:TransientData
venkat	RecFcn.h	/^void RecFcn::venkat(double Vimax, double Vimin, double Vi, double Vij, double ctrlVoli,$/;"	f	class:RecFcn
venkatDerivative	RecFcn.h	/^void RecFcn::venkatDerivative(double Vimax, double dVimax, double Vimin, double dVimin, double Vi, double dVi, double Vij, double dVij, double ctrlVoli, double dCtrlVoli,$/;"	f	class:RecFcn
verbose	IoData.h	/^  int verbose;$/;"	m	struct:ProblemData
verbose	IoData.h	/^  int verbose;$/;"	m	struct:SparseGridData
verbose	SparseGrid.h	/^  int verbose;$/;"	m	class:SparseGrid
verbosity_level	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    int verbosity_level;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
verbosity_level	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    int& verbosity_level;$/;"	m	class:PhysBAM::LOG_REAL::LOG_ENTRY
verif_clipping	VarFcnBase.h	/^  bool verif_clipping; \/\/KW(05\/09\/2011): This seems to be a flag for screen output...$/;"	m	class:VarFcnBase
verification	VarFcnBase.h	/^  virtual int  verification(int glob, double *U, double *V) { return 0; }$/;"	f	class:VarFcnBase
verification	VarFcnJwl.h	/^int VarFcnJwl::verification(int glob, double *U, double *V)$/;"	f	class:VarFcnJwl
verification	VarFcnSGEuler.h	/^int VarFcnSGEuler::verification(int glob, double *U, double *V)$/;"	f	class:VarFcnSGEuler
verification	VarFcnSGKE.h	/^int VarFcnSGKE::verification(int glob, double *U, double *V)$/;"	f	class:VarFcnSGKE
verification	VarFcnSGSA.h	/^int VarFcnSGSA::verification(int glob, double *U, double *V)$/;"	f	class:VarFcnSGSA
verification	VarFcnTait.h	/^int VarFcnTait::verification(int glob, double *U, double *V)$/;"	f	class:VarFcnTait
version	BinFileHandler.h	/^  double version;$/;"	m	class:BinFileHandler
vf	DistBcData.h	/^  VarFcn *vf;$/;"	m	class:DistBcData
vf	Extrapolation.h	/^  VarFcn *vf;$/;"	m	class:Extrapolation
vf	FluxFcnBase.h	/^  VarFcnBase *vf;$/;"	m	class:FluxFcnBase
vf	OneDimensionalSolver.C	/^  VarFcn* vf;$/;"	m	class:EulerSource	file:
vf	OneDimensionalSolver.C	/^  VarFcn* vf;$/;"	m	class:LevelSetSource	file:
vf_	FluxFcn.h	/^  VarFcn *vf_;$/;"	m	class:FluxFcn
vf_	ImplicitRiemann.C	/^  VarFcn* vf_;$/;"	m	struct:JwlInfo	file:
vf_	LocalRiemann.h	/^    VarFcn* vf_;$/;"	m	struct:LocalRiemannGfmpar::RiemannInvParams
vf_	LocalRiemann.h	/^  VarFcn *vf_;$/;"	m	class:LocalRiemann
vfar	EmbeddedTsDesc.h	/^  double vfar[dim]; \/\/farfield state$/;"	m	class:EmbeddedTsDesc
vfar	MultiPhysicsTsDesc.h	/^  double vfar[dim]; \/\/farfield state$/;"	m	class:MultiPhysicsTsDesc
viewEdgeLength	Edge.h	/^  double* viewEdgeLength() { return(edgeLength); }$/;"	f	class:EdgeSet
vin	MeshMotionHandler.h	/^  Vec3D vin;$/;"	m	class:RigidMeshMotionHandler
viscQuadRcn	HigherOrderFSI.h	/^	bool viscQuadRcn;$/;"	m	class:HigherOrderFSI
viscSecOrder	EmbeddedTsDesc.h	/^  bool linRecAtInterface, viscSecOrder;$/;"	m	class:EmbeddedTsDesc
viscSecOrder	MatVecProd.h	/^    bool linRecAtInterface, viscSecOrder;$/;"	m	struct:MatVecProd::_fsi
viscSecOrder	MatVecProd.h	/^    bool linRecAtInterface, viscSecOrder;$/;"	m	struct:MatVecProdMultiPhase::_fsi
viscSecOrder	MultiPhysicsTsDesc.h	/^  bool linRecAtInterface, viscSecOrder;$/;"	m	class:MultiPhysicsTsDesc
viscoFcn	NavierStokesTerm.h	/^  ViscoFcn *viscoFcn;$/;"	m	class:NavierStokesTerm
viscoFcn	ThermalCondFcn.h	/^  ViscoFcn *viscoFcn;$/;"	m	class:ConstantPrandtlThermalCondFcn
viscoFcn	WallFcn.h	/^  ViscoFcn *viscoFcn;$/;"	m	class:WallFcn
viscosityModel	IoData.h	/^  ViscosityModelData viscosityModel;$/;"	m	struct:EquationsData
viscosity_mu	RefVal.h	/^  double viscosity_mu;$/;"	m	class:RefVal
viscousCst	DistTimeState.h	/^  double viscousCst;$/;"	m	class:DistTimeState
viscousCst	IoData.h	/^  double viscousCst;$/;"	m	struct:TsData
viscous_switch	LocalRiemannDesc.h	/^  double viscous_switch;$/;"	m	class:LocalRiemannFluidStructure
viscousboundarycondition	IoData.h	/^  enum ViscousBoundaryCondition {WEAK = 0, STRONG = 1} viscousboundarycondition;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::ViscousBoundaryCondition
viscousinterfaceorder	IoData.h	/^  enum ViscousInterfaceOrder {FIRST = 0, SECOND = 1} viscousinterfaceorder;$/;"	m	struct:EmbeddedFramework	typeref:enum:EmbeddedFramework::ViscousInterfaceOrder
vkcst	IoData.h	/^  double vkcst;$/;"	m	struct:DESModelData
vkcst	IoData.h	/^  double vkcst;$/;"	m	struct:SAModelData
vkcst	WallFcn.h	/^  double vkcst;$/;"	m	class:WallFcn
vms	IoData.h	/^  VMSLESData vms;$/;"	m	struct:LESModelData
vms	PostOperator.h	/^  DistVMSLESTerm<dim> *vms;$/;"	m	class:PostOperator
vms	SpaceOperator.h	/^  DistVMSLESTerm<dim> *vms;$/;"	m	class:SpaceOperator
vms	Timer.h	/^		feJac, vms, dvms, h2Assembly, fluidPrecSetup, fluidKsp, meshMetrics,$/;"	e	enum:Timer::TimerIndex
vmst	DistVMSLESTerm.h	/^  VMSLESTerm        *vmst;$/;"	m	class:DistVMSLESTerm
volForce	SpaceOperator.h	/^  VolumicForceTerm *volForce;$/;"	m	class:SpaceOperator
volInfo	FemEquationTerm.h	/^  map<int, PorousMedia *> volInfo;$/;"	m	class:FemEquationTerm
volPat	Domain.h	/^  CommPattern<double> *volPat;$/;"	m	class:Domain
volRatio	DistDynamicVMSTerm.h	/^  DistSVec<double,1>   **volRatio;$/;"	m	class:DistDynamicVMSTerm
volRatio	DistVMSLESTerm.h	/^  DistSVec<double,1>   *volRatio;$/;"	m	class:DistVMSLESTerm
volStiff	IoData.h	/^  double volStiff;$/;"	m	struct:DefoMeshMotionData
volStiff	MeshMotionSolver.h	/^  double volStiff;$/;"	m	class:TetMeshMotionSolver
volforce	VolumicForceTerm.h	/^  double volforce[3];$/;"	m	class:VolumicForceTerm
volume	MacroCell.h	/^  double volume;$/;"	m	class:MacroCell
volumeMap	IoData.h	/^  ObjectMap<VolumeData> volumeMap;$/;"	m	struct:Volumes
volumeType	IoData.h	/^  enum VolumeType { CONSTANT_VOLUME = 0, REAL_VOLUME = 1} volumeType;$/;"	m	struct:OneDimensionalInfo	typeref:enum:OneDimensionalInfo::VolumeType
volumeType	OneDimensionalSolver.h	/^  OneDimensionalInfo::VolumeType volumeType;$/;"	m	class:OneDimensional
volume_id	Elem.h	/^  int volume_id;$/;"	m	class:Elem
volumes	IoData.h	/^  Volumes volumes;$/;"	m	class:IoData
vorticity	IoData.h	/^  const char *vorticity;$/;"	m	struct:TransientData
vpts	IoData.h	/^  VelocityPoints* vpts[num];$/;"	m	struct:RigidMeshMotionData
vpts1	IoData.h	/^  VelocityPoints vpts1;$/;"	m	struct:RigidMeshMotionData
vpts10	IoData.h	/^  VelocityPoints vpts10;$/;"	m	struct:RigidMeshMotionData
vpts2	IoData.h	/^  VelocityPoints vpts2;$/;"	m	struct:RigidMeshMotionData
vpts3	IoData.h	/^  VelocityPoints vpts3;$/;"	m	struct:RigidMeshMotionData
vpts4	IoData.h	/^  VelocityPoints vpts4;$/;"	m	struct:RigidMeshMotionData
vpts5	IoData.h	/^  VelocityPoints vpts5;$/;"	m	struct:RigidMeshMotionData
vpts6	IoData.h	/^  VelocityPoints vpts6;$/;"	m	struct:RigidMeshMotionData
vpts7	IoData.h	/^  VelocityPoints vpts7;$/;"	m	struct:RigidMeshMotionData
vpts8	IoData.h	/^  VelocityPoints vpts8;$/;"	m	struct:RigidMeshMotionData
vpts9	IoData.h	/^  VelocityPoints vpts9;$/;"	m	struct:RigidMeshMotionData
vref	DistBcData.h	/^  double vref;$/;"	m	class:DistBcData
vs	VectorSet.h	/^   VecSet<VecType> *vs;$/;"	m	class:SubVecSet
vscale	OneDimensionalSolver.h	/^  double vscale[PostFcn::SSIZE];$/;"	m	class:OneDimensional
vscale	TsOutput.h	/^  double vscale[PostFcn::SSIZE];$/;"	m	class:TsOutput
vx	IoData.h	/^  double vx;$/;"	m	struct:RigidMeshMotionData
vy	IoData.h	/^  double vy;$/;"	m	struct:RigidMeshMotionData
vz	IoData.h	/^  double vz;$/;"	m	struct:RigidMeshMotionData
w	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
w	IntersectorFRG/Geometry/KDTree.h	/^     double w[dim];$/;"	m	class:KDTree
w	IntersectorFRG/IntersectorFRG.C	/^  double x[3], w[3];$/;"	m	class:MyTriangle	file:
w	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
w	KspSolver.h	/^  VecType w, r;$/;"	m	class:GmresSolver
w	LevelSet.h	/^  DistVec<double> w;			\/\/ weights in epxlicit positive coefficient scheme (cf Barth and Sethian)$/;"	m	class:LevelSet
w	MeshMotionHandler.h	/^  double u, v, w;$/;"	m	class:PitchingMeshMotionHandler
w0	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
w_x	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
w_y	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
w_z	IoData.h	/^  double cen_x, cen_y, cen_z, w_x,w_y,w_z;$/;"	m	struct:PrismData
wait	Modal.C	/^void ModalSolver<dim>::wait(const int seconds )$/;"	f	class:ModalSolver
waitForAllReq	CommunicatorMPI.C	/^void Communicator::waitForAllReq()$/;"	f	class:Communicator
waitrec	Timer.h	/^		lsKsp,lsPrecSetup,lsJac, waitrec, timeStep, intersect, embedPhaseChange,$/;"	e	enum:Timer::TimerIndex
wale	IoData.h	/^  WaleLESData wale;$/;"	m	struct:LESModelData
wale	PostOperator.h	/^  WaleLESTerm *wale;  $/;"	m	class:PostOperator
wale	SpaceOperator.h	/^  WaleLESTerm *wale;$/;"	m	class:SpaceOperator
wall	IoData.h	/^  BcsWallData wall;$/;"	m	struct:BcsData
wallFcn	BcFcn.h	/^  bool wallFcn;$/;"	m	class:BcFcnKE
wallFcn	BcFcn.h	/^  bool wallFcn;$/;"	m	class:BcFcnSA
wallFcn	DynamicLESTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:DynamicLESTerm
wallFcn	DynamicVMSTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:DynamicVMSTerm
wallFcn	FemEquationTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:FemEquationTerm
wallFcn	PostFcn.h	/^  WallFcn* wallFcn;$/;"	m	class:PostFcnNS
wallFcn	SmagorinskyLESTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:SmagorinskyLESTerm
wallFcn	VMSLESTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:VMSLESTerm
wallFcn	WaleLESTerm.h	/^  WallFcn* wallFcn;$/;"	m	class:WaleLESTerm
wallMask	GappyPreprocessing.h	/^  DistVec<double>* wallMask;$/;"	m	class:GappyPreprocessing
wallNeighborsMask	GappyPreprocessing.h	/^  DistVec<double>* wallNeighborsMask;$/;"	m	class:GappyPreprocessing
wallNodes	SubDomain.h	/^  std::vector<int> wallNodes;$/;"	m	class:SubDomain
wallRecType	TsDesc.h	/^  BcsWallData::Reconstruction wallRecType;$/;"	m	class:TsDesc
wallType	TsDesc.h	/^  BcsWallData::Integration wallType;$/;"	m	class:TsDesc
wall_computer	EmbeddedTsDesc.h	/^  ReinitializeDistanceToWall<1> *wall_computer;$/;"	m	class:EmbeddedTsDesc
walldistance	Timer.h	/^		eulerFSI, embedforce, walldistance, lsreinitialization, readSnapshotFile,$/;"	e	enum:Timer::TimerIndex
wallsurfacedisplac	IoData.h	/^  const char *wallsurfacedisplac; \/\/YC$/;"	m	struct:InputData
wallsurfacedisplac	TsInput.h	/^  char *wallsurfacedisplac;$/;"	m	struct:TsInput
weight	Connectivity.h	/^  float *weight;      \/\/ weights of pointer (or NULL)$/;"	m	class:Connectivity
weight	DistExactRiemannSolver.h	/^  DistVec<double> *weight;             \/\/node based$/;"	m	class:DistExactRiemannSolver
weight	ExactRiemannSolver.h	/^  Vec<double>       &weight;$/;"	m	class:ExactRiemannSolver
weight	OneDimensionalSolver.h	/^  Vec<double> weight;$/;"	m	class:OneDimensional
weight	Quadrature.h	/^    double *weight;  \/\/ weight for each quadrature point$/;"	m	class:Quadrature
weightDerivativePat	Domain.h	/^  CommPattern<double> *weightDerivativePat;$/;"	m	class:Domain
weightPat	Domain.h	/^  CommPattern<double> *weightPat;$/;"	m	class:Domain
weightPhaseChangePat	Domain.h	/^  CommPattern<double> *weightPhaseChangePat;$/;"	m	class:Domain
weights	VarFcn.h	/^  double weights[7];$/;"	m	class:VarFcn
whereis	MacroCellCore.C	/^int MacroCell::whereis(int nodeNum)$/;"	f	class:MacroCell
which	arpack++/include/arrseig.h	/^  char*   which;      \/\/ Specify which of the Ritz values of OP to compute.$/;"	m	class:ARrcStdEig
whoami	MacroCell.h	/^  int whoami() { return IDtag; }$/;"	f	class:MacroCell
width	IntersectorFRG/IntersectorFRG.C	/^  double width(int i) const { return w[i]; }$/;"	f	class:MyTriangle
wii	DistNodalGrad.h	/^  DistSVec<double,3> *wii;$/;"	m	class:DistNodalGrad
wii	NodalGrad.h	/^  SVec<double,3> *wii;$/;"	m	class:NodalGrad
wij	DistNodalGrad.h	/^  DistSVec<double,3> *wij;$/;"	m	class:DistNodalGrad
wij	NodalGrad.h	/^  SVec<double,3> *wij;$/;"	m	class:NodalGrad
willNotSolve	EmbeddedTsDesc.h	/^  virtual bool willNotSolve(double dts, double t) {return (t+dts*2)<tmax;}$/;"	f	class:EmbeddedTsDesc
willNotSolve	MultiPhysicsTsDesc.h	/^  virtual bool willNotSolve(double dts, double t) {return (t+dts*2)<tmax;}$/;"	f	class:MultiPhysicsTsDesc
willNotSolve	TsDesc.h	/^  virtual bool willNotSolve(double dts, double t) {return false;}$/;"	f	class:TsDesc
win	Communicator.h	/^    MPI_Win win;$/;"	m	class:Communication::Window
winDisp	FSI/DynamicNodalTransfer.h	/^        Communication::Window<double> *winDisp;$/;"	m	class:DynamicNodalTransfer
winForce	FSI/DynamicNodalTransfer.h	/^        Communication::Window<double> *winForce;$/;"	m	class:DynamicNodalTransfer
wintime	FSI/DynamicNodalTransfer.h	/^        Communication::Window<double> *wintime;$/;"	m	class:DynamicNodalTransfer
withCracking	EmbeddedTsDesc.h	/^  bool withCracking;$/;"	m	class:EmbeddedTsDesc
withCracking	IntersectorFRG/IntersectorFRG.h	/^    bool withCracking() const                                    {return false;}$/;"	f	class:IntersectorFRG
withCracking	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    bool withCracking() const {return distIntersector.cracking ? true : false;}$/;"	f	class:IntersectorPhysBAM
withCracking	LevelSet/MultiGridLevelSetStructure.h	/^    bool withCracking() const { return false; }$/;"	f	class:MultiGridLevelSetStructure
withCracking	MultiPhysicsTsDesc.h	/^  bool withCracking;$/;"	m	class:MultiPhysicsTsDesc
withMixedLS	MultiPhysicsTsDesc.h	/^  bool withMixedLS;$/;"	m	class:MultiPhysicsTsDesc
withViscousTerms	IntersectorFRG/IntersectorFRG.h	/^	 bool withViscousTerms;$/;"	m	class:DistIntersectorFRG
withViscousTerms	IntersectorPhysBAM/IntersectorPhysBAM.h	/^	 bool withViscousTerms;$/;"	m	class:DistIntersectorPhysBAM
withWallFcn	FemEquationTerm.h	/^  virtual bool withWallFcn() {return false; };$/;"	f	class:FemEquationTerm
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermDES
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermDESmean
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermDESturb
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermKE
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermKEmean
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermKEturb
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermNS
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermSA
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermSAmean
withWallFcn	FemEquationTermDesc.h	/^  bool withWallFcn() $/;"	f	class:FemEquationTermSAturb
with_sensitivity	LevelSet/LevelSetStructure.h	/^    bool with_sensitivity;$/;"	m	class:DistLevelSetStructure
wji	DistNodalGrad.h	/^  DistSVec<double,3> *wji;$/;"	m	class:DistNodalGrad
wji	NodalGrad.h	/^  SVec<double,3> *wji;$/;"	m	class:NodalGrad
word	parser/Dictionary.h	/^   string &word(int tk) { return tkm[tk]; }$/;"	f	class:Dictionary
workd	arpack++/include/arrseig.h	/^  ARTYPE  *workd;     \/\/ Original ARPACK internal vector.$/;"	m	class:ARrcStdEig
workl	arpack++/include/arrseig.h	/^  ARTYPE  *workl;     \/\/ Original ARPACK internal vector.$/;"	m	class:ARrcStdEig
workv	arpack++/include/arrseig.h	/^  ARTYPE  *workv;     \/\/ Original ARPACK internal vector.$/;"	m	class:ARrcStdEig
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	/^inline VECTOR<T,d> wrap(const VECTOR<T,d>& value,const VECTOR<T,d>& lower,const VECTOR<T,d>& upper)$/;"	f	namespace:PhysBAM
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	/^inline double wrap(const double value,const double lower,const double upper)$/;"	f	namespace:PhysBAM
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	/^inline float wrap(const float value,const float lower,const float upper)$/;"	f	namespace:PhysBAM
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Math_Tools/wrap.h	/^inline int wrap(const int i,const int n)$/;"	f	namespace:PhysBAM
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^wrap(const VECTOR<T,2>& v,const VECTOR<T,2>& vmin,const VECTOR<T,2>& vmax)$/;"	f	namespace:PhysBAM
wrap	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^wrap(const VECTOR<T,3>& v,const VECTOR<T,3>& vmin,const VECTOR<T,3>& vmax)$/;"	f	namespace:PhysBAM
write	BinFileHandler.h	/^void BinFileHandler::write(Scalar *p, int nobjs)$/;"	f	class:BinFileHandler
write	ConnectivityCore.C	/^Connectivity::write(BinFileHandler &file)$/;"	f	class:Connectivity
writeAvgVectorsToDisk	TsOutput.C	/^void TsOutput<dim>::writeAvgVectorsToDisk(bool lastIt, int it, double t, DistSVec<double,3> &X,$/;"	f	class:TsOutput
writeBinaryDerivativeOfVectorsToDisk	TsOutput.C	/^void TsOutput<dim>::writeBinaryDerivativeOfVectorsToDisk(int it, int actvar, double dS[3], $/;"	f	class:TsOutput
writeBinaryVectorsToDisk	TsOutput.C	/^void TsOutput<dim>::writeBinaryVectorsToDisk(bool lastIt, int it, double t, DistSVec<double,3> &X, $/;"	f	class:TsOutput
writeBinaryVectorsToDisk	TsOutput.C	/^void TsOutput<dim>::writeBinaryVectorsToDisk(bool lastIt, int it, double t, DistSVec<double,3> &X,$/;"	f	class:TsOutput
writeBinaryVectorsToDiskRom	EmbeddedTsDesc.C	/^void EmbeddedTsDesc<dim>::writeBinaryVectorsToDiskRom(bool lastNewtonIt, int timeStep, int newtonIter,$/;"	f	class:EmbeddedTsDesc
writeBinaryVectorsToDiskRom	ImplicitEmbeddedRomTsDesc.h	/^    void writeBinaryVectorsToDiskRom(bool, int, DistSVec<double, dim> &, DistSVec<double, dim> &) {};$/;"	f	class:ImplicitEmbeddedRomTsDesc
writeBinaryVectorsToDiskRom	ImplicitTsDesc.C	/^void ImplicitTsDesc<dim>::writeBinaryVectorsToDiskRom(bool lastNewtonIt, int timeStep, int newtonIt, $/;"	f	class:ImplicitTsDesc
writeBinaryVectorsToDiskRom	MeshMotionSolver.h	/^  void writeBinaryVectorsToDiskRom(bool, int, int, DistSVec<double,3> *, DistSVec<double,3> *) {}$/;"	f	class:TetMeshMotionSolver
writeBinaryVectorsToDiskRom	TsDesc.h	/^  virtual void writeBinaryVectorsToDiskRom(bool, int, int, DistSVec<double,dim> *, DistSVec<double,dim> *) {}  \/\/ state, residual$/;"	f	class:TsDesc
writeBinaryVectorsToDiskRom	TsOutput.C	/^int TsOutput<dim>::writeBinaryVectorsToDiskRom(bool lastNewtonIt, int timeStep, int newtonIt, $/;"	f	class:TsOutput
writeCPUTimingToDisk	TsOutput.C	/^void TsOutput<dim>::writeCPUTimingToDisk(bool lastIt, int it, double t, Timer *timer)$/;"	f	class:TsOutput
writeClusteredBinaryVectors	NonlinearRom.C	/^void NonlinearRom<dim>::writeClusteredBinaryVectors(int iCluster, DistSVec<double,dim> *U1, DistSVec<double,dim> *U2, $/;"	f	class:NonlinearRom
writeConservationErrors	TsOutput.C	/^void TsOutput<dim>::writeConservationErrors(IoData &iod, int it, double t,$/;"	f	class:TsOutput
writeCrackingData	FSI/CrackingSurface.cpp	/^void CrackingSurface::writeCrackingData(std::ofstream& restart_file) const {$/;"	f	class:CrackingSurface
writeCrackingData	FSI/CrackingSurface.cpp	/^writeCrackingData(std::ofstream& restart_file) const {$/;"	f	class:PhantomElement
writeCrackingData	FSI/DynamicNodalTransfer.cpp	/^void DynamicNodalTransfer::writeCrackingData(std::ofstream& restart_file) const {$/;"	f	class:DynamicNodalTransfer
writeCrackingData	FSI/DynamicNodalTransfer.cpp	/^void EmbeddedStructure::writeCrackingData(std::ofstream& restart_file) const {$/;"	f	class:EmbeddedStructure
writeCrackingDataToDisk	TsRestartCore.C	/^void TsRestart::writeCrackingDataToDisk(int cpuNum, bool lastIt, int it, double t,$/;"	f	class:TsRestart
writeDerivativeOfFluxNormToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfFluxNormToDisk(int it, int actvar, double normF, double dnormF)$/;"	f	class:TsOutput
writeDerivativeOfForcesToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfForcesToDisk(int it, int actvar, Vec3D & F, Vec3D & dF, Vec3D & M, Vec3D & dM, double &sboom, double &dSboom)$/;"	f	class:TsOutput
writeDerivativeOfLiftDragToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfLiftDragToDisk(int it, int actvar, Vec3D & L, Vec3D & dL)$/;"	f	class:TsOutput
writeDerivativeOfLiftxToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfLiftxToDisk(double& dLx)$/;"	f	class:TsOutput
writeDerivativeOfLiftyToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfLiftyToDisk(double& dLy)$/;"	f	class:TsOutput
writeDerivativeOfLiftzToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfLiftzToDisk(double& dLz)$/;"	f	class:TsOutput
writeDerivativeOfMatchPressureToDisk	TsOutput.C	/^void TsOutput<dim>::writeDerivativeOfMatchPressureToDisk(int it, int actvar, DistSVec<double,1> &dPds, DistSVec<double,3> &X, DistSVec<double,dim> &U, DistVec<double> &A, DistTimeState<dim> *timeState)$/;"	f	class:TsOutput
writeDisplacementVectorToDisk	TsOutput.C	/^void TsOutput<dim>::writeDisplacementVectorToDisk(int step, double tag, $/;"	f	class:TsOutput
writeEmbeddedSurfaceToDisk	TsOutput.C	/^void TsOutput<dim>::writeEmbeddedSurfaceToDisk(bool lastIt, int it, double t, Vec<Vec3D>& solidX, Vec<Vec3D>& solidX0)$/;"	f	class:TsOutput
writeErrorToDisk	TsDesc.h	/^  virtual void writeErrorToDisk(int it, double cpu) {};$/;"	f	class:TsDesc
writeFFPValues	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::writeFFPValues$/;"	f	class:KirchhoffIntegrator
writeFluxNormToDisk	TsOutput.C	/^void TsOutput<dim>::writeFluxNormToDisk(int it, int itSc, int itNl, double t, double normFlux)$/;"	f	class:TsOutput
writeForcesToDisk	TsOutput.C	/^void TsOutput<dim>::writeForcesToDisk(DistExactRiemannSolver<dim> &riemann,$/;"	f	class:TsOutput
writeForcesToDisk	TsOutput.C	/^void TsOutput<dim>::writeForcesToDisk(bool lastIt, int it, int itSc, int itNl, double t, double cpu, $/;"	f	class:TsOutput
writeHeatFluxesToDisk	TsOutput.C	/^  void TsOutput<dim>::writeHeatFluxesToDisk(bool lastIt, int it, int itSc, int itNl, double t, double cpu,$/;"	f	class:TsOutput
writeHydroForcesToDisk	TsOutput.C	/^void TsOutput<dim>::writeHydroForcesToDisk(bool lastIt, int it, int itSc, int itNl, double t, double cpu, $/;"	f	class:TsOutput
writeHydroLiftsToDisk	TsOutput.C	/^void TsOutput<dim>::writeHydroLiftsToDisk(IoData &iod, bool lastIt, int it, int itSc, int itNl, double t, double cpu,$/;"	f	class:TsOutput
writeKPtraces	TsRestart.h	/^  bool writeKPtraces;$/;"	m	class:TsRestart
writeKPtracesToDisk	TsRestart.C	/^void TsRestart::writeKPtracesToDisk$/;"	f	class:TsRestart
writeKrylovVectors	KspBinaryOutput.C	/^void KspBinaryOutput<VecType>::writeKrylovVectors(VecSet<DistEmbeddedVec<Scalar, dim> >& kspVecs, Vec<Scalar> kspCoords, int numVecs) {$/;"	f	class:KspBinaryOutput
writeKrylovVectors	KspBinaryOutput.C	/^void KspBinaryOutput<VecType>::writeKrylovVectors(VecSet<DistSVec<bcomp, dim> >& kspVecs, Vec<bcomp> kspCoords, int numVecs) {$/;"	f	class:KspBinaryOutput
writeKrylovVectors	KspBinaryOutput.C	/^void KspBinaryOutput<VecType>::writeKrylovVectors(VecSet<DistSVec<double, dim> >& kspVecs, Vec<double> kspCoords, int numVecs) {$/;"	f	class:KspBinaryOutput
writeLiftsToDisk	TsOutput.C	/^void TsOutput<dim>::writeLiftsToDisk(IoData &iod, bool lastIt, int it, int itSc, int itNl, double t, double cpu, $/;"	f	class:TsOutput
writeLinePlotsToDisk	TsOutput.C	/^void TsOutput<dim>::writeLinePlotsToDisk(bool lastIt, int it, double t, DistSVec<double,3> &X,$/;"	f	class:TsOutput
writeMatchPressureToDisk	TsOutput.C	/^void TsOutput<dim>::writeMatchPressureToDisk(IoData &iod, bool lastIt, int it, int itSc, int itNl, double t, double cpu,$/;"	f	class:TsOutput
writeMatchStateToDisk	TsOutput.C	/^void TsOutput<dim>::writeMatchStateToDisk(IoData &iod,  int it, double t, double cpu, DistSVec<double,dim> &U, DistVec<double> &A)$/;"	f	class:TsOutput
writeMaterialMassEnergyToDisk	TsOutput.C	/^void TsOutput<dim>::writeMaterialMassEnergyToDisk(int it, double t,DistSVec<double,dim> & U,  DistVec<double> &A, DistVec<int> *fluidId)$/;"	f	class:TsOutput
writeMaterialVolumesToDisk	TsOutput.C	/^void TsOutput<dim>::writeMaterialVolumesToDisk(int it, double t, DistVec<double> &A, DistVec<int> *fluidId)$/;"	f	class:TsOutput
writeMultiVecASCII	NonlinearRom.C	/^void NonlinearRom<dim>::writeMultiVecASCII(char* path, std::vector<double>* vec1,$/;"	f	class:NonlinearRom
writePVTUAgglomerationFile	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::writePVTUAgglomerationFile(const char* filename) {$/;"	f	class:MultiGridLevel
writePVTUFile	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::writePVTUFile(const char* filename) {$/;"	f	class:MultiGridLevel
writePVTUSolutionFile	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::writePVTUSolutionFile(const char* filename,$/;"	f	class:MultiGridLevel
writePValues	KirchhoffIntegrator.C	/^void KirchhoffIntegrator::writePValues$/;"	f	class:KirchhoffIntegrator
writePositionSensitivityVectorToDisk	TsOutput.C	/^void TsOutput<dim>::writePositionSensitivityVectorToDisk(int step, double tag, $/;"	f	class:TsOutput
writeProbesToDisk	TsOutput.C	/^void TsOutput<dim>::writeProbesToDisk(bool lastIt, int it, double t, DistSVec<double,3> &X,$/;"	f	class:TsOutput
writeProjErrorSweepToDisk	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::writeProjErrorSweepToDisk(std::vector<std::vector<int> > robSizes,$/;"	f	class:NonlinearRomDatabaseConstruction
writeProjErrorToDisk	NonlinearRomDatabaseConstruction.C	/^void NonlinearRomDatabaseConstruction<dim>::writeProjErrorToDisk()  {$/;"	f	class:NonlinearRomDatabaseConstruction
writeReducedCoords	NonlinearRom.C	/^void NonlinearRom<dim>::writeReducedCoords(const int totalTimeSteps, bool clusterSwitch, bool update, int iCluster, Vec<double> dUromTimeIt) {$/;"	f	class:NonlinearRom
writeResidualsToDisk	TsOutput.C	/^void TsOutput<dim>::writeResidualsToDisk(int it, double cpu, double res, double cfl)$/;"	f	class:TsOutput
writeRestartFileNames	TsRestartCore.C	/^void TsRestart::writeRestartFileNames(const char* fn) {$/;"	f	class:TsRestart
writeStateMaskVectorsToDiskRom	TsOutput.C	/^void TsOutput<dim>::writeStateMaskVectorsToDiskRom(int timestep, DistSVec<double, dim> &state, DistSVec<char, dim> &mask){$/;"	f	class:TsOutput
writeStateRomToDisk	TsDesc.h	/^  virtual void writeStateRomToDisk(int it, double cpu) {};$/;"	f	class:TsDesc
writeStructPosToDisk	TsRestartCore.C	/^void TsRestart::writeStructPosToDisk(int cpuNum, bool lastIt, Vec<Vec3D>& Xs)$/;"	f	class:TsRestart
writeTagToFile	SubDomain.C	/^void SubDomain::writeTagToFile(const char *prefix, int no, double tag)$/;"	f	class:SubDomain
writeToDisk	DistGeoState.C	/^void DistGeoState::writeToDisk(char *name)  {$/;"	f	class:DistGeoState
writeToDisk	DistTimeState.C	/^void DistTimeState<dim>::writeToDisk(char *name)$/;"	f	class:DistTimeState
writeToDisk	FluidSelectorCore.C	/^void FluidSelector::writeToDisk(const char* name) {$/;"	f	class:FluidSelector
writeToDisk	LevelSet.C	/^void LevelSet<dimLS>::writeToDisk(char *name)$/;"	f	class:LevelSet
writeToDisk	TsRestart.C	/^void TsRestart::writeToDisk(int cpuNum, bool lastIt, int it, double t, double dt,$/;"	f	class:TsRestart
writeVectorToFile	Domain.C	/^void Domain::writeVectorToFile(const char *prefix, int step, double tag,$/;"	f	class:Domain
writeVectorToFile	SubDomain.C	/^void SubDomain::writeVectorToFile(const char *prefix, int no,$/;"	f	class:SubDomain
writeXpostFile	MultiGridLevel.C	/^void MultiGridLevel<Scalar>::writeXpostFile(const std::string& fileName,$/;"	f	class:MultiGridLevel
wtmach	IoData.h	/^  const char *wtmach;$/;"	m	struct:TransientData
wtspeed	IoData.h	/^  const char *wtspeed;$/;"	m	struct:TransientData
x	DistEmbeddedVector.h	/^  const T &x;$/;"	m	class:EmbeddedExpr
x	DistEmbeddedVector.h	/^  const T &x;$/;"	m	class:EmbeddedScaleExpr
x	DistEmbeddedVector.h	/^  const T1 &x;$/;"	m	class:EmbeddedDiffExpr
x	DistEmbeddedVector.h	/^  const T1 &x;$/;"	m	class:EmbeddedSumExpr
x	IntersectorFRG/IntersectorFRG.C	/^  Vec3D x;$/;"	m	class:ClosestTriangle	file:
x	IntersectorFRG/IntersectorFRG.C	/^  double x[3], w[3];$/;"	m	class:MyTriangle	file:
x	IoData.h	/^  double x,y,z;$/;"	m	struct:PointData
x	KDTree.h	/^    double x[3];$/;"	m	struct:KDTree::ScalarGlob
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    T1 x;T2 y;$/;"	m	class:PhysBAM::PAIR
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    T1 x;T2 y;T3 z;$/;"	m	class:PhysBAM::TRIPLE
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    T *x; \/\/ pointer to the one dimensional data$/;"	m	class:PhysBAM::MATRIX_MXN
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_1D.h	/^    T x;$/;"	m	class:PhysBAM::VECTOR
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T x,y;$/;"	m	class:PhysBAM::VECTOR
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T x,y,z;$/;"	m	class:PhysBAM::VECTOR
x	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    T* x; \/\/ pointer to the n vector$/;"	m	class:PhysBAM::VECTOR_ND
x	Vector.h	/^  T x;$/;"	m	class:Expr
x0	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
x0	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
x0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
x0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:RotationData
x0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:TransientData
x0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:LinePlot
x0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:OneDimensionalInputData
x0	IoData.h	/^  double x0;$/;"	m	struct:BFixData
x0	IoData.h	/^  double x0;$/;"	m	struct:CFixData
x0	IoData.h	/^  double x0;$/;"	m	struct:SFixData
x0	IoData.h	/^  double x0;$/;"	m	struct:SpiralingData
x0	IoData.h	/^  double x0;$/;"	m	struct:TBFixData
x0	KspSolver.h	/^  VecType w, r, R, AR, temp, w0, x0;$/;"	m	class:GcrSolver
x0	ProgrammedBurn.h	/^    double x0[3];$/;"	m	struct:ProgrammedBurn::Burn
x0	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
x0	TsOutput.h	/^    double x0,y0,z0;$/;"	m	struct:TsOutput::line_output
x0	TsOutput.h	/^  Vec3D x0;$/;"	m	class:TsOutput
x0	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
x0	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
x0id	ProgrammedBurn.h	/^    int x0subdom, x0id;$/;"	m	struct:ProgrammedBurn::Burn
x0subdom	ProgrammedBurn.h	/^    int x0subdom, x0id;$/;"	m	struct:ProgrammedBurn::Burn
x1	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
x1	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
x1	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
x1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
x1	IoData.h	/^  double x1,y1,z1;$/;"	m	struct:LinePlot
x1	IoData.h	/^  double x1;$/;"	m	struct:BFixData
x1	IoData.h	/^  double x1;$/;"	m	struct:CFixData
x1	IoData.h	/^  double x1;$/;"	m	struct:TBFixData
x1	MeshMotionHandler.h	/^  double x1[3];$/;"	m	class:PitchingMeshMotionHandler
x1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/LINE_2D.h	/^    TV x1; \/\/ point on the line$/;"	m	class:PhysBAM::LINE_2D
x1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/PLANE.h	/^    TV x1; \/\/ point on the plane$/;"	m	class:PhysBAM::PLANE
x1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/POINT_SIMPLEX_1D.h	/^    VECTOR<T,1> x1;$/;"	m	class:PhysBAM::POINT_SIMPLEX_1D
x1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV x1,x2;$/;"	m	class:PhysBAM::SEGMENT_2D
x1	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    VECTOR<T,3> x1,x2;$/;"	m	class:PhysBAM::SEGMENT_3D
x1	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
x1	TsOutput.h	/^    double x1,y1,z1;$/;"	m	struct:TsOutput::line_output
x1	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
x1	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
x11	IoData.h	/^  double x11;$/;"	m	struct:PitchingData
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T x11,x22;$/;"	m	class:PhysBAM::DIAGONAL_MATRIX
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T x11,x22,x33;$/;"	m	class:PhysBAM::DIAGONAL_MATRIX
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T x11,x21,x22;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T x11,x12,x22;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x11	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x12	IoData.h	/^  double x12;$/;"	m	struct:PitchingData
x12	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T x11,x12,x22;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x12	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x13	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x2	FSI/DynamicNodalTransfer.h	/^  double alpha_in, alpha_max, x1[3], x2[3], u, v, w, ix, iy, iz;$/;"	m	class:EmbeddedStructure
x2	MeshMotionHandler.h	/^  double x2[3];$/;"	m	class:PitchingMeshMotionHandler
x2	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_2D.h	/^    TV x1,x2;$/;"	m	class:PhysBAM::SEGMENT_2D
x2	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Basic_Geometry/SEGMENT_3D.h	/^    VECTOR<T,3> x1,x2;$/;"	m	class:PhysBAM::SEGMENT_3D
x21	IoData.h	/^  double x21;$/;"	m	struct:PitchingData
x21	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T x11,x21,x22;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x21	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x22	IoData.h	/^  double x22;$/;"	m	struct:PitchingData
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_2X2.h	/^    T x11,x22;$/;"	m	class:PhysBAM::DIAGONAL_MATRIX
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T x11,x22,x33;$/;"	m	class:PhysBAM::DIAGONAL_MATRIX
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_2X2.h	/^    T x11,x21,x22;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_2X2.h	/^    T x11,x12,x22;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x22	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x23	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
x31	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x32	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x33	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/DIAGONAL_MATRIX_3X3.h	/^    T x11,x22,x33;$/;"	m	class:PhysBAM::DIAGONAL_MATRIX
x33	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/SYMMETRIC_MATRIX_3X3.h	/^    T x11,x21,x31,x22,x32,x33;$/;"	m	class:PhysBAM::SYMMETRIC_MATRIX
x33	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/UPPER_TRIANGULAR_MATRIX_3X3.h	/^    T x11,x12,x22,x13,x23,x33;$/;"	m	class:PhysBAM::UPPER_TRIANGULAR_MATRIX
xL	IoData.h	/^  double xL;$/;"	m	struct:SpiralingData
xMax	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
xMin	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
xWallNode	IntersectorFRG/IntersectorFRG.C	/^bool IntersectorFRG::xWallNode(int i, Vec3D &xWall)$/;"	f	class:IntersectorFRG
xWallNode	IntersectorPhysBAM/IntersectorPhysBAM.C	/^bool IntersectorPhysBAM::xWallNode(int i, Vec3D &xWall)$/;"	f	class:IntersectorPhysBAM
xWallNode	LevelSet/MultiGridLevelSetStructure.h	/^	 bool xWallNode(int i, Vec3D &xWall) {exit(-1);}$/;"	f	class:MultiGridLevelSetStructure
xWallWithSI	IntersectorFRG/IntersectorFRG.C	/^void IntersectorFRG::xWallWithSI(int n, Vec3D &xWall)$/;"	f	class:IntersectorFRG
xWallWithSI	IntersectorPhysBAM/IntersectorPhysBAM.C	/^void IntersectorPhysBAM::xWallWithSI(int n, Vec3D &xWall)$/;"	f	class:IntersectorPhysBAM
xWallWithSI	LevelSet/MultiGridLevelSetStructure.h	/^	 void xWallWithSI(int n, Vec3D &xWall) {exit(-1);}$/;"	f	class:MultiGridLevelSetStructure
x_1D	OneDimensionalSolver.h	/^    double* x_1D,*v_1D;$/;"	m	class:OneDimensional::Veval
x_not	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    T1 x_not,direction_x;$/;"	m	class:PhysBAM::PARAMETRIC_LINE
xbeg	FSI/DynamicNodalTransfer.h	/^  double cableLen, xbeg;$/;"	m	class:EmbeddedStructure
xcomp	Connectivity.h	/^  int *xcomp;  \/\/ pointer to renum for the beginning of each component $/;"	m	struct:compStruct
xi	LevelSet/LevelSetStructure.h	/^  double xi[3];$/;"	m	struct:LevelSetResult
xi	MatchNode.h	/^  double (*xi)[3];$/;"	m	class:MatchNodeSet
xi1	LevelSet/LevelSetStructure.h	/^  double xi1,xi2; \/\/ local coordinates.$/;"	m	struct:ClosestPoint
xi2	LevelSet/LevelSetStructure.h	/^  double xi1,xi2; \/\/ local coordinates.$/;"	m	struct:ClosestPoint
xi_SI	LevelSet/LevelSetStructure.h	/^	 DistVec<double> *xi_SI;$/;"	m	class:DistLevelSetStructure
xi_SI	LevelSet/LevelSetStructure.h	/^	 Vec<double>   &xi_SI; \/\/ baricentric cooardinates of the the $/;"	m	class:LevelSetStructure
xi_node	LevelSet/LevelSetStructure.h	/^	 DistVec<double> *xi_node;$/;"	m	class:DistLevelSetStructure
xi_node	LevelSet/LevelSetStructure.h	/^	 Vec<double>   &xi_node; \/\/ baricentric cooardinates of the the $/;"	m	class:LevelSetStructure
xi_p	RecFcnDesc.h	/^  double xi_p, xi_rho;$/;"	m	class:RecFcnExtendedVanAlbada
xi_rho	RecFcnDesc.h	/^  double xi_p, xi_rho;$/;"	m	class:RecFcnExtendedVanAlbada
xic	EdgeGrad.h	/^  double xic;$/;"	m	class:EdgeGrad
xic	IoData.h	/^  double xic;$/;"	m	struct:SchemeData
xip	IoData.h	/^  double xip;$/;"	m	struct:SchemeData
xip	LevelSet/LevelSetStructure.h	/^	   double *xip;$/;"	m	class:LevelSetResult::iterator
xirho	IoData.h	/^  double xirho;$/;"	m	struct:SchemeData
xiu	EdgeGrad.h	/^  double xiu;$/;"	m	class:EdgeGrad
xiu	IoData.h	/^  double xiu;$/;"	m	struct:SchemeData
xlsub	arpack++/include/arlspdef.h	/^    int	    *xlsub;$/;"	m	struct:__anon35
xlsub	arpack++/include/arlspdef.h	/^    int	    *xlsub;$/;"	m	struct:__anon36
xlsub	arpack++/include/arlspdef.h	/^    int	    *xlsub;$/;"	m	struct:__anon37
xlsub	arpack++/include/arlspdef.h	/^    int	    *xlsub;$/;"	m	struct:__anon38
xlusup	arpack++/include/arlspdef.h	/^    int     *xlusup;$/;"	m	struct:__anon35
xlusup	arpack++/include/arlspdef.h	/^    int     *xlusup;$/;"	m	struct:__anon36
xlusup	arpack++/include/arlspdef.h	/^    int     *xlusup;$/;"	m	struct:__anon37
xlusup	arpack++/include/arlspdef.h	/^    int     *xlusup;$/;"	m	struct:__anon38
xmach	EmbeddedFluidShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:EmbeddedFluidShapeOptimizationHandler
xmach	FluidCollocationShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:FluidCollocationShapeOptimizationHandler
xmach	FluidGnatShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:FluidGnatShapeOptimizationHandler
xmach	FluidMetricShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:FluidMetricShapeOptimizationHandler
xmach	FluidRomShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:FluidRomShapeOptimizationHandler
xmach	FluidShapeOptimizationHandler.h	/^  double xmach;$/;"	m	class:FluidShapeOptimizationHandler
xml	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    bool xml;$/;"	m	class:PhysBAM::LOG_REAL::LOG_CLASS
xo	MeshMotionHandler.h	/^  Vec3D xo;$/;"	m	class:RigidRollMeshMotionHandler
xold	MultiGridPrec.h	/^  MultiGridDistSVec<Scalar2,dim> xold, myX, myPx, myR;  $/;"	m	class:MultiGridPrec
xpol	SpaceOperator.h	/^  DistExtrapolation<dim> *xpol;$/;"	m	class:SpaceOperator
xscale	TsOutput.h	/^  double xscale;$/;"	m	class:TsOutput
xsup	arpack++/include/arlspdef.h	/^    int     *xsup;    \/* supernode and column mapping *\/$/;"	m	struct:__anon35
xsup	arpack++/include/arlspdef.h	/^    int     *xsup;    \/* supernode and column mapping *\/$/;"	m	struct:__anon36
xsup	arpack++/include/arlspdef.h	/^    int     *xsup;    \/* supernode and column mapping *\/$/;"	m	struct:__anon37
xsup	arpack++/include/arlspdef.h	/^    int     *xsup;    \/* supernode and column mapping *\/$/;"	m	struct:__anon38
xusub	arpack++/include/arlspdef.h	/^    int	    *xusub;$/;"	m	struct:__anon35
xusub	arpack++/include/arlspdef.h	/^    int	    *xusub;$/;"	m	struct:__anon36
xusub	arpack++/include/arlspdef.h	/^    int	    *xusub;$/;"	m	struct:__anon37
xusub	arpack++/include/arlspdef.h	/^    int	    *xusub;$/;"	m	struct:__anon38
xyz	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    ARRAY<VECTOR<double,3> > xyz;$/;"	m	class:IntersectorPhysBAM
xyz	ReducedMeshShapeChanger.h	/^	double **xyz;	\/\/ xyz[iReducedNodes][iXYZ] is the iXYZ coordinte of the iReducedNodes node$/;"	m	class:ReducedMeshShapeChanger
xyz	TriangulatedInterface.h	/^  double* xyz;$/;"	m	class:TriangulatedInterface
xyz_n	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    ARRAY<VECTOR<double,3> > xyz_n;$/;"	m	class:IntersectorPhysBAM
xyzdot	TriangulatedInterface.h	/^  double* xyzdot;$/;"	m	class:TriangulatedInterface
y	DistEmbeddedVector.h	/^  const T2 &y;$/;"	m	class:EmbeddedDiffExpr
y	DistEmbeddedVector.h	/^  const T2 &y;$/;"	m	class:EmbeddedSumExpr
y	IoData.h	/^  double x,y,z;$/;"	m	struct:PointData
y	KspSolver.h	/^  ScalarT *y;                                                                                                                  $/;"	m	class:GcrSolver
y	KspSolver.h	/^  Vec<ScalarT> g, y;$/;"	m	class:GmresSolver
y	KspSolver.h	/^  VecType r, Ap, y, p;$/;"	m	class:CgSolver
y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    T1 x;T2 y;$/;"	m	class:PhysBAM::PAIR
y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    T1 x;T2 y;T3 z;$/;"	m	class:PhysBAM::TRIPLE
y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_2D.h	/^    T x,y;$/;"	m	class:PhysBAM::VECTOR
y	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T x,y,z;$/;"	m	class:PhysBAM::VECTOR
y	Vector.h	/^  Scalar y;$/;"	m	class:OuterProd
y0	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
y0	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
y0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
y0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:RotationData
y0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:TransientData
y0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:LinePlot
y0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:OneDimensionalInputData
y0	IoData.h	/^  double y0;$/;"	m	struct:BFixData
y0	IoData.h	/^  double y0;$/;"	m	struct:CFixData
y0	IoData.h	/^  double y0;$/;"	m	struct:SFixData
y0	IoData.h	/^  double y0;$/;"	m	struct:TBFixData
y0	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
y0	TsOutput.h	/^    double x0,y0,z0;$/;"	m	struct:TsOutput::line_output
y0	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
y0	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
y0prime	ExactSolution.C	/^double y0prime(double r) {$/;"	f
y1	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
y1	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
y1	FSI/DynamicNodalTransfer.h	/^  double beta_in, beta_max, y1[3], y2[3];$/;"	m	class:EmbeddedStructure
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
y1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
y1	IoData.h	/^  double x1,y1,z1;$/;"	m	struct:LinePlot
y1	IoData.h	/^  double y1;$/;"	m	struct:BFixData
y1	IoData.h	/^  double y1;$/;"	m	struct:CFixData
y1	IoData.h	/^  double y1;$/;"	m	struct:TBFixData
y1	MeshMotionHandler.h	/^  double y1[3];$/;"	m	class:PitchingMeshMotionHandler
y1	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
y1	TsOutput.h	/^    double x1,y1,z1;$/;"	m	struct:TsOutput::line_output
y1	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
y1	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
y11	IoData.h	/^  double y11;$/;"	m	struct:PitchingData
y12	IoData.h	/^  double y12;$/;"	m	struct:PitchingData
y2	FSI/DynamicNodalTransfer.h	/^  double beta_in, beta_max, y1[3], y2[3];$/;"	m	class:EmbeddedStructure
y2	MeshMotionHandler.h	/^  double y2[3];$/;"	m	class:PitchingMeshMotionHandler
y21	IoData.h	/^  double y21;$/;"	m	struct:PitchingData
y22	IoData.h	/^  double y22;$/;"	m	struct:PitchingData
yMax	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
yMin	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
y_not	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    T2 y_not,direction_y;$/;"	m	class:PhysBAM::PARAMETRIC_LINE
yield	ResizeArray.h	/^ResizeArray<Type>::yield()$/;"	f	class:ResizeArray
ytemp	RKIntegrator.h	/^  T* ytemp;$/;"	m	class:RKIntegrator
z	IoData.h	/^  double x,y,z;$/;"	m	struct:PointData
z	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/TRIPLE.h	/^    T1 x;T2 y;T3 z;$/;"	m	class:PhysBAM::TRIPLE
z	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_3D.h	/^    T x,y,z;$/;"	m	class:PhysBAM::VECTOR
z0	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
z0	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
z0	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
z0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:RotationData
z0	IoData.h	/^  double x0, y0, z0;$/;"	m	struct:TransientData
z0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:LinePlot
z0	IoData.h	/^  double x0,y0,z0;$/;"	m	struct:OneDimensionalInputData
z0	IoData.h	/^  double z0;$/;"	m	struct:BFixData
z0	IoData.h	/^  double z0;$/;"	m	struct:CFixData
z0	IoData.h	/^  double z0;$/;"	m	struct:SFixData
z0	IoData.h	/^  double z0;$/;"	m	struct:TBFixData
z0	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
z0	TsOutput.h	/^    double x0,y0,z0;$/;"	m	struct:TsOutput::line_output
z0	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
z0	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
z1	DynamicLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicLESTerm
z1	DynamicVMSTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:DynamicVMSTerm
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDES
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESmean
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermDESturb
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKE
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEmean
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermKEturb
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSA
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAmean
z1	FemEquationTermDesc.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:FemEquationTermSAturb
z1	IoData.h	/^  double x1,y1,z1;$/;"	m	struct:LinePlot
z1	IoData.h	/^  double z1;$/;"	m	struct:BFixData
z1	IoData.h	/^  double z1;$/;"	m	struct:CFixData
z1	IoData.h	/^  double z1;$/;"	m	struct:TBFixData
z1	SmagorinskyLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:SmagorinskyLESTerm
z1	TsOutput.h	/^    double x1,y1,z1;$/;"	m	struct:TsOutput::line_output
z1	VMSLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:VMSLESTerm
z1	WaleLESTerm.h	/^  double x0,y0,z0,x1,y1,z1;$/;"	m	class:WaleLESTerm
z11	IoData.h	/^  double z11;$/;"	m	struct:PitchingData
z12	IoData.h	/^  double z12;$/;"	m	struct:PitchingData
z21	IoData.h	/^  double z21;$/;"	m	struct:PitchingData
z22	IoData.h	/^  double z22;$/;"	m	struct:PitchingData
zGlobalLU_t	arpack++/include/arlspdef.h	/^} zGlobalLU_t;$/;"	t	typeref:struct:__anon38
zMax	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
zMin	IntersectorPhysBAM/IntersectorPhysBAM.h	/^    double xMin, xMax, yMin, yMax, zMin, zMax; \/\/a bounding box over the struct body$/;"	m	class:DistIntersectorPhysBAM
z_add	arpack++/include/arlcomp.h	33;"	d
z_eq	arpack++/include/arlcomp.h	54;"	d
z_sub	arpack++/include/arlcomp.h	37;"	d
zaxpy_	arpack++/include/arlnames.h	122;"	d
zaxpy_	arpack++/include/arlnames.h	193;"	d
zcopy_	arpack++/include/arlnames.h	119;"	d
zcopy_	arpack++/include/arlnames.h	190;"	d
zd_mult	arpack++/include/arlcomp.h	41;"	d
zero	DenseMatrix.C	/^GenFullM<Scalar>::zero()$/;"	f	class:GenFullM
zero	DenseMatrix.C	/^void SymFullM<Scalar>::zero()$/;"	f	class:SymFullM
zero	MultiGridOperator.h	/^  DistSVec<Scalar,dim>* zero;$/;"	m	class:MultiGridOperator
zeroData	RectangularSparseMatrix.h	/^  void zeroData() { a = 0.0; }$/;"	f	class:RectangularSparseMat
zeroData	SparseMatrix.h	/^  void zeroData() { a = 0.0; }$/;"	f	class:SparseMat
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcn::zeroDiagonalTerm(int t, bcomp *a)$/;"	f	class:BcFcn
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcn::zeroDiagonalTerm(int t, double *a)$/;"	f	class:BcFcn
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcn::zeroDiagonalTerm(int t, float *a)$/;"	f	class:BcFcn
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::zeroDiagonalTerm(int type, bcomp *A)$/;"	f	class:BcFcnNS
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::zeroDiagonalTerm(int type, double *A)$/;"	f	class:BcFcnNS
zeroDiagonalTerm	BcFcnCore.C	/^void BcFcnNS::zeroDiagonalTerm(int type, float *A)$/;"	f	class:BcFcnNS
zeroFd	Malloc.C	/^int zeroFd;$/;"	v
zeroInternalVals	Domain.C	/^void Domain::zeroInternalVals(DistSVec<double, dim> &v)  {$/;"	f	class:Domain
zeroInternalVals	SubDomain.C	/^void SubDomain::zeroInternalVals(SVec<double, dim> &v)  {$/;"	f	class:SubDomain
zeroMeshMotionBCDofs	SubDomain.C	/^void SubDomain::zeroMeshMotionBCDofs(SVec<double,dim> &x, int* DofType)$/;"	f	class:SubDomain
zeroNonMaster	DistVector.h	/^DistVec<Scalar>::zeroNonMaster() $/;"	f	class:DistVec
zeta	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^  T zeta[3];  \/\/ Intersection is at zeta[0]*triNode1+zeta[1]*triNode2+zeta[2]*triNode3$/;"	m	struct:PhysBAM::IntersectionResult
zgemm_	arpack++/include/arlnames.h	125;"	d
zgemm_	arpack++/include/arlnames.h	196;"	d
zgemv_	arpack++/include/arlnames.h	123;"	d
zgemv_	arpack++/include/arlnames.h	194;"	d
zgerc_	arpack++/include/arlnames.h	127;"	d
zgerc_	arpack++/include/arlnames.h	198;"	d
zhemv_	arpack++/include/arlnames.h	128;"	d
zhemv_	arpack++/include/arlnames.h	199;"	d
zher2_	arpack++/include/arlnames.h	129;"	d
zher2_	arpack++/include/arlnames.h	200;"	d
zoom	ImplicitRomTsDesc.C	/^double ImplicitRomTsDesc<dim>::zoom(double alphaLo, double alphaHi, double meritLo, double meritHi, double meritDerivLo, double meritDerivZero, double meritZero, double c1Wolfe, double c2, DistSVec<double, dim> Q, DistSVec<double, dim> dQ, DistSVec<double, dim> R, int it){$/;"	f	class:ImplicitRomTsDesc
zroots	utils/Laguerre.C	/^int zroots(bcomp *a, int degree, bcomp *roots, const bool &polish)$/;"	f
zscal_	arpack++/include/arlnames.h	120;"	d
zscal_	arpack++/include/arlnames.h	191;"	d
ztrsm_	arpack++/include/arlnames.h	126;"	d
ztrsm_	arpack++/include/arlnames.h	197;"	d
ztrsv_	arpack++/include/arlnames.h	124;"	d
ztrsv_	arpack++/include/arlnames.h	195;"	d
zz_mult	arpack++/include/arlcomp.h	45;"	d
~ARCompGenEig	arpack++/include/argcomp.h	/^  virtual ~ARCompGenEig() { }$/;"	f	class:ARCompGenEig
~ARCompStdEig	arpack++/include/arscomp.h	/^  virtual ~ARCompStdEig() { }$/;"	f	class:ARCompStdEig
~ARGenEig	arpack++/include/argeig.h	/^  virtual ~ARGenEig() { }$/;"	f	class:ARGenEig
~ARMatrix	arpack++/include/armat.h	/^  virtual ~ARMatrix() { }$/;"	f	class:ARMatrix
~ARNonSymGenEig	arpack++/include/argnsym.h	/^  virtual ~ARNonSymGenEig() { }$/;"	f	class:ARNonSymGenEig
~ARNonSymStdEig	arpack++/include/arsnsym.h	/^  virtual ~ARNonSymStdEig() { }$/;"	f	class:ARNonSymStdEig
~ARRAY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY.h	/^    ~ARRAY()$/;"	f	class:PhysBAM::ARRAY
~ARRAY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_BASE.h	/^    ~ARRAY_BASE(){}$/;"	f	class:PhysBAM::ARRAY_BASE
~ARRAY_COLLECTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION.cpp	/^~ARRAY_COLLECTION()$/;"	f	class:PhysBAM::ARRAY_COLLECTION
~ARRAY_COLLECTION_ELEMENT	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Arrays/ARRAY_COLLECTION_ELEMENT.h	/^    ~ARRAY_COLLECTION_ELEMENT()$/;"	f	class:PhysBAM::ARRAY_COLLECTION_ELEMENT
~ARStdEig	arpack++/include/arseig.h	/^  virtual ~ARStdEig() { }$/;"	f	class:ARStdEig
~ARSymGenEig	arpack++/include/argsym.h	/^  virtual ~ARSymGenEig() { }$/;"	f	class:ARSymGenEig
~ARSymStdEig	arpack++/include/arssym.h	/^  virtual ~ARSymStdEig() { }$/;"	f	class:ARSymStdEig
~ARbdNonSymMatrix	arpack++/include/arbnsmat.h	/^  virtual ~ARbdNonSymMatrix() { ClearMem(); }$/;"	f	class:ARbdNonSymMatrix
~ARbdNonSymPencil	arpack++/include/arbnspen.h	/^  virtual ~ARbdNonSymPencil() { }$/;"	f	class:ARbdNonSymPencil
~ARbdSymMatrix	arpack++/include/arbsmat.h	/^  virtual ~ARbdSymMatrix() { ClearMem(); }$/;"	f	class:ARbdSymMatrix
~ARbdSymPencil	arpack++/include/arbspen.h	/^  virtual ~ARbdSymPencil() { }$/;"	f	class:ARbdSymPencil
~ARdfMatrix	arpack++/include/ardfmat.h	/^ARdfMatrix<ARTYPE>::~ARdfMatrix()$/;"	f	class:ARdfMatrix
~ARdsNonSymMatrix	arpack++/include/ardnsmat.h	/^  virtual ~ARdsNonSymMatrix() { ClearMem(); }$/;"	f	class:ARdsNonSymMatrix
~ARdsNonSymPencil	arpack++/include/ardnspen.h	/^  virtual ~ARdsNonSymPencil() { }$/;"	f	class:ARdsNonSymPencil
~ARdsSymMatrix	arpack++/include/ardsmat.h	/^  virtual ~ARdsSymMatrix() { ClearMem(); }$/;"	f	class:ARdsSymMatrix
~ARdsSymPencil	arpack++/include/ardspen.h	/^  virtual ~ARdsSymPencil() { }$/;"	f	class:ARdsSymPencil
~ARhbMatrix	arpack++/include/arhbmat.h	/^ARhbMatrix<ARINT, ARTYPE>::~ARhbMatrix()$/;"	f	class:ARhbMatrix
~ARluCompGenEig	arpack++/include/arbgcomp.h	/^  virtual ~ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
~ARluCompGenEig	arpack++/include/ardgcomp.h	/^  virtual ~ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
~ARluCompGenEig	arpack++/include/arlgcomp.h	/^  virtual ~ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
~ARluCompGenEig	arpack++/include/arugcomp.h	/^  virtual ~ARluCompGenEig() { }$/;"	f	class:ARluCompGenEig
~ARluCompStdEig	arpack++/include/arbscomp.h	/^  virtual ~ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
~ARluCompStdEig	arpack++/include/ardscomp.h	/^  virtual ~ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
~ARluCompStdEig	arpack++/include/arlscomp.h	/^  virtual ~ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
~ARluCompStdEig	arpack++/include/aruscomp.h	/^  virtual ~ARluCompStdEig() { }$/;"	f	class:ARluCompStdEig
~ARluNonSymGenEig	arpack++/include/arbgnsym.h	/^  virtual ~ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
~ARluNonSymGenEig	arpack++/include/ardgnsym.h	/^  virtual ~ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
~ARluNonSymGenEig	arpack++/include/arlgnsym.h	/^  virtual ~ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
~ARluNonSymGenEig	arpack++/include/arugnsym.h	/^  virtual ~ARluNonSymGenEig() { }$/;"	f	class:ARluNonSymGenEig
~ARluNonSymMatrix	arpack++/include/arlnsmat.h	/^  virtual ~ARluNonSymMatrix() { ClearMem(); }$/;"	f	class:ARluNonSymMatrix
~ARluNonSymPencil	arpack++/include/arlnspen.h	/^  virtual ~ARluNonSymPencil() { ClearMem(); }$/;"	f	class:ARluNonSymPencil
~ARluNonSymStdEig	arpack++/include/arbsnsym.h	/^  virtual ~ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
~ARluNonSymStdEig	arpack++/include/ardsnsym.h	/^  virtual ~ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
~ARluNonSymStdEig	arpack++/include/arlsnsym.h	/^  virtual ~ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
~ARluNonSymStdEig	arpack++/include/arusnsym.h	/^  virtual ~ARluNonSymStdEig() { }$/;"	f	class:ARluNonSymStdEig
~ARluSymGenEig	arpack++/include/arbgsym.h	/^  virtual ~ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
~ARluSymGenEig	arpack++/include/ardgsym.h	/^  virtual ~ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
~ARluSymGenEig	arpack++/include/arlgsym.h	/^  virtual ~ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
~ARluSymGenEig	arpack++/include/arugsym.h	/^  virtual ~ARluSymGenEig() { }$/;"	f	class:ARluSymGenEig
~ARluSymMatrix	arpack++/include/arlsmat.h	/^  virtual ~ARluSymMatrix() { ClearMem(); }$/;"	f	class:ARluSymMatrix
~ARluSymPencil	arpack++/include/arlspen.h	/^  virtual ~ARluSymPencil() { ClearMem(); }$/;"	f	class:ARluSymPencil
~ARluSymStdEig	arpack++/include/arbssym.h	/^  virtual ~ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
~ARluSymStdEig	arpack++/include/ardssym.h	/^  virtual ~ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
~ARluSymStdEig	arpack++/include/arlssym.h	/^  virtual ~ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
~ARluSymStdEig	arpack++/include/arussym.h	/^  virtual ~ARluSymStdEig() { }$/;"	f	class:ARluSymStdEig
~ARrcCompGenEig	arpack++/include/arrgcomp.h	/^  virtual ~ARrcCompGenEig() { }$/;"	f	class:ARrcCompGenEig
~ARrcCompStdEig	arpack++/include/arrscomp.h	/^  virtual ~ARrcCompStdEig() { }$/;"	f	class:ARrcCompStdEig
~ARrcGenEig	arpack++/include/arrgeig.h	/^  virtual ~ARrcGenEig() { }$/;"	f	class:ARrcGenEig
~ARrcNonSymGenEig	arpack++/include/arrgnsym.h	/^  virtual ~ARrcNonSymGenEig() { }$/;"	f	class:ARrcNonSymGenEig
~ARrcNonSymStdEig	arpack++/include/arrsnsym.h	/^  virtual ~ARrcNonSymStdEig() { }$/;"	f	class:ARrcNonSymStdEig
~ARrcStdEig	arpack++/include/arrseig.h	/^  virtual ~ARrcStdEig() { ClearMem(); }$/;"	f	class:ARrcStdEig
~ARrcSymGenEig	arpack++/include/arrgsym.h	/^  virtual ~ARrcSymGenEig() { }$/;"	f	class:ARrcSymGenEig
~ARrcSymStdEig	arpack++/include/arrssym.h	/^  virtual ~ARrcSymStdEig() { }$/;"	f	class:ARrcSymStdEig
~ARumNonSymMatrix	arpack++/include/arunsmat.h	/^  virtual ~ARumNonSymMatrix() { ClearMem(); }$/;"	f	class:ARumNonSymMatrix
~ARumNonSymPencil	arpack++/include/arunspen.h	/^  virtual ~ARumNonSymPencil() { }$/;"	f	class:ARumNonSymPencil
~ARumSymMatrix	arpack++/include/arusmat.h	/^  virtual ~ARumSymMatrix() { ClearMem(); }$/;"	f	class:ARumSymMatrix
~ARumSymPencil	arpack++/include/aruspen.h	/^  virtual ~ARumSymPencil() { }$/;"	f	class:ARumSymPencil
~AccAeroMeshMotionHandler	MeshMotionHandler.h	/^  ~AccAeroMeshMotionHandler() {}$/;"	f	class:AccAeroMeshMotionHandler
~AccDeformingMeshMotionHandler	MeshMotionHandler.h	/^  ~AccDeformingMeshMotionHandler() {}$/;"	f	class:AccDeformingMeshMotionHandler
~AccHeavingMeshMotionHandler	MeshMotionHandler.h	/^  ~AccHeavingMeshMotionHandler() {}$/;"	f	class:AccHeavingMeshMotionHandler
~AccMeshMotionHandler	MeshMotionHandler.h	/^  ~AccMeshMotionHandler() {}$/;"	f	class:AccMeshMotionHandler
~AccPitchingMeshMotionHandler	MeshMotionHandler.h	/^  ~AccPitchingMeshMotionHandler() {}$/;"	f	class:AccPitchingMeshMotionHandler
~AeroMeshMotionHandler	MeshMotionHandlerCore.C	/^AeroMeshMotionHandler::~AeroMeshMotionHandler()$/;"	f	class:AeroMeshMotionHandler
~AeroelasticData	IoData.h	/^  ~AeroelasticData() {}$/;"	f	struct:AeroelasticData
~AgglomeratedFace	AgglomeratedFace.C	/^AgglomeratedFace::~AgglomeratedFace() {$/;"	f	class:AgglomeratedFace
~AgglomeratedFaceSet	AgglomeratedFace.C	/^AgglomeratedFaceSet::~AgglomeratedFaceSet() {$/;"	f	class:AgglomeratedFaceSet
~AlternatingLeastSquare	AlternatingLeastSquare/als_lapack.cpp	/^AlternatingLeastSquare::~AlternatingLeastSquare() {$/;"	f	class:AlternatingLeastSquare
~ApproximatedMetricData	IoData.h	/^  ~ApproximatedMetricData() {}$/;"	f	struct:ApproximatedMetricData
~Assigner	parser/Assigner.h	/^   virtual ~Assigner() {}$/;"	f	class:Assigner
~BCApplier	BCApplierCore.C	/^BCApplier::~BCApplier()$/;"	f	class:BCApplier
~BCondSet	BCond.h	/^  ~BCondSet() { if (bcs) delete[] bcs; }$/;"	f	class:BCondSet
~BFixData	IoData.h	/^  ~BFixData() {}$/;"	f	struct:BFixData
~BLMeshMotionData	IoData.h	/^   ~BLMeshMotionData() {};$/;"	f	struct:BLMeshMotionData
~BOX_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/BOX_HIERARCHY.cpp	/^~BOX_HIERARCHY()$/;"	f	class:BOX_HIERARCHY
~BasisUpdatesData	IoData.h	/^  ~BasisUpdatesData() {}$/;"	f	struct:BasisUpdatesData
~BcData	BcData.h	/^  ~BcData() {}$/;"	f	class:BcData
~BcFcn	BcFcn.h	/^  virtual ~BcFcn() {}$/;"	f	class:BcFcn
~BcFcnKE	BcFcn.h	/^  ~BcFcnKE() {}$/;"	f	class:BcFcnKE
~BcFcnKEturb	BcFcn.h	/^  ~BcFcnKEturb() {}$/;"	f	class:BcFcnKEturb
~BcFcnNS	BcFcn.h	/^  ~BcFcnNS() {}$/;"	f	class:BcFcnNS
~BcFcnSA	BcFcn.h	/^  ~BcFcnSA() {}$/;"	f	class:BcFcnSA
~BcFcnSAturb	BcFcn.h	/^  ~BcFcnSAturb() {}$/;"	f	class:BcFcnSAturb
~BcsData	IoData.h	/^  ~BcsData() {}$/;"	f	struct:BcsData
~BcsFreeStreamData	IoData.h	/^  ~BcsFreeStreamData() {}$/;"	f	struct:BcsFreeStreamData
~BcsHydroData	IoData.h	/^  ~BcsHydroData() {}$/;"	f	struct:BcsHydroData
~BcsWallData	IoData.h	/^  ~BcsWallData() {}$/;"	f	struct:BcsWallData
~BinFileHandler	BinFileHandler.h	/^BinFileHandler::~BinFileHandler() $/;"	f	class:BinFileHandler
~BlockAlloc	BlockAlloc.C	/^BlockAlloc::~BlockAlloc()$/;"	f	class:BlockAlloc
~BlockTridiagonalMatrix	BlockTridiagonalMatrix.C	/^BlockTridiagonalMatrix<Scalar,dim>::~BlockTridiagonalMatrix() {$/;"	f	class:BlockTridiagonalMatrix
~BoundarySchemeData	IoData.h	/^  ~BoundarySchemeData() {}$/;"	f	struct:BoundarySchemeData
~CFLData	IoData.h	/^  ~CFLData() {}$/;"	f	struct:CFLData
~CFixData	IoData.h	/^  ~CFixData() {}$/;"	f	struct:CFixData
~CLONEABLE_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Clone/CLONEABLE.h	/^    virtual ~CLONEABLE_BASE()$/;"	f	class:PhysBAM::CLONEABLE_BASE
~CgSolver	KspSolver.h	/^  ~CgSolver() {}$/;"	f	class:CgSolver
~ClassAssigner	parser/Assigner.h	/^    virtual ~ClassAssigner()$/;"	f	class:ClassAssigner
~ClippingData	IoData.h	/^  ~ClippingData() {}$/;"	f	struct:ClippingData
~ClusteringData	IoData.h	/^  ~ClusteringData() {}$/;"	f	struct:ClusteringData
~CommPattern	Communicator.h	/^  ~CommPattern()$/;"	f	class:CommPattern
~Communicator	Communicator.h	/^  ~Communicator(){};$/;"	f	class:Communicator
~Connectivity	ConnectivityCore.C	/^Connectivity::~Connectivity()$/;"	f	class:Connectivity
~ConstantPrandtlThermalCondFcn	ThermalCondFcn.h	/^  ~ConstantPrandtlThermalCondFcn() { viscoFcn = 0; varFcn = 0;}$/;"	f	class:ConstantPrandtlThermalCondFcn
~ConstantThermalCondFcn	ThermalCondFcn.h	/^  ~ConstantThermalCondFcn() {}$/;"	f	class:ConstantThermalCondFcn
~ConstantViscoFcn	ViscoFcn.h	/^  ~ConstantViscoFcn() {}$/;"	f	class:ConstantViscoFcn
~CorotSolver	CorotSolver.C	/^CorotSolver::~CorotSolver()$/;"	f	class:CorotSolver
~CrackingSurface	FSI/CrackingSurface.cpp	/^CrackingSurface::~CrackingSurface()$/;"	f	class:CrackingSurface
~CurvatureDetection	CurvatureDetection.C	/^CurvatureDetection::~CurvatureDetection()$/;"	f	class:CurvatureDetection
~CylinderData	IoData.h	/^  ~CylinderData() {}$/;"	f	struct:CylinderData
~DESModelData	IoData.h	/^  ~DESModelData() {}$/;"	f	struct:DESModelData
~DESTerm	DESTerm.h	/^  ~DESTerm() {}$/;"	f	class:DESTerm
~DGCLData	IoData.h	/^  ~DGCLData() {}$/;"	f	struct:DGCLData
~DataCompressionData	IoData.h	/^  ~DataCompressionData() {}$/;"	f	struct:DataCompressionData
~DefoMeshMotionData	IoData.h	/^  ~DefoMeshMotionData() {}$/;"	f	struct:DefoMeshMotionData
~DeformingData	IoData.h	/^  ~DeformingData() {}$/;"	f	struct:DeformingData
~DeformingMeshMotionHandler	MeshMotionHandlerCore.C	/^DeformingMeshMotionHandler::~DeformingMeshMotionHandler()$/;"	f	class:DeformingMeshMotionHandler
~DiagMat	DiagMatrix.h	/^  ~DiagMat() {}$/;"	f	class:DiagMat
~Dictionary	parser/Dictionary.h	/^   ~Dictionary() {}$/;"	f	class:Dictionary
~DistBcData	DistBcData.C	/^DistBcData<dim>::~DistBcData()$/;"	f	class:DistBcData
~DistBcDataEuler	DistBcData.h	/^  ~DistBcDataEuler() {}$/;"	f	class:DistBcDataEuler
~DistBcDataKE	DistBcData.C	/^DistBcDataKE<dim>::~DistBcDataKE()$/;"	f	class:DistBcDataKE
~DistBcDataSA	DistBcData.C	/^DistBcDataSA<dim>::~DistBcDataSA()$/;"	f	class:DistBcDataSA
~DistDynamicLESTerm	DistDynamicLESTerm.C	/^DistDynamicLESTerm<dim>::~DistDynamicLESTerm()$/;"	f	class:DistDynamicLESTerm
~DistDynamicVMSTerm	DistDynamicVMSTerm.C	/^DistDynamicVMSTerm<dim>::~DistDynamicVMSTerm()$/;"	f	class:DistDynamicVMSTerm
~DistEdgeGrad	DistEdgeGrad.C	/^DistEdgeGrad<dim>::~DistEdgeGrad()$/;"	f	class:DistEdgeGrad
~DistEmbeddedVec	DistEmbeddedVector.h	/^DistEmbeddedVec<Scalar,dim>::~DistEmbeddedVec() $/;"	f	class:DistEmbeddedVec
~DistExactRiemannSolver	DistExactRiemannSolver.C	/^DistExactRiemannSolver<dim>::~DistExactRiemannSolver()$/;"	f	class:DistExactRiemannSolver
~DistExtrapolation	DistExtrapolation.C	/^DistExtrapolation<dim>::~DistExtrapolation()$/;"	f	class:DistExtrapolation
~DistGeoState	DistGeoState.C	/^DistGeoState::~DistGeoState()$/;"	f	class:DistGeoState
~DistInfo	DistInfo.h	/^  ~DistInfo() $/;"	f	struct:DistInfo
~DistIntersectorFRG	IntersectorFRG/IntersectorFRG.C	/^DistIntersectorFRG::~DistIntersectorFRG() $/;"	f	class:DistIntersectorFRG
~DistIntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.C	/^DistIntersectorPhysBAM::~DistIntersectorPhysBAM() $/;"	f	class:DistIntersectorPhysBAM
~DistLeastSquareSolver	DistLeastSquareSolver.C	/^DistLeastSquareSolver::~DistLeastSquareSolver() {$/;"	f	class:DistLeastSquareSolver
~DistLevelSetStructure	LevelSet/LevelSetStructure.h	/^    virtual ~DistLevelSetStructure()$/;"	f	class:DistLevelSetStructure
~DistMacroCellSet	DistMacroCellCore.C	/^DistMacroCellSet::~DistMacroCellSet()$/;"	f	class:DistMacroCellSet
~DistMat	DistMatrix.h	/^DistMat<Scalar,dim>::~DistMat()$/;"	f	class:DistMat
~DistMultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.h	/^    virtual ~DistMultiGridLevelSetStructure()$/;"	f	class:DistMultiGridLevelSetStructure
~DistMvpMatrix	DistMvpMatrix.h	/^DistMvpMatrix<Scalar,dim>::~DistMvpMatrix() {$/;"	f	class:DistMvpMatrix
~DistNodalGrad	DistNodalGrad.C	/^DistNodalGrad<dim, Scalar>::~DistNodalGrad()$/;"	f	class:DistNodalGrad
~DistSVec	DistVector.h	/^DistSVec<Scalar,dim>::~DistSVec() $/;"	f	class:DistSVec
~DistTimeState	DistTimeState.C	/^DistTimeState<dim>::~DistTimeState()$/;"	f	class:DistTimeState
~DistVMSLESTerm	DistVMSLESTerm.C	/^DistVMSLESTerm<dim>::~DistVMSLESTerm()$/;"	f	class:DistVMSLESTerm
~DistVec	DistVector.h	/^DistVec<Scalar>::~DistVec() $/;"	f	class:DistVec
~Domain	DomainCore.C	/^Domain::~Domain()$/;"	f	class:Domain
~DummyPointData	IoData.h	/^  ~DummyPointData() {}$/;"	f	struct:DummyPointData
~DynamicLESData	IoData.h	/^  ~DynamicLESData() {}$/;"	f	struct:DynamicLESData
~DynamicLESTerm	DynamicLESTerm.C	/^DynamicLESTerm::~DynamicLESTerm()$/;"	f	class:DynamicLESTerm
~DynamicNodalTransfer	FSI/DynamicNodalTransfer.cpp	/^DynamicNodalTransfer::~DynamicNodalTransfer() {$/;"	f	class:DynamicNodalTransfer
~DynamicVMSData	IoData.h	/^  ~DynamicVMSData() {}$/;"	f	struct:DynamicVMSData
~DynamicVMSTerm	DynamicVMSTerm.C	/^DynamicVMSTerm::~DynamicVMSTerm()$/;"	f	class:DynamicVMSTerm
~EdgeGalerkin	EdgeGalerkinCore.C	/^EdgeGalerkin::~EdgeGalerkin()$/;"	f	class:EdgeGalerkin
~EdgeGrad	EdgeGrad.C	/^EdgeGrad<dim>::~EdgeGrad()$/;"	f	class:EdgeGrad
~EdgeSet	EdgeCore.C	/^EdgeSet::~EdgeSet()$/;"	f	class:EdgeSet
~ElemSet	ElemCore.C	/^ElemSet::~ElemSet()  $/;"	f	class:ElemSet
~ElemTet	ElemTet.h	/^  ~ElemTet() {}$/;"	f	class:ElemTet
~EmbeddedALEMeshMotionHandler	MeshMotionHandlerCore.C	/^EmbeddedALEMeshMotionHandler::~EmbeddedALEMeshMotionHandler()$/;"	f	class:EmbeddedALEMeshMotionHandler
~EmbeddedALETetMeshMotionSolver	MeshMotionSolver.h	/^  ~EmbeddedALETetMeshMotionSolver(){};$/;"	f	class:EmbeddedALETetMeshMotionSolver
~EmbeddedAlternatingLeastSquare	EmbeddedAlternatingLeastSquare.C	/^EmbeddedAlternatingLeastSquare<dim>::~EmbeddedAlternatingLeastSquare() {$/;"	f	class:EmbeddedAlternatingLeastSquare
~EmbeddedAlternatingLeastSquareData	AlternatingLeastSquare/als_io.h	/^    ~EmbeddedAlternatingLeastSquareData() {}$/;"	f	struct:EmbeddedAlternatingLeastSquareData
~EmbeddedAlternatingLeastSquareData	IoData.h	/^    ~EmbeddedAlternatingLeastSquareData() {}$/;"	f	struct:EmbeddedAlternatingLeastSquareData
~EmbeddedCorotSolver	EmbeddedCorotSolver.h	/^  ~EmbeddedCorotSolver() {};$/;"	f	class:EmbeddedCorotSolver
~EmbeddedFluidShapeOptimizationHandler	EmbeddedFluidShapeOptimizationHandler.C	/^EmbeddedFluidShapeOptimizationHandler<dim>::~EmbeddedFluidShapeOptimizationHandler()$/;"	f	class:EmbeddedFluidShapeOptimizationHandler
~EmbeddedFramework	IoData.h	/^  ~EmbeddedFramework() {}$/;"	f	struct:EmbeddedFramework
~EmbeddedMeshMotionHandler	MeshMotionHandlerCore.C	/^EmbeddedMeshMotionHandler::~EmbeddedMeshMotionHandler()$/;"	f	class:EmbeddedMeshMotionHandler
~EmbeddedStructure	FSI/DynamicNodalTransfer.cpp	/^EmbeddedStructure::~EmbeddedStructure()$/;"	f	class:EmbeddedStructure
~EmbeddedTsDesc	EmbeddedTsDesc.C	/^EmbeddedTsDesc<dim>::~EmbeddedTsDesc()$/;"	f	class:EmbeddedTsDesc
~EquationsData	IoData.h	/^  ~EquationsData() {}$/;"	f	struct:EquationsData
~EulerSource	OneDimensionalSolver.C	/^  ~EulerSource() { }$/;"	f	class:EulerSource
~ExactRiemannSolver	ExactRiemannSolver.C	/^ExactRiemannSolver<dim>::~ExactRiemannSolver() $/;"	f	class:ExactRiemannSolver
~ExplicitData	IoData.h	/^  ~ExplicitData() {}$/;"	f	struct:ExplicitData
~ExplicitEmbeddedTsDesc	ExplicitEmbeddedTsDesc.C	/^ExplicitEmbeddedTsDesc<dim>::~ExplicitEmbeddedTsDesc()$/;"	f	class:ExplicitEmbeddedTsDesc
~ExplicitLevelSetTsDesc	ExplicitLevelSetTsDesc.C	/^ExplicitLevelSetTsDesc<dim,dimLS>::~ExplicitLevelSetTsDesc()$/;"	f	class:ExplicitLevelSetTsDesc
~ExplicitMultiPhysicsTsDesc	ExplicitMultiPhysicsTsDesc.C	/^ExplicitMultiPhysicsTsDesc<dim,dimLS>::~ExplicitMultiPhysicsTsDesc()$/;"	f	class:ExplicitMultiPhysicsTsDesc
~ExplicitTsDesc	ExplicitTsDesc.C	/^ExplicitTsDesc<dim>::~ExplicitTsDesc()$/;"	f	class:ExplicitTsDesc
~Extrapolation	Extrapolation.C	/^Extrapolation<dim>::~Extrapolation()$/;"	f	class:Extrapolation
~FACTORY_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    virtual ~FACTORY_BASE(){}$/;"	f	struct:PhysBAM::FACTORY_BASE
~FaceSet	FaceCore.C	/^FaceSet::~FaceSet()$/;"	f	class:FaceSet
~FemEquationTerm	FemEquationTerm.h	/^  virtual ~FemEquationTerm() { if (wallFcn) delete wallFcn; }$/;"	f	class:FemEquationTerm
~FemEquationTermDES	FemEquationTermDesc.h	/^  ~FemEquationTermDES() {}$/;"	f	class:FemEquationTermDES
~FemEquationTermDESmean	FemEquationTermDesc.h	/^  ~FemEquationTermDESmean() {}$/;"	f	class:FemEquationTermDESmean
~FemEquationTermDESturb	FemEquationTermDesc.h	/^  ~FemEquationTermDESturb() {}$/;"	f	class:FemEquationTermDESturb
~FemEquationTermKE	FemEquationTermDesc.h	/^  ~FemEquationTermKE() {}$/;"	f	class:FemEquationTermKE
~FemEquationTermKEmean	FemEquationTermDesc.h	/^  ~FemEquationTermKEmean() {}$/;"	f	class:FemEquationTermKEmean
~FemEquationTermKEturb	FemEquationTermDesc.h	/^  ~FemEquationTermKEturb() {}$/;"	f	class:FemEquationTermKEturb
~FemEquationTermNS	FemEquationTermDesc.h	/^  ~FemEquationTermNS() {}$/;"	f	class:FemEquationTermNS
~FemEquationTermSA	FemEquationTermDesc.h	/^  ~FemEquationTermSA() {}$/;"	f	class:FemEquationTermSA
~FemEquationTermSAmean	FemEquationTermDesc.h	/^  ~FemEquationTermSAmean() {}$/;"	f	class:FemEquationTermSAmean
~FemEquationTermSAturb	FemEquationTermDesc.h	/^  ~FemEquationTermSAturb() {}$/;"	f	class:FemEquationTermSAturb
~FloodFill	IntersectorPhysBAM/FloodFill.h	/^~FloodFill()$/;"	f	class:FloodFill
~FluidCollocationShapeOptimizationHandler	FluidCollocationShapeOptimizationHandler.C	/^FluidCollocationShapeOptimizationHandler<dim>::~FluidCollocationShapeOptimizationHandler()$/;"	f	class:FluidCollocationShapeOptimizationHandler
~FluidGnatShapeOptimizationHandler	FluidGnatShapeOptimizationHandler.C	/^FluidGnatShapeOptimizationHandler<dim>::~FluidGnatShapeOptimizationHandler()$/;"	f	class:FluidGnatShapeOptimizationHandler
~FluidMetricShapeOptimizationHandler	FluidMetricShapeOptimizationHandler.C	/^FluidMetricShapeOptimizationHandler<dim>::~FluidMetricShapeOptimizationHandler()$/;"	f	class:FluidMetricShapeOptimizationHandler
~FluidModelData	IoData.h	/^  ~FluidModelData() {}$/;"	f	struct:FluidModelData
~FluidRemapData	IoData.h	/^  ~FluidRemapData() {}$/;"	f	struct:FluidRemapData
~FluidRomShapeOptimizationHandler	FluidRomShapeOptimizationHandler.C	/^FluidRomShapeOptimizationHandler<dim>::~FluidRomShapeOptimizationHandler()$/;"	f	class:FluidRomShapeOptimizationHandler
~FluidSelector	FluidSelectorCore.C	/^FluidSelector::~FluidSelector()$/;"	f	class:FluidSelector
~FluidShapeOptimizationHandler	FluidShapeOptimizationHandler.C	/^FluidShapeOptimizationHandler<dim>::~FluidShapeOptimizationHandler()$/;"	f	class:FluidShapeOptimizationHandler
~FluxFcn	FluxFcn.h	/^  ~FluxFcn() {$/;"	f	class:FluxFcn
~FluxFcnApprJacHLLCEuler3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLCEuler3D() {}$/;"	f	class:FluxFcnApprJacHLLCEuler3D
~FluxFcnApprJacHLLCKE3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLCKE3D() {}$/;"	f	class:FluxFcnApprJacHLLCKE3D
~FluxFcnApprJacHLLCSA3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLCSA3D() {}$/;"	f	class:FluxFcnApprJacHLLCSA3D
~FluxFcnApprJacHLLEEuler3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLEEuler3D() {}$/;"	f	class:FluxFcnApprJacHLLEEuler3D
~FluxFcnApprJacHLLEKE3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLEKE3D() {}$/;"	f	class:FluxFcnApprJacHLLEKE3D
~FluxFcnApprJacHLLESA3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacHLLESA3D() {}$/;"	f	class:FluxFcnApprJacHLLESA3D
~FluxFcnApprJacRoeEuler3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacRoeEuler3D() {}$/;"	f	class:FluxFcnApprJacRoeEuler3D
~FluxFcnApprJacRoeKE3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacRoeKE3D() {}$/;"	f	class:FluxFcnApprJacRoeKE3D
~FluxFcnApprJacRoeSA3D	FluxFcnDesc.h	/^  ~FluxFcnApprJacRoeSA3D() {}$/;"	f	class:FluxFcnApprJacRoeSA3D
~FluxFcnBase	FluxFcnBase.h	/^  virtual ~FluxFcnBase() { vf = 0; }$/;"	f	class:FluxFcnBase
~FluxFcnDirectStateInflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateInflowEuler3D() {}$/;"	f	class:FluxFcnDirectStateInflowEuler3D
~FluxFcnDirectStateInflowKE3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateInflowKE3D() {}$/;"	f	class:FluxFcnDirectStateInflowKE3D
~FluxFcnDirectStateInflowKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateInflowKEturb3D() {}$/;"	f	class:FluxFcnDirectStateInflowKEturb3D
~FluxFcnDirectStateInflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateInflowSA3D() {}$/;"	f	class:FluxFcnDirectStateInflowSA3D
~FluxFcnDirectStateInflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateInflowSAturb3D() {}$/;"	f	class:FluxFcnDirectStateInflowSAturb3D
~FluxFcnDirectStateOutflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateOutflowEuler3D() {}$/;"	f	class:FluxFcnDirectStateOutflowEuler3D
~FluxFcnDirectStateOutflowKE3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateOutflowKE3D() {}$/;"	f	class:FluxFcnDirectStateOutflowKE3D
~FluxFcnDirectStateOutflowKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateOutflowKEturb3D() {}$/;"	f	class:FluxFcnDirectStateOutflowKEturb3D
~FluxFcnDirectStateOutflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateOutflowSA3D() {}$/;"	f	class:FluxFcnDirectStateOutflowSA3D
~FluxFcnDirectStateOutflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnDirectStateOutflowSAturb3D() {}$/;"	f	class:FluxFcnDirectStateOutflowSAturb3D
~FluxFcnExactJacRoeEuler3D	FluxFcnDesc.h	/^  ~FluxFcnExactJacRoeEuler3D() {}$/;"	f	class:FluxFcnExactJacRoeEuler3D
~FluxFcnExactJacRoeKE3D	FluxFcnDesc.h	/^  ~FluxFcnExactJacRoeKE3D() {}$/;"	f	class:FluxFcnExactJacRoeKE3D
~FluxFcnExactJacRoeSA3D	FluxFcnDesc.h	/^  ~FluxFcnExactJacRoeSA3D() {}$/;"	f	class:FluxFcnExactJacRoeSA3D
~FluxFcnFD	FluxFcnBase.h	/^  ~FluxFcnFD() { vf = 0; }$/;"	f	class:FluxFcnFD
~FluxFcnFDJacHLLCEuler3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLCEuler3D() {}$/;"	f	class:FluxFcnFDJacHLLCEuler3D
~FluxFcnFDJacHLLCKE3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLCKE3D() {}$/;"	f	class:FluxFcnFDJacHLLCKE3D
~FluxFcnFDJacHLLCSA3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLCSA3D() {}$/;"	f	class:FluxFcnFDJacHLLCSA3D
~FluxFcnFDJacHLLEEuler3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLEEuler3D() {}$/;"	f	class:FluxFcnFDJacHLLEEuler3D
~FluxFcnFDJacHLLEKE3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLEKE3D() {}$/;"	f	class:FluxFcnFDJacHLLEKE3D
~FluxFcnFDJacHLLESA3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacHLLESA3D() {}$/;"	f	class:FluxFcnFDJacHLLESA3D
~FluxFcnFDJacRoeEuler3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacRoeEuler3D() {}$/;"	f	class:FluxFcnFDJacRoeEuler3D
~FluxFcnFDJacRoeKE3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacRoeKE3D() {}$/;"	f	class:FluxFcnFDJacRoeKE3D
~FluxFcnFDJacRoeSA3D	FluxFcnDesc.h	/^  ~FluxFcnFDJacRoeSA3D() {}$/;"	f	class:FluxFcnFDJacRoeSA3D
~FluxFcnGhidagliaEuler3D	FluxFcnDesc.h	/^  ~FluxFcnGhidagliaEuler3D() {}$/;"	f	class:FluxFcnGhidagliaEuler3D
~FluxFcnGhidagliaKE3D	FluxFcnDesc.h	/^  ~FluxFcnGhidagliaKE3D() {}$/;"	f	class:FluxFcnGhidagliaKE3D
~FluxFcnGhidagliaKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnGhidagliaKEturb3D() {}$/;"	f	class:FluxFcnGhidagliaKEturb3D
~FluxFcnGhidagliaSA3D	FluxFcnDesc.h	/^  ~FluxFcnGhidagliaSA3D() {}$/;"	f	class:FluxFcnGhidagliaSA3D
~FluxFcnGhidagliaSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnGhidagliaSAturb3D() {}$/;"	f	class:FluxFcnGhidagliaSAturb3D
~FluxFcnInflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnInflowEuler3D() {}$/;"	f	class:FluxFcnInflowEuler3D
~FluxFcnInternalInflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnInternalInflowEuler3D() {}$/;"	f	class:FluxFcnInternalInflowEuler3D
~FluxFcnInternalInflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnInternalInflowSA3D() {}$/;"	f	class:FluxFcnInternalInflowSA3D
~FluxFcnInternalInflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnInternalInflowSAturb3D() {}$/;"	f	class:FluxFcnInternalInflowSAturb3D
~FluxFcnInternalOutflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnInternalOutflowEuler3D() {}$/;"	f	class:FluxFcnInternalOutflowEuler3D
~FluxFcnInternalOutflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnInternalOutflowSA3D() {}$/;"	f	class:FluxFcnInternalOutflowSA3D
~FluxFcnInternalOutflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnInternalOutflowSAturb3D() {}$/;"	f	class:FluxFcnInternalOutflowSAturb3D
~FluxFcnJwlApprJacRoeEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlApprJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlApprJacRoeEuler3D
~FluxFcnJwlExactJacRoeEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlExactJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlExactJacRoeEuler3D
~FluxFcnJwlFDJacRoeEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlFDJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlFDJacRoeEuler3D
~FluxFcnJwlGhidagliaEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlGhidagliaEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlGhidagliaEuler3D
~FluxFcnJwlInflowEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlInflowEuler3D
~FluxFcnJwlInternalInflowEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlInternalInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlInternalInflowEuler3D
~FluxFcnJwlInternalOutflowEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlInternalOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlInternalOutflowEuler3D
~FluxFcnJwlOutflowEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlOutflowEuler3D
~FluxFcnJwlWallEuler3D	FluxFcnDescJwl.h	/^  ~FluxFcnJwlWallEuler3D() { vf = 0; }$/;"	f	class:FluxFcnJwlWallEuler3D
~FluxFcnMassFlowInflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowInflowEuler3D() {}$/;"	f	class:FluxFcnMassFlowInflowEuler3D
~FluxFcnMassFlowInflowKE3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowInflowKE3D() {}$/;"	f	class:FluxFcnMassFlowInflowKE3D
~FluxFcnMassFlowInflowKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowInflowKEturb3D() {}$/;"	f	class:FluxFcnMassFlowInflowKEturb3D
~FluxFcnMassFlowInflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowInflowSA3D() {}$/;"	f	class:FluxFcnMassFlowInflowSA3D
~FluxFcnMassFlowInflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowInflowSAturb3D() {}$/;"	f	class:FluxFcnMassFlowInflowSAturb3D
~FluxFcnMassFlowOutflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowOutflowEuler3D() {}$/;"	f	class:FluxFcnMassFlowOutflowEuler3D
~FluxFcnMassFlowOutflowKE3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowOutflowKE3D() {}$/;"	f	class:FluxFcnMassFlowOutflowKE3D
~FluxFcnMassFlowOutflowKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowOutflowKEturb3D() {}$/;"	f	class:FluxFcnMassFlowOutflowKEturb3D
~FluxFcnMassFlowOutflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowOutflowSA3D() {}$/;"	f	class:FluxFcnMassFlowOutflowSA3D
~FluxFcnMassFlowOutflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnMassFlowOutflowSAturb3D() {}$/;"	f	class:FluxFcnMassFlowOutflowSAturb3D
~FluxFcnModifiedGhidagliaEuler3D	FluxFcnDesc.h	/^  ~FluxFcnModifiedGhidagliaEuler3D() {}$/;"	f	class:FluxFcnModifiedGhidagliaEuler3D
~FluxFcnOutflowEuler3D	FluxFcnDesc.h	/^  ~FluxFcnOutflowEuler3D() {} $/;"	f	class:FluxFcnOutflowEuler3D
~FluxFcnOutflowKE3D	FluxFcnDesc.h	/^  ~FluxFcnOutflowKE3D() {}$/;"	f	class:FluxFcnOutflowKE3D
~FluxFcnOutflowKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnOutflowKEturb3D() {}$/;"	f	class:FluxFcnOutflowKEturb3D
~FluxFcnOutflowSA3D	FluxFcnDesc.h	/^  ~FluxFcnOutflowSA3D() {}$/;"	f	class:FluxFcnOutflowSA3D
~FluxFcnOutflowSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnOutflowSAturb3D() {}$/;"	f	class:FluxFcnOutflowSAturb3D
~FluxFcnPorousWallEuler3D	FluxFcnDesc.h	/^  ~FluxFcnPorousWallEuler3D() {}$/;"	f	class:FluxFcnPorousWallEuler3D
~FluxFcnPorousWallKE3D	FluxFcnDesc.h	/^  ~FluxFcnPorousWallKE3D() {}$/;"	f	class:FluxFcnPorousWallKE3D
~FluxFcnPorousWallKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnPorousWallKEturb3D() {}$/;"	f	class:FluxFcnPorousWallKEturb3D
~FluxFcnPorousWallSA3D	FluxFcnDesc.h	/^  ~FluxFcnPorousWallSA3D() {}$/;"	f	class:FluxFcnPorousWallSA3D
~FluxFcnPorousWallSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnPorousWallSAturb3D() {}$/;"	f	class:FluxFcnPorousWallSAturb3D
~FluxFcnRoeKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnRoeKEturb3D() {}$/;"	f	class:FluxFcnRoeKEturb3D
~FluxFcnRoeSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnRoeSAturb3D() {}$/;"	f	class:FluxFcnRoeSAturb3D
~FluxFcnSGApprJacHLLCEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLCEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLCEuler3D
~FluxFcnSGApprJacHLLCKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLCKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLCKE3D
~FluxFcnSGApprJacHLLCSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLCSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLCSA3D
~FluxFcnSGApprJacHLLEEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLEEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLEEuler3D
~FluxFcnSGApprJacHLLEKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLEKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLEKE3D
~FluxFcnSGApprJacHLLESA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacHLLESA3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacHLLESA3D
~FluxFcnSGApprJacRoeEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacRoeEuler3D
~FluxFcnSGApprJacRoeKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacRoeKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacRoeKE3D
~FluxFcnSGApprJacRoeSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGApprJacRoeSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGApprJacRoeSA3D
~FluxFcnSGDirectStateInflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateInflowEuler3D
~FluxFcnSGDirectStateInflowKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateInflowKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateInflowKE3D
~FluxFcnSGDirectStateInflowKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateInflowKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateInflowKEturb3D
~FluxFcnSGDirectStateInflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateInflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateInflowSA3D
~FluxFcnSGDirectStateInflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateInflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateInflowSAturb3D
~FluxFcnSGDirectStateOutflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateOutflowEuler3D
~FluxFcnSGDirectStateOutflowKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateOutflowKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateOutflowKE3D
~FluxFcnSGDirectStateOutflowKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateOutflowKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateOutflowKEturb3D
~FluxFcnSGDirectStateOutflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateOutflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateOutflowSA3D
~FluxFcnSGDirectStateOutflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGDirectStateOutflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGDirectStateOutflowSAturb3D
~FluxFcnSGExactJacRoeEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGExactJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGExactJacRoeEuler3D
~FluxFcnSGExactJacRoeKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGExactJacRoeKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGExactJacRoeKE3D
~FluxFcnSGExactJacRoeSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGExactJacRoeSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGExactJacRoeSA3D
~FluxFcnSGFDJacHLLCEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLCEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLCEuler3D
~FluxFcnSGFDJacHLLCKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLCKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLCKE3D
~FluxFcnSGFDJacHLLCSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLCSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLCSA3D
~FluxFcnSGFDJacHLLEEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLEEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLEEuler3D
~FluxFcnSGFDJacHLLEKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLEKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLEKE3D
~FluxFcnSGFDJacHLLESA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacHLLESA3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacHLLESA3D
~FluxFcnSGFDJacRoeEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacRoeEuler3D
~FluxFcnSGFDJacRoeKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacRoeKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacRoeKE3D
~FluxFcnSGFDJacRoeSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGFDJacRoeSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGFDJacRoeSA3D
~FluxFcnSGGhidagliaEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGGhidagliaEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGGhidagliaEuler3D
~FluxFcnSGGhidagliaKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGGhidagliaKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGGhidagliaKE3D
~FluxFcnSGGhidagliaKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGGhidagliaKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGGhidagliaKEturb3D
~FluxFcnSGGhidagliaSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGGhidagliaSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGGhidagliaSA3D
~FluxFcnSGGhidagliaSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGGhidagliaSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGGhidagliaSAturb3D
~FluxFcnSGInflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGInflowEuler3D
~FluxFcnSGInternalInflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalInflowEuler3D
~FluxFcnSGInternalInflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalInflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalInflowSA3D
~FluxFcnSGInternalInflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalInflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalInflowSAturb3D
~FluxFcnSGInternalOutflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalOutflowEuler3D
~FluxFcnSGInternalOutflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalOutflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalOutflowSA3D
~FluxFcnSGInternalOutflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGInternalOutflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGInternalOutflowSAturb3D
~FluxFcnSGMassFlowInflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowInflowEuler3D
~FluxFcnSGMassFlowInflowKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowInflowKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowInflowKE3D
~FluxFcnSGMassFlowInflowKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowInflowKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowInflowKEturb3D
~FluxFcnSGMassFlowInflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowInflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowInflowSA3D
~FluxFcnSGMassFlowInflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowInflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowInflowSAturb3D
~FluxFcnSGMassFlowOutflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowOutflowEuler3D
~FluxFcnSGMassFlowOutflowKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowOutflowKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowOutflowKE3D
~FluxFcnSGMassFlowOutflowKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowOutflowKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowOutflowKEturb3D
~FluxFcnSGMassFlowOutflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowOutflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowOutflowSA3D
~FluxFcnSGMassFlowOutflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGMassFlowOutflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGMassFlowOutflowSAturb3D
~FluxFcnSGModifiedGhidagliaEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGModifiedGhidagliaEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGModifiedGhidagliaEuler3D
~FluxFcnSGOutflowEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGOutflowEuler3D
~FluxFcnSGOutflowKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGOutflowKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGOutflowKE3D
~FluxFcnSGOutflowKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGOutflowKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGOutflowKEturb3D
~FluxFcnSGOutflowSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGOutflowSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGOutflowSA3D
~FluxFcnSGOutflowSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGOutflowSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGOutflowSAturb3D
~FluxFcnSGPorousWallEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGPorousWallEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGPorousWallEuler3D
~FluxFcnSGPorousWallKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGPorousWallKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGPorousWallKE3D
~FluxFcnSGPorousWallKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGPorousWallKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGPorousWallKEturb3D
~FluxFcnSGPorousWallSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGPorousWallSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGPorousWallSA3D
~FluxFcnSGPorousWallSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGPorousWallSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGPorousWallSAturb3D
~FluxFcnSGRoeKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGRoeKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGRoeKEturb3D
~FluxFcnSGRoeSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGRoeSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGRoeSAturb3D
~FluxFcnSGVanLeerEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGVanLeerEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGVanLeerEuler3D
~FluxFcnSGWallEuler3D	FluxFcnDescSG.h	/^  ~FluxFcnSGWallEuler3D() { vf = 0; }$/;"	f	class:FluxFcnSGWallEuler3D
~FluxFcnSGWallKE3D	FluxFcnDescSG.h	/^  ~FluxFcnSGWallKE3D() { vf = 0; }$/;"	f	class:FluxFcnSGWallKE3D
~FluxFcnSGWallKEturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGWallKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGWallKEturb3D
~FluxFcnSGWallSA3D	FluxFcnDescSG.h	/^  ~FluxFcnSGWallSA3D() { vf = 0; }$/;"	f	class:FluxFcnSGWallSA3D
~FluxFcnSGWallSAturb3D	FluxFcnDescSG.h	/^  ~FluxFcnSGWallSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnSGWallSAturb3D
~FluxFcnTaitApprJacRoeEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitApprJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitApprJacRoeEuler3D
~FluxFcnTaitApprJacRoeKE3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitApprJacRoeKE3D() { vf = 0; }$/;"	f	class:FluxFcnTaitApprJacRoeKE3D
~FluxFcnTaitApprJacRoeSA3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitApprJacRoeSA3D() { vf = 0; }$/;"	f	class:FluxFcnTaitApprJacRoeSA3D
~FluxFcnTaitExactJacRoeEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitExactJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitExactJacRoeEuler3D
~FluxFcnTaitFDJacRoeEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitFDJacRoeEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitFDJacRoeEuler3D
~FluxFcnTaitGhidagliaEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitGhidagliaEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitGhidagliaEuler3D
~FluxFcnTaitGhidagliaKE3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitGhidagliaKE3D() { vf = 0; }$/;"	f	class:FluxFcnTaitGhidagliaKE3D
~FluxFcnTaitGhidagliaKEturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitGhidagliaKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitGhidagliaKEturb3D
~FluxFcnTaitGhidagliaSA3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitGhidagliaSA3D() { vf = 0; }$/;"	f	class:FluxFcnTaitGhidagliaSA3D
~FluxFcnTaitGhidagliaSAturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitGhidagliaSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitGhidagliaSAturb3D
~FluxFcnTaitInflowEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitInflowEuler3D
~FluxFcnTaitInternalInflowEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitInternalInflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitInternalInflowEuler3D
~FluxFcnTaitInternalOutflowEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitInternalOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitInternalOutflowEuler3D
~FluxFcnTaitModifiedGhidagliaEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitModifiedGhidagliaEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitModifiedGhidagliaEuler3D
~FluxFcnTaitOutflowEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitOutflowEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitOutflowEuler3D
~FluxFcnTaitRoeKEturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitRoeKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitRoeKEturb3D
~FluxFcnTaitRoeSAturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitRoeSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitRoeSAturb3D
~FluxFcnTaitWallEuler3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitWallEuler3D() { vf = 0; }$/;"	f	class:FluxFcnTaitWallEuler3D
~FluxFcnTaitWallKE3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitWallKE3D() { vf = 0; }$/;"	f	class:FluxFcnTaitWallKE3D
~FluxFcnTaitWallKEturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitWallKEturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitWallKEturb3D
~FluxFcnTaitWallSA3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitWallSA3D() { vf = 0; }$/;"	f	class:FluxFcnTaitWallSA3D
~FluxFcnTaitWallSAturb3D	FluxFcnDescTait.h	/^  ~FluxFcnTaitWallSAturb3D() { vf = 0; }$/;"	f	class:FluxFcnTaitWallSAturb3D
~FluxFcnVanLeerEuler3D	FluxFcnDesc.h	/^  ~FluxFcnVanLeerEuler3D() {}$/;"	f	class:FluxFcnVanLeerEuler3D
~FluxFcnWallEuler3D	FluxFcnDesc.h	/^  ~FluxFcnWallEuler3D() {}$/;"	f	class:FluxFcnWallEuler3D
~FluxFcnWallKE3D	FluxFcnDesc.h	/^  ~FluxFcnWallKE3D() {}$/;"	f	class:FluxFcnWallKE3D
~FluxFcnWallKEturb3D	FluxFcnDesc.h	/^  ~FluxFcnWallKEturb3D() {}$/;"	f	class:FluxFcnWallKEturb3D
~FluxFcnWallSA3D	FluxFcnDesc.h	/^  ~FluxFcnWallSA3D() {}$/;"	f	class:FluxFcnWallSA3D
~FluxFcnWallSAturb3D	FluxFcnDesc.h	/^  ~FluxFcnWallSAturb3D() {}$/;"	f	class:FluxFcnWallSAturb3D
~ForcePoints	IoData.h	/^  ~ForcePoints() {}$/;"	f	struct:ForcePoints
~ForcedData	IoData.h	/^  ~ForcedData() {}$/;"	f	struct:ForcedData
~GEOMETRY_PARTICLES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Geometry_Particles/GEOMETRY_PARTICLES.cpp	/^~GEOMETRY_PARTICLES()$/;"	f	class:PhysBAM::GEOMETRY_PARTICLES
~GappyConstructionData	IoData.h	/^  ~GappyConstructionData() {}$/;"	f	struct:GappyConstructionData
~GappyPreprocessing	GappyPreprocessing.C	/^GappyPreprocessing<dim>::~GappyPreprocessing() $/;"	f	class:GappyPreprocessing
~GasModelData	IoData.h	/^  ~GasModelData() {}$/;"	f	struct:GasModelData
~GcrSolver	KspSolver.h	/^  ~GcrSolver() {}$/;"	f	class:GcrSolver
~GenFullM	DenseMatrix.C	/^GenFullM<Scalar>::~GenFullM()$/;"	f	class:GenFullM
~GenMat	GenMatrix.h	/^  ~GenMat() {}$/;"	f	class:GenMat
~GeoData	GeoData.h	/^  ~GeoData() {}$/;"	f	class:GeoData
~GeoSource	GeoSource.C	/^GeoSource::~GeoSource()$/;"	f	class:GeoSource
~GeoState	GeoState.h	/^  ~GeoState() {}$/;"	f	class:GeoState
~GhostPoint	GhostPoint.h	/^  ~GhostPoint() {$/;"	f	class:GhostPoint
~GmresSolver	KspSolver.h	/^  ~GmresSolver() {}$/;"	f	class:GmresSolver
~HASHTABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/HASHTABLE.h	/^    ~HASHTABLE()$/;"	f	class:PhysBAM::HASHTABLE
~Heap	SparseGridCore.C	/^SparseGrid::Heap::~Heap(){$/;"	f	class:SparseGrid::Heap
~HeatTransferHandler	HeatTransferHandler.h	/^  ~HeatTransferHandler() {}$/;"	f	class:HeatTransferHandler
~HeavingData	IoData.h	/^  ~HeavingData() {}$/;"	f	struct:HeavingData
~HeavingMeshMotionHandler	MeshMotionHandlerCore.C	/^HeavingMeshMotionHandler::~HeavingMeshMotionHandler()$/;"	f	class:HeavingMeshMotionHandler
~HigherOrderFSI	HigherOrderFSI.C	/^HigherOrderFSI::~HigherOrderFSI() {$/;"	f	class:HigherOrderFSI
~HigherOrderMultiFluid	HigherOrderMultiFluid.C	/^HigherOrderMultiFluid::~HigherOrderMultiFluid() {$/;"	f	class:HigherOrderMultiFluid
~IMPLICIT_OBJECT	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Implicit_Objects/IMPLICIT_OBJECT.cpp	/^~IMPLICIT_OBJECT()$/;"	f	class:IMPLICIT_OBJECT
~INITIALIZATION_HELPER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^    ~INITIALIZATION_HELPER()$/;"	f	struct:PhysBAM::LOG_REAL::__anon18::INITIALIZATION_HELPER
~IdentityPrec	KspPrec.h	/^  ~IdentityPrec() {}$/;"	f	class:IdentityPrec
~IluPrec	KspPrec.C	/^IluPrec<Scalar,dim, Scalar2>::~IluPrec()$/;"	f	class:IluPrec
~ImplicitCollocationTsDesc	ImplicitCollocationTsDesc.C	/^ImplicitCollocationTsDesc<dim>::~ImplicitCollocationTsDesc() {}$/;"	f	class:ImplicitCollocationTsDesc
~ImplicitCoupledTsDesc	ImplicitCoupledTsDesc.C	/^ImplicitCoupledTsDesc<dim>::~ImplicitCoupledTsDesc()$/;"	f	class:ImplicitCoupledTsDesc
~ImplicitData	IoData.h	/^  ~ImplicitData() {}$/;"	f	struct:ImplicitData
~ImplicitEmbeddedCoupledTsDesc	ImplicitEmbeddedCoupledTsDesc.C	/^ImplicitEmbeddedCoupledTsDesc<dim>::~ImplicitEmbeddedCoupledTsDesc()$/;"	f	class:ImplicitEmbeddedCoupledTsDesc
~ImplicitEmbeddedRomTsDesc	ImplicitEmbeddedRomTsDesc.cpp	/^ImplicitEmbeddedRomTsDesc<dim>::~ImplicitEmbeddedRomTsDesc() {$/;"	f	class:ImplicitEmbeddedRomTsDesc
~ImplicitEmbeddedSegTsDesc	ImplicitEmbeddedSegTsDesc.C	/^ImplicitEmbeddedSegTsDesc<dim,neq1,neq2>::~ImplicitEmbeddedSegTsDesc()$/;"	f	class:ImplicitEmbeddedSegTsDesc
~ImplicitEmbeddedTsDesc	ImplicitEmbeddedTsDesc.C	/^ImplicitEmbeddedTsDesc<dim>::~ImplicitEmbeddedTsDesc()$/;"	f	class:ImplicitEmbeddedTsDesc
~ImplicitGappyTsDesc	ImplicitGappyTsDesc.C	/^ImplicitGappyTsDesc<dim>::~ImplicitGappyTsDesc() $/;"	f	class:ImplicitGappyTsDesc
~ImplicitGnatTsDesc	ImplicitGnatTsDesc.C	/^ImplicitGnatTsDesc<dim>::~ImplicitGnatTsDesc() {}$/;"	f	class:ImplicitGnatTsDesc
~ImplicitLevelSetTsDesc	ImplicitLevelSetTsDesc.C	/^ImplicitLevelSetTsDesc<dim,dimLS>::~ImplicitLevelSetTsDesc()$/;"	f	class:ImplicitLevelSetTsDesc
~ImplicitMetricTsDesc	ImplicitMetricTsDesc.C	/^ImplicitMetricTsDesc<dim>::~ImplicitMetricTsDesc() {}$/;"	f	class:ImplicitMetricTsDesc
~ImplicitMultiPhysicsTsDesc	ImplicitMultiPhysicsTsDesc.C	/^ImplicitMultiPhysicsTsDesc<dim,dimLS>::~ImplicitMultiPhysicsTsDesc()$/;"	f	class:ImplicitMultiPhysicsTsDesc
~ImplicitPGTsDesc	ImplicitPGTsDesc.C	/^ImplicitPGTsDesc<dim>::~ImplicitPGTsDesc(){$/;"	f	class:ImplicitPGTsDesc
~ImplicitRomTsDesc	ImplicitRomTsDesc.C	/^ImplicitRomTsDesc<dim>::~ImplicitRomTsDesc()$/;"	f	class:ImplicitRomTsDesc
~ImplicitSegTsDesc	ImplicitSegTsDesc.C	/^ImplicitSegTsDesc<dim,neq1,neq2>::~ImplicitSegTsDesc()$/;"	f	class:ImplicitSegTsDesc
~ImplicitTsDesc	ImplicitTsDesc.C	/^ImplicitTsDesc<dim>::~ImplicitTsDesc()$/;"	f	class:ImplicitTsDesc
~ImplosionSetup	IoData.h	/^  ~ImplosionSetup() {}$/;"	f	struct:ImplosionSetup
~InletNode	InletNodeCore.C	/^InletNode::~InletNode()$/;"	f	class:InletNode
~InletNodeSet	InletNodeCore.C	/^InletNodeSet::~InletNodeSet()$/;"	f	class:InletNodeSet
~InputData	IoData.h	/^  ~InputData() {}$/;"	f	struct:InputData
~IntersectorFRG	IntersectorFRG/IntersectorFRG.C	/^IntersectorFRG::~IntersectorFRG()$/;"	f	class:IntersectorFRG
~IntersectorPhysBAM	IntersectorPhysBAM/IntersectorPhysBAM.C	/^IntersectorPhysBAM::~IntersectorPhysBAM()$/;"	f	class:IntersectorPhysBAM
~IoData	IoData.h	/^  ~IoData() {}$/;"	f	class:IoData
~JWLModelData	IoData.h	/^  ~JWLModelData() {}$/;"	f	struct:JWLModelData
~JacobiPrec	KspPrec.C	/^JacobiPrec<Scalar,dim, Scalar2>::~JacobiPrec()$/;"	f	class:JacobiPrec
~JacobianActionData	IoData.h	/^  ~JacobianActionData() {}$/;"	f	struct:JacobianActionData
~KDTree	IntersectorFRG/Geometry/KDTree.h	/^KDTree<Obj, dim, CompType>::~KDTree() {$/;"	f	class:KDTree
~KD_TREE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE.h	/^    ~KD_TREE()$/;"	f	class:PhysBAM::KD_TREE
~KD_TREE_NODE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/KD_TREE_NODE.h	/^    ~KD_TREE_NODE()$/;"	f	class:PhysBAM::KD_TREE_NODE
~KEModelData	IoData.h	/^  ~KEModelData() {}$/;"	f	struct:KEModelData
~KEpsilonTerm	KEpsilonTerm.h	/^  ~KEpsilonTerm() {}$/;"	f	class:KEpsilonTerm
~KirchhoffData	IoData.h	/^  ~KirchhoffData() {}$/;"	f	struct:KirchhoffData
~KirchhoffIntegrator	KirchhoffIntegrator.C	/^KirchhoffIntegrator::~KirchhoffIntegrator$/;"	f	class:KirchhoffIntegrator
~KrylovData	IoData.h	/^  ~KrylovData() {}$/;"	f	struct:KrylovData
~KspBinaryOutput	KspBinaryOutput.C	/^KspBinaryOutput<VecType>::~KspBinaryOutput() $/;"	f	class:KspBinaryOutput
~KspConvCriterion	KspConvCriterion.h	/^  ~KspConvCriterion() {}$/;"	f	class:KspConvCriterion
~KspData	IoData.h	/^  ~KspData() {}$/;"	f	struct:KspData
~KspFluidData	IoData.h	/^  ~KspFluidData() {}$/;"	f	struct:KspFluidData
~KspPrec	KspPrec.h	/^  virtual ~KspPrec() {}$/;"	f	class:KspPrec
~KspSolver	KspSolver.h	/^  virtual ~KspSolver() { if (kspConvCriterion) delete kspConvCriterion; }$/;"	f	class:KspSolver
~LESModelData	IoData.h	/^  ~LESModelData() {}$/;"	f	struct:LESModelData
~LEVELSET_UTILITIES	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Level_Sets/LEVELSET_UTILITIES.h	/^    virtual ~LEVELSET_UTILITIES() {};$/;"	f	class:PhysBAM::LEVELSET_UTILITIES
~LOG_CLASS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.cpp	/^LOG_CLASS::~LOG_CLASS()$/;"	f	class:PhysBAM::LOG_REAL::LOG_CLASS
~LOG_ENTRY	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_ENTRY.h	/^    virtual ~LOG_ENTRY()$/;"	f	class:PhysBAM::LOG_REAL::LOG_ENTRY
~LOG_SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG_SCOPE.h	/^    virtual ~LOG_SCOPE()$/;"	f	class:PhysBAM::LOG_REAL::LOG_SCOPE
~LevelSet	LevelSet.C	/^LevelSet<dimLS>::~LevelSet()$/;"	f	class:LevelSet
~LevelSetSource	OneDimensionalSolver.C	/^  ~LevelSetSource() { }$/;"	f	class:LevelSetSource
~LevelSetStructure	LevelSet/LevelSetStructure.h	/^    virtual ~LevelSetStructure()$/;"	f	class:LevelSetStructure
~LevelSetTsDesc	LevelSetTsDesc.C	/^LevelSetTsDesc<dim,dimLS>::~LevelSetTsDesc()$/;"	f	class:LevelSetTsDesc
~LinePlot	IoData.h	/^  ~LinePlot() {} $/;"	f	struct:LinePlot
~LineSearchData	IoData.h	/^  ~LineSearchData() {}$/;"	f	struct:LineSearchData
~LinearizedData	IoData.h	/^  ~LinearizedData() {}$/;"	f	struct:LinearizedData
~LiquidModelData	IoData.h	/^  ~LiquidModelData() {}$/;"	f	struct:LiquidModelData
~LocalRiemann	LocalRiemann.h	/^  virtual ~LocalRiemann()  { vf_ = 0; }$/;"	f	class:LocalRiemann
~LocalRiemannFluidStructure	LocalRiemannDesc.h	/^  virtual ~LocalRiemannFluidStructure() { vf_ = 0; }$/;"	f	class:LocalRiemannFluidStructure
~LocalRiemannGfmp	LocalRiemann.h	/^  virtual ~LocalRiemannGfmp() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmp
~LocalRiemannGfmpGasGas	LocalRiemannDesc.h	/^  ~LocalRiemannGfmpGasGas() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmpGasGas
~LocalRiemannGfmpGasJWL	LocalRiemannDesc.h	/^  ~LocalRiemannGfmpGasJWL() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmpGasJWL
~LocalRiemannGfmpJWLJWL	LocalRiemannDesc.h	/^  ~LocalRiemannGfmpJWLJWL() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmpJWLJWL
~LocalRiemannGfmpTaitTait	LocalRiemannDesc.h	/^  ~LocalRiemannGfmpTaitTait() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmpTaitTait
~LocalRiemannGfmpar	LocalRiemann.h	/^  virtual ~LocalRiemannGfmpar() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmpar
~LocalRiemannGfmparGasGas	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparGasGas() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmparGasGas
~LocalRiemannGfmparGasJWL	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparGasJWL(){ vf_ = 0; sgCluster_ = 0; }$/;"	f	class:LocalRiemannGfmparGasJWL
~LocalRiemannGfmparGasTait	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparGasTait() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmparGasTait
~LocalRiemannGfmparJWLJWL	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparJWLJWL() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmparJWLJWL
~LocalRiemannGfmparTaitJWL	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparTaitJWL(){ vf_ = 0; sgCluster_ = 0; }$/;"	f	class:LocalRiemannGfmparTaitJWL
~LocalRiemannGfmparTaitTait	LocalRiemannDesc.h	/^  ~LocalRiemannGfmparTaitTait() { vf_ = 0; }$/;"	f	class:LocalRiemannGfmparTaitTait
~LocalRiemannLowMach	LocalRiemann.h	/^  virtual ~LocalRiemannLowMach()  { vf_ = 0; }$/;"	f	class:LocalRiemannLowMach
~LogarithmicMapping	SparseGrid.h	/^    ~LogarithmicMapping()          { }$/;"	f	class:SparseGrid::LogarithmicMapping
~LowMachPrec	LowMachPrec.h	/^  virtual ~LowMachPrec() {}; \/\/destructor of base class should always be virtual$/;"	f	class:LowMachPrec
~MATRIX_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_BASE.h	/^    ~MATRIX_BASE()$/;"	f	class:PhysBAM::MATRIX_BASE
~MATRIX_MXN	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Matrices/MATRIX_MXN.h	/^    ~MATRIX_MXN()$/;"	f	class:PhysBAM::MATRIX_MXN
~MT19937	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/MT19937.cpp	/^~MT19937()$/;"	f	class:PhysBAM::MT19937
~MacroCell	MacroCellCore.C	/^MacroCell::~MacroCell()$/;"	f	class:MacroCell
~MacroCellSet	MacroCellCore.C	/^MacroCellSet::~MacroCellSet()$/;"	f	class:MacroCellSet
~MatVecProd	MatVecProd.h	/^  virtual ~MatVecProd() {}$/;"	f	class:MatVecProd
~MatVecProdFD	MatVecProd.C	/^MatVecProdFD<dim, neq>::~MatVecProdFD()$/;"	f	class:MatVecProdFD
~MatVecProdFDMultiPhase	MatVecProd.C	/^MatVecProdFDMultiPhase<dim,dimLS>::~MatVecProdFDMultiPhase()$/;"	f	class:MatVecProdFDMultiPhase
~MatVecProdH1	MatVecProd.C	/^MatVecProdH1<dim,Scalar,neq>::~MatVecProdH1()$/;"	f	class:MatVecProdH1
~MatVecProdH1MultiPhase	MatVecProd.C	/^MatVecProdH1MultiPhase<dim,dimLS>::~MatVecProdH1MultiPhase()$/;"	f	class:MatVecProdH1MultiPhase
~MatVecProdH2	MatVecProd.C	/^MatVecProdH2<dim,Scalar,neq>::~MatVecProdH2()$/;"	f	class:MatVecProdH2
~MatVecProdLS	MatVecProd.C	/^MatVecProdLS<dim,dimLS>::~MatVecProdLS()$/;"	f	class:MatVecProdLS
~MatVecProdMultiPhase	MatVecProd.h	/^  virtual ~MatVecProdMultiPhase() { timeState=0; spaceOp = 0; riemann = 0; fluidSelector = 0; }$/;"	f	class:MatVecProdMultiPhase
~MatVecProd_dRdX	MatVecProd.C	/^MatVecProd_dRdX<dim,Scalar,neq>::~MatVecProd_dRdX()$/;"	f	class:MatVecProd_dRdX
~MatchNodeSet	MatchNodeCore.C	/^MatchNodeSet::~MatchNodeSet()$/;"	f	class:MatchNodeSet
~MemoryPool	MemoryPool.h	/^  ~MemoryPool() {}$/;"	f	class:MemoryPool
~MeshMotionHandler	MeshMotionHandler.h	/^  virtual ~MeshMotionHandler() {}$/;"	f	class:MeshMotionHandler
~MeshMotionSolver	MeshMotionSolver.h	/^  virtual ~MeshMotionSolver() {}$/;"	f	class:MeshMotionSolver
~MultiFluidData	IoData.h	/^  ~MultiFluidData() {}$/;"	f	struct:MultiFluidData
~MultiGridCoupledTsDesc	MultiGridCoupledTsDesc.C	/^~MultiGridCoupledTsDesc() {$/;"	f	class:MultiGridCoupledTsDesc
~MultiGridData	IoData.h	/^  ~MultiGridData() {}$/;"	f	struct:MultiGridData
~MultiGridDistSVec	MultiGridDistSVec.C	/^~MultiGridDistSVec() {$/;"	f	class:MultiGridDistSVec
~MultiGridEmbeddedTsDesc	MultiGridEmbeddedTsDesc.C	/^~MultiGridEmbeddedTsDesc() {$/;"	f	class:MultiGridEmbeddedTsDesc
~MultiGridJacobiPrec	MultiGridKspSolver.h	/^  ~MultiGridJacobiPrec() { }                                                                      $/;"	f	class:MultiGridJacobiPrec
~MultiGridKernel	MultiGridKernel.C	/^MultiGridKernel<Scalar>::~MultiGridKernel()$/;"	f	class:MultiGridKernel
~MultiGridKspSolver	MultiGridKspSolver.C	/^~MultiGridKspSolver() {$/;"	f	class:MultiGridKspSolver
~MultiGridLevel	MultiGridLevel.C	/^MultiGridLevel<Scalar>::~MultiGridLevel()$/;"	f	class:MultiGridLevel
~MultiGridLevelSetStructure	LevelSet/MultiGridLevelSetStructure.h	/^    ~MultiGridLevelSetStructure()$/;"	f	class:MultiGridLevelSetStructure
~MultiGridMatVecProd	MultiGridKspSolver.h	/^  ~MultiGridMatVecProd() { }                                                                      $/;"	f	class:MultiGridMatVecProd
~MultiGridMvpMatrix	MultiGridMvpMatrix.C	/^~MultiGridMvpMatrix() {$/;"	f	class:MultiGridMvpMatrix
~MultiGridOperator	MultiGridOperator.C	/^MultiGridOperator<Scalar,dim>::~MultiGridOperator() {$/;"	f	class:MultiGridOperator
~MultiGridPrec	MultiGridPrec.C	/^MultiGridPrec<Scalar,dim,Scalar2>::~MultiGridPrec()$/;"	f	class:MultiGridPrec
~MultiGridRASPrec	MultiGridKspSolver.h	/^  ~MultiGridRASPrec() { }$/;"	f	class:MultiGridRASPrec
~MultiGridSegTsDesc	MultiGridSegTsDesc.C	/^~MultiGridSegTsDesc() {$/;"	f	class:MultiGridSegTsDesc
~MultiGridSmoothingMatrices	MultiGridSmoothingMatrices.C	/^MultiGridSmoothingMatrices<Scalar,dim>::~MultiGridSmoothingMatrices() {$/;"	f	class:MultiGridSmoothingMatrices
~MultiGridSmoothingMatrix	MultiGridSmoothingMatrix.C	/^~MultiGridSmoothingMatrix() {$/;"	f	class:MultiGridSmoothingMatrix
~MultiGridSolver	MultiGridSolver.h	/^  ~MultiGridSolver() {}$/;"	f	class:MultiGridSolver
~MultiGridSpaceOperator	MultiGridSpaceOperator.C	/^~MultiGridSpaceOperator() {$/;"	f	class:MultiGridSpaceOperator
~MultiPhaseSpaceOperator	SpaceOperator.C	/^MultiPhaseSpaceOperator<dim,dimLS>::~MultiPhaseSpaceOperator()$/;"	f	class:MultiPhaseSpaceOperator
~MultiPhysicsTsDesc	MultiPhysicsTsDesc.C	/^MultiPhysicsTsDesc<dim,dimLS>::~MultiPhysicsTsDesc()$/;"	f	class:MultiPhysicsTsDesc
~MvpMat	MvpMatrix.h	/^  ~MvpMat() {$/;"	f	class:MvpMat
~NONCOPYABLE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/NONCOPYABLE.h	/^    ~NONCOPYABLE(){}$/;"	f	class:PhysBAM::NONCOPYABLE
~NONLINEAR_FUNCTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual ~NONLINEAR_FUNCTION() {}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
~NONLINEAR_FUNCTION	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Nonlinear_Equations/NONLINEAR_FUNCTION.h	/^    virtual ~NONLINEAR_FUNCTION(){}$/;"	f	class:PhysBAM::NONLINEAR_FUNCTION
~NavierStokesTerm	NavierStokesTerm.h	/^NavierStokesTerm::~NavierStokesTerm()$/;"	f	class:NavierStokesTerm
~NewtonData	IoData.h	/^  ~NewtonData() {}$/;"	f	struct:NewtonData
~NewtonSolver	NewtonSolver.h	/^  ~NewtonSolver() {}$/;"	f	class:NewtonSolver
~NodalGrad	NodalGrad.h	/^  ~NodalGrad() {}$/;"	f	class:NodalGrad
~NodeSet	Node.h	/^  ~NodeSet() {}$/;"	f	class:NodeSet
~NonlinearRom	NonlinearRom.C	/^NonlinearRom<dim>::~NonlinearRom() $/;"	f	class:NonlinearRom
~NonlinearRomDatabaseConstruction	NonlinearRomDatabaseConstruction.C	/^NonlinearRomDatabaseConstruction<dim>::~NonlinearRomDatabaseConstruction() $/;"	f	class:NonlinearRomDatabaseConstruction
~NonlinearRomDirectoriesData	IoData.h	/^  ~NonlinearRomDirectoriesData() {}$/;"	f	struct:NonlinearRomDirectoriesData
~NonlinearRomFileSystemData	IoData.h	/^  ~NonlinearRomFileSystemData() {}$/;"	f	struct:NonlinearRomFileSystemData
~NonlinearRomFilesData	IoData.h	/^  ~NonlinearRomFilesData() {}$/;"	f	struct:NonlinearRomFilesData
~NonlinearRomOfflineData	IoData.h	/^  ~NonlinearRomOfflineData() {}$/;"	f	struct:NonlinearRomOfflineData
~NonlinearRomOnlineData	IoData.h	/^  ~NonlinearRomOnlineData() {}$/;"	f	struct:NonlinearRomOnlineData
~NonlinearRomOnlineII	NonlinearRomOnlineII.C	/^NonlinearRomOnlineII<dim>::~NonlinearRomOnlineII() $/;"	f	class:NonlinearRomOnlineII
~NonlinearRomOnlineIII	NonlinearRomOnlineIII.C	/^NonlinearRomOnlineIII<dim>::~NonlinearRomOnlineIII() $/;"	f	class:NonlinearRomOnlineIII
~NonlinearRomOnlineNonStateData	IoData.h	/^  ~NonlinearRomOnlineNonStateData() {}$/;"	f	struct:NonlinearRomOnlineNonStateData
~ODEIntegrator	ODEIntegrator.h	/^  ~ODEIntegrator() {$/;"	f	class:ODEIntegrator
~ObjectMap	IoData.h	/^  ~ObjectMap()$/;"	f	class:ObjectMap
~OneDimensional	OneDimensionalSolver.C	/^OneDimensional::~OneDimensional(){$/;"	f	class:OneDimensional
~OneDimensionalInfo	IoData.h	/^  ~OneDimensionalInfo() {}$/;"	f	struct:OneDimensionalInfo
~OneDimensionalInputData	IoData.h	/^  ~OneDimensionalInputData() {}$/;"	f	struct:OneDimensionalInputData
~OneDimensionalSourceTerm	OneDimensionalSourceTerm.h	/^  ~OneDimensionalSourceTerm() { }$/;"	f	class:OneDimensionalSourceTerm
~OutputData	IoData.h	/^  ~OutputData() {}$/;"	f	struct:OutputData
~PAIR	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Data_Structures/PAIR.h	/^    ~PAIR()$/;"	f	class:PhysBAM::PAIR
~POINTER_POOL	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/POINTER_POOL.h	/^    ~POINTER_POOL()$/;"	f	class:PhysBAM::POINTER_POOL
~POINT_CLOUD	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Point_Clouds/POINT_CLOUD.h	/^    virtual ~POINT_CLOUD(){}$/;"	f	class:PhysBAM::POINT_CLOUD
~PadeData	IoData.h	/^  ~PadeData() {}$/;"	f	struct:PadeData
~ParallelRom	ParallelRom.C	/^ParallelRom<dim>::~ParallelRom() $/;"	f	class:ParallelRom
~ParallelRomExtension	ParallelRomExtension.cpp	/^ParallelRomExtension<dim>::~ParallelRomExtension() {$/;"	f	class:ParallelRomExtension
~ParseTree	parser/ParseTree.cpp	/^ParseTree::~ParseTree() {$/;"	f	class:ParseTree
~PcData	IoData.h	/^  ~PcData() {}$/;"	f	struct:PcData
~PhantomElement	FSI/CrackingSurface.h	/^  ~PhantomElement() {if(phi) delete[] phi;  if(nodes) delete[] nodes;}$/;"	f	struct:PhantomElement
~PhysBAMInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.cpp	/^~PhysBAMInterface()$/;"	f	class:PhysBAMInterface
~PitchingData	IoData.h	/^  ~PitchingData() {}$/;"	f	struct:PitchingData
~PitchingMeshMotionHandler	MeshMotionHandlerCore.C	/^PitchingMeshMotionHandler::~PitchingMeshMotionHandler()$/;"	f	class:PitchingMeshMotionHandler
~PlaneData	IoData.h	/^  ~PlaneData() {}$/;"	f	struct:PlaneData
~PointData	IoData.h	/^  ~PointData() {}$/;"	f	struct:PointData
~PostFcn	PostFcn.h	/^  virtual ~PostFcn() {}$/;"	f	class:PostFcn
~PostFcnDES	PostFcn.h	/^  virtual ~PostFcnDES() {}$/;"	f	class:PostFcnDES
~PostFcnEuler	PostFcn.h	/^  virtual ~PostFcnEuler() {}$/;"	f	class:PostFcnEuler
~PostFcnKE	PostFcn.h	/^  virtual ~PostFcnKE() {}$/;"	f	class:PostFcnKE
~PostFcnNS	PostFcn.C	/^PostFcnNS::~PostFcnNS()$/;"	f	class:PostFcnNS
~PostFcnSA	PostFcn.C	/^PostFcnSA::~PostFcnSA()$/;"	f	class:PostFcnSA
~PostOperator	PostOperator.C	/^PostOperator<dim>::~PostOperator()$/;"	f	class:PostOperator
~PrandtlViscoFcn	ViscoFcn.h	/^  ~PrandtlViscoFcn() {}$/;"	f	class:PrandtlViscoFcn
~PreconditionData	IoData.h	/^  ~PreconditionData() {}$/;"	f	struct:PreconditionData
~PrismData	IoData.h	/^  ~PrismData() {}$/;"	f	struct:PrismData
~Probes	IoData.h	/^  ~Probes() {}$/;"	f	struct:Probes
~ProblemData	IoData.h	/^  ~ProblemData() {}$/;"	f	struct:ProblemData
~ProgrammedBurn	ProgrammedBurnCore.C	/^ProgrammedBurn::~ProgrammedBurn() {$/;"	f	class:ProgrammedBurn
~ProgrammedBurnData	IoDataCore.C	/^ProgrammedBurnData::~ProgrammedBurnData() { $/;"	f	class:ProgrammedBurnData
~Quadrature	Quadrature.h	/^    ~Quadrature() {$/;"	f	class:Quadrature
~RANDOM_NUMBERS	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Random_Numbers/RANDOM_NUMBERS.cpp	/^~RANDOM_NUMBERS()$/;"	f	class:PhysBAM::RANDOM_NUMBERS
~REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/REGISTRY.h	/^    ~REGISTRY()$/;"	f	class:PhysBAM::REGISTRY
~RKIntegrator	RKIntegrator.h	/^  ~RKIntegrator() {$/;"	f	class:RKIntegrator
~ROBConstructionData	IoData.h	/^  ~ROBConstructionData() {}$/;"	f	struct:ROBConstructionData
~ROMOutputData	IoData.h	/^  ~ROMOutputData() {}$/;"	f	struct:ROMOutputData
~RTree	RTree.h	/^  ~RTree() { }$/;"	f	class:RTree
~RbmExtractor	MeshMotionHandler.h	/^  ~RbmExtractor(){}$/;"	f	class:RbmExtractor
~RecFcn	RecFcn.h	/^  virtual ~RecFcn() {}$/;"	f	class:RecFcn
~RecFcnBarth	RecFcnDesc.h	/^  ~RecFcnBarth() {}$/;"	f	class:RecFcnBarth
~RecFcnConstant	RecFcnDesc.h	/^  ~RecFcnConstant() {}$/;"	f	class:RecFcnConstant
~RecFcnExtendedVanAlbada	RecFcnDesc.h	/^  ~RecFcnExtendedVanAlbada() {}$/;"	f	class:RecFcnExtendedVanAlbada
~RecFcnLinear	RecFcnDesc.h	/^  ~RecFcnLinear() {}$/;"	f	class:RecFcnLinear
~RecFcnLinearConstant	RecFcnDesc.h	/^  ~RecFcnLinearConstant() {}$/;"	f	class:RecFcnLinearConstant
~RecFcnLinearVanAlbada	RecFcnDesc.h	/^  ~RecFcnLinearVanAlbada() {}$/;"	f	class:RecFcnLinearVanAlbada
~RecFcnLtdLinear	RecFcnDesc.h	/^  ~RecFcnLtdLinear() {}$/;"	f	class:RecFcnLtdLinear
~RecFcnLtdLinearConstant	RecFcnDesc.h	/^  ~RecFcnLtdLinearConstant() {}$/;"	f	class:RecFcnLtdLinearConstant
~RecFcnLtdMultiDim	RecFcnDesc.h	/^  ~RecFcnLtdMultiDim() {}$/;"	f	class:RecFcnLtdMultiDim
~RecFcnLtdSensor	RecFcnDesc.h	/^  ~RecFcnLtdSensor() {}$/;"	f	class:RecFcnLtdSensor
~RecFcnVanAlbada	RecFcnDesc.h	/^  ~RecFcnVanAlbada() {}$/;"	f	class:RecFcnVanAlbada
~RecFcnVanAlbadaConstant	RecFcnDesc.h	/^  ~RecFcnVanAlbadaConstant() {}$/;"	f	class:RecFcnVanAlbadaConstant
~RecFcnVenkat	RecFcnDesc.h	/^  ~RecFcnVenkat() {}$/;"	f	class:RecFcnVenkat
~RectangularSparseMat	RectangularSparseMatrix.C	/^RectangularSparseMat<Scalar,dim,dim2>::~RectangularSparseMat()$/;"	f	class:RectangularSparseMat
~ReducedMeshShapeChanger	ReducedMeshShapeChanger.C	/^ReducedMeshShapeChanger<dim>::~ReducedMeshShapeChanger() { $/;"	f	class:ReducedMeshShapeChanger
~RefVal	RefVal.h	/^  ~RefVal() {}$/;"	f	class:RefVal
~RefVec	RefVector.h	/^RefVec<VecType>::~RefVec() $/;"	f	class:RefVec
~ReferenceStateData	IoData.h	/^  ~ReferenceStateData() {}$/;"	f	struct:ReferenceStateData
~ReinitializeDistanceToWall	ReinitializeDistanceToWall.C	/^ReinitializeDistanceToWall<dimLS>::~ReinitializeDistanceToWall()$/;"	f	class:ReinitializeDistanceToWall
~RelativeProjectionErrorData	IoData.h	/^  ~RelativeProjectionErrorData() {}$/;"	f	struct:RelativeProjectionErrorData
~ResidualData	IoData.h	/^  ~ResidualData() {}$/;"	f	struct:ResidualData
~ResizeArray	ResizeArray.h	/^ResizeArray<Type>::~ResizeArray()$/;"	f	class:ResizeArray
~RestartData	IoData.h	/^  ~RestartData() {}$/;"	f	struct:RestartData
~RestartParametersData	IoData.h	/^  ~RestartParametersData() {}$/;"	f	struct:RestartParametersData
~RichardsonSolver	KspSolver.h	/^  ~RichardsonSolver() {}$/;"	f	class:RichardsonSolver
~RigidMeshMotionData	IoData.h	/^  ~RigidMeshMotionData() {}$/;"	f	struct:RigidMeshMotionData
~RigidMeshMotionHandler	MeshMotionHandlerCore.C	/^RigidMeshMotionHandler::~RigidMeshMotionHandler()$/;"	f	class:RigidMeshMotionHandler
~RigidRollMeshMotionHandler	MeshMotionHandler.h	/^  ~RigidRollMeshMotionHandler() {}$/;"	f	class:RigidRollMeshMotionHandler
~SAModelData	IoData.h	/^  ~SAModelData() {}$/;"	f	struct:SAModelData
~SATerm	SpalartAllmarasTerm.h	/^  ~SATerm() {}$/;"	f	class:SATerm
~SCOPE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Log/LOG.h	/^    ~SCOPE()$/;"	f	class:PhysBAM::LOG_REAL::SCOPE
~SEGMENT_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SEGMENT_MESH.cpp	/^~SEGMENT_MESH()$/;"	f	class:SEGMENT_MESH
~SFixData	IoData.h	/^  ~SFixData() {}$/;"	f	struct:SFixData
~SIMPLEX_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/SIMPLEX_MESH.cpp	/^~SIMPLEX_MESH()$/;"	f	class:PhysBAM::SIMPLEX_MESH
~STRUCTURE	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology_Based_Geometry/STRUCTURE.cpp	/^~STRUCTURE()$/;"	f	class:STRUCTURE
~STRUCTURE_REGISTRY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Registry/STRUCTURE_REGISTRY.cpp	/^~STRUCTURE_REGISTRY()$/;"	f	class:STRUCTURE_REGISTRY
~SVec	Vector.h	/^  ~SVec() { if (locAlloc && v) delete [] v; }$/;"	f	class:SVec
~SchemeData	IoData.h	/^  ~SchemeData() {}$/;"	f	struct:SchemeData
~SchemeFixData	IoData.h	/^  ~SchemeFixData() {}$/;"	f	struct:SchemeFixData
~SchemesData	IoData.h	/^  ~SchemesData() {}$/;"	f	struct:SchemesData
~SensitivityAnalysis	IoData.h	/^  ~SensitivityAnalysis() {}$/;"	f	struct:SensitivityAnalysis
~SensitivityData	IoData.h	/^  ~SensitivityData() {}$/;"	f	struct:SensitivityData
~SimpleBuffer	SimpleBuffer.h	/^SimpleBuffer<Scalar>::~SimpleBuffer() {$/;"	f	class:SimpleBuffer
~SmagorinskyLESData	IoData.h	/^  ~SmagorinskyLESData() {}$/;"	f	struct:SmagorinskyLESData
~SmagorinskyLESTerm	SmagorinskyLESTerm.C	/^SmagorinskyLESTerm::~SmagorinskyLESTerm()$/;"	f	class:SmagorinskyLESTerm
~SnapshotsData	IoData.h	/^  ~SnapshotsData() {}$/;"	f	struct:SnapshotsData
~SpaceOperator	SpaceOperator.C	/^SpaceOperator<dim>::~SpaceOperator()$/;"	f	class:SpaceOperator
~SparseGrid	SparseGridCore.C	/^SparseGrid::~SparseGrid(){$/;"	f	class:SparseGrid
~SparseGridCluster	SparseGridClusterCore.C	/^SparseGridCluster::~SparseGridCluster()$/;"	f	class:SparseGridCluster
~SparseGridData	IoData.h	/^  ~SparseGridData() {}$/;"	f	struct:SparseGridData
~SparseGridGeneratorDesc	SparseGridGeneratorDesc.h	/^  ~SparseGridGeneratorDesc(){$/;"	f	class:SparseGridGeneratorDesc
~SparseMat	SparseMatrix.C	/^SparseMat<Scalar,dim>::~SparseMat()$/;"	f	class:SparseMat
~SpatialLowMachPrec	LowMachPrec.h	/^  ~SpatialLowMachPrec() {};$/;"	f	class:SpatialLowMachPrec
~SphereData	IoData.h	/^  ~SphereData() {}$/;"	f	struct:SphereData
~SpiralingData	IoData.h	/^  ~SpiralingData() {}$/;"	f	struct:SpiralingData
~SpiralingMeshMotionHandler	MeshMotionHandlerCore.C	/^SpiralingMeshMotionHandler::~SpiralingMeshMotionHandler()$/;"	f	class:SpiralingMeshMotionHandler
~StateData	IoData.h	/^  ~StateData() {}$/;"	f	struct:StateData
~StateSnapshotsData	IoData.h	/^  ~StateSnapshotsData() {}$/;"	f	struct:StateSnapshotsData
~StiffMat	StiffMatrix.C	/^StiffMat<Scalar,dim>::~StiffMat()$/;"	f	class:StiffMat
~StringManager	parser/StringManager.C	/^StringManager::~StringManager()$/;"	f	class:StringManager
~StructExc	StructExc.C	/^StructExc::~StructExc()$/;"	f	class:StructExc
~SubDInterface	PhysBAM_Interface/PHYSBAM_INTERFACE.h	/^    ~SubDInterface() {} \/\/ Leave Deletion responsibilities of scoped_triangle_mesh and triangle_hierarchy to DistPhysBAMInterface$/;"	f	struct:PhysBAM::SubDInterface
~SubDTopo	CommunicatorCore.C	/^SubDTopo::~SubDTopo()$/;"	f	class:SubDTopo
~SubDomain	SubDomainCore.C	/^SubDomain::~SubDomain()$/;"	f	class:SubDomain
~SutherlandViscoFcn	ViscoFcn.h	/^  ~SutherlandViscoFcn() {}$/;"	f	class:SutherlandViscoFcn
~SymFullM	DenseMatrix.C	/^SymFullM<Scalar>::~SymFullM()$/;"	f	class:SymFullM
~SymmetryData	IoData.h	/^  ~SymmetryData() {};$/;"	f	struct:SymmetryData
~SysSmbMap	parser/Dictionary.C	/^SysSmbMap::~SysSmbMap()$/;"	f	class:SysSmbMap
~TBFixData	IoData.h	/^  ~TBFixData() {}$/;"	f	struct:TBFixData
~TIMER	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Utilities/TIMER.cpp	/^~TIMER()$/;"	f	class:PhysBAM::TIMER
~TRIANGLE_HIERARCHY	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Spatial_Acceleration/TRIANGLE_HIERARCHY.cpp	/^~TRIANGLE_HIERARCHY()$/;"	f	class:TRIANGLE_HIERARCHY
~TRIANGLE_MESH	PhysBAM_Interface/Public_Library/PhysBAM_Geometry/Topology/TRIANGLE_MESH.cpp	/^~TRIANGLE_MESH()$/;"	f	class:TRIANGLE_MESH
~TetMeshMotionSolver	MeshMotionSolver.C	/^TetMeshMotionSolver::~TetMeshMotionSolver()$/;"	f	class:TetMeshMotionSolver
~ThermalCondFcn	ThermalCondFcn.h	/^  virtual ~ThermalCondFcn() {}$/;"	f	class:ThermalCondFcn
~ThermalCondModelData	IoData.h	/^  ~ThermalCondModelData() {}$/;"	f	struct:ThermalCondModelData
~TimeData	TimeData.h	/^  ~TimeData() {}$/;"	f	class:TimeData
~TimeLowMachPrec	LowMachPrec.h	/^  ~TimeLowMachPrec() {};$/;"	f	class:TimeLowMachPrec
~TimeState	TimeState.h	/^  ~TimeState() {}$/;"	f	class:TimeState
~Timer	Timer.C	/^Timer::~Timer()$/;"	f	class:Timer
~TransientData	IoData.h	/^  ~TransientData() {}$/;"	f	struct:TransientData
~TriangulatedInterface	TriangulatedInterface.C	/^TriangulatedInterface::~TriangulatedInterface() {$/;"	f	class:TriangulatedInterface
~TriangulatedSurface	TriangulatedSurface.C	/^TriangulatedSurface::~TriangulatedSurface()$/;"	f	class:TriangulatedSurface
~TripDomainData	IoData.h	/^  ~TripDomainData() {}$/;"	f	struct:TripDomainData
~TsData	IoData.h	/^  ~TsData() {}$/;"	f	struct:TsData
~TsDesc	TsDesc.C	/^TsDesc<dim>::~TsDesc()$/;"	f	class:TsDesc
~TsInput	TsInput.C	/^TsInput::~TsInput() {$/;"	f	class:TsInput
~TsOutput	TsOutput.C	/^TsOutput<dim>::~TsOutput()$/;"	f	class:TsOutput
~TsParameters	TsParameters.C	/^TsParameters::~TsParameters()$/;"	f	class:TsParameters
~TsRestart	TsRestart.h	/^  ~TsRestart()$/;"	f	class:TsRestart
~TsSolver	TsSolver.h	/^  ~TsSolver() {}$/;"	f	class:TsSolver
~TurbulenceClosureData	IoData.h	/^  ~TurbulenceClosureData() {}$/;"	f	struct:TurbulenceClosureData
~TurbulenceModelData	IoData.h	/^  ~TurbulenceModelData() {}$/;"	f	struct:TurbulenceModelData
~VECTOR_BASE	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_BASE.h	/^    ~VECTOR_BASE()$/;"	f	class:PhysBAM::VECTOR_BASE
~VECTOR_ND	PhysBAM_Interface/Public_Library/PhysBAM_Tools/Vectors/VECTOR_ND.h	/^    ~VECTOR_ND()$/;"	f	class:PhysBAM::VECTOR_ND
~VMSLESData	IoData.h	/^  ~VMSLESData() {}$/;"	f	struct:VMSLESData
~VMSLESTerm	VMSLESTerm.C	/^VMSLESTerm::~VMSLESTerm()$/;"	f	class:VMSLESTerm
~VarFcn	VarFcn.h	/^  ~VarFcn() {$/;"	f	class:VarFcn
~VarFcnBase	VarFcnBase.h	/^  virtual ~VarFcnBase() {}$/;"	f	class:VarFcnBase
~VarFcnJwl	VarFcnJwl.h	/^  ~VarFcnJwl() { delete [] pname;}$/;"	f	class:VarFcnJwl
~VarFcnSGEuler	VarFcnSGEuler.h	/^  ~VarFcnSGEuler() { delete [] pname; }$/;"	f	class:VarFcnSGEuler
~VarFcnSGKE	VarFcnSGKE.h	/^  ~VarFcnSGKE() { delete [] pname; }$/;"	f	class:VarFcnSGKE
~VarFcnSGSA	VarFcnSGSA.h	/^  ~VarFcnSGSA() { delete [] pname; }$/;"	f	class:VarFcnSGSA
~VarFcnTait	VarFcnTait.h	/^  virtual ~VarFcnTait() {$/;"	f	class:VarFcnTait
~VarFcnTaitKE	VarFcnTaitKE.h	/^  ~VarFcnTaitKE() {}$/;"	f	class:VarFcnTaitKE
~VarFcnTaitSA	VarFcnTaitSA.h	/^  ~VarFcnTaitSA() {}$/;"	f	class:VarFcnTaitSA
~Vec	Vector.h	/^  ~Vec() { if (locAlloc && v) delete [] v; }$/;"	f	class:Vec
~Vec3D	Vector3D.h	/^  ~Vec3D() {}$/;"	f	struct:Vec3D
~VecSet	VectorSet.h	/^VecSet<VecType>::~VecSet() $/;"	f	class:VecSet
~VelocityPoints	IoData.h	/^  ~VelocityPoints() {}$/;"	f	struct:VelocityPoints
~Veval	OneDimensionalSolver.h	/^    ~Veval() { }$/;"	f	class:OneDimensional::Veval
~ViscoFcn	ViscoFcn.h	/^  virtual ~ViscoFcn() {}$/;"	f	class:ViscoFcn
~ViscosityModelData	IoData.h	/^  ~ViscosityModelData() {}$/;"	f	struct:ViscosityModelData
~VolumicForceTerm	VolumicForceTerm.h	/^  ~VolumicForceTerm() {}$/;"	f	class:VolumicForceTerm
~WaleLESData	IoData.h	/^  ~WaleLESData() {}$/;"	f	struct:WaleLESData
~WaleLESTerm	WaleLESTerm.C	/^WaleLESTerm::~WaleLESTerm()$/;"	f	class:WaleLESTerm
~WallDistanceMethodData	IoData.h	/^  ~WallDistanceMethodData() {}$/;"	f	struct:WallDistanceMethodData
~WallFcn	WallFcn.h	/^  ~WallFcn() {}$/;"	f	class:WallFcn
~WallFcnKE	WallFcn.h	/^  ~WallFcnKE() {}$/;"	f	class:WallFcnKE
~WallFcnSA	WallFcn.h	/^  ~WallFcnSA() {}$/;"	f	class:WallFcnSA
~Window	Communicator.C	/^    Window<Scalar>::~Window() {$/;"	f	class:Communication::Window
~compStruct	Connectivity.h	/^  ~compStruct() $/;"	f	struct:compStruct
~dRdXoperators	MatVecProd.h	/^  ~dRdXoperators() {$/;"	f	struct:dRdXoperators
